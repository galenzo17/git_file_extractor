/home/agustin/Documentos/Repos/Payouts/payouts-api/.vscode/settings.json
{
    "typescript.tsdk": "node_modules/typescript/lib"
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/packages/typescript-config/dashboard.json
{
    "extends": "./base.json",
	"compilerOptions": {
		"allowSyntheticDefaultImports": true,
		"forceConsistentCasingInFileNames": true,
		"isolatedModules": true,
		"jsx": "react-jsx",
		"lib": ["DOM", "DOM.Iterable", "ESNext"],
		"noEmit": true,
		"strict": true,
		"types": ["vite/client", "vitest/globals", "vite-plugin-pwa/client"],
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/packages/typescript-config/package.json
{
  "name": "@repo/typescript-config",
  "version": "0.0.0",
  "private": true,
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  }
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/packages/typescript-config/base.json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "esModuleInterop": false,
    "removeComments": true,
    "lib": ["ESNext"],
    "module": "ESNext",
		"moduleResolution": "node",
    "noUncheckedIndexedAccess": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "target": "ESNext",
    "allowJs": true,
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/packages/typescript-config/api.json
{
    "$schema": "https://json.schemastore.org/tsconfig",
    "extends": "./base.json",
    "compilerOptions": {
        "module": "commonjs",
        "moduleResolution": "node",
        "skipLibCheck": true,
        "declaration": true,
        "removeComments": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noImplicitAny": false,
        "target": "esnext",
        "sourceMap": true,
        "outDir": "./dist",
        "noLib": false,
        "lib": ["es2022"],
        "emitDecoratorMetadata": true,
        "experimentalDecorators": true,
        "resolveJsonModule": true,
        "allowJs": true,
    },
   
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/packages/eslint-config/package.json
{
  "name": "@repo/eslint-config",
  "version": "0.0.0",
  "private": true,
  "files": [
    "api.js",
    "react.js"
  ],
  "devDependencies": {
    "@nabla/vite-plugin-eslint": "1.4.0",
    "@typescript-eslint/eslint-plugin": "^6.7.4",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "8.16.0",
    "eslint-config-airbnb": "19.0.4",
    "eslint-config-airbnb-base": "15.0.0",
    "eslint-config-airbnb-typescript": "17.1.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-config-turbo": "^1.11.3",
    "eslint-plugin-cucumber": "^2.0.0",
    "eslint-plugin-import": "2.26.0",
    "eslint-plugin-jsx-a11y": "6.5.1",
    "eslint-plugin-only-warn": "^1.1.0",
    "eslint-plugin-react": "^7.30.0",
    "eslint-plugin-react-hooks": "^4.5.0",
    "eslint-plugin-react-prefer-function-component": "2.0.0",
    "eslint-plugin-testing-library": "5.5.1",
    "eslint-plugin-unicorn": "42.0.0",
    "eslint-plugin-unused-imports": "^3.0.0",
    "typescript": "^5.3.3"
  }
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/package.json
{
  "name": "payouts-engine",
  "private": true,
  "scripts": {
    "build": "turbo build",
    "dev": "turbo dev",
    "test": "turbo test:unit test:e2e --concurrency=1",
    "lint": "turbo lint",
    "format": "prettier --write \"**/*.{ts,tsx,md}\""
  },
  "devDependencies": {
    "@repo/eslint-config": "workspace:*",
    "@repo/typescript-config": "workspace:*",
    "husky": "^9.0.10",
    "lint-staged": "^15.2.2",
    "prettier": "^3.1.1",
    "turbo": "latest",
    "typescript": "4.9.5"
  },
  "packageManager": "pnpm@8.9.0",
  "engines": {
    "node": ">=18"
  },
  "volta": {
    "node": "20.10.0",
    "pnpm": "8.15.0"
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": [
    "**/.env.*local"
  ],
  "pipeline": {
    "build": {
      "dependsOn": [
        "^build"
      ],
      "outputs": []
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "test:unit": {
      "cache": false
    },
    "test:e2e": {
      "cache": false,
      "dependsOn": [
        "test:unit"
      ]
    },
    "deploy": {
      "dependsOn": [
        "build",
        "test"
      ],
      "outputs": []
    }
  }
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/e2e/tsconfig.json
{
	"compilerOptions": {
		"module": "commonjs",
		"target": "ES2020",
		"allowJs": true,
		"checkJs": true,
		"noEmit": true,
		"strictNullChecks": true
	},
	"include": ["**/*.js", "**/*.d.ts", "**/*.mjs", "**/*.*.mjs"]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/e2e/types/global.d.ts
/* eslint-disable vars-on-top */
/* eslint-disable no-var */

import type { Page, BrowserContext, Browser } from 'playwright'

declare global {
	var page: Page
	var context: BrowserContext
	var browser: Browser
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/e2e/types/types.d.ts
/* eslint-disable @typescript-eslint/no-type-alias */

export declare type State = 'active' | 'deleted' | 'inactive'

export declare interface Merchant {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	identifier: string
	state: State
}

export declare interface User {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	email: string
	password?: string
	state: State
	role: UserRole
	mfa?: boolean
	mfaState?: MFAState
	merchantId: number
	merchant: Merchant
	code?: string
}

export declare interface Bank {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	state: State
	name: string
	code: string
}

declare type UserRole = 'admin' | 'super' | 'support' | 'user'

declare type MFAState = 'disabled' | 'enrolled' | 'verified'


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/vitePlugins.ts
/// <reference types="vitest" />
import type { Plugin } from 'vite'

export default (warningsToIgnore: string[][]): Plugin => {
	const mutedMessages = new Set()
	return {
		name: 'mute-warnings',
		enforce: 'pre',
		config: userConfig => ({
			build: {
				rollupOptions: {
					onwarn(warning, defaultHandler): void {
						if (warning.code) {
							const muted = warningsToIgnore.find(
								([code, message]) =>
									code === warning.code && warning.message.includes(message)
							)

							if (muted) {
								mutedMessages.add(muted.join(''))
								return
							}
						}

						if (userConfig.build?.rollupOptions?.onwarn) {
							userConfig.build.rollupOptions.onwarn(warning, defaultHandler)
						} else {
							defaultHandler(warning)
						}
					}
				}
			}
		}),
		closeBundle(): void {
			const diff = warningsToIgnore.filter(x => !mutedMessages.has(x.join('')))
			if (diff.length > 0) {
				this.warn(
					'Some of your muted warnings never appeared during the build process:'
				)
				for (const m of diff) this.warn(`- ${m.join(': ')}`)
			}
		}
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/.vscode/extensions.json
{
	"recommendations": ["zixuanchen.vitest-explorer"]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/vitest.global-setup.ts
/* eslint-disable unicorn/filename-case */
/* eslint-disable @typescript-eslint/explicit-function-return-type */

const setup = () => {
	process.env.TZ = 'America/Santiago'
}

export default setup


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/.postcssrc.json
{
	"plugins": {
		"autoprefixer": {}
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/package.json
{
	"name": "dashboard",
	"private": true,
	"version": "1.20.0",
	"scripts": {
		"build": "vite build",
		"commit": "cz",
		"dev": "vite --open",
		"start": "vite --open",
		"preview": "vite preview",
		"preview:test": "start-server-and-test preview http://localhost:4173",
		"test:watch": "vitest",
		"test:verbose": "vitest --reporter verbose",
		"test:unit": "vitest run",
		"test:cov": "vitest run --coverage",
		"test:cucumber": "cucumber-js --config e2e/cucumber.mjs",
		"test:cucumber:headful": "HEADFUL=true pnpm run test:cucumber",
		"test:cucumber:all": "cucumber-js --config e2e/cucumber.mjs --profile allFeatures",
		"test:cucumber:all:parallel": "cucumber-js --config e2e/cucumber.mjs --profile allFeaturesParallel",
		"format": "prettier -uw --ignore-path .gitignore .",
		"run-tsc": "tsc",
		"run-eslint": "eslint --cache --fix --ignore-path .gitignore --ext .ts,.tsx src",
		"run-stylelint": "stylelint --cache --fix --ignore-path .gitignore \"**/*.css\"",
		"lint": "run-p run-tsc run-eslint run-stylelint",
		"validate": "run-p lint test:ci test:e2e:headless"
	},
	"dependencies": {
		"@chakra-ui/icons": "^2.1.1",
		"@chakra-ui/react": "^2.8.2",
		"@emotion/react": "^11.11.3",
		"@emotion/styled": "^11.11.0",
		"@fontsource/pt-mono": "^4.5.9",
		"@monaco-editor/react": "^4.4.5",
		"@sentry/react": "^7.47.0",
		"@sentry/vite-plugin": "^0.5.1",
		"filtrex": "^3.0.0",
		"framer-motion": "^6.5.1",
		"js-cookie": "^3.0.1",
		"jwt-decode": "^3.1.2",
		"monaco-editor": ">=0.25.0 <1.0.0",
		"qrcode": "^1.5.1",
		"react": "18.1.0",
		"react-dom": "18.1.0",
		"react-icons": "^4.4.0",
		"react-query": "3.39.1",
		"react-query-auth": "^1.1.0",
		"react-router-dom": "6.3.0",
		"styled-components": "^6.0.2",
		"use-debounce": "^8.0.1",
		"usehooks-ts": "^2.9.1"
	},
	"devDependencies": {
		"@cucumber/cucumber": "^9.1.0",
		"@cucumber/messages": "^22.0.0",
		"@cucumber/pretty-formatter": "^1.0.0",
		"@nabla/vite-plugin-eslint": "2.0.2",
		"@playwright/test": "^1.32.3",
		"@testing-library/dom": "^8.13.0",
		"@testing-library/jest-dom": "^5.16.4",
		"@testing-library/react": "^13.3.0",
		"@testing-library/user-event": "^14.5.2",
		"@types/css-mediaquery": "0.1.1",
		"@types/js-cookie": "^3.0.2",
		"@types/qrcode": "^1.5.0",
		"@types/react": "18.0.12",
		"@types/react-dom": "18.0.5",
		"@types/react-router-dom": "5.3.3",
		"@types/testing-library__jest-dom": "5.14.3",
		"@vitejs/plugin-react": "1.3.2",
		"@vitest/ui": "^0.30.1",
		"@xmldom/xmldom": "0.7.5",
		"autoprefixer": "10.4.7",
		"c8": "7.11.3",
		"commitizen": "4.2.4",
		"css-mediaquery": "0.1.2",
		"cz-conventional-changelog": "3.3.0",
		"jsdom": "19.0.0",
		"npm-run-all": "4.1.5",
		"playwright": "^1.34.3",
		"postcss": "8.4.14",
		"prettier": "2.6.2",
		"rollup": "2.75.4",
		"rollup-plugin-istanbul": "3.0.0",
		"start-server-and-test": "1.14.0",
		"stylelint": "14.8.5",
		"stylelint-config-prettier": "9.0.3",
		"stylelint-config-standard": "25.0.0",
		"typescript": "4.9.5",
		"vite": "5.0.12",
		"vite-plugin-pwa": "0.17.5",
		"vite-tsconfig-paths": "3.5.0",
		"vitest": "0.14.0",
		"whatwg-fetch": "3.6.2",
		"workbox-build": "7.0.0",
		"workbox-window": "7.0.0",
		"@repo/eslint-config": "workspace:*"
	},
	"browserslist": {
		"production": "Edge >= 18, Firefox >= 60, Chrome >= 61, Safari >= 11, Opera >= 48",
		"development": [
			"last 1 chrome version",
			"last 1 firefox version"
		]
	},
	"lint-staged": {
		"*": "prettier -uw",
		"*.css": "stylelint --cache --fix",
		"*.{ts,tsx}": [
			"eslint --cache --fix",
			"vitest related --run --coverage=false"
		]
	},
	"volta": {
		"node": "20.10.0",
		"pnpm": "8.15.1"
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  // Look for test files in the "tests" directory, relative to this configuration file.
  testDir: './e2e/',

  // Run all tests in parallel.
  fullyParallel: true,

  // Fail the build on CI if you accidentally left test.only in the source code.
  forbidOnly: !!process.env.CI,

  // Retry on CI only.
  retries: process.env.CI ? 2 : 0,

  // Opt out of parallel tests on CI.
  workers: process.env.CI ? 1 : undefined,

  // Reporter to use
  reporter: 'html',

  use: {
    // Base URL to use in actions like `await page.goto('/')`.
    baseURL: 'http://127.0.0.1:3000',

    // Collect trace when retrying the failed test.
    trace: 'on-first-retry',
  },
  // Configure projects for major browsers.
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  // Run your local dev server before starting the tests.
  webServer: {
    command: 'pnpm start',
    url: 'http://127.0.0.1:3000',
    reuseExistingServer: !process.env.CI,
  },
});

/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/tsconfig.node.json
{
	"compilerOptions": {
		"allowSyntheticDefaultImports": true,
		"composite": true,
		"forceConsistentCasingInFileNames": true,
		"isolatedModules": true,
		"module": "ESNext",
		"moduleResolution": "Node",
		"skipLibCheck": true,
		"strict": true,
		"target": "ESNext"
	},
	"include": ["vite.config.ts", "vitest.global-setup.ts"]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/.stylelintrc.json
{
	"extends": ["stylelint-config-standard", "stylelint-config-prettier"],
	"rules": {
		"at-rule-no-unknown": [
			true,
			{
				"ignoreAtRules": ["layer"]
			}
		]
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/vite.config.ts
/// <reference types="vitest" />
// import eslintPlugin from '@nabla/vite-plugin-eslint'
import react from '@vitejs/plugin-react'
import { defineConfig, loadEnv } from 'vite'
import { VitePWA } from 'vite-plugin-pwa'
import tsconfigPaths from 'vite-tsconfig-paths'
import { sentryVitePlugin } from '@sentry/vite-plugin'
import type { Plugin } from 'vite'
import muteWarningsPlugin from './vitePlugins'

// To see more details please visit: https://github.com/vitejs/vite/issues/15012
const warningsToIgnore = [
	['SOURCEMAP_ERROR', "Can't resolve original location of error"],
	['INVALID_ANNOTATION', 'contains an annotation that Rollup cannot interpret'],
	[
		'MODULE_LEVEL_DIRECTIVE',
		'Module level directives cause errors when bundled, "use client"'
	]
]

const sentryPlugin = (environment: Record<string, string>): Plugin[] => {
	const hasSentryEnvironmentVariables = !!(
		environment.SENTRY_ORG &&
		environment.SENTRY_PROJECT &&
		environment.SENTRY_AUTH_TOKEN
	)
	return (
		hasSentryEnvironmentVariables
			? [
					sentryVitePlugin({
						org: environment.SENTRY_ORG,
						project: environment.SENTRY_PROJECT,
						include: './dist',
						authToken: environment.SENTRY_AUTH_TOKEN,
						release: environment.RELEASE_VERSION
					})
			  ]
			: []
	) as Plugin[]
}

export default defineConfig(({ mode }) => ({
	define: process.env.VITEST ? {} : { global: 'window' },
	test: {
		include: ['src/**/__tests__/**/*'],
		silent: true,
		globals: true,
		environment: 'jsdom',
		setupFiles: 'src/setupTests.ts',
		clearMocks: true,
		coverage: {
			enabled: false,
			// '100': true, // TODO: uncomment this to fail tests if coverage is below 100%
			reporter: ['text', 'lcov'],
			reportsDirectory: 'coverage/jest'
		},
		globalSetup: './vitest.global-setup.ts'
	},
	build: {
		sourcemap: true
	},
	plugins: [
		muteWarningsPlugin(warningsToIgnore),
		tsconfigPaths(),
		react(),
		...(mode !== 'test'
			? [
					// eslintPlugin(),
					VitePWA({
						registerType: 'autoUpdate',
						includeAssets: [
							'favicon.png',
							'robots.txt',
							'apple-touch-icon.png',
							'icons/*.svg',
							'fonts/*.woff2'
						],
						manifest: {
							theme_color: '#BD34FE',
							icons: [
								{
									src: '/android-chrome-192x192.png',
									sizes: '192x192',
									type: 'image/png',
									purpose: 'any maskable'
								},
								{
									src: '/android-chrome-512x512.png',
									sizes: '512x512',
									type: 'image/png'
								}
							]
						}
					})
			  ]
			: []),
		...sentryPlugin(loadEnv(mode, process.cwd(), ''))
	]
}))


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/.cz.json
{
	"path": "cz-conventional-changelog"
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/tsconfig.json
{
	"extends": "@repo/typescript-config/dashboard.json",
	"compilerOptions": {
		"baseUrl": "src/",
		"outDir": "./dist",
		"types": ["vite/client", "vitest/globals", "vite-plugin-pwa/client"],
		"paths": {
			"src/*": ["./src/*"]
		},
		"jsx": "react-jsx"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/.prettierrc.json
{
	"arrowParens": "avoid",
	"bracketSameLine": false,
	"bracketSpacing": true,
	"jsxSingleQuote": true,
	"plugins": [],
	"printWidth": 80,
	"quoteProps": "as-needed",
	"semi": false,
	"singleQuote": true,
	"tabWidth": 2,
	"trailingComma": "none",
	"useTabs": true
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/httpStatusCode.ts
/**
 * Hypertext Transfer Protocol (HTTP) response status codes.
 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
 *
 * Taken from: {@link https://gist.github.com/scokmen/f813c904ef79022e84ab2409574d1b45}
 */
enum HttpStatusCode {

	/**
	 * The server has received the request headers and the client should proceed to send the request body
	 * (in the case of a request for which a body needs to be sent; for example, a POST request).
	 * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.
	 * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request
	 * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.
	 */
	CONTINUE = 100,

	/**
	 * The requester has asked the server to switch protocols and the server has agreed to do so.
	 */
	SWITCHING_PROTOCOLS = 101,

	/**
	 * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.
	 * This code indicates that the server has received and is processing the request, but no response is available yet.
	 * This prevents the client from timing out and assuming the request was lost.
	 */
	PROCESSING = 102,

	/**
	 * Standard response for successful HTTP requests.
	 * The actual response will depend on the request method used.
	 * In a GET request, the response will contain an entity corresponding to the requested resource.
	 * In a POST request, the response will contain an entity describing or containing the result of the action.
	 */
	OK = 200,

	/**
	 * The request has been fulfilled, resulting in the creation of a new resource.
	 */
	CREATED = 201,

	/**
	 * The request has been accepted for processing, but the processing has not been completed.
	 * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.
	 */
	ACCEPTED = 202,

	/**
	 * SINCE HTTP/1.1
	 * The server is a transforming proxy that received a 200 OK from its origin,
	 * but is returning a modified version of the origin's response.
	 */
	NON_AUTHORITATIVE_INFORMATION = 203,

	/**
	 * The server successfully processed the request and is not returning any content.
	 */
	NO_CONTENT = 204,

	/**
	 * The server successfully processed the request, but is not returning any content.
	 * Unlike a 204 response, this response requires that the requester reset the document view.
	 */
	RESET_CONTENT = 205,

	/**
	 * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.
	 * The range header is used by HTTP clients to enable resuming of interrupted downloads,
	 * or split a download into multiple simultaneous streams.
	 */
	PARTIAL_CONTENT = 206,

	/**
	 * The message body that follows is an XML message and can contain a number of separate response codes,
	 * depending on how many sub-requests were made.
	 */
	MULTI_STATUS = 207,

	/**
	 * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,
	 * and are not being included again.
	 */
	ALREADY_REPORTED = 208,

	/**
	 * The server has fulfilled a request for the resource,
	 * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
	 */
	IM_USED = 226,

	/**
	 * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).
	 * For example, this code could be used to present multiple video format options,
	 * to list files with different filename extensions, or to suggest word-sense disambiguation.
	 */
	MULTIPLE_CHOICES = 300,

	/**
	 * This and all future requests should be directed to the given URI.
	 */
	MOVED_PERMANENTLY = 301,

	/**
	 * This is an example of industry practice contradicting the standard.
	 * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect
	 * (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302
	 * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307
	 * to distinguish between the two behaviours. However, some Web applications and frameworks
	 * use the 302 status code as if it were the 303.
	 */
	FOUND = 302,

	/**
	 * SINCE HTTP/1.1
	 * The response to the request can be found under another URI using a GET method.
	 * When received in response to a POST (or PUT/DELETE), the client should presume that
	 * the server has received the data and should issue a redirect with a separate GET message.
	 */
	SEE_OTHER = 303,

	/**
	 * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.
	 * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.
	 */
	NOT_MODIFIED = 304,

	/**
	 * SINCE HTTP/1.1
	 * The requested resource is available only through a proxy, the address for which is provided in the response.
	 * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.
	 */
	USE_PROXY = 305,

	/**
	 * No longer used. Originally meant "Subsequent requests should use the specified proxy."
	 */
	SWITCH_PROXY = 306,

	/**
	 * SINCE HTTP/1.1
	 * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.
	 * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.
	 * For example, a POST request should be repeated using another POST request.
	 */
	TEMPORARY_REDIRECT = 307,

	/**
	 * The request and all future requests should be repeated using another URI.
	 * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.
	 * So, for example, submitting a form to a permanently redirected resource may continue smoothly.
	 */
	PERMANENT_REDIRECT = 308,

	/**
	 * The server cannot or will not process the request due to an apparent client error
	 * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).
	 */
	BAD_REQUEST = 400,

	/**
	 * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet
	 * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the
	 * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means
	 * "unauthenticated",i.e. the user does not have the necessary credentials.
	 */
	UNAUTHORIZED = 401,

	/**
	 * Reserved for future use. The original intention was that this code might be used as part of some form of digital
	 * cash or micro payment scheme, but that has not happened, and this code is not usually used.
	 * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.
	 */
	PAYMENT_REQUIRED = 402,

	/**
	 * The request was valid, but the server is refusing action.
	 * The user might not have the necessary permissions for a resource.
	 */
	FORBIDDEN = 403,

	/**
	 * The requested resource could not be found but may be available in the future.
	 * Subsequent requests by the client are permissible.
	 */
	NOT_FOUND = 404,

	/**
	 * A request method is not supported for the requested resource;
	 * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.
	 */
	METHOD_NOT_ALLOWED = 405,

	/**
	 * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
	 */
	NOT_ACCEPTABLE = 406,

	/**
	 * The client must first authenticate itself with the proxy.
	 */
	PROXY_AUTHENTICATION_REQUIRED = 407,

	/**
	 * The server timed out waiting for the request.
	 * According to HTTP specifications:
	 * "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
	 */
	REQUEST_TIMEOUT = 408,

	/**
	 * Indicates that the request could not be processed because of conflict in the request,
	 * such as an edit conflict between multiple simultaneous updates.
	 */
	CONFLICT = 409,

	/**
	 * Indicates that the resource requested is no longer available and will not be available again.
	 * This should be used when a resource has been intentionally removed and the resource should be purged.
	 * Upon receiving a 410 status code, the client should not request the resource in the future.
	 * Clients such as search engines should remove the resource from their indices.
	 * Most use cases do not require clients and search engines to purge the resource, and a "404 Not Found" may be used instead.
	 */
	GONE = 410,

	/**
	 * The request did not specify the length of its content, which is required by the requested resource.
	 */
	LENGTH_REQUIRED = 411,

	/**
	 * The server does not meet one of the preconditions that the requester put on the request.
	 */
	PRECONDITION_FAILED = 412,

	/**
	 * The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".
	 */
	PAYLOAD_TOO_LARGE = 413,

	/**
	 * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,
	 * in which case it should be converted to a POST request.
	 * Called "Request-URI Too Long" previously.
	 */
	URI_TOO_LONG = 414,

	/**
	 * The request entity has a media type which the server or resource does not support.
	 * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.
	 */
	UNSUPPORTED_MEDIA_TYPE = 415,

	/**
	 * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.
	 * For example, if the client asked for a part of the file that lies beyond the end of the file.
	 * Called "Requested Range Not Satisfiable" previously.
	 */
	RANGE_NOT_SATISFIABLE = 416,

	/**
	 * The server cannot meet the requirements of the Expect request-header field.
	 */
	EXPECTATION_FAILED = 417,

	/**
	 * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,
	 * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by
	 * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.
	 */
	I_AM_A_TEAPOT = 418,

	/**
	 * The request was directed at a server that is not able to produce a response (for example because a connection reuse).
	 */
	MISDIRECTED_REQUEST = 421,

	/**
	 * The request was well-formed but was unable to be followed due to semantic errors.
	 */
	UNPROCESSABLE_ENTITY = 422,

	/**
	 * The resource that is being accessed is locked.
	 */
	LOCKED = 423,

	/**
	 * The request failed due to failure of a previous request (e.g., a PROPPATCH).
	 */
	FAILED_DEPENDENCY = 424,

	/**
	 * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.
	 */
	UPGRADE_REQUIRED = 426,

	/**
	 * The origin server requires the request to be conditional.
	 * Intended to prevent "the 'lost update' problem, where a client
	 * GETs a resource's state, modifies it, and PUTs it back to the server,
	 * when meanwhile a third party has modified the state on the server, leading to a conflict."
	 */
	PRECONDITION_REQUIRED = 428,

	/**
	 * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.
	 */
	TOO_MANY_REQUESTS = 429,

	/**
	 * The server is unwilling to process the request because either an individual header field,
	 * or all the header fields collectively, are too large.
	 */
	REQUEST_HEADER_FIELDS_TOO_LARGE = 431,

	/**
	 * A server operator has received a legal demand to deny access to a resource or to a set of resources
	 * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.
	 */
	UNAVAILABLE_FOR_LEGAL_REASONS = 451,

	/**
	 * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.
	 */
	INTERNAL_SERVER_ERROR = 500,

	/**
	 * The server either does not recognize the request method, or it lacks the ability to fulfill the request.
	 * Usually this implies future availability (e.g., a new feature of a web-service API).
	 */
	NOT_IMPLEMENTED = 501,

	/**
	 * The server was acting as a gateway or proxy and received an invalid response from the upstream server.
	 */
	BAD_GATEWAY = 502,

	/**
	 * The server is currently unavailable (because it is overloaded or down for maintenance).
	 * Generally, this is a temporary state.
	 */
	SERVICE_UNAVAILABLE = 503,

	/**
	 * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
	 */
	GATEWAY_TIMEOUT = 504,

	/**
	 * The server does not support the HTTP protocol version used in the request
	 */
	HTTP_VERSION_NOT_SUPPORTED = 505,

	/**
	 * Transparent content negotiation for the request results in a circular reference.
	 */
	VARIANT_ALSO_NEGOTIATES = 506,

	/**
	 * The server is unable to store the representation needed to complete the request.
	 */
	INSUFFICIENT_STORAGE = 507,

	/**
	 * The server detected an infinite loop while processing the request.
	 */
	LOOP_DETECTED = 508,

	/**
	 * Further extensions to the request are required for the server to fulfill it.
	 */
	NOT_EXTENDED = 510,

	/**
	 * The client needs to authenticate to gain network access.
	 * Intended for use by intercepting proxies used to control access to the network (e.g., "captive portals" used
	 * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).
	 */
	NETWORK_AUTHENTICATION_REQUIRED = 511
}

export default HttpStatusCode


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/merchantLimits.ts
import { get, type PaginatedResponse, post, patch, remove } from 'api/requests'
import type { PaginationObject } from 'components/Pagination'

import type { Merchant, MerchantLimit } from 'types'

export async function getMerchantLimits(
	merchantId: Merchant['id'] | undefined,
	pagination: PaginationObject
): Promise<PaginatedResponse<MerchantLimit>> {
	const { data: results, pagination: responsePagination } = await get<
		MerchantLimit[]
	>(`/v2/merchants/${merchantId}/limits`, pagination)
	return { results, pagination: responsePagination }
}

export async function createMerchantLimit({
	merchantId,
	data
}: {
	merchantId: Merchant['id']
	data: Partial<MerchantLimit>
}): Promise<MerchantLimit> {
	return post<MerchantLimit>(`/v2/merchants/${merchantId}/limits`, data)
}

export async function updateMerchantLimit({
	id,
	merchantId,
	data
}: {
	id: MerchantLimit['id']
	merchantId: Merchant['id']
	data: Partial<MerchantLimit>
}): Promise<MerchantLimit> {
	return patch<MerchantLimit>(`/v2/merchants/${merchantId}/limits/${id}`, data)
}
export async function deleteMerchantLimit({
	id,
	merchantId
}: {
	id: MerchantLimit['id']
	merchantId: Merchant['id']
}): Promise<MerchantLimit> {
	return remove<MerchantLimit>(`/v2/merchants/${merchantId}/limits/${id}`)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/apiKey.ts
import type { PaginationObject } from 'components/Pagination'
import type { ApiKey } from 'types'
import type { PaginatedResponse } from '../requests'
import { get } from '../requests'

export async function getApiKey(id: ApiKey['id']): Promise<ApiKey> {
	const { data } = await get<ApiKey>(`/v2/api-keys/${id}`)
	return data
}

export async function getApiKeys(
	pagination: PaginationObject
): Promise<PaginatedResponse<ApiKey>> {
	const { data: results, pagination: responsePagination } = await get<ApiKey[]>(
		'/v2/api-keys',
		pagination
	)

	return { results, pagination: responsePagination }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/accounts.ts
import { get, patch, post } from '../requests'
import type { PaginationObject } from 'components/Pagination'
import type { PaginatedResponse } from '../requests'
import type { Account } from 'types'

export async function getAccounts(
	pagination: PaginationObject
): Promise<PaginatedResponse<Account>> {
	const { data: results, pagination: responsePagination } = await get<
		Account[]
	>('/v2/accounts', pagination)

	return { results, pagination: responsePagination }
}

export async function updateAccount({
	id,
	data
}: {
	id: Account['id']
	data: Partial<Account>
}): Promise<Account> {
	return patch<Account>(`/v2/accounts/${id}`, data)
}

export async function createAccount({
	data
}: {
	data: Partial<Account>
}): Promise<Account> {
	return post<Account>('/v2/accounts', data)
}

export async function getAccount(id: Account['id']): Promise<Account> {
	const { data: result } = await get<Account>(`/v2/accounts/${id}`)
	return result
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/internals.ts
import type { FeatureFlag } from 'hooks/useFeatureFlag'
import { getTyped } from '../requests'

interface FeatureFlagResponse {
	value: boolean
}
export async function getFeatureFlag(
	featureName: FeatureFlag
): Promise<boolean> {
	const { value } = await getTyped<FeatureFlagResponse>(
		`/internal/feature-flags/${featureName}`
	)
	return value
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/payouts.ts
import type { FileArrayBuffer, Payout, Provider } from 'types'
import type { PaginatedResponse } from '../requests'
import { get, patch } from '../requests'
import {
	searchParametersToUrlString,
	type SearchParameters
} from '../search/searchParameters'

import type { PaginationObject } from 'components/Pagination'
import Cookies from 'js-cookie'
import config from 'config'
import HttpStatusCode from 'httpStatusCode'

const API_URL = config.api.url

export async function getPayouts(
	searchParameters: Partial<SearchParameters>,
	pagination: PaginationObject
): Promise<PaginatedResponse<Payout>> {
	const endpoint = '/v2/payouts'
	const urlParameters = searchParametersToUrlString(searchParameters)

	const { data: results, pagination: responsePagination } = await get<Payout[]>(
		`${endpoint}?${urlParameters}&version[]=v1&version[]=v2`,
		pagination
	)
	return { results, pagination: responsePagination }
}

export async function getPayout(id: number): Promise<Payout> {
	const endpoint = '/v2/payouts'
	const { data: result } = await get<Payout>(`${endpoint}/${id}`)
	return result
}

export async function cancelPayout(id: Payout['id']): Promise<unknown> {
	return patch<unknown>(`/v2/management/payouts/${id}/cancel`, {})
}

export async function retryPayout(id: Payout['id']): Promise<unknown> {
	return patch<unknown>(`/v2/management/payouts/${id}/retry`, {})
}

export async function completePayout(id: Payout['id']): Promise<unknown> {
	return patch<unknown>(`/v2/management/payouts/${id}/complete`, {})
}

export async function reassignPayout({
	id,
	providerId
}: {
	id: Payout['id']
	providerId?: Provider['id']
}): Promise<unknown> {
	return patch<unknown>(`/v2/management/payouts/${id}/reassign`, {
		providerId
	})
}

export async function exportPayouts(
	searchParameters: Partial<SearchParameters>
): Promise<FileArrayBuffer | undefined> {
	const endpoint = '/v2/payouts/export'
	const urlParameters = searchParametersToUrlString(searchParameters)

	const token = Cookies.get('token')

	if (!token) {
		throw new Error('No token present')
	}

	const response = await fetch(`${API_URL}${endpoint}?${urlParameters}`, {
		method: 'GET',
		headers: {
			Authorization: `Bearer ${token}`
		}
	})

	if (response.status === Number(HttpStatusCode.NO_CONTENT)) return undefined

	if (response.status !== Number(HttpStatusCode.OK)) {
		throw new Error('Error al exportar los pagos')
	}

	const fileBuffer = await response.arrayBuffer()

	const contentDispositionHeader = response.headers.get('Content-Disposition')
	const filenameMatch = contentDispositionHeader?.match(/filename="(.+)"/)
	const filename = filenameMatch
		? filenameMatch[1]
		: 'HistorialTransferencias.xlsx'

	return { data: fileBuffer, filename }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/auth.ts
import HttpStatusCode from 'httpStatusCode'
import { MFAError } from 'types'
import type { User } from 'types'

import config from '../../config'
import type { APIError } from '../requests'
import { get, post, patch } from '../requests'

const API_URL = config.api.url

export interface AuthResponse {
	token: string
}
export interface MFAInitResponse {
	otpauthUrl: string
}

export interface LoginInfo {
	email: string
	password: string
	mfaCode?: string
}

export enum AuthError {
	NoToken = 'no_token',
	TokenExpired = 'token_expired',
	WrongCredentials = 'wrong_credentials',
	Unknown = 'unknown',
	MissingMFACode = 'missing_mfa_code',
	InvalidCode = 'invalid_code',
	DisabledMFA = 'disabled_mfa',
	InvalidStep = 'invalid_step'
}

export async function loginWithUsernameAndPassword(
	loginInfo: LoginInfo
): Promise<[AuthResponse?, AuthError?]> {
	try {
		const response = await fetch(`${API_URL}/v2/auth/login`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify(loginInfo)
		})
		const body = await response.json();

		if (response.ok) {
			return [body as AuthResponse, undefined]
		}
		if (
			response.status === Number(HttpStatusCode.NOT_FOUND) ||
			response.status === Number(HttpStatusCode.UNAUTHORIZED)
		) {
			const errorResponse = body as APIError

			if (errorResponse.message === MFAError.INVALID_CODE) {
				return [undefined, AuthError.InvalidCode]
			}
			return [undefined, AuthError.WrongCredentials]
		}
		if (response.status === Number(HttpStatusCode.BAD_REQUEST)) {
			const errorResponse = body as APIError

			if (errorResponse.message === MFAError.INVALID_CODE) {
				return [undefined, AuthError.InvalidCode]
			}
			if (errorResponse.message === MFAError.MISSING_MFA_CODE) {
				return [undefined, AuthError.MissingMFACode]
			}
		}

		return [undefined, AuthError.Unknown]
	} catch {
		return [undefined, AuthError.Unknown]
	}
}

export async function register({
	data
}: {
	data: Partial<User>
}): Promise<User> {
	return post<User>('/v2/auth/register', data)
}

export async function getCurrentUser(): Promise<User> {
	const { data: user } = await get<User>('/v2/users/me')
	return user
}

export async function mfaInit(): Promise<{ otpauthUrl: string }> {
	return post<MFAInitResponse>('/v2/auth/mfa/init')
}

export async function mfaEnroll(code: string): Promise<boolean> {
	return patch<boolean>('/v2/auth/mfa/enroll', { code })
}

export async function mfaVerify(password: string): Promise<boolean> {
	return patch<boolean>('/v2/auth/mfa/verify', { password })
}

export async function resetMfa(userId: number): Promise<{ message: string }> {
	return patch<{ message: string }>(`/v2/auth/mfa/reset/${userId}`)
}

export async function resetUserPassword(
	userId: number
): Promise<{ message: string }> {
	return patch<{ message: string }>(`/v2/auth/reset-password/${userId}`)
}

export interface ChangeUserPasswordDto {
	oldPassword: string
	// eslint-disable-next-line unicorn/no-keyword-prefix
	newPassword: string
	confirmNewPassword: string
	mfaCode?: string
}

export async function changePassword(
	data: Partial<ChangeUserPasswordDto>
): Promise<{ message: string }> {
	return patch<{ message: string }>('/v2/auth/change-password', data)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/transferErrors.ts
import { get, type PaginatedResponse } from 'api/requests'
import type { PaginationObject } from 'components/Pagination'
import type { TransferError } from 'types'

export async function getTransferErrors(
	pagination: PaginationObject
): Promise<PaginatedResponse<TransferError>> {
	const { data: results, pagination: responsePagination } = await get<
		TransferError[]
	>('/v2/transfer-errors', pagination)

	return { results, pagination: responsePagination }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/banks.ts
import type { PaginationObject } from '../../components/Pagination'
import type { Bank } from 'types'
import type { PaginatedResponse } from '../requests'
import { get } from '../requests'

export async function getBanks(
	pagination: PaginationObject
): Promise<PaginatedResponse<Bank>> {
	const { data: results, pagination: paginationResponse } = await get<Bank[]>(
		'/v2/banks?',
		pagination
	)

	return { results, pagination: paginationResponse }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/users.ts
import { searchParametersToUrlString } from 'api/search/searchParameters'
import type { PaginationObject } from 'components/Pagination'
import type { UserFilter } from 'hooks/useUsers'
import type { User } from 'types'
import type { PaginatedResponse } from '../requests'
import { remove, patch, get } from '../requests'

export async function getUser(id: User['id']): Promise<User> {
	const { data } = await get<User>(`/users/${id}`)
	return data
}

export async function getUsers(
	pagination: PaginationObject,
	{ search }: Partial<UserFilter>
): Promise<PaginatedResponse<User>> {
	// Regex to check if search is empty or only contains whitespace
	const urlParameters = /^\s*$/.test(search ?? '')
		? ''
		: searchParametersToUrlString({ search })

	const { data: results, pagination: responsePagination } = await get<User[]>(
		`/v2/users?${urlParameters}`,
		pagination
	)

	return { results, pagination: responsePagination }
}

export async function isEmailInUse(email: string): Promise<boolean> {
	const { data: result } = await get<{ isInUse: boolean }>(
		`/v2/users/is-email-in-use/${email}`
	)
	return result.isInUse
}

export async function updateUser({
	id,
	data
}: {
	id: User['id']
	data: Partial<User>
}): Promise<User> {
	return patch<User>(`/v2/users/${id}`, { ...data })
}

export async function deleteUser(id: User['id']): Promise<void> {
	return remove(`/v2/users/${id}`)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/transferMethod.ts
import type { PaginationObject } from 'components/Pagination'
import type { TransferMethod } from 'types'
import type { PaginatedResponse } from '../requests'
import { get, post, patch } from '../requests'

export async function getTransferMethods(
	pagination: PaginationObject
): Promise<PaginatedResponse<TransferMethod>> {
	// return get<TransferMethod[]>('/transfer-methods')
	const { data: results, pagination: responsePagination } = await get<
		TransferMethod[]
	>('/v2/transfer-methods?', pagination)

	return { results, pagination: responsePagination }
}

export async function getTransferMethod(
	id: TransferMethod['id']
): Promise<TransferMethod> {
	const { data } = await get<TransferMethod>(`/v2/transfer-methods/${id}`)
	return data
}

export async function createTransferMethod({
	data
}: {
	data: Partial<TransferMethod>
}): Promise<TransferMethod> {
	return post<TransferMethod>('/v2/transfer-methods', data)
}

export async function updateTransferMethod({
	id,
	data
}: {
	id: TransferMethod['id']
	data: Partial<TransferMethod>
}): Promise<TransferMethod> {
	return patch<TransferMethod>(`/v2/transfer-methods/${id}`, data)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/reconciliation.ts
import { get } from 'api/requests'
import type { TransferMismatch } from 'types'

interface TransferReconciliationDto {
	startDate: string
	endDate: string
}

export async function getReconciliation(
	data: TransferReconciliationDto
): Promise<TransferMismatch[]> {
	const response = await get<TransferMismatch[]>(
		`/v2/reconciliations?startDate=${data.startDate}&endDate=${data.endDate}`
	)

	return response.data
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/auditLogs.ts
import { get } from 'api/requests'
import type { PaginatedResponse } from 'api/requests'
import type { PaginationObject } from 'components/Pagination'
import type { AuditLog } from 'types'
import type { AuditLogFilter } from 'hooks/useAuditLogs'

export async function getAuditLogs(
	pagination: PaginationObject,
	searchParameters: Partial<AuditLogFilter>
): Promise<PaginatedResponse<AuditLog>> {
	const urlParameters = new URLSearchParams(searchParameters).toString()
	const { data: results, pagination: responsePagination } = await get<
		AuditLog[]
	>(`/v2/audit-logs?${urlParameters}`, pagination)

	return { results, pagination: responsePagination }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/accountStatements.ts
import type { PaginationObject } from 'components/Pagination'
import type { AccountStatement } from 'types'
import type { PaginatedResponse } from '../requests'
import { get } from '../requests'
import type { SearchParameters } from '../search/searchParameters'
import { searchParametersToUrlString } from '../search/searchParameters'

export async function getAccountStatements(
	searchParameters: Partial<SearchParameters>,
	pagination: PaginationObject
): Promise<PaginatedResponse<AccountStatement>> {
	const urlParameters = searchParametersToUrlString(searchParameters)
	const { data: results, pagination: responsePagination } = await get<
		AccountStatement[]
	>(`/v2/account-statements?${urlParameters}`, pagination)

	return { results, pagination: responsePagination }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/merchants.ts
import type { PaginationObject } from '../../components/Pagination'
import type { Merchant } from 'types'
import type { PaginatedResponse } from '../requests'
import { get } from '../requests'

export async function getMerchants(
	pagination: PaginationObject
): Promise<PaginatedResponse<Merchant>> {
	const { data: results, pagination: paginationResponse } = await get<
		Merchant[]
	>('/v2/merchants', pagination)

	return { results, pagination: paginationResponse }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/accountStatementJobs.ts
import type { PaginationObject } from 'components/Pagination'
import type { AccountStatementJobParameters } from 'hooks/useAccountStatementJob'
import type {
	Account,
	AccountStatementJob,
	AccountStatementJobState
} from 'types'
import { get, type PaginatedResponse, post } from '../requests'
import { searchParametersToUrlString } from '../search/searchParameters'

interface SearchParameters {
	accountId?: number
	states?: AccountStatementJobState[]
	sort?: 'ASC' | 'DESC'
}

export async function getAccountStatementJobs(
	pagination: PaginationObject,
	searchParameters: Partial<SearchParameters>
): Promise<PaginatedResponse<AccountStatementJob>> {
	const urlParameters = searchParametersToUrlString(searchParameters)

	const { data: results, pagination: responsePagination } = await get<
		AccountStatementJob[]
	>(`/v2/account-statement-jobs?${urlParameters}`, pagination)

	return { results, pagination: responsePagination }
}

export async function postAccountStatementJob({
	accountId,
	parameters
}: {
	accountId: Account['id']
	parameters: Partial<AccountStatementJobParameters>
}): Promise<unknown> {
	return post<boolean>(`/v2/accounts/${accountId}/statements`, parameters)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/providers.ts
import type { PaginatedResponse } from 'api/requests'
import { get, patch, post, remove, toPaginatedResponse } from 'api/requests'
import { searchParametersToUrlString } from 'api/search/searchParameters'
import type { PaginationObject } from 'components/Pagination'
import type { ProviderFilter } from 'hooks/useProviders'
import type { Account, Provider } from 'types'

export async function getProvidersByAccount(
	accountId: number,
	pagination: PaginationObject,
	searchParameters: Partial<ProviderFilter>
): Promise<PaginatedResponse<Provider>> {
	const { search } = searchParameters
	const urlParameters = searchParametersToUrlString({ search })
	const { data: results, pagination: responsePagination } = await get<
		Provider[]
	>(`/v2/accounts/${accountId}/providers?${urlParameters}`, pagination)

	return { results, pagination: responsePagination }
}

export async function getProviders(): Promise<PaginatedResponse<Provider>> {
	const { data: results } = await get<Provider[]>(`/v2/providers`)
	return toPaginatedResponse(results)
}

export async function getMerchantProviders(
	merchantId: number | undefined
): Promise<PaginatedResponse<Provider>> {
	if (!merchantId) {
		return toPaginatedResponse([])
	}

	const { data: results } = await get<Provider[]>(
		`/v2/merchants/${merchantId}/providers`
	)
	return toPaginatedResponse(results)
}

export async function getProvider(providerId: number): Promise<Provider> {
	const { data } = await get<Provider>(`/v2/providers/${providerId}`)
	return data
}

export async function updateProvider({
	id,
	accountId,
	data
}: {
	id: Provider['id']
	accountId: Account['id']
	data: Partial<Provider>
}): Promise<PaginatedResponse<Provider>> {
	const provider = await patch<Provider>(
		`/v2/accounts/${accountId}/providers/${id}`,
		data
	)
	return toPaginatedResponse(provider)
}

export async function createProvider({
	accountId,
	data
}: {
	accountId: Account['id']
	data: Partial<Provider>
}): Promise<PaginatedResponse<Provider>> {
	const provider = await post<Provider>(
		`/v2/accounts/${accountId}/providers`,
		data
	)
	return toPaginatedResponse(provider)
}

export async function deleteProvider({
	accountId,
	providerId
}: {
	accountId: Account['id']
	providerId: Provider['id']
}): Promise<void> {
	await remove(`/v2/accounts/${accountId}/providers/${providerId}`)
}

export async function getAccount(
	id: Account['id']
): Promise<PaginatedResponse<Account>> {
	const { data: result } = await get<Account>(`/v2/accounts/${id}`)
	return toPaginatedResponse(result)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/metrics.ts
import { get } from '../requests'
import type { TransferState } from 'types'

export interface TimeMetrics {
	avg: number
	max: number
	min: number
}

export interface AmountMetrics {
	avg: number
	max: number
	min: number
	sum: number
}

export interface ManagementMetrics {
	cancel: number
	reassign: number
	retry: number
	complete: number
}

export interface StateMetrics extends Record<string, number> {
	[TransferState.PENDING]: number
	[TransferState.ASSIGNED]: number
	[TransferState.PROCESSING]: number
	[TransferState.COMPLETED]: number
	[TransferState.FAILED]: number
	[TransferState.CANCELED]: number
}

export interface MetricsParameters {
	from?: string
	to?: string
}

export async function getTimeMetrics(
	providerId: number,
	parameters: MetricsParameters = {}
): Promise<TimeMetrics> {
	const endpoint = `/v2/metrics/${providerId}/time`

	const dateRange = {
		...(parameters.from && { from: parameters.from }),
		...(parameters.to && { to: parameters.to })
	}

	const urlParameters = new URLSearchParams(dateRange).toString()

	const { data: metrics } = await get<TimeMetrics>(
		`${endpoint}?${urlParameters}`
	)
	return metrics
}

export async function getAmountMetrics(
	providerId: number,
	parameters: MetricsParameters = {}
): Promise<AmountMetrics> {
	const endpoint = `/v2/metrics/${providerId}/amount`
	const dateRange = {
		...(parameters.from && { from: parameters.from }),
		...(parameters.to && { to: parameters.to })
	}

	const urlParameters = new URLSearchParams(dateRange).toString()

	const { data: metrics } = await get<AmountMetrics>(
		`${endpoint}?${urlParameters}`
	)
	return metrics
}

export async function getManagementMetrics(
	providerId: number,
	parameters: MetricsParameters = {}
): Promise<ManagementMetrics> {
	const endpoint = `/v2/metrics/${providerId}/management`
	const dateRange = {
		...(parameters.from && { from: parameters.from }),
		...(parameters.to && { to: parameters.to })
	}

	const urlParameters = new URLSearchParams(dateRange).toString()

	const { data: metrics } = await get<ManagementMetrics>(
		`${endpoint}?${urlParameters}`
	)
	return metrics
}

export async function getStateMetrics(
	providerId: number,
	parameters: MetricsParameters = {}
): Promise<StateMetrics> {
	const endpoint = `/v2/metrics/${providerId}/state`

	const dateRange = {
		...(parameters.from && { from: parameters.from }),
		...(parameters.to && { to: parameters.to })
	}

	const urlParameters = new URLSearchParams(dateRange).toString()

	const { data: metrics } = await get<StateMetrics>(
		`${endpoint}?${urlParameters}`
	)
	return metrics
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/v2/payoutActions.ts
import { get, type PaginatedResponse } from 'api/requests'
import type { PaginationObject } from 'components/Pagination'
import type { PayoutAction } from 'types'

export async function getPayoutActions(
	pagination: PaginationObject
): Promise<PaginatedResponse<PayoutAction>> {
	const { data: results, pagination: responsePagination } = await get<
		PayoutAction[]
	>('/v2/payout-actions', pagination)

	return { results, pagination: responsePagination }
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/searchParameters.ts
/**
 * Returns a Date object for 24 hours ago
 * @return {Date}
 */
export const get24HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 24 * 60 * 60 * 1000)
}

export const get6HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 6 * 60 * 60 * 1000)
}

export const get3HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 3 * 60 * 60 * 1000)
}

/** Returns a tuple of Date objects for the current day
 * @return {[Date, Date]}
 * @example
 * const [from, to] = getToday()
 * console.log(from.toISOString()) // '2020-01-01T00:00:00.000Z'
 * console.log(to.toISOString()) // '2020-01-07T23:59:59.999Z'
 */
export const getToday = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getFullYear(), now.getMonth(), now.getDate())
	const to = new Date(from.getTime() + 24 * 60 * 60 * 1000 - 1)
	return [from, to]
}

/** Returns a tuple of Date objects for yesterday
 * @return {[Date, Date]}
 */
export const getYesterday = (): [Date, Date] => {
	const [from] = getToday()
	return [
		new Date(from.getTime() - 24 * 60 * 60 * 1000),
		new Date(from.getTime() - 1)
	]
}

/**  Returns a tuple of Date objects for the current month
 * @return {[Date, Date]}
 */
export const getThisMonth = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getFullYear(), now.getMonth(), 1)
	const to = new Date(
		new Date(now.getFullYear(), now.getMonth() + 1, 1).getTime() - 1
	)
	return [from, to]
}

export const getPastMonth = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
	return [from, now]
}

export const getPastWeek = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
	return [from, now]
}

export class DateRange {
	public to?: string

	public from?: string

	public constructor(interval: SearchParameters['dateInterval']) {
		switch (interval) {
			case 'last_24_hours': {
				this.from = get24HoursAgo().toISOString()
				break
			}
			case 'today': {
				const [from, to] = getToday()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'yesterday': {
				const [from, to] = getYesterday()
				this.from = from.toISOString()
				this.to = to.toISOString()

				break
			}
			case 'past_month': {
				const [from, to] = getPastMonth()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'past_week': {
				const [from, to] = getPastWeek()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'this_month': {
				const [from, to] = getThisMonth()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'last_6_hours': {
				this.from = get6HoursAgo().toISOString()
				break
			}
			case 'last_3_hours': {
				this.from = get3HoursAgo().toISOString()
				break
			}
			case 'all': {
				this.from = undefined
				this.to = undefined
				break
			}
			default: {
				this.from = interval.from?.toISOString()
				this.to = interval.to?.toISOString()
				break
			}
		}
	}

	public static urlParamsFromDateInterval(
		interval: SearchParameters['dateInterval']
	): string {
		const range = new DateRange(interval)
		return range.urlParams()
	}

	public urlParams(): string {
		const parameters: Record<string, string> = {}
		if (this.from) parameters.from = this.from
		if (this.to) parameters.to = this.to

		return new URLSearchParams(parameters).toString()
	}
}

// | 'all'
// | 'last_24_hours'
// | 'last_month' // last 30 days
// | 'this_month' // current month
// | 'past_week' // last 7 days
// | 'today'
// | 'yesterday'

export interface SearchParameters {
	dateInterval:
		| 'all'
		| 'last_3_hours'
		| 'last_6_hours'
		| 'last_24_hours'
		| 'past_month'
		| 'past_week'
		| 'this_month'
		| 'today'
		| 'yesterday'
		| { from?: Date; to?: Date }
	destinationBankCode?: string
	originBankCode?: string
}

export const dateIntervalLabels: Record<string, string> = {
	last_3_hours: 'Últimas 3 hrs',
	last_6_hours: 'Últimas 6 hrs',
	last_24_hours: 'Últimas 24 hrs',
	today: 'Hoy',
	yesterday: 'Ayer',
	past_week: 'Última semana (7 días)',
	this_month: 'Mes actual',
	past_month: 'Último mes (30 días)',

	all: 'Todo el tiempo'
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/search/searchParameters.ts
import type { Currency, PayoutState } from '../../types'
import DateRange from './dateRange'
import State from './state'

export interface DateIntervalObject {
	from?: Date
	to?: Date
}

export interface SearchParameters {
	dateInterval:
		| 'all'
		| 'dateRange'
		| 'last_3_hours'
		| 'last_6_hours'
		| 'last_24_hours'
		| 'past_month'
		| 'past_week'
		| 'this_month'
		| 'today'
		| 'yesterday'
	states?: PayoutState[]
	search?: string
	destinationBankCode?: string
	originBankCode?: string
	sort?: 'ASC' | 'DESC'
	amount?: number
	destinationHolderId?: string
	bankAccountId?: number
	currency?: Currency
	merchantId?: number
	providerId?: number
}

export interface SearchParameter {
	urlParams: () => string
}

export function searchParametersToUrlString(
	parameters: Record<string, unknown>
): string {
	const urlParameters: string[] = []

	for (const [key, value] of Object.entries(parameters)) {
		switch (key) {
			case 'dateRange':
			case 'dateInterval':
				urlParameters.push(
					new DateRange(value as SearchParameters['dateInterval']).urlParams()
				)
				break
			case 'states':
				urlParameters.push(new State(value as string[]).urlParams())
				break
			case 'originBankCode':
				if (typeof value === 'string') {
					urlParameters.push(
						new URLSearchParams({
							'transfer[originBankCode]': value
						}).toString()
					)
				}
				break
			case 'providerId':
				if (typeof value === 'number') {
					urlParameters.push(
						new URLSearchParams({
							'transfer[providerId]': value.toString()
						}).toString()
					)
				}
				break
			default:
				if (typeof value === 'number' || typeof value === 'string') {
					urlParameters.push(
						new URLSearchParams({
							[key]: value.toString().trim()
						}).toString()
					)
				}
		}
	}

	return urlParameters.join('&')
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/search/dateRange.ts
import { splitDateRange } from 'utils'
import type { SearchParameter, SearchParameters } from './searchParameters'

/**
 * Returns a Date object for 24 hours ago
 * @return {Date}
 */
export const get24HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 24 * 60 * 60 * 1000)
}

export const get6HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 6 * 60 * 60 * 1000)
}

export const get3HoursAgo = (): Date => {
	const now = new Date()
	return new Date(now.getTime() - 3 * 60 * 60 * 1000)
}

/** Returns a tuple of Date objects for the current day
 * @return {[Date, Date]}
 * @example
 * const [from, to] = getToday()
 * console.log(from.toISOString()) // '2020-01-01T00:00:00.000Z'
 * console.log(to.toISOString()) // '2020-01-07T23:59:59.999Z'
 */
export const getToday = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getFullYear(), now.getMonth(), now.getDate())
	const to = new Date(from.getTime() + 24 * 60 * 60 * 1000 - 1)
	return [from, to]
}

/** Returns a tuple of Date objects for yesterday
 * @return {[Date, Date]}
 */
export const getYesterday = (): [Date, Date] => {
	const [from] = getToday()
	return [
		new Date(from.getTime() - 24 * 60 * 60 * 1000),
		new Date(from.getTime() - 1)
	]
}

/**  Returns a tuple of Date objects for the current month
 * @return {[Date, Date]}
 */
export const getThisMonth = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getFullYear(), now.getMonth(), 1)
	const to = new Date(
		new Date(now.getFullYear(), now.getMonth() + 1, 1).getTime() - 1
	)
	return [from, to]
}

export const getPastMonth = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
	return [from, now]
}

export const getPastWeek = (): [Date, Date] => {
	const now = new Date()
	const from = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
	return [from, now]
}
export default class DateRange implements SearchParameter {
	public to?: string

	public from?: string

	public constructor(interval: SearchParameters['dateInterval']) {
		switch (interval) {
			case 'last_24_hours': {
				this.from = get24HoursAgo().toISOString()
				break
			}
			case 'today': {
				const [from, to] = getToday()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'yesterday': {
				const [from, to] = getYesterday()
				this.from = from.toISOString()
				this.to = to.toISOString()

				break
			}
			case 'past_month': {
				const [from, to] = getPastMonth()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'past_week': {
				const [from, to] = getPastWeek()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'this_month': {
				const [from, to] = getThisMonth()
				this.from = from.toISOString()
				this.to = to.toISOString()
				break
			}
			case 'last_6_hours': {
				this.from = get6HoursAgo().toISOString()
				break
			}
			case 'last_3_hours': {
				this.from = get3HoursAgo().toISOString()
				break
			}
			case 'all': {
				this.from = undefined
				this.to = undefined
				break
			}
			default: {
				const dateRange = splitDateRange(interval)

				if (dateRange.from) this.from = dateRange.from.toISOString()
				if (dateRange.to) this.to = dateRange.to.toISOString()

				break
			}
		}
	}

	public static urlParamsFromDateInterval(
		interval: SearchParameters['dateInterval']
	): string {
		const range = new DateRange(interval)
		return range.urlParams()
	}

	public urlParams(): string {
		const parameters: Record<string, string> = {}
		if (this.from) parameters.from = this.from
		if (this.to) parameters.to = this.to

		return new URLSearchParams(parameters).toString()
	}
}

export const dateIntervalLabels: Record<string, string> = {
	last_3_hours: 'Últimas 3 hrs',
	last_6_hours: 'Últimas 6 hrs',
	last_24_hours: 'Últimas 24 hrs',
	today: 'Hoy',
	yesterday: 'Ayer',
	past_week: 'Última semana (7 días)',
	this_month: 'Mes actual',
	past_month: 'Último mes (30 días)',

	all: 'Todo el tiempo'
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/search/__tests__/searchParameters.spec.ts
import { PayoutState } from 'types'
import { test } from 'vitest'
import type { SearchParameters } from '../searchParameters'
import { searchParametersToUrlString } from '../searchParameters'

test.each([
	{
		input: {
			dateInterval: '2023-01-01T00:00:00.000Z::2023-12-31T00:00:00.000Z'
		},
		output: 'from=2023-01-01T00%3A00%3A00.000Z&to=2023-12-31T00%3A00%3A00.000Z'
	},
	{
		input: {
			states: [PayoutState.PENDING, PayoutState.PROCESSING, PayoutState.FAILED],
			currency: 'clp',
			destinationBankCode: 'cl_banco_de_chile',
			originBankCode: 'cl_banco_de_chile',
			sort: 'DESC'
		},
		output:
			'states%5B%5D=pending&states%5B%5D=processing&states%5B%5D=failed&currency=clp&destinationBankCode=cl_banco_de_chile&transfer%5BoriginBankCode%5D=cl_banco_de_chile&sort=DESC'
	},
	{
		input: {
			states: [PayoutState.PENDING, PayoutState.PROCESSING],
			currency: 'clp',
			merchantId: 1,
			sort: 'ASC'
		},
		output:
			'states%5B%5D=pending&states%5B%5D=processing&currency=clp&merchantId=1&sort=ASC'
	}
])(
	'Given search parameters, when converted to URL string, then result should match expected output',
	({ input, output }) => {
		const result = searchParametersToUrlString(
			input as Partial<SearchParameters>
		)
		expect(result).toBe(output)
	}
)


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/search/state.ts
import type { SearchParameter } from './searchParameters'

export default class State implements SearchParameter {
	public constructor(states: string[]) {
		this.states = states
	}

	public states: string[]

	public urlParams(): string {
		return this.states
			.map(state => new URLSearchParams({ 'states[]': state }).toString())
			.join('&')
	}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/requests.ts
import type { PaginationObject } from 'components/Pagination'
import { headersToPagination } from 'components/Pagination'
import { merchantFilterRoutes } from 'hooks/useAuth'
import HttpStatusCode from 'httpStatusCode'
import Cookies from 'js-cookie'
import { cleanRequestEmptyProperties } from 'utils'
import config from '../config'

const API_URL = config.api.url

export interface PaginatedResponse<T> {
	results: T[]
	pagination: PaginationObject
}

function appendQueryMerchantId(endpoint: string, merchantId: string): string {
	const includesRoute = merchantFilterRoutes.some(
		route => endpoint.startsWith(route) && endpoint !== '/v2/users/me'
	)
	if (includesRoute) return `&merchantId=${merchantId}`
	return ''
}

async function parseJsonResponse<Type>(response: Response): Promise<Type> {
	const body = await response.text()
	if (body.length === 0) {
		return {} as Promise<Type>
	}

	return JSON.parse(body) as Promise<Type>
}

// Convert any response to a PaginatedResponse
export function toPaginatedResponse<T>(data: T | T[]): PaginatedResponse<T> {
	if (Array.isArray(data)) {
		return {
			results: data,
			pagination: {
				currentPage: 1,
				totalElements: data.length,
				elementsPerPage: data.length
			}
		}
	}
	return {
		results: [data],
		pagination: {
			currentPage: 1,
			totalElements: 1,
			elementsPerPage: 1
		}
	}
}

async function getMethod(endpoint: string, token: string): Promise<Response> {
	const cleanedEndpoint = cleanRequestEmptyProperties(endpoint)
	const response = await fetch(`${API_URL}${cleanedEndpoint}`, {
		method: 'GET',
		headers: {
			Authorization: `Bearer ${token}`
		}
	})
	if (!response.ok) {
		const errorResponse = (await response.json()) as APIError
		if (errorResponse.statusCode === HttpStatusCode.UNAUTHORIZED)
			dispatchEvent(new Event('logout'))
		const error =
			errorResponse.statusCode && errorResponse.message && errorResponse.error
				? new Error(
						`${errorResponse.error} (${errorResponse.statusCode}): ${errorResponse.message}`
				  )
				: new Error(`Failed to get ${endpoint}`)
		throw error
	}
	return response
}

export async function getTyped<Type>(endpoint: string): Promise<Type> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}
	const response = await getMethod(endpoint, token)
	const result = (await response.json()) as Type
	return result
}

export async function get<Type>(
	endpoint: string,
	pagination?: PaginationObject
): Promise<{ data: Type; pagination: PaginationObject }> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}
	const merchantId = localStorage.getItem('merchantId')
	let urlParameters = endpoint.includes('?') ? '&' : '?'
	if (pagination) {
		const paginationParameters = new URLSearchParams({
			page: String(pagination.currentPage),
			limit: String(pagination.elementsPerPage)
		})
		urlParameters += paginationParameters.toString()
	}
	const appendMerchantId = merchantId
		? appendQueryMerchantId(endpoint, merchantId)
		: ''
	const url = `${endpoint}${urlParameters}${appendMerchantId}`
	const response = await getMethod(url, token)

	const headersObject: Record<string, string> = {}
	for (const [key, value] of response.headers.entries()) {
		headersObject[key.toLocaleLowerCase()] = value
	}

	return {
		data: (await response.json()) as Type,
		pagination: headersToPagination(headersObject)
	}
}

export interface APIError {
	statusCode?: number
	message?: string
	error?: string
}

export async function patch<Type>(
	endpoint: string,
	body?: Record<string, unknown>
): Promise<Type> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}

	const response = await fetch(`${API_URL}${endpoint}`, {
		method: 'PATCH',
		headers: {
			Authorization: `Bearer ${token}`,
			'Content-Type': 'application/json'
		},
		body: JSON.stringify(body)
	})
	if (!response.ok) {
		const errorResponse = (await response.json()) as APIError
		if (errorResponse.statusCode === HttpStatusCode.UNAUTHORIZED)
			dispatchEvent(new Event('logout'))
		const error =
			errorResponse.statusCode && errorResponse.message && errorResponse.error
				? new Error(
						`${errorResponse.error} (${errorResponse.statusCode}): ${errorResponse.message}`
				  )
				: new Error(`Failed to patch ${endpoint}`)
		throw error
	}
	return response.json() as Promise<Type>
}

export async function put<Type>(
	endpoint: string,
	body: Record<string, unknown>
): Promise<Type> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}

	const response = await fetch(`${API_URL}${endpoint}`, {
		method: 'PUT',
		headers: {
			Authorization: `Bearer ${token}`,
			'Content-Type': 'application/json'
		},
		body: JSON.stringify(body)
	})
	if (!response.ok) {
		const errorResponse = (await response.json()) as APIError
		if (errorResponse.statusCode === HttpStatusCode.UNAUTHORIZED)
			dispatchEvent(new Event('logout'))
		const error =
			errorResponse.statusCode && errorResponse.message && errorResponse.error
				? new Error(
						`${errorResponse.error} (${errorResponse.statusCode}): ${errorResponse.message}`
				  )
				: new Error(`Failed to put ${endpoint}`)
		throw error
	}
	return response.json() as Promise<Type>
}

export async function post<Type>(
	endpoint: string,
	body?: Record<string, unknown>
): Promise<Type> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}

	const response = await fetch(`${API_URL}${endpoint}`, {
		method: 'POST',
		headers: {
			Authorization: `Bearer ${token}`,
			'Content-Type': 'application/json'
		},
		body: JSON.stringify(body)
	})
	if (!response.ok) {
		const errorResponse = (await response.json()) as APIError
		if (errorResponse.statusCode === HttpStatusCode.UNAUTHORIZED)
			dispatchEvent(new Event('logout'))
		const error =
			errorResponse.statusCode && errorResponse.message && errorResponse.error
				? new Error(
						`${errorResponse.error} (${errorResponse.statusCode}): ${errorResponse.message}`
				  )
				: new Error(`Failed to post ${endpoint}`)
		throw error
	}
	return response.json() as Promise<Type>
}

export async function remove<Type>(endpoint: string): Promise<Type> {
	const token = Cookies.get('token')
	if (!token) {
		throw new Error('No token present')
	}

	const response = await fetch(`${API_URL}${endpoint}`, {
		method: 'DELETE',
		headers: {
			Authorization: `Bearer ${token}`,
			'Content-Type': 'application/json'
		}
	})

	if (!response.ok) {
		const errorResponse = (await response.json()) as APIError
		if (errorResponse.statusCode === HttpStatusCode.UNAUTHORIZED)
			dispatchEvent(new Event('logout'))
		const error =
			errorResponse.statusCode && errorResponse.message && errorResponse.error
				? new Error(
						`${errorResponse.error} (${errorResponse.statusCode}): ${errorResponse.message}`
				  )
				: new Error(`Failed to delete ${endpoint}`)
		throw error
	}

	return parseJsonResponse(response)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockTransferErrors.ts
import type { PaginationObject } from 'components/Pagination'
import { makeTransferErrors } from 'mocks/data/transferErrors'
import type { TransferError } from 'types'
import type { SpyInstance } from 'vitest'
import * as TransferErrorsModule from '../../v2/transferErrors'

export function mockGetTransferErrors(
	qty: number,
	items?: TransferError[]
): SpyInstance {
	const generatedItems: TransferError[] = items ?? makeTransferErrors(qty)
	return vi
		.spyOn(TransferErrorsModule, 'getTransferErrors')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedItems.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedItems.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockProviders.ts
import * as ProviderModule from '../../v2/providers'
import { makeProviders } from 'mocks/data/providers'
import type { Account, Provider } from 'types'
import type { PaginationObject } from 'components/Pagination'
import type { SpyInstance } from 'vitest'
import { toPaginatedResponse } from 'api/requests'

export function mockGetProvidersByAccount(qty: number): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'getProvidersByAccount')
		.mockImplementation(
			async (accountId: number, pagination: PaginationObject) => {
				const providers: Provider[] = makeProviders(qty, {
					accountId
				})

				return {
					results: providers.slice(
						(pagination.currentPage - 1) * pagination.elementsPerPage,
						pagination.elementsPerPage * pagination.currentPage
					),
					pagination: {
						...pagination,
						totalElements: providers.length
					}
				}
			}
		)
}

export function mockGetProviders(qty: number): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'getProviders')
		.mockImplementation(async () => {
			const providers: Provider[] = makeProviders(qty)

			return toPaginatedResponse(providers)
		})
}

export function mockGetProvider(): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'getProvider')
		.mockImplementation(
			async (providerId: number) => makeProviders(1, { id: providerId })[0]
		)
}

export function mockGetMerchantProviders(
	qty: number,
	providers?: Provider[]
): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'getMerchantProviders')
		.mockImplementation(async () => {
			const createdProviders: Provider[] = makeProviders(qty)
			return toPaginatedResponse(providers ?? createdProviders)
		})
}

export function mockUpdateProvider(): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'updateProvider')
		.mockImplementation(
			async ({
				id,
				accountId,
				data
			}: {
				id: Provider['id']
				accountId: Account['id']
				data: Partial<Provider>
			}) => toPaginatedResponse(makeProviders(1, { id, accountId, ...data }))
		)
}

export function mockCreateProvider(): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'createProvider')
		.mockImplementation(async ({ data }: { data: Partial<Provider> }) =>
			toPaginatedResponse(makeProviders(1, data))
		)
}

export function mockDeleteProvider(): SpyInstance {
	return vi
		.spyOn(ProviderModule, 'deleteProvider')
		.mockImplementation(async (): Promise<void> => {})
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockAccounts.ts
import type { Account } from 'types'
import * as AccountsModule from '../../v2/accounts'
import type { PaginationObject } from 'components/Pagination'
import { makeAccounts } from 'mocks/data/accounts'
import type { SpyInstance } from 'vitest'

export function mockGetAccounts(
	qty: number,
	override?: Account[]
): SpyInstance {
	const accounts: Account[] = override ?? makeAccounts(qty)

	return vi
		.spyOn(AccountsModule, 'getAccounts')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: accounts.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: accounts.length
			}
		}))
}

export function mockUpdateAccount(): SpyInstance {
	return vi
		.spyOn(AccountsModule, 'updateAccount')
		.mockImplementation(
			async ({ id, data }: { id: Account['id']; data: Partial<Account> }) => {
				const account = makeAccounts(1)[0]

				return Object.assign(account, { id, ...data })
			}
		)
}

export function mockCreateAccount(): SpyInstance {
	return vi
		.spyOn(AccountsModule, 'createAccount')
		.mockImplementation(async ({ data }: { data: Partial<Account> }) => {
			const account = makeAccounts(1)[0]

			return Object.assign(account, { ...data })
		})
}

export function mockGetAccountById(
	id: number,
	override?: Account
): SpyInstance {
	const account: Account = override ?? makeAccounts(1, { id })[0]

	return vi
		.spyOn(AccountsModule, 'getAccount')
		.mockImplementation(async () => account)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockApiKeys.ts
import type { PaginationObject } from 'components/Pagination'
import type { ApiKey } from 'types'
import type { SpyInstance } from 'vitest'
import * as ApiKeysModule from '../../v2/apiKey'
import type { PaginatedResponse } from 'api/requests'
import { makeApiKey, makeApiKeys } from 'mocks/data/apiKeys'

export function mockGetApiKeys(
	qty: number,
	apiKeys?: ApiKey[]
): SpyInstance<
	[pagination: PaginationObject],
	Promise<PaginatedResponse<ApiKey>>
> {
	const generatedApiKeys: ApiKey[] = apiKeys ?? makeApiKeys(qty)
	return vi
		.spyOn(ApiKeysModule, 'getApiKeys')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedApiKeys.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedApiKeys.length
			}
		}))
}

export function mockGetApiKey(
	apiKey?: Partial<ApiKey>
): SpyInstance<[id: number], Promise<ApiKey>> {
	const generatedApiKey: ApiKey = makeApiKey(apiKey)
	return vi
		.spyOn(ApiKeysModule, 'getApiKey')
		.mockImplementation(async (id: number) => {
			if (!id) throw new Error('No api key id provided')
			return generatedApiKey
		})
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockAuditLogs.ts
import * as AuditLogsModule from '../../v2/auditLogs'
import type { PaginationObject } from 'components/Pagination'
import type { AuditLog } from 'types'
import type { SpyInstance } from 'vitest'
import { makeAuditLogs } from 'mocks/data/auditLogs'

export function mockGetAuditLogs(qty: number): SpyInstance {
	const auditLogs: AuditLog[] = makeAuditLogs(qty)

	return vi
		.spyOn(AuditLogsModule, 'getAuditLogs')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: auditLogs.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: auditLogs.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockAccountStatements.ts
import type { SpyInstance } from 'vitest'
import { makeAccountStatements } from 'mocks/data/accountStatements'
import type { AccountStatement } from 'types'
import * as AccountStatementsModule from '../../v2/accountStatements'
import type { PaginationObject } from 'components/Pagination'

export function mockGetAccountStatements(
	qty: number,
	override?: AccountStatement[]
): SpyInstance {
	const accountStatements = override ?? makeAccountStatements(qty)

	return vi
		.spyOn(AccountStatementsModule, 'getAccountStatements')
		.mockImplementation(
			async (_searchParameters, pagination: PaginationObject) => ({
				results: accountStatements.slice(
					(pagination.currentPage - 1) * pagination.elementsPerPage,
					pagination.elementsPerPage * pagination.currentPage
				),
				pagination: {
					...pagination,
					totalElements: accountStatements.length
				}
			})
		)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockMerchantLimits.ts
import type { SpyInstance } from 'vitest'
import type { Merchant, MerchantLimit } from 'types'
import * as MerchantLimitModule from '../../v2/merchantLimits'
import { makeMerchantLimits } from 'mocks/data/merchantLimits'
import { toPaginatedResponse } from 'api/requests'

export function mockGetMerchantLimits(
	qty: number,
	merchantLimits?: MerchantLimit[]
): SpyInstance {
	return vi
		.spyOn(MerchantLimitModule, 'getMerchantLimits')
		.mockImplementation(async () => {
			const createdMerchantLimits: MerchantLimit[] = makeMerchantLimits(qty)
			return toPaginatedResponse(merchantLimits ?? createdMerchantLimits)
		})
}

export function mockCreateMerchantLimit(): SpyInstance {
	return vi
		.spyOn(MerchantLimitModule, 'createMerchantLimit')
		.mockImplementation(async ({ data }: { data: Partial<MerchantLimit> }) => {
			const merchant = makeMerchantLimits(1, data)[0]

			return Object.assign(merchant, { ...data })
		})
}

export function mockUpdateMerchantLimit(): SpyInstance {
	return vi
		.spyOn(MerchantLimitModule, 'updateMerchantLimit')
		.mockImplementation(
			async ({
				id,
				merchantId,
				data
			}: {
				id: MerchantLimit['id']
				merchantId: Merchant['id']
				data: Partial<MerchantLimit>
			}) => {
				const merchantLimit = makeMerchantLimits(1)[0]

				return Object.assign(merchantLimit, { id, merchantId, ...data })
			}
		)
}

export function mockDeleteMerchantLimit(): SpyInstance {
	return vi
		.spyOn(MerchantLimitModule, 'deleteMerchantLimit')
		.mockImplementation(
			async ({
				id,
				merchantId
			}: {
				id: MerchantLimit['id']
				merchantId: Merchant['id']
			}) => {
				const merchantLimit = makeMerchantLimits(1)[0]

				return Object.assign(merchantLimit, { id, merchantId })
			}
		)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockUsers.ts
import type { PaginationObject } from 'components/Pagination'
import type { User } from 'types'
import type { SpyInstance } from 'vitest'
import * as UsersModule from '../../v2/users'
import * as AuthModule from '../../v2/auth'
import { makeUsers } from 'mocks/data/users'
import type { ChangeUserPasswordDto } from '../../v2/auth'

export function mockGetUser(
	user?: Partial<User>
): SpyInstance<[id: number], Promise<User>> {
	const generatedUser: User = makeUsers(1, user)[0]
	return vi
		.spyOn(UsersModule, 'getUser')
		.mockImplementation(async (id: number) => {
			if (!id) throw new Error('No user id provided')
			return generatedUser
		})
}

export function mockGetUsers(qty: number, users?: User[]): SpyInstance {
	const generatedUsers: User[] = users ?? makeUsers(qty)
	return vi
		.spyOn(UsersModule, 'getUsers')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedUsers.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedUsers.length
			}
		}))
}

export const mockUpdateUser = (
	user: Pick<User, 'id'>
): SpyInstance<[{ id: number; data: Partial<User> }], Promise<User>> =>
	vi
		.spyOn(UsersModule, 'updateUser')
		.mockImplementation(async () => user as User)

export const mockDeleteUser = (): SpyInstance<[id: number], Promise<void>> =>
	vi.spyOn(UsersModule, 'deleteUser').mockImplementation(async () => {})

export const mockResetMfa = (): SpyInstance<
	[id: number],
	Promise<{ message: string }>
> =>
	vi
		.spyOn(AuthModule, 'resetMfa')
		.mockImplementation(async () => ({ message: 'ok' }))

export const mockResetUserPassword = (): SpyInstance<
	[id: number],
	Promise<{ message: string }>
> =>
	vi
		.spyOn(AuthModule, 'resetUserPassword')
		.mockImplementation(async () => ({ message: 'Password reset successful' }))

export const mockChangePassword = (): SpyInstance<
	[data: Partial<ChangeUserPasswordDto>],
	Promise<{ message: string }>
> =>
	vi
		.spyOn(AuthModule, 'changePassword')
		.mockImplementation(async (data: Partial<ChangeUserPasswordDto>) => {
			void data
			return { message: 'ok' }
		})

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockReconciliations.ts
import type { SpyInstance } from 'vitest'
import * as ReconciliationModule from '../../v2/reconciliation'

export function mockGetReconciliation(): SpyInstance {
	return vi
		.spyOn(ReconciliationModule, 'getReconciliation')
		.mockImplementation(async () => [
			{
				destinationHolderId: '1239129123',
				amountMismatch: 123,
				diffCount: 1,
				transfers: [],
				accountStatements: []
			}
		])
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockBanks.ts
import type { PaginationObject } from 'components/Pagination'
import { makeBanks } from 'mocks/data/banks'
import type { Bank } from 'types'
import type { SpyInstance } from 'vitest'
import * as BanksModule from '../../v2/banks'
import type { PaginatedResponse } from 'api/requests'

export function mockGetBanks(
	qty: number,
	banks?: Bank[]
): SpyInstance<
	[pagination: PaginationObject],
	Promise<PaginatedResponse<Bank>>
> {
	const generatedBanks: Bank[] = banks ?? makeBanks(qty)
	return vi
		.spyOn(BanksModule, 'getBanks')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedBanks.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedBanks.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockTransferMethods.ts
import type { PaginationObject } from 'components/Pagination'
import type { TransferMethod } from 'types'
import type { SpyInstance } from 'vitest'
import * as TransferMethodsModule from '../../v2/transferMethod'
import type { PaginatedResponse } from 'api/requests'
import { makeTransferMethods } from 'mocks/data/transferMethods'

export function mockGetTransferMethod(
	transferMethod?: Partial<TransferMethod>
): SpyInstance<[id: number], Promise<TransferMethod>> {
	const generatedTransferMethod: TransferMethod = makeTransferMethods(
		1,
		transferMethod
	)[0]
	return vi
		.spyOn(TransferMethodsModule, 'getTransferMethod')
		.mockImplementation(async (id: number) => {
			if (!id) throw new Error('No transfer method id provided')
			return generatedTransferMethod
		})
}

export function mockGetTransferMethods(
	qty: number,
	transferMethods?: TransferMethod[]
): SpyInstance<
	[pagination: PaginationObject],
	Promise<PaginatedResponse<TransferMethod>>
> {
	const generatedTransferMethods: TransferMethod[] =
		transferMethods ?? makeTransferMethods(qty)
	return vi
		.spyOn(TransferMethodsModule, 'getTransferMethods')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedTransferMethods.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedTransferMethods.length
			}
		}))
}

export function mockCreateTransferMethod(
	error?: Error
): SpyInstance<[{ data: Partial<TransferMethod> }], Promise<TransferMethod>> {
	return vi
		.spyOn(TransferMethodsModule, 'createTransferMethod')
		.mockImplementation(async ({ data }) => {
			if (error) throw error
			// Here we need to assume that the data is complete enough to satisfy a TransferMethod,
			// perhaps by providing default values in a real implementation
			return data as TransferMethod
		})
}

export function mockUpdateTransferMethod(
	error?: Error
): SpyInstance<
	[{ id: TransferMethod['id']; data: Partial<TransferMethod> }],
	Promise<TransferMethod>
> {
	return vi
		.spyOn(TransferMethodsModule, 'updateTransferMethod')
		.mockImplementation(async ({ id, data }) => {
			if (error) throw error
			const transferMethod: TransferMethod = makeTransferMethods(1)[0]
			return { ...transferMethod, ...data, id }
		})
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockAccountStatementJob.ts
import type { PaginationObject } from 'components/Pagination'
import type { AccountStatementJob } from 'types'
import type { SpyInstance } from 'vitest'
import { makeAccountStatementJobs } from '../../../mocks/data/accountStatementJob'
import * as AccountStatementsJobModule from '../../v2/accountStatementJobs'

export function mockPostAccountStatementJob(): SpyInstance {
	return vi
		.spyOn(AccountStatementsJobModule, 'postAccountStatementJob')
		.mockImplementation(async () => {})
}

export function mockGetAccountStatementJobs(
	qty: number,
	override?: AccountStatementJob[]
): SpyInstance {
	const accountStatements: AccountStatementJob[] =
		override ?? makeAccountStatementJobs(qty)
	return vi
		.spyOn(AccountStatementsJobModule, 'getAccountStatementJobs')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: accountStatements.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: accountStatements.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockMerchants.ts
import type { PaginationObject } from 'components/Pagination'
import type { Merchant } from 'types'
import type { SpyInstance } from 'vitest'
import * as MerchantsModule from '../../v2/merchants'
import type { PaginatedResponse } from 'api/requests'
import { makeMerchants } from 'mocks/data/merchants'

export function mockGetMerchants(
	qty: number,
	merchants?: Merchant[]
): SpyInstance<
	[pagination: PaginationObject],
	Promise<PaginatedResponse<Merchant>>
> {
	const generatedMerchants: Merchant[] = merchants ?? makeMerchants(qty)
	return vi
		.spyOn(MerchantsModule, 'getMerchants')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedMerchants.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedMerchants.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockPayoutActions.ts
import type { PaginationObject } from 'components/Pagination'
import { makePayoutActions } from 'mocks/data/payoutActions'
import type { PayoutAction } from 'types'
import type { SpyInstance } from 'vitest'
import * as PayoutActionModule from '../../v2/payoutActions'

export function mockGetPayoutActions(
	qty: number,
	payoutActions?: PayoutAction[]
): SpyInstance {
	const generatedPayoutActions: PayoutAction[] =
		payoutActions ?? makePayoutActions(qty)
	return vi
		.spyOn(PayoutActionModule, 'getPayoutActions')
		.mockImplementation(async (pagination: PaginationObject) => ({
			results: generatedPayoutActions.slice(
				(pagination.currentPage - 1) * pagination.elementsPerPage,
				pagination.elementsPerPage * pagination.currentPage
			),
			pagination: {
				...pagination,
				totalElements: generatedPayoutActions.length
			}
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/api/__mocks__/v2/mockPayouts.ts
import type { SpyInstance } from 'vitest'
import type { PaginationObject } from 'components/Pagination'
import { makePayout, makePayouts } from 'mocks/data/payouts'
import { ApiVersion, type Payout } from 'types'
import * as PayoutsModule from '../../v2/payouts'

export function mockGetPayouts(qty: number, payouts?: Payout[]): SpyInstance {
	const generatedPayouts: Payout[] = payouts ?? makePayouts(qty)
	return vi
		.spyOn(PayoutsModule, 'getPayouts')
		.mockImplementation(
			async (_searchParameters, pagination: PaginationObject) => ({
				results: generatedPayouts.slice(
					(pagination.currentPage - 1) * pagination.elementsPerPage,
					pagination.elementsPerPage * pagination.currentPage
				),
				pagination: {
					...pagination,
					totalElements: generatedPayouts.length
				}
			})
		)
}

export function mockGetPayoutById(id?: number): SpyInstance {
	const payout = makePayout(id ? { id } : undefined)

	return vi
		.spyOn(PayoutsModule, 'getPayout')
		.mockImplementation(async () => payout)
}

export function mockCancelPayout(): SpyInstance {
	return vi
		.spyOn(PayoutsModule, 'cancelPayout')
		.mockImplementation(
			async (id: Payout['id'], version: ApiVersion = ApiVersion.v2) => {
				const payout = makePayout({ id, version })

				return payout
			}
		)
}

export function mockCompletePayout(): SpyInstance {
	return vi
		.spyOn(PayoutsModule, 'completePayout')
		.mockImplementation(
			async (id: Payout['id'], version: ApiVersion = ApiVersion.v2) => {
				const payout = makePayout({ id, version })

				return payout
			}
		)
}

export function mockRetryPayout(): SpyInstance {
	return vi
		.spyOn(PayoutsModule, 'retryPayout')
		.mockImplementation(async (id: Payout['id']) => {
			const payout = makePayout({ id, version: ApiVersion.v2 })

			return payout
		})
}

export function mockReassignPayout(): SpyInstance {
	return vi
		.spyOn(PayoutsModule, 'reassignPayout')
		.mockImplementation(
			async (payload: { id: number; providerId?: number }) => {
				const payout = makePayout({ id: payload.id })

				return payout
			}
		)
}

export function mockExportPayouts(): SpyInstance {
	return vi
		.spyOn(PayoutsModule, 'exportPayouts')
		.mockImplementation(async () => ({
			data: new ArrayBuffer(0),
			filename: 'HistorialPagos.xlsx'
		}))
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/utils/__tests__/utils.spec.ts
import { describe, test, expect } from 'vitest'
import {
	arrayToMap,
	diffJson,
	exceedThreshold,
	formattedLocalTimestamp,
	getTimeElapsed,
	randomBetween,
	jsonToText,
	parseDatesInObject,
	parseJson,
	sameValues,
	createStringURL,
	splitDateRange,
	isEmpty,
	formatLocalDate,
	addMinutes,
	cleanRequestEmptyProperties
} from 'utils'

describe('when formattedLocalTimestamp is call', () => {
	test('then returns the formatted local timestamp', () => {
		const date = new Date('2023-05-15T10:30:00')
		const formattedTimestamp = formattedLocalTimestamp(date)
		expect(formattedTimestamp).toEqual('2023-05-15 10:30:00')
	})
	test('then returns undefined if date is invalid', () => {
		const date = new Date('invalid date')
		const formattedTimestamp = formattedLocalTimestamp(date)
		expect(formattedTimestamp).toEqual(undefined)
	})
})

describe('when parseDatesInObject is call with an object', () => {
	test('Then should parse ISO date string properties to Date object', () => {
		const data = {
			date: '2011-10-05T14:48:00.000Z'
		}

		const result = parseDatesInObject<{ date: Date }>(data)

		expect(result.date).toBeInstanceOf(Date)
	})

	test('Then should parse ISO date string properties to Date object on nested objets', () => {
		const data = {
			nested: {
				date: '2011-10-05T14:48:00.000Z'
			}
		}

		const result = parseDatesInObject<{ nested: { date: Date } }>(data)

		expect(result.nested.date).toBeInstanceOf(Date)
	})

	test('Then should ignore any non ISO date string properties', () => {
		const data = {
			number: 1,
			boolean: true,
			array: ['value'],
			object: {
				value: 'value'
			}
		}

		const result = parseDatesInObject(data)

		expect(result).toEqual(data)
	})
})

describe('when randomBetween is call', () => {
	test('randomBetween should return a value between min and max', () => {
		const min = 15
		const max = 20
		const result = randomBetween(min, max)
		expect(result).greaterThanOrEqual(min)
		expect(result).lessThanOrEqual(max)
	})
})

describe('when exceedThreshold is call', () => {
	test('exceedThreshold should return true when difference exceeds threshold', () => {
		const toCompareDate = new Date('2023-06-29T10:00:00Z')
		const baseDate = new Date('2023-06-29T09:30:00Z')
		const threshold = 15
		const result = exceedThreshold({ toCompareDate, baseDate, threshold })
		expect(result).toBe(true)
	})

	test('exceedThreshold should return false when difference does not exceed threshold', () => {
		const toCompareDate = new Date('2023-06-29T10:00:00Z')
		const baseDate = new Date('2023-06-29T09:40:00Z')
		const threshold = 30
		const result = exceedThreshold({ toCompareDate, baseDate, threshold })
		expect(result).toBe(false)
	})

	test('exceedThreshold should return false when threshold is zero', () => {
		const toCompareDate = new Date('2023-06-29T10:00:00Z')
		const baseDate = new Date('2023-06-29T10:00:00Z')
		const threshold = 0
		const result = exceedThreshold({ toCompareDate, baseDate, threshold })
		expect(result).toBe(false)
	})

	test('exceedThreshold should return false when baseDate is in the future', () => {
		const toCompareDate = new Date('2023-06-29T10:00:00Z')
		const baseDate = new Date('2023-06-29T10:30:00Z')
		const threshold = 15
		const result = exceedThreshold({ toCompareDate, baseDate, threshold })
		expect(result).toBe(false)
	})

	test('exceedThreshold should return true when threshold is negative', () => {
		const toCompareDate = new Date('2023-06-29T10:00:00Z')
		const baseDate = new Date('2023-06-29T09:30:00Z')
		const threshold = -10
		const result = exceedThreshold({ toCompareDate, baseDate, threshold })
		expect(result).toBe(true)
	})
})

describe('when parseJson is called', () => {
	it('then should return an empty object if invalid json string is provided', () => {
		const validStringJson = ''
		const parsed = parseJson(validStringJson)

		expect(Object.keys(parsed)).toHaveLength(0)
	})

	it('then should return the parsed json object', () => {
		const validStringJson = '{"key":"value","nKey":"value"}'
		const parsed = parseJson(validStringJson)

		expect(Object.keys(parsed)).toHaveLength(2)
	})
})
describe('when jsonToText is called', () => {
	it('then should return an empty object as string if invalid json is provided', () => {
		const object = {}
		const text = jsonToText(object)

		expect(text).toEqual('{}')
	})
	it('then should return the json stringify', () => {
		const object = { key: 'value', nKey: 'value' }
		const text = jsonToText(object)

		expect(JSON.stringify(object)).toEqual(text)
	})
})
describe('when splitDateRange is called', () => {
	it('then should return an object with both from and to value', () => {
		const dateRange = '2023-08-01::2023-08-15'
		const result = splitDateRange(dateRange)

		expect(result.from).toEqual(new Date('2023-08-01'))
		expect(result.to).toEqual(new Date('2023-08-15'))
	})

	it('then should return an object with only from value if only from date is given', () => {
		const dateRange = '2023-08-01::'
		const result = splitDateRange(dateRange)

		expect(result.from).toEqual(new Date('2023-08-01'))
		expect(result.to).toBeUndefined()
	})

	it('then should return an object with only to value if only to date is given', () => {
		const dateRange = '::2023-08-15'
		const result = splitDateRange(dateRange)

		expect(result.from).toBeUndefined()
		expect(result.to).toEqual(new Date('2023-08-15'))
	})

	it('then should return undefined if no date range to split', () => {
		const emptyInput = ''
		const result = splitDateRange(emptyInput)

		expect(result.from).toBeUndefined()
		expect(result.to).toBeUndefined()
	})
})
describe('when sameValues is called', () => {
	it('then should return a new object with same values', () => {
		const nValue = 'newValue'
		const inputObject = {
			key1: 42,
			key2: 'value',
			key3: true
		}

		expect(sameValues(inputObject, nValue)).toEqual({
			key1: 'newValue',
			key2: 'newValue',
			key3: 'newValue'
		})
	})
	it('then should return a new object with undefined values if no value is provided', () => {
		const inputObject = {
			key1: 42,
			key2: 'value',
			key3: true
		}

		expect(sameValues(inputObject)).toEqual({
			key1: undefined,
			key2: undefined,
			key3: undefined
		})
	})
})
describe('when createStringURL is called', () => {
	it('then should return an empty string if the object is empty', () => {
		const emptyObject = {}
		const result = createStringURL(emptyObject)
		expect(result).toBe('')
	})
	it('then should generate a valid query string from the object', () => {
		const parameters = {
			amount: 1000,
			destinationHolderId: '189340222',
			destinationBankCode: 'cl_banco_santander',
			createdAt: '2023-04-01T00:00:00.000Z::2023-04-01T00:00:00.000Z'
		}

		const result = createStringURL(parameters)

		expect(result).toContain('amount=1000')
		expect(result).toContain('destinationHolderId=189340222')
		expect(result).toContain('destinationBankCode=cl_banco_santander')
		expect(result).toContain(
			`createdAt=${encodeURIComponent(parameters.createdAt)}`
		)
	})
})

describe('when arrayToMap is called', () => {
	it('should create a map with correct values for specific array', () => {
		const array = [
			{ id: 1, name: 'John' },
			{ id: 2, name: 'Alice' },
			{ id: 3, name: 'Doe' }
		]
		const result = arrayToMap(array, 'id')
		expect(result).toEqual({
			'1': { id: 1, name: 'John' },
			'2': { id: 2, name: 'Alice' },
			'3': { id: 3, name: 'Doe' }
		})
	})
	it('should handle an empty input array', () => {
		const array: Record<string, string>[] = []
		const result = arrayToMap(array, 'id')
		expect(result).toEqual({})
	})
	it('should handle input with duplicate keys by overwriting values', () => {
		const array = [
			{ id: 1, name: 'John' },
			{ id: 2, name: 'Alice' },
			{ id: 1, name: 'Doe' }
		]
		const result = arrayToMap(array, 'id')
		expect(result).toEqual({
			'1': { id: 1, name: 'Doe' },
			'2': { id: 2, name: 'Alice' }
		})
	})
	it('should handle missing properties in objects by skipping them', () => {
		const array = [{ id: 1, name: 'John' }, {}, { id: 3, name: 'Doe' }]
		const result = arrayToMap(array, 'id')
		expect(result).toEqual({
			'1': { id: 1, name: 'John' },
			'3': { id: 3, name: 'Doe' }
		})
	})
})

describe('when diffJson is called', () => {
	it('should return undefined if the beforeString object string is empty or undefined', () => {
		const object = {}
		const after = jsonToText(object)
		const diff = diffJson(undefined, after)

		expect(diff).toBeUndefined()
	})
	it('should return undefined if the afterString object is empty or undefined', () => {
		const object = {}
		const before = jsonToText(object)
		const diff = diffJson(before, '')

		expect(diff).toBeUndefined()
	})
	it('should return the json diff between two json objects for a single object change', () => {
		const before = { key: 'value', nKey: 'value' }
		const after = { key: 'value-alpha', nKey: 'value' }
		const diff = diffJson(jsonToText(before), jsonToText(after))

		expect(diff).toEqual({ key: [before.key, after.key] })
	})

	// key: before, after
	// value.key: before, after

	it('should return the json diff between two json objects for multiple object changes', () => {
		const before = { key: 'value', nKey: 'value' }
		const after = { key: 'value-alpha', nKey: 'value-beta' }
		const diff = diffJson(jsonToText(before), jsonToText(after))

		expect(diff).toEqual({
			key: [before.key, after.key],
			nKey: [before.nKey, after.nKey]
		})
	})
	it('should return the json diff between two nested json objects', () => {
		const before = { key: { childKey: 'value' } }
		const after = { key: { childKey: 'value-alpha' } }
		const diff = diffJson(jsonToText(before), jsonToText(after))

		expect(diff).toEqual({
			key: { childKey: [before.key.childKey, after.key.childKey] }
		})
	})
	it("should return an empty json object if there aren't differences", () => {
		const before = { key: 'value', nKey: 'value' }
		const after = { key: 'value', nKey: 'value' }

		const diff = diffJson(jsonToText(before), jsonToText(after))

		expect(diff).toEqual({})
	})
	it('should return the json diff when one object has a null property value and the other not', () => {
		// eslint-disable-next-line unicorn/no-null
		const before = { key: 'value', target: null }
		const after = {
			key: 'value',
			target: {
				child: 'value'
			}
		}

		const diff = diffJson(jsonToText(before), jsonToText(after))

		expect(diff).toEqual({
			target: [before.target, after.target]
		})
	})
})

describe('when cleanRequestEmptyProperties is called', () => {
	test('should not return properties with empty values', () => {
		const request =
			'/v2/payouts?states=&from=2023-11-16T14%3A51%3A18.190Z&sort=&currency=&version[]=v1&version[]=v2&page=1&limit=50'
		const cleanedRequest = cleanRequestEmptyProperties(request)
		expect(cleanedRequest).toEqual(
			'/v2/payouts?from=2023-11-16T14%3A51%3A18.190Z&version[]=v1&version[]=v2&page=1&limit=50'
		)
	})
	test('should return duplicated properties as they are given', () => {
		const request = '/v2/payouts?version[]=v1&version[]=v2'
		const cleanedRequest = cleanRequestEmptyProperties(request)
		expect(cleanedRequest).toEqual(request)
	})
	test('should return the single path if no query its given', () => {
		const request = '/v2/payouts'
		const cleanedRequest = cleanRequestEmptyProperties(request)
		expect(cleanedRequest).toEqual('/v2/payouts')
	})
	test('should return the single path if there are only empty values', () => {
		const request =
			'/v2/payouts?states=&from=&sort=&currency=&version[]=&version[]=&page=&limit='
		const cleanedRequest = cleanRequestEmptyProperties(request)
		expect(cleanedRequest).toEqual('/v2/payouts')
	})
})

describe('when getTimeElapsed is called', () => {
	// Test case 1: Valid start and end date, expect the correct output
	test('should return the correct time elapsed format', () => {
		const startDate1 = '2023-01-15'
		const endDate1 = '2023-07-23'
		expect(getTimeElapsed(startDate1, endDate1)).toBe('6 meses')

		const startDate2 = '2023-01-15'
		const endDate2 = '2023-01-15'
		expect(getTimeElapsed(startDate2, endDate2)).toBe('0 seg')

		const startDate3 = '2023-07-23'
		const endDate3 = '2023-07-23'
		expect(getTimeElapsed(startDate3, endDate3)).toBe('0 seg')
	})

	// Test case 2: Only start date provided, expect '-'
	test('should return "-" if only the start date is provided', () => {
		const startDate = '2023-01-15'
		expect(getTimeElapsed(startDate)).toBe('-')
	})

	test('should return "-" if the start date is null', () => {
		const endDate = '2023-01-15'
		// eslint-disable-next-line unicorn/no-null
		expect(getTimeElapsed(null, endDate)).toBe('-')
	})

	// Test case 3: Only end date provided, expect '-'
	test('should return "-" if only the end date is provided', () => {
		const endDate = '2023-07-23'
		expect(getTimeElapsed(undefined, endDate)).toBe('-')
	})

	// Test case 4: No dates provided, expect '-'
	test('should return "-" if no start or end date is provided', () => {
		expect(getTimeElapsed()).toBe('-')
	})

	// Test case 5: Time elapsed less than a minute, expect seconds
	test('should return seconds if time elapsed is less than a minute', () => {
		const startDate = '2023-01-15T12:00:00'
		const endDate = '2023-01-15T12:00:30'
		expect(getTimeElapsed(startDate, endDate)).toBe('30 seg')
	})

	// Test case 6: Time elapsed less than an hour, expect minutes
	test('should return minutes if time elapsed is less than an hour', () => {
		const startDate = '2023-01-15T12:00:00'
		const endDate = '2023-01-15T12:45:00'
		expect(getTimeElapsed(startDate, endDate)).toBe('45 min')
	})

	// Test case 7: Time elapsed less than a day, expect hours
	test('should return hours if time elapsed is less than a day', () => {
		const startDate = '2023-01-15T12:00:00'
		const endDate = '2023-01-15T22:00:00'
		expect(getTimeElapsed(startDate, endDate)).toBe('10 horas')
	})

	// Test case 8: Time elapsed less than a month, expect days
	test('should return days if time elapsed is less than a month', () => {
		const startDate = '2023-01-15'
		const endDate = '2023-02-05'
		expect(getTimeElapsed(startDate, endDate)).toBe('21 días')
	})

	// Test case 9: Time elapsed less than a year, expect months
	test('should return months if time elapsed is less than a year', () => {
		const startDate = '2023-01-15'
		const endDate = '2023-07-05'
		expect(getTimeElapsed(startDate, endDate)).toBe('5 meses')
	})

	// Test case 10: Time elapsed more than a year, expect years
	test('should return years if time elapsed is more than a year', () => {
		const startDate = '2023-01-15'
		const endDate = '2024-07-23'
		expect(getTimeElapsed(startDate, endDate)).toBe('1 año')
	})
})

describe('when isEmpty is called', () => {
	it('should return true for an empty object', () => {
		const emptyObject: Record<string, unknown> = {}
		expect(isEmpty(emptyObject)).toBe(true)
	})

	it('should return false for a non-empty object', () => {
		const nonEmptyObject = { key: 'value' }
		expect(isEmpty(nonEmptyObject)).toBe(false)
	})

	it('should return true for an empty Map', () => {
		const emptyMap = new Map()
		expect(isEmpty(emptyMap)).toBe(true)
	})

	it('should return false for a non-empty Map', () => {
		const nonEmptyMap = new Map()
		nonEmptyMap.set('key', 'value')
		expect(isEmpty(nonEmptyMap)).toBe(false)
	})

	it('should return true for an empty Set', () => {
		const emptySet = new Set()
		expect(isEmpty(emptySet)).toBe(true)
	})

	it('should return false for a non-empty Set', () => {
		const nonEmptySet = new Set()
		nonEmptySet.add('value')
		expect(isEmpty(nonEmptySet)).toBe(false)
	})

	it('should return true for undefined', () => {
		// eslint-disable-next-line unicorn/no-useless-undefined
		expect(isEmpty(undefined)).toBe(true)
	})
})

// The timezone is fixed in vitest.global-setup.ts and vite.config.ts
// as found in this StackOverflow reply: https://stackoverflow.com/questions/69418842/setting-a-timezone-in-vitest
describe('when formatLocalDate is called', () => {
	test('should format the date correctly', () => {
		const date = new Date('2022-01-01T00:00:00Z')
		const formattedDate = formatLocalDate(date)
		// Check for both possible timezone offsets
		expect(formattedDate).toMatch(
			/^(31-12-2021, 20:00:00|31-12-2021, 21:00:00)$/
		)
	})
})

describe('addMinutes function', () => {
	it('should correctly add minutes to a date', () => {
		const date = new Date('2023-10-18T12:00:00')
		const updatedDate = addMinutes(date, 30)

		const expectedDate = new Date('2023-10-18T12:30:00')

		expect(updatedDate).toEqual(expectedDate)
	})

	it('should handle negative minutes to subtract from a date', () => {
		const date = new Date('2023-10-18T12:00:00')
		const updatedDate = addMinutes(date, -15)

		const expectedDate = new Date('2023-10-18T11:45:00')

		expect(updatedDate).toEqual(expectedDate)
	})

	it('should not modify the original date object', () => {
		const date = new Date('2023-10-18T12:00:00')
		const updatedDate = addMinutes(date, 15)

		expect(updatedDate).not.toBe(date)
	})
})


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/utils/__tests__/dateUtils.spec.ts
// test that formatAsDate method returns a date in the format YYYY-MM-DD

import {
	endOfMonth,
	endOfYear,
	formatAsDate,
	startOfMonth,
	startOfYear
} from 'utils/dateUtils'
import { describe, expect } from 'vitest'

describe('formatAsDate', () => {
	it('returns a date in the format YYYY-MM-DD', () => {
		const date = new Date('2020-01-01T00:00:00.000Z')
		expect(formatAsDate(date)).toEqual('2020-01-01')
	})

	it('fails when an invalid date is passed', () => {
		const date = new Date('invalid')
		expect(() => formatAsDate(date)).toThrow()
	})
})

describe('startOfYear', () => {
	it('returns the first day of the year', () => {
		const date = new Date('2020-01-01T00:00:00.000Z')
		expect(startOfYear(date)).toEqual('2020-01-01')
	})

	it('fails when an invalid date is passed', () => {
		const date = new Date('invalid')
		expect(() => startOfYear(date)).toThrow()
	})
})

describe('endOfYear', () => {
	it('returns the last day of the year', () => {
		const date = new Date('2020-01-01T00:00:00.000Z')
		expect(endOfYear(date)).toEqual('2020-12-31')
	})

	it('fails when an invalid date is passed', () => {
		const date = new Date('invalid')
		expect(() => endOfYear(date)).toThrow()
	})
})

describe('startOfMonth', () => {
	it('returns the first day of the month', () => {
		const date = new Date('2020-01-01T00:00:00.000Z')
		expect(startOfMonth(date)).toEqual('2020-01-01')
	})

	it('fails when an invalid date is passed', () => {
		const date = new Date('invalid')
		expect(() => startOfMonth(date)).toThrow()
	})
})

describe('endOfMonth', () => {
	it('returns the last day of the month', () => {
		const date = new Date('2020-01-01T00:00:00.000Z')
		expect(endOfMonth(date)).toEqual('2020-01-31')
	})

	it('fails when an invalid date is passed', () => {
		const date = new Date('invalid')
		expect(() => endOfMonth(date)).toThrow()
	})
})


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/components/DynamicForm/types.ts
/**
 * Types for Dynamic Forms
 *
 * This file uses type composition to build complex types from simpler, reusable pieces.
 * Prefering composition over inheritance to make the codebase more flexible and easier to maintain.
 *
 * - `CommonProperties<T>`: Properties that are common across all form elements.
 * - `ValidatableProperties`: Properties related to validation.
 * - `LoadableProperties`: Properties related to loading state.
 *
 * Each specific form element type then uses these building blocks to compose its own, more specific type.
 */

import type { ResponsiveValue } from '@chakra-ui/react'
import type { FC, ReactElement } from 'react'
import type { InputValidation } from './TextInput'

// Common properties for all form elements
interface CommonProperties<T> {
	key: keyof T
	title?: string
	hiddenIf?: string
	span?: DynamicFormInputGridProperties
}

// Properties specific to form elements that can be validated
interface ValidatableProperties {
	validation?: InputValidation
	autoValidate?: boolean
	onAutoValidateChange?: (
		autovalidation: InputValidation,
		value: number | string,
		key: string
	) => Promise<void> | void
}

// Properties specific to form elements that can show a loading state
interface LoadableProperties {
	isLoading?: boolean
}

// Grid properties for form elements
interface DynamicFormInputGridProperties {
	col?: ResponsiveValue<number | 'auto'>
	row?: ResponsiveValue<number | 'auto'>
	colEnd?: ResponsiveValue<number | 'auto'>
	colStart?: ResponsiveValue<number | 'auto'>
}

// DisplayForm interface
export interface DisplayForm<T> {
	title?: string
	saveButton: ReactElement | string
	invokeButton?: ReactElement | string
	invokeButtonRender?: ReactElement
	templateColumns?: ResponsiveValue<string>
	fields: DisplayFormField<T>[]
	disabledFields?: (keyof T)[]
	submitDisabled?: boolean
	extraButtons?: ExtraButtonElement<T>[]
}

export type DisplayFormField<T> =
	| BankSelectFormElement<T>
	| CheckboxFormElement<T>
	| JsonFormElement<T>
	| MultiSelectFormElement<T>
	| SelectFormElement<T>
	| StateSwitchFormElement<T>
	| TextFormElement<T>

/**
 * TextFormElement type
 *
 * Composed of CommonProperties, ValidatableProperties, and LoadableProperties.
 * The `type` property serves as a discriminant for TypeScript's discriminated unions.
 */
export type TextFormElement<T> = CommonProperties<T> &
	LoadableProperties &
	ValidatableProperties & {
		type: 'text'
		inputType?: 'email' | 'number' | 'password' | 'text'
		onChange?: (
			value: number | string,
			key: string,
			target: HTMLInputElement
		) => void
		required?: boolean
		autocomplete?: 'auto' | 'off' | 'on'
		startClean?: boolean
	}

export type SelectFormElement<T> = CommonProperties<T> &
	LoadableProperties &
	ValidatableProperties & {
		type: 'select'
		options: {
			value: number | string
			label: string
		}[]
		placeholder?: string
		required?: boolean
		startClean?: boolean
	}

export type CheckboxFormElement<T> = CommonProperties<T> & {
	type: 'checkbox'
	options: {
		value: number | string
		label: string
	}[]
}

export type BankSelectFormElement<T> = CommonProperties<T> & {
	type: 'bankSelect'
	placeholder?: string
}

export type JsonFormElement<T> = CommonProperties<T> & {
	type: 'json'
}

export type StateSwitchFormElement<T> = CommonProperties<T> & {
	type: 'stateSwitch'
}

export type MultiSelectFormElement<T> = CommonProperties<T> & {
	type: 'multiSelect'
	options: {
		value: number | string
		label: string
	}[]
	placeholder?: string
}

/**
 * Extra buttons
 */

export interface ExtraButtonElementProperties<T> {
	data: Partial<T>
	onParentDrawerClose: () => void
}

export type ExtraButtonElement<T> = FC<ExtraButtonElementProperties<T>>


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/components/PayoutActions/types.ts
import type { IconType } from 'react-icons'

export enum Action {
	CANCEL = 'cancel',
	COMPLETE = 'complete',
	REASSIGN = 'reassign',
	RETRY = 'retry'
}

export enum PayoutsAutoActions {
	AUTO_CANCEL = 'AUTO_CANCEL',
	AUTO_RETRY = 'AUTO_RETRY'
}

export interface PayoutAction {
	label: string
	sublabel: string
	icon?: IconType
	action: Action
}
export const mappedAction = {
	[PayoutsAutoActions.AUTO_CANCEL]: Action.CANCEL,
	[PayoutsAutoActions.AUTO_RETRY]: Action.RETRY
}
export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/types.ts
export enum Currency {
	CLP = 'clp',
	COP = 'cop',
	MXN = 'mxn',
	PEN = 'pen',
	BRL = 'brl',
	BOB = 'bob'
}

export enum State {
	ACTIVE = 'active',
	INACTIVE = 'inactive',
	DELETED = 'deleted'
}

export enum TimeFactor {
	MILLIS_TO_SECONDS = 1000
}

export interface Merchant {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	identifier: string
	state: State
	merchantLimits?: MerchantLimit[]
}

export enum LimitScope {
	MERCHANT = 'merchant',
	PERSON = 'person'
}

export enum LimitCriteria {
	AMOUNT = 'amount',
	COUNT = 'count'
}

export enum LimitAggregation {
	MINUTE = 'minute',
	DAY = 'day',
	HOUR = 'hour',
	WEEK = 'week',
	MONTH = 'month',
	YEAR = 'year'
}

export interface MerchantLimitDefinition {
	id?: number // corresponds to MerchantLimit['id'], but is required by the edition
	value: number
	criteria: LimitCriteria
	currency?: Currency
	scope: LimitScope
	aggregation: LimitAggregation
}

export enum MerchantLimitType {
	RATE = 'rate'
}

export interface MerchantLimit {
	id: number
	uuid: string
	limitType: MerchantLimitType
	limitDefinition?: Partial<MerchantLimitDefinition>
	state: State
	merchantId: number
	createdAt: string
	updatedAt: string
}

export const NonUpdatableMerchantLimitDefinitionProperties: (keyof MerchantLimitDefinition)[] =
	['id', 'currency', 'criteria', 'scope', 'scope', 'aggregation']

export interface User {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	email: string
	password?: string
	state: State
	role: UserRole
	mfa?: boolean
	mfaState?: MFAState
	merchantId: number
	code?: string
}

export const NonUpdatableUserProperties: (keyof User)[] = [
	'id',
	'uuid',
	'createdAt',
	'updatedAt',
	'email',
	'merchantId',
	'code',
	'mfa',
	'mfaState'
]

export enum UserRole {
	ADMIN = 'admin',
	SUPER = 'super',
	USER = 'user',
	SUPPORT = 'support'
}

export const UserRoleLabels: { [key in UserRole]: string } = {
	[UserRole.ADMIN]: 'Administrador',
	[UserRole.SUPER]: 'Super Administrador',
	[UserRole.USER]: 'Usuario',
	[UserRole.SUPPORT]: 'Soporte'
}

export enum MFAState {
	DISABLED = 'disabled',
	ENROLLED = 'enrolled',
	VERIFIED = 'verified'
}

export enum MFAError {
	INVALID_STEP = 'Invalid Step',
	MISSING_MFA_CODE = 'Missing MFA code',
	DISABLED_MFA = 'Disabled MFA',
	INVALID_CODE = 'Invalid Code'
}

export enum PayoutState {
	PENDING = 'pending',
	PROCESSING = 'processing',
	COMPLETED = 'completed',
	FAILED = 'failed',
	CANCELED = 'canceled'
}

export const PayoutFinishedStates = [
	PayoutState.COMPLETED,
	PayoutState.CANCELED,
	PayoutState.FAILED
]
export enum ApiVersion {
	v1 = 'v1',
	v2 = 'v2'
}

export const PayoutStateColors: { [key in PayoutState]: string } = {
	[PayoutState.PENDING]: 'teal',
	[PayoutState.PROCESSING]: 'blue',
	[PayoutState.COMPLETED]: 'green',
	[PayoutState.CANCELED]: 'gray',
	[PayoutState.FAILED]: 'red'
}

export const PayoutStateLabels: { [key in PayoutState]: string } = {
	[PayoutState.PENDING]: 'Pendiente',
	[PayoutState.PROCESSING]: 'Procesando',
	[PayoutState.COMPLETED]: 'Completado',
	[PayoutState.CANCELED]: 'Cancelado',
	[PayoutState.FAILED]: 'Fallido'
}

export interface Payout {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	state: PayoutState
	amount: number
	currency: Currency
	concept: string
	trackingCode: string
	metadata?: PayoutMetadata
	destinationEmail: string
	destinationName: string
	destinationAddress: string
	destinationHolderId: string
	destinationAccount: string
	destinationBankCode: string
	destinationPhone?: string
	version: ApiVersion
	providerId?: number
	merchantId: number
	merchant: Merchant
	transfers: Transfer[]
	message?: string | null
	errorCode?: string
}
export interface PayoutActionMetadata {
	action: string
}
export interface PayoutMetadata {
	paymentId?: number
	companyId?: number
	action?: string
	message?: string
}

export enum TransferState {
	ASSIGNED = 'assigned',
	COMPLETED = 'completed',
	FAILED = 'failed',
	PENDING = 'pending',
	AUTHORIZING = 'authorizing',
	PROCESSING = 'processing',
	CANCELED = 'canceled',
	CREATED = 'created'
}

export enum CountryCode {
	BRASIL = 'BRA',
	CHILE = 'CHL',
	COLOMBIA = 'COL',
	MEXICO = 'MEX',
	PERU = 'PER',
	BOLIVIA = 'BOL'
}

export interface TransferMetadata {
	externalId?: string
}

export interface Transfer {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	state: TransferState
	amount: number
	currency: Currency
	mode: 'bulk' | 'single'
	concept: string
	trackingCode: string
	destinationEmail: string
	destinationName: string
	destinationHolderId: string
	destinationAccount: string
	destinationBankCode: string
	merchantId: number
	payoutId: number | null
	originBankCode: string | null
	originBankAccessId: number | null
	originBankAccountId: number | null
	originBankAccess: BankAccess | null
	providerId: number | null
	message: string | null
	startedAt: string | null
	finishedAt: string | null
	metadata: TransferMetadata | null
	destinationPhone: string | null
	externalId: string | null
	version: ApiVersion
	autoRetried: boolean
}

export interface BankAccount {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	identifier: string
	state: State
	currency: Currency
	accountType: 'current' | 'savings'
	holderId: string
	bankCode: string
	merchantId: number
}

export interface AccountStatement {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	date: Date
	originBankCode: string
	originBankAccountIdentifier: string
	currency: Currency
	concept: string
	countryCode: CountryCode
	amount: number
	state: PayoutState
	transactionCode: string
	destinationHolderId: string
	destinationName: string
	destinationAccount: string
	destinationEmail: string
	destinationBankCode: string
	retrievedAt: Date
	metadata: AccountStatementMetadata
	accountStatementJobId: number
}

export enum AccountStatementJobState {
	STARTED = 'started',
	CREATED = 'created',
	FINISHED = 'finished',
	ERROR = 'error'
}

export const AccountStatementJobStateColors: {
	[key in AccountStatementJobState]: string
} = {
	[AccountStatementJobState.CREATED]: 'teal',
	[AccountStatementJobState.STARTED]: 'blue',
	[AccountStatementJobState.FINISHED]: 'green',
	[AccountStatementJobState.ERROR]: 'red'
}

export const AccountStatementJobStateLabels: {
	[key in AccountStatementJobState]: string
} = {
	[AccountStatementJobState.CREATED]: 'Creado',
	[AccountStatementJobState.STARTED]: 'Iniciado',
	[AccountStatementJobState.FINISHED]: 'Finalizado',
	[AccountStatementJobState.ERROR]: 'Error'
}

export interface AccountStatementJob {
	id: number
	endDate: Date
	startDate: Date
	state: AccountStatementJobState
	endedAt?: string
	startedAt: string
	balance?: number
	retrievedAt?: string
	totalRetrieved?: number
	jobId: string
	bankAccountId?: number
	accountId?: number
	bankAccount?: BankAccount
	accountStatements?: AccountStatement[]
	createdAt: Date
	updatedAt: Date
}

export const NonUpdatableBankAccountProperties: (keyof BankAccount)[] = [
	'id',
	'uuid',
	'createdAt',
	'updatedAt',
	'currency',
	'bankCode',
	'merchantId'
]

export interface Bank {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	state: State
	name: string
	code: string
}

export enum BankAccessProviderType {
	SCRAPER_CG = 'scraperCG',
	SCRAPER_PW = 'scraperPW',
	MINKA = 'minka',
	LIQUIDO = 'liquido',
	SHINKANSEN = 'shinkansen'
}
export interface BankAccess {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	name: string
	state: State
	accessType: 'business' | 'personal'
	providerType: BankAccessProviderType
	credentials: {
		username: string
		password: string
	}
	merchantId: number
	bankCode: string
	bankAccounts: BankAccount[]
	bankAccountIds?: BankAccount['id'][]
	transferMethods: TransferMethod[]
	bank: Bank
	capabilities?: ('authorize_transfer' | 'create_transfer')[]
}

export interface Account {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	bankCode: string
	identifier: string
	state: State
	name: string
	rules?: unknown
	merchantId: Merchant['id']
	currency: Currency
	countryCode: CountryCode
	holderId: string
}

export enum ProviderType {
	ScraperCG = 'scraperCG',
	ScraperPW = 'scraperPW',
	Minka = 'minka',
	Liquido = 'liquido',
	Shinkansen = 'shinkansen'
}

export interface Provider {
	id: number
	uuid: string
	account?: Account
	createdAt: string
	updatedAt: string
	providerType: ProviderType
	capabilities: ProviderCapability[]
	name: string
	state: State
	rules?: unknown
	priority?: number | null
	credentials?: object
	accountId: Account['id']
}

export interface AuditLog {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	version?: number
	context?: string
	authorId?: number
	authorType?: string
	event: string
	entityId: string
	entityType: string
	entityAfter?: string
	entityBefore?: string
}

export interface TransferMismatch {
	destinationHolderId: string
	amountMismatch: number
	diffCount: number
	transfers: Transfer[]
	accountStatements: AccountStatement[]
}
// eslint-disable-next-line unicorn/no-null
export const NULL_PRIORITY = null

export const NonUpdatableBankAccessProperties: (keyof BankAccess)[] = [
	'id',
	'uuid',
	'createdAt',
	'updatedAt',
	'accessType',
	'merchantId',
	'bankCode',
	'bankAccounts',
	'transferMethods',
	'bank'
]

export interface TransferMethod {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	state: State
	signingKeys: string | null
	methodType: 'digipass' | 'security_card' | 'sms'
	merchantId: Merchant['id']
	bankAccessId: BankAccess['id']
	identifier: string
}

export interface AccountStatementMetadata {
	status?: string
	destinationBank?: string
}

export const NonUpdatableTransferMethodProperties: (keyof TransferMethod)[] = [
	'id',
	'uuid',
	'createdAt',
	'updatedAt',
	'identifier',
	'methodType',
	'bankAccessId',
	'merchantId'
]

export const NonUpdatableAccountProperties: (keyof Account)[] = [
	'id',
	'uuid',
	'bankCode',
	'identifier',
	'holderId',
	'merchantId',
	'currency',
	'countryCode',
	'createdAt',
	'updatedAt'
]

export const NonUpdatableProviderProperties: (keyof Provider)[] = [
	'id',
	'uuid',
	'account',
	'providerType',
	'accountId',
	'createdAt',
	'updatedAt'
]
export interface ApiKey {
	id: number
	uuid: string
	key: string
	name: string
	state: State
	merchantId?: Merchant['id']
	role: User['role']
	createdAt: string
	updatedAt: string
}

export interface PayoutAction {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	errorCode: string
	errorType?: string
	action?: string
	suggestion?: string
}

export interface TransferError {
	id: number
	uuid: string
	createdAt: string
	updatedAt: string
	errorRaw: string
	pattern?: string
	errorCode: string
	errorType?: string
	description?: string
	issuer?: string
	externalErrorCode?: string
	providerType?: string
}

export interface LabelProperties {
	title: string
	colorScheme?: string
}

export interface FileArrayBuffer {
	data: ArrayBuffer
	filename: string
	fileType?: string
}

export enum CurrencyFromCountryCode {
	CHL = 'clp',
	COL = 'cop',
	MEX = 'mxn',
	PER = 'pen',
	BRA = 'brl'
}

export enum ShortCountryCode {
	CHILE = 'cl',
	COLOMBIA = 'co',
	MEXICO = 'mx',
	PERU = 'pe',
	BRAZIL = 'br',
	BOLIVIA = 'bo'
}

export enum AuditLogEvent {
	INSERT = 'insert',
	UPDATE = 'update',
	REMOVE = 'remove',
	SOFTREMOVE = 'softremove'
}

export enum AuditLogEntityType {
	PayoutEntity = 'PayoutEntity',
	TransferEntity = 'TransferEntity',
	UserEntity = 'UserEntity'
}

export enum AuditLogAuthorType {
	UserEntity = 'UserEntity',
	ApiKeyEntity = 'ApiKeyEntity',
	PayoutsApi = 'PayoutsApi'
}

export interface SelectOption {
	value: number | string
	label: string
	color?: string
}

export const CurrencyToSelectOptions: SelectOption[] = [
	{ value: 'ars', label: 'Peso argentino' },
	{ value: 'bob', label: 'Peso boliviano' },
	{ value: 'brl', label: 'Real brasileño' },
	{ value: 'clp', label: 'Peso chileno' },
	{ value: 'cop', label: 'Peso colombiano' },
	{ value: 'mxn', label: 'Peso mexicano' },
	{ value: 'pen', label: 'Sol peruano' },
	{ value: 'usd', label: 'Dólar estadounidense' },
	{ value: 'uyu', label: 'Peso uruguayo' }
]

// TODO: Use  SelectOption interface
export const LimitCriteriaToSelectOptions = [
	{ value: 'amount', label: 'Monto' },
	{ value: 'count', label: 'Cantidad' }
]

export const LimitScopeToSelectOptions = [
	{ value: 'merchant', label: 'Merchant', color: 'green' },
	{ value: 'person', label: 'Persona', color: 'blue' }
]

export const StateToSelectOptions: SelectOption[] = [
	{ color: 'green', label: 'Activa', value: 'active' },
	{ color: 'gray', label: 'Inactiva', value: 'inactive' },
	{ color: 'yellow', label: 'Eliminada', value: 'deleted' }
]

export const LimitAggregationToSelectOptions = [
	{ value: LimitAggregation.MINUTE, label: 'Minuto' },
	{ value: LimitAggregation.HOUR, label: 'Hora' },
	{ value: LimitAggregation.DAY, label: 'Día' },
	{ value: LimitAggregation.WEEK, label: 'Semana' },
	{ value: LimitAggregation.MONTH, label: 'Mes' },
	{ value: LimitAggregation.YEAR, label: 'Año' }
]

export const ProviderTypeToSelectOptions = [
	{ value: 'minka', label: 'Minka' },
	{ value: 'liquido', label: 'Liquido' },
	{ value: 'shinkansen', label: 'Shinkansen' },
	{ value: 'scraperCG', label: 'Scraper CG' },
	{ value: 'scraperPW', label: 'Scraper PW' },
	{ value: 'thomas', label: 'Thomas' }
]

export const ProviderCapabilityToSelectOptions = [
	{ value: 'read_transfer', label: 'Lectura' },
	{ value: 'create_transfer', label: 'Creación' }
]

export enum ProviderCapability {
	READ_TRANSFER = 'read_transfer',
	CREATE_TRANSFER = 'create_transfer',
	ALL = 'all'
}

export const ProviderCapabilityLabels: { [key in ProviderCapability]: string } =
	{
		[ProviderCapability.READ_TRANSFER]: 'Lectura',
		[ProviderCapability.CREATE_TRANSFER]: 'Creación',
		[ProviderCapability.ALL]: 'Múltiple'
	}

export const CountryToSelectOptions = [
	{ value: 'BRA', label: 'Brasil' },
	{ value: 'CHL', label: 'Chile' },
	{ value: 'COL', label: 'Colombia' },
	{ value: 'MEX', label: 'México' },
	{ value: 'PER', label: 'Perú' }
]

export const InactiveActiveStateToSelectOptions = [
	{
		value: 'active',
		label: 'Activo'
	},
	{ value: 'inactive', label: 'Inactivo' }
]

export enum TransferErrorType {
	UNKNOWN_ERROR = 'UNKNOWN_ERROR',
	PROVIDER_INTERNAL_FAILURE = 'PROVIDER_INTERNAL_FAILURE',
	PROVIDER_INSUFFICIENT_FUNDS = 'PROVIDER_INSUFFICIENT_FUNDS',
	RECIPIENT_FIRST_TRANSFER = 'RECIPIENT_FIRST_TRANSFER',
	RECIPIENT_INVALID_ACCOUNT = 'RECIPIENT_INVALID_ACCOUNT',
	RECIPIENT_DISABLED_ACCOUNT = 'RECIPIENT_DISABLED_ACCOUNT',
	DESTINATION_BANK_IN_MAINTENANCE = 'DESTINATION_BANK_IN_MAINTENANCE',
	DESTINATION_BANK_NOT_AVAILABLE = 'DESTINATION_BANK_NOT_AVAILABLE',
	DESTINATION_BANK_TIMEOUT = 'DESTINATION_BANK_TIMEOUT',
	RECIPIENT_ACCOUNT_OVER_LIMIT = 'RECIPIENT_ACCOUNT_OVER_LIMIT',
	MERCHANT_LIMIT_EXCEED = 'MERCHANT_LIMIT_EXCEED'
}

export interface TransferErrorLabel {
	type: TransferErrorType
	label: string
}

export const TransferErrorLabels: TransferErrorLabel[] = [
	{
		type: TransferErrorType.UNKNOWN_ERROR,
		label: 'Error desconocido'
	},
	{
		type: TransferErrorType.PROVIDER_INTERNAL_FAILURE,
		label: 'Fallo interno del proveedor'
	},
	{
		type: TransferErrorType.PROVIDER_INSUFFICIENT_FUNDS,
		label: 'Fondos insuficientes en el proveedor'
	},
	{
		type: TransferErrorType.RECIPIENT_FIRST_TRANSFER,
		label: 'Primera transferencia para el destinatario'
	},
	{
		type: TransferErrorType.RECIPIENT_INVALID_ACCOUNT,
		label: 'Cuenta de destinatario inválida'
	},
	{
		type: TransferErrorType.RECIPIENT_DISABLED_ACCOUNT,
		label: 'Cuenta de destinatario desactivada'
	},
	{
		type: TransferErrorType.DESTINATION_BANK_IN_MAINTENANCE,
		label: 'Banco de destino en mantenimiento'
	},
	{
		type: TransferErrorType.DESTINATION_BANK_NOT_AVAILABLE,
		label: 'Banco de destino no disponible'
	},
	{
		type: TransferErrorType.DESTINATION_BANK_TIMEOUT,
		label: 'Tiempo de espera del banco de destino agotado'
	},
	{
		type: TransferErrorType.RECIPIENT_ACCOUNT_OVER_LIMIT,
		label: 'Cuenta de destinatario sobre el límite'
	},
	{
		type: TransferErrorType.MERCHANT_LIMIT_EXCEED,
		label: 'Excede el límite del merchant'
	}
]


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/utils.ts
/* eslint-disable unicorn/no-unsafe-regex */
import { useLayoutEffect, useState } from 'react'
import type { DateIntervalObject } from 'api/search/searchParameters'
import type { NavItem } from 'components/Nav'
import type { UserRole } from 'types'

// TODO: remove as it is unused
export function useMediaQuery(query: string): boolean {
	const [matches, setMatches] = useState(() => matchMedia(query).matches)

	useLayoutEffect(() => {
		const mediaQuery = matchMedia(query)

		function onMediaQueryChange(): void {
			setMatches(mediaQuery.matches)
		}

		mediaQuery.addEventListener('change', onMediaQueryChange)

		return (): void => {
			mediaQuery.removeEventListener('change', onMediaQueryChange)
		}
	}, [query])

	return matches
}

export const LOCALE = 'es-CL'
export const DEFAULT_TIMEZONE = 'America/Santiago'

function isValidTimezone(timeZone?: string): boolean {
	if (!timeZone) {
		return false
	}
	try {
		const validTimezone = new Date().toLocaleString(LOCALE, { timeZone })
		return !!validTimezone
	} catch {
		return false
	}
}

function getBrowserTimezone(): string {
	try {
		const { timeZone } = Intl.DateTimeFormat().resolvedOptions()
		return isValidTimezone(timeZone) ? timeZone : DEFAULT_TIMEZONE
	} catch {
		return DEFAULT_TIMEZONE
	}
}

/**
 * Formats a given date to a local date string.
 * @param date - The date to be formatted.
 * @returns The formatted local date string.
 * @example
 * // Returns "31-12-2021, 20:00:00" if the browser's timezone is 'America/Santiago' and it is currently in a 4 hour offset from UTC.
 * formatLocalDate(new Date('2023-01-01T00:00:00Z'))
 * @see {@link utils.spec.ts} for tests related to this function.
 *
 * Note: This function uses the browser's timezone for formatting.
 */
export function formatLocalDate(date: Date): string {
	const tz = getBrowserTimezone()
	return date.toLocaleString(LOCALE, {
		timeZone: tz
	})
}

/**
 * Converts an array of objects into a key-value map based on the specified properties.
 * @param {Array<T>} array - The array of objects to convert.
 * @param {string} keyProperty - The property to use as the key in the map.
 * @returns {Object} A key-value map where keys are taken from the keyProperty and values from the given interface.
 */
export const arrayToMap = <T>(
	array: T[],
	keyProperty: keyof T
): Record<string, T> => {
	const map: Record<string, T> = {}
	for (const item of array) {
		const keyValue = item[keyProperty]
		if (!(typeof keyValue === 'undefined')) {
			map[String(keyValue)] = item
		}
	}
	return map
}

/**
 * Formats timestamp to YYYY-MM-DDTHH:mm:ss
 * @param date - Date to be formatted
 * @returns formatted timestamp
 */
export const formattedTimestamp = (date: Date): string => {
	const dateString = date.toISOString().split('T')[0]
	const time = date.toTimeString().split(' ')[0]
	return `${dateString} ${time}`
}

/**
 * Formats to local timestamp to YYYY-MM-DDTHH:mm:ss
 * @param date - Date to be formatted
 * @returns formatted local timestamp
 */
export const formattedLocalTimestamp = (date: Date): string | undefined => {
	try {
		if (date instanceof Date) {
			const localeDate = formatLocalDate(date)
			const dateString = localeDate.split(',')[0]
			const dateStringArray = dateString.split('-').reverse().join('-')
			const time = localeDate.split(',')[1].trim()
			return `${dateStringArray} ${time}`
		}
		return undefined
	} catch {
		return undefined
	}
}

export function createStringURL(object: Record<string, unknown>): string {
	const objectKeys = Object.keys(object)
	if (objectKeys.length === 0) return ''
	const nObject: Record<string, string> = {}
	for (const key of objectKeys) {
		if (object[key] !== undefined) {
			nObject[key] = String(object[key])
		}
	}
	const query = new URLSearchParams(nObject)
	return query.toString()
}

/**
 * Capitalizes first letter of each word
 * @param string_ - string to capitalize
 * @returns capitalized string
 */
export function titleCase(string_: string): string {
	return string_
		.split(' ')
		.map(word => word.charAt(0).toUpperCase() + word.slice(1))
		.join(' ')
}

/**
 * Returns time elapsed between given date and current time
 * @param date - Date
 * @returns time elapsed
 */
export function timeAgo(date: Date): string {
	const rtf = new Intl.RelativeTimeFormat(LOCALE, {
		localeMatcher: 'best fit', // other values: "lookup"
		numeric: 'auto', // other values: "auto"
		style: 'long' // other values: "short" or "narrow"
	})

	const seconds = Math.floor((Date.now() - date.getTime()) / 1000)

	let interval = Math.floor(seconds / 86_400)

	if (interval > 1) {
		// return `${interval} días`
		return rtf.format(-interval, 'day')
	}

	interval = Math.floor(seconds / 3600)

	if (interval > 1) {
		// return `${interval} horas`
		return rtf.format(-interval, 'hour')
	}

	interval = Math.floor(seconds / 60)

	if (interval > 1) {
		// return `${interval} minutos`
		return rtf.format(-interval, 'minute')
	}

	// return `${Math.floor(seconds)} segundos`
	return rtf.format(-seconds, 'second')
}

const INVALID_CHARACTERS_REGEX = /[^\dk]/gi

/**
 * Checks if a string has a valid RUT format. It doesn't check if the RUT has a valid verification digit.
 * @param {string} value The string to check.
 * @return {boolean}
 */
export const validateRUTString = (value: string): boolean => {
	// checks that :
	// - value exists
	// - value has length of 9 or 8 after removing invalid characters
	// - value has only numbers except for the last one
	// - value last character is either a number or uppercase K
	if (!value) return false
	let nValue = value.toString().toUpperCase()
	nValue = nValue.replace(INVALID_CHARACTERS_REGEX, '')
	return (
		(nValue.length === 8 || nValue.length === 9) &&
		/^\d+$/.test(nValue.slice(0, -1)) &&
		(value.endsWith('K') || /^\d+$/.test(nValue.slice(-1)))
	)
}

/**
 * @param min: number: The minimum value of the range (inclusive)
 * @param max: number: The maximum value of the range (exclusive).
 * @returns number: A random number within the specified range, rounded down to the nearest integer.
 */
export function randomBetween(min: number, max: number): number {
	return Math.floor(Math.random() * (max - min)) + min
}

/**
 * Iterates over an object and searches for values in ISO 8601 date format to convert them to Date objects.
 * @template Type - Type of the output object.
 * @param {Record<string, unknown>} data - Object to iterate over and analyze.
 * @returns {Type} - Object with converted dates.
 */
export function parseDatesInObject<Type>(data: Record<string, unknown>): Type {
	// Regular expression to match ISO 8601 date format
	const dateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/
	const result: Record<string, unknown> = data
	for (const [key, value] of Object.entries(data)) {
		if (typeof value === 'string' && dateRegex.test(value)) {
			result[key] = new Date(value)
		} else if (typeof value === 'object') {
			result[key] = parseDatesInObject(value as Record<string, unknown>)
		}
	}

	return result as Type
}

export function downloadFile(data: Blob, filename: string): void {
	const url = window.URL.createObjectURL(data)
	const link = document.createElement('a')
	link.download = filename
	link.href = url

	link.click()
	link.remove()
	URL.revokeObjectURL(url)
}

export function getAWSBatchJobLink(jobId: string): string {
	return `https://us-west-1.console.aws.amazon.com/batch/home?region=us-west-1#jobs/detail/${jobId}`
}
// This code was copied from here: https://bitbucket.org/payflow-chile/dashboard-front-end/src/master/src/utils/rut.js
// If possible, update that one to match the linter rules from this project, eventually - MT

const diffTime = (fistTime: number, secondTime: number): number =>
	fistTime - secondTime

/**
 * Returns if difference between two datetimes exceeds a threshold
 * @param {Date} toCompareDate
 * @param {Date} baseDate
 * @param {number} threshold number of the threshold
 * @return {string\null} The formatted RUT or null if the RUT is invalid
 */
export function exceedThreshold({
	toCompareDate,
	baseDate,
	threshold = 15
}: {
	toCompareDate: Date
	baseDate: Date
	threshold?: number
}): boolean {
	const diffInMs = diffTime(toCompareDate.getTime(), baseDate.getTime())
	const diff = Math.floor(diffInMs / (1000 * 60))
	return diff > threshold
}

export function sameValues(
	object: Record<string, unknown>,
	value?: unknown
): unknown {
	const objectKeys = Object.keys(object)
	const objectCopy: Record<string, unknown> = {}
	for (const key of objectKeys) {
		objectCopy[key] = value
	}
	return objectCopy
}

/**
 * Determines whether user role its present on navItem roles (navigation or sub-navigation) .
 * @param childRole - The role of the child navigation item.
 * @param navItemRole - The role of the parent navigation item.
 * @param navBarMode - The user role for the current navigation bar mode.
 * @returns A boolean indicating whether to render the sub-navigation.
 */
export function hasRoleForPath(
	childRole: NavItem['role'],
	navItemRole: NavItem['role'],
	navBarMode: UserRole
): boolean {
	const parentRoleCondition =
		!childRole && navItemRole && navItemRole.length > 0
			? navItemRole.includes(navBarMode)
			: false

	const childRoleCondition =
		childRole && childRole.length > 0 ? childRole.includes(navBarMode) : false

	return parentRoleCondition || childRoleCondition
}

export function parseJson(rawString: string): Record<string, unknown> {
	try {
		return JSON.parse(rawString) as Record<string, unknown>
	} catch {
		return {}
	}
}

export function jsonToText(object: unknown): string {
	try {
		return JSON.stringify(object)
	} catch {
		return '{}'
	}
}

export function isObject(object: unknown): boolean {
	return typeof object === 'object'
}

/**
 * This code was generated by chatGPT ^.^
 * Returns the diff between two JSON objects
 * Example
 * ```typescript
 * // Before
 * {"a": 100, "b": "Hola"}
 * // After
 * {"a": 10, "b": "Hola"}
 * //Result
 * {"a": [100, 10]}
 * ```
 */
export function diffJson(
	beforeString?: string,
	afterString?: string
): Record<string, unknown> | undefined {
	if (!beforeString || !afterString) return undefined

	const before = parseJson(beforeString)
	const after = parseJson(afterString)
	const diff: Record<string, unknown> = {}

	const entries = Object.entries(before)
	for (const [key] of entries) {
		if (key in before && before[key] !== after[key]) {
			const areNotNull = before[key] && after[key]
			const areObjects = isObject(before[key]) && isObject(after[key])

			if (areNotNull && areObjects) {
				// eslint-disable-next-line @typescript-eslint/no-unused-vars
				const nestedDiff = diffJson(
					jsonToText(before[key]),
					jsonToText(after[key])
				)
				if (nestedDiff && Object.keys(nestedDiff).length > 0) {
					diff[key] = nestedDiff
				}
			} else {
				diff[key] = [before[key], after[key]]
			}
		}
	}

	return diff
}

export function getTimeElapsed(
	startDate?: string | null,
	endDate?: string | null
): string {
	// Check if the start or end date is not provided
	if (!startDate || !endDate) {
		return '-'
	}

	// Calculate the time difference in milliseconds
	const timeDiff = new Date(endDate).getTime() - new Date(startDate).getTime()

	// Calculate seconds, minutes, hours, days, months, and years
	const seconds = Math.floor(timeDiff / 1000)
	const minutes = Math.floor(seconds / 60)
	const hours = Math.floor(minutes / 60)
	const days = Math.floor(hours / 24)
	const months = Math.floor(days / 30) // Approximation, not precise
	const years = Math.floor(days / 365) // Approximation, not precise

	// Determine the most appropriate unit of time
	if (years > 0) return `${years} año${years > 1 ? 's' : ''}`
	if (months > 0) return `${months} mes${months > 1 ? 'es' : ''}`
	if (days > 0) return `${days} día${days > 1 ? 's' : ''}`
	if (hours > 0) return `${hours} hora${hours > 1 ? 's' : ''}`
	if (minutes > 0) return `${minutes} min`

	return `${seconds} seg`
}

export function getPreviousDay(date: Date): Date {
	const previous = new Date(date.getTime())
	previous.setDate(date.getDate() - 1)

	return previous
}

export function splitDateRange(
	value?: string,
	separator = '::'
): DateIntervalObject {
	const result: DateIntervalObject = {
		from: undefined,
		to: undefined
	}

	if (!value || typeof value !== 'string') return result

	const dateRange = value.split(separator)

	const fromDate = new Date(dateRange[0])
	const toDate = new Date(dateRange[1])

	result.from = !Number.isNaN(fromDate.getTime()) ? fromDate : undefined
	result.to = !Number.isNaN(toDate.getTime()) ? toDate : undefined

	return result
}

export function cleanRequestEmptyProperties(request: string): string {
	const pathQueryPair: string[] = request.split('?')
	if (pathQueryPair.length === 1) return request
	const path = pathQueryPair[0]
	const queryString = pathQueryPair[1]
	const pairs: string[] = queryString.split('&')

	const cleanedParameters: Record<string, string[]> = {}

	for (const pair of pairs) {
		const [key, value] = pair.split('=')

		// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
		if (value !== undefined && value !== null && value !== '') {
			// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
			if (!cleanedParameters[key]) {
				cleanedParameters[key] = []
			}
			cleanedParameters[key].push(value)
		}
	}

	const cleanedQuery: string = Object.entries(cleanedParameters)
		.map(([key, values]) => values.map(value => `${key}=${value}`).join('&'))
		.join('&')
	if (cleanedQuery.length === 0) return path
	return `${path}?${cleanedQuery}`
}

export function formatDate(date: Date): string {
	try {
		return date.toISOString().split('T')[0]
	} catch {
		return ''
	}
}

/**
 * Adds minutes to a date
 * @param date Date
 * @param minutes number
 * @returns The date with the minutes added
 */
export function addMinutes(date: Date, minutes: number): Date {
	return new Date(date.getTime() + minutes * 60_000)
}

/**
 * Checks if an object, map, or set is empty.
 * @param {Object | Map<unknown, unknown> | Set<unknown> | undefined} value - The object, map, or set to check.
 * @returns {boolean} - Returns true if the object, map, or set is empty, otherwise false.
 */

// eslint-disable-next-line @typescript-eslint/ban-types
export function isEmpty(value: unknown): boolean {
	if (value === undefined) {
		return true
	}

	if (value instanceof Map || value instanceof Set) {
		return value.size === 0
	}

	if (typeof value === 'object' && value !== null) {
		return Object.keys(value).length === 0
	}

	return true
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/merchantLimits.ts
import {
	Currency,
	type MerchantLimit,
	MerchantLimitType,
	State,
	LimitCriteria,
	LimitAggregation,
	LimitScope
} from 'types'
import {
	factory,
	randFromEnum,
	randISODateString,
	randNumber,
	randUuid
} from './factory'

function limitsFactory(): MerchantLimit {
	return {
		id: randNumber(),
		uuid: randUuid(),
		limitType: MerchantLimitType.RATE,
		limitDefinition: {
			value: randNumber(),
			criteria: LimitCriteria.AMOUNT,
			scope: LimitScope.PERSON,
			aggregation: randFromEnum(LimitAggregation),
			currency: Currency.CLP
		},
		merchantId: 1,
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		state: State.ACTIVE
	}
}
export function makeMerchantLimits(
	qty = 10,
	override?: Partial<MerchantLimit>
): MerchantLimit[] {
	return factory(limitsFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/accounts.ts
import type { Account } from 'types'
import { CountryCode, Currency, State } from 'types'
import {
	factory,
	randFromEnum,
	randISODateString,
	randName,
	randNumber,
	randUuid
} from './factory'

function accountsFactory(): Account {
	return {
		id: randNumber(),
		uuid: randUuid(),
		bankCode: 'cl_banco_santander',
		countryCode: randFromEnum(CountryCode),
		currency: randFromEnum(Currency),
		holderId: '1200123112',
		identifier: '1912399123',
		merchantId: 1,
		name: randName(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		state: State.ACTIVE
	}
}

export function makeAccounts(qty = 10, override?: Partial<Account>): Account[] {
	return factory(accountsFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/payouts.ts
import { Currency, PayoutState, ApiVersion, State } from 'types'
import type { Payout } from 'types'
import {
	factory,
	randFromEnum,
	randISODateString,
	randName,
	randNumber,
	randUuid
} from './factory'

function payoutFactory(): Payout {
	return {
		id: randNumber(),
		uuid: randUuid(),
		amount: randNumber(),
		concept: randName(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		currency: randFromEnum(Currency),
		destinationAccount: randName(),
		destinationName: randName(),
		destinationAddress: randName(),
		destinationBankCode: 'cl_banco_santander',
		destinationEmail: randName(),
		destinationHolderId: `${randNumber() * 9999}`,
		merchantId: 1,
		state: randFromEnum(PayoutState),
		trackingCode: randName(),
		transfers: [],
		version: ApiVersion.v2,
		merchant: {
			id: 1,
			uuid: randUuid(),
			name: randName(),
			createdAt: randISODateString(),
			updatedAt: randISODateString(),
			identifier: randName(),
			state: State.ACTIVE
		}
	}
}

export function makePayout(override?: Partial<Payout>): Payout {
	return factory(payoutFactory).create(override)
}

export function makePayouts(qty = 10, override?: Partial<Payout>): Payout[] {
	return factory(payoutFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/accountStatementJob.ts
import { AccountStatementJobState, type AccountStatementJob } from 'types'
import { factory, randFromEnum, randName, randNumber } from './factory'

function accountStatementJobFactory(): AccountStatementJob {
	return {
		id: randNumber(),
		endDate: new Date(),
		startDate: new Date(),
		state: randFromEnum(AccountStatementJobState),
		endedAt: new Date(),
		startedAt: new Date(),
		balance: randNumber(),
		retrievedAt: new Date().toISOString(),
		totalRetrieved: randNumber(),
		jobId: randName(),
		accountId: randNumber(),
		createdAt: new Date()
	}
}

export function makeAccountStatementJob(
	override?: Partial<AccountStatementJob>
): AccountStatementJob {
	return factory(accountStatementJobFactory).create(override)
}

export function makeAccountStatementJobs(
	qty: number,
	override?: Partial<AccountStatementJob>
): AccountStatementJob[] {
	return factory(accountStatementJobFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/transferErrors.ts
import type { TransferError } from 'types'
import {
	factory,
	randISODateString,
	randName,
	randNumber,
	randUuid
} from './factory'

function transferErrorFactory(): TransferError {
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		errorRaw: randName(),
		errorCode: 'ERROR_0005',
		errorType: 'DESTINATION_BANK_IN_MAINTENANCE'
	}
}

export function makeTransferError(
	override?: Partial<TransferError>
): TransferError {
	return factory(transferErrorFactory).create(override)
}

export function makeTransferErrors(
	qty = 10,
	override?: Partial<TransferError>
): TransferError[] {
	return factory(transferErrorFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/transferMethods.ts
/* eslint-disable unicorn/no-null */
import { State, type TransferMethod } from 'types'
import { randNumber, randUuid, randISODateString, factory } from './factory'

function getRandomMethodType(): TransferMethod['methodType'] {
	const methodTypes: TransferMethod['methodType'][] = [
		'digipass',
		'security_card',
		'sms'
	]
	return methodTypes[Math.floor(Math.random() * methodTypes.length)]
}

function transferMethodsFactory(): TransferMethod {
	const methodType = getRandomMethodType()
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		state: State.ACTIVE,
		signingKeys: methodType === 'security_card' ? randUuid() : null,
		methodType,
		merchantId: randNumber(),
		bankAccessId: randNumber(),
		identifier: `${randNumber()}`
	}
}

export function makeTransferMethod(
	override?: Partial<TransferMethod>
): TransferMethod {
	return factory(transferMethodsFactory).create(override)
}

export function makeTransferMethods(
	qty = 10,
	override?: Partial<TransferMethod>
): TransferMethod[] {
	return factory(transferMethodsFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/banks.ts
import { State, type Bank } from 'types'
import {
	randNumber,
	randUuid,
	randISODateString,
	randName,
	factory
} from './factory'

function banksFactory(): Bank {
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		state: State.ACTIVE,
		name: randName(),
		code: `cl_${randName().toLowerCase()}`
	}
}

export function makeBank(override?: Partial<Bank>): Bank {
	return factory(banksFactory).create(override)
}

export function makeBanks(qty = 10, override?: Partial<Bank>): Bank[] {
	return factory(banksFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/factory.ts
function getRandNumber(): number {
	return Math.random()
}

export function factory<T>(generator: () => T): {
	create: (override?: Partial<T>) => T
	createMany: (qty: number, override?: Partial<T>) => T[]
} {
	return {
		create: (override?: Partial<T>): T => {
			if (override) {
				const generated = generator()
				return { ...generated, ...override }
			}

			return generator()
		},
		createMany: (qty: number, override?: Partial<T>): T[] => {
			const results: T[] = []
			// eslint-disable-next-line no-plusplus
			for (let index = 0; index < qty; index++) {
				if (override) {
					results.push({ ...generator(), ...override })
				} else {
					results.push(generator())
				}
			}

			return results
		}
	}
}

export function randName(): string {
	const vowels = 'aeiou'
	const consonants = 'bcdfghjklmnpqrstvwxyz'
	const nameLength = Math.floor(getRandNumber() * 5) + 5 // generates a random length between 5 and 9 characters
	let name = ''

	// eslint-disable-next-line no-plusplus
	for (let index = 0; index < nameLength; index++) {
		// alternates consonants and vowels to create a random name
		name +=
			index % 2 === 0
				? consonants.charAt(Math.floor(getRandNumber() * consonants.length))
				: vowels.charAt(Math.floor(getRandNumber() * vowels.length))
	}

	return name
}

/**
 * Generates a random UUID-like string. If a UUID is provided, it returns the provided UUID.
 * This function doesn't generate a fully compliant UUID, but it should be sufficient for generating mock data.
 *
 * @param {string} [uuid] - An optional UUID string to return.
 * @returns {string} - A random UUID-like string or the provided UUID.
 */
export const randUuid = (uuid?: string): string => {
	if (uuid) return uuid

	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
		const r = Math.trunc(getRandNumber() * 16)
		const v = c === 'x' ? r : (r % 4) + 8
		return v.toString(16)
	})
}

export function randNumber(max = 1000): number {
	return Math.floor(getRandNumber() * max)
}

export function randBoolean(): boolean {
	const seed = randNumber()

	return seed < 299
}

export function randEmail(): string {
	const domains = ['mail.com', 'example.com']
	const randomDomainIndex = randNumber(domains.length)
	const randomDomain = domains[randomDomainIndex]

	const username = randName()
	const cleanName = username.replace(/\s/g, '')
	const email = `${cleanName}@${randomDomain}`
	return email
}

export function randISODateString(date?: string): string {
	if (date) return date

	const nowTimestamp = Date.now()

	const randDays = Math.floor(getRandNumber() * 10)
	const miliseconds = randDays * 24 * 60 * 60 * 1000

	return new Date(nowTimestamp - miliseconds).toISOString()
}

export function randFromEnum<T extends Record<string, K>, K>(data: T): K {
	const values = Object.values(data)

	const index = Math.floor(getRandNumber() * values.length)

	return values[index]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/users.ts
import type { User } from 'types'
import { MFAState, State, UserRole } from 'types'
import {
	randNumber,
	randUuid,
	randISODateString,
	randName,
	randBoolean,
	factory,
	randEmail
} from './factory'

function usersFactory(): User {
	const name = randName()
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		name,
		email: randEmail(),
		state: State.ACTIVE,
		role: UserRole.SUPER,
		mfa: randBoolean(),
		mfaState: MFAState.DISABLED,
		merchantId: randNumber()
	}
}

export function makeUser(override?: Partial<User>): User {
	return factory(usersFactory).create(override)
}

export function makeUsers(qty = 10, override?: Partial<User>): User[] {
	return factory(usersFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/auditLogs.ts
import type { AuditLog } from 'types'
import { AuditLogEvent } from 'types'
import {
	factory,
	randFromEnum,
	randISODateString,
	randNumber,
	randUuid
} from './factory'

function auditLogsFactory(): AuditLog {
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		context: undefined,
		authorId: randNumber(),
		authorType: 'UserEntity',
		event: randFromEnum(AuditLogEvent),
		entityType: 'PayoutEntity',
		entityId: '1',
		entityAfter: '{"amount":1000,"currency":"clp"}',
		entityBefore: '{"amount":2500,"currency":"clp"}'
	}
}

export function makeAuditLogs(
	qty = 10,
	override?: Partial<AuditLog>
): AuditLog[] {
	return factory(auditLogsFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/accountStatements.ts
import { CountryCode, Currency, PayoutState } from 'types'
import type { AccountStatement } from 'types'
import {
	factory,
	randFromEnum,
	randISODateString,
	randName,
	randNumber,
	randUuid
} from './factory'

function accountStatementFactory(): AccountStatement {
	return {
		id: randNumber(),
		uuid: randUuid(),
		amount: randNumber(),
		concept: randName(),
		date: new Date(),
		currency: randFromEnum(Currency),
		countryCode: randFromEnum(CountryCode),
		destinationAccount: randName(),
		destinationName: randName(),
		destinationBankCode: 'cl_banco_santander',
		destinationEmail: randName(),
		destinationHolderId: `${randNumber() * 9999}`,
		originBankCode: 'cl_banco_santander',
		originBankAccountIdentifier: randName(),
		retrievedAt: new Date(),
		metadata: {},
		state: randFromEnum(PayoutState),
		transactionCode: randName(),
		accountStatementJobId: randNumber(),
		createdAt: randISODateString(),
		updatedAt: randISODateString()
	}
}

export function makeAccountStatements(
	qty = 10,
	override?: Partial<AccountStatement>
): AccountStatement[] {
	return factory(accountStatementFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/merchants.ts
import { State, type Merchant } from 'types'
import {
	randNumber,
	randUuid,
	randISODateString,
	randName,
	factory
} from './factory'

function merchantsFactory(): Merchant {
	const name = randName()
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		name,
		identifier: `identifier_${name.toLowerCase()}`,
		state: State.ACTIVE
	}
}

export function makeMerchant(override?: Partial<Merchant>): Merchant {
	return factory(merchantsFactory).create(override)
}

export function makeMerchants(
	qty = 10,
	override?: Partial<Merchant>
): Merchant[] {
	return factory(merchantsFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/providers.ts
import { type Provider, State, ProviderType, ProviderCapability } from 'types'
import {
	factory,
	randISODateString,
	randName,
	randNumber,
	randUuid
} from './factory'

function providersFactory(): Provider {
	return {
		id: randNumber(),
		uuid: randUuid(),
		accountId: 1,
		name: randName(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		providerType: ProviderType.ScraperPW,
		state: State.ACTIVE,
		capability: ProviderCapability.ALL
	}
}

export function makeProviders(
	qty = 10,
	override?: Partial<Provider>
): Provider[] {
	return factory(providersFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/apiKeys.ts
import { State, type ApiKey, UserRole } from 'types'
import {
	randNumber,
	randUuid,
	randISODateString,
	randName,
	factory
} from './factory'

function apiKeysFactory(): ApiKey {
	return {
		id: randNumber(),
		uuid: randUuid(),
		key: randUuid(),
		name: randName(),
		state: State.ACTIVE,
		merchantId: randNumber(),
		role: UserRole.SUPER,
		createdAt: randISODateString(),
		updatedAt: randISODateString()
	}
}

export function makeApiKey(override?: Partial<ApiKey>): ApiKey {
	return factory(apiKeysFactory).create(override)
}

export function makeApiKeys(qty = 10, override?: Partial<ApiKey>): ApiKey[] {
	return factory(apiKeysFactory).createMany(qty, override)
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/mocks/data/payoutActions.ts
import type { PayoutAction } from 'types'
import { factory, randISODateString, randNumber, randUuid } from './factory'

function payoutActionFactory(): PayoutAction {
	return {
		id: randNumber(),
		uuid: randUuid(),
		createdAt: randISODateString(),
		updatedAt: randISODateString(),
		action: 'AUTO_CANCEL',
		suggestion: '',
		errorCode: 'ERROR_0005',
		errorType: 'DESTINATION_BANK_IN_MAINTENANCE'
	}
}

export function makePayoutAction(
	override?: Partial<PayoutAction>
): PayoutAction {
	return factory(payoutActionFactory).create(override)
}

export function makePayoutActions(
	qty = 10,
	override?: Partial<PayoutAction>
): PayoutAction[] {
	return factory(payoutActionFactory).createMany(qty, override)
}

export default {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/hooks/__mocks__/mockUseBanks.ts
import type { PaginationObject } from 'components/Pagination'
import type { CountryCode, Currency, SelectOption } from 'types'
import { State, type Bank } from 'types'
import { vi } from 'vitest'
import * as useBanksModule from 'hooks/useBanks'

const mockBanks: Bank[] = [
	{
		code: 'BANK1',
		name: 'Bank 1',
		id: 1,
		state: State.ACTIVE,
		uuid: '1',
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	},
	{
		code: 'BANK2',
		name: 'Bank 2',
		id: 2,
		state: State.ACTIVE,
		uuid: '2',
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	}
]

export default function mockUseBanks(mockBankList: Bank[] = mockBanks): void {
	vi.spyOn(useBanksModule, 'useBanks').mockImplementation(() => ({
		results: mockBankList,
		totalResults: mockBankList.length,
		isLoading: false,
		isFetching: false,
		getBankByCode: (code: string): Bank | undefined =>
			mockBankList.find(bank => bank.code === code),
		applyPagination: (pagination: PaginationObject): void => {
			void pagination
		},
		getBanksByCountryCode: (countryCode: CountryCode): SelectOption[] =>
			useBanksModule.buildBanksByCountryCode({
				banks: mockBankList,
				countryCode
			}),
		getBanksByCurrency: (currency: Currency): SelectOption[] => {
			const countryCode = useBanksModule.convertCurrency[currency]
			return useBanksModule.buildBanksByCountryCode({
				banks: mockBankList,
				countryCode
			})
		},
		refresh: (): void => {}
	}))
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/hooks/__mocks__/mockUseMerchants.ts
import type { PaginationObject } from 'components/Pagination'
import { type Merchant, State } from 'types'
import { vi } from 'vitest'
import * as useMerchantsModule from 'hooks/useMerchants'

const mockMerchants: Merchant[] = [
	{
		name: 'Merchant 1',
		identifier: 'Merchant1',
		state: State.ACTIVE,
		id: 1,
		uuid: '1',
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	},
	{
		name: 'Merchant 2',
		identifier: 'Merchant2',
		state: State.ACTIVE,
		id: 2,
		uuid: '2',
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	}
]

export default function mockUseMerchants(
	mockMerchantList: Merchant[] = mockMerchants
): void {
	vi.spyOn(useMerchantsModule, 'useMerchants').mockImplementation(() => ({
		results: mockMerchantList,
		totalResults: mockMerchantList.length,
		isLoading: false,
		isFetching: false,
		getMerchantById: (id: number): Merchant | undefined =>
			mockMerchantList.find(merchant => merchant.id === id),
		applyPagination: (pagination: PaginationObject): void => {
			void pagination
		},
		refresh: (): void => {}
	}))
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/hooks/__mocks__/mockUseApiKeys.ts
import { vi } from 'vitest'
import type { PaginationObject } from 'components/Pagination'
import { UserRole, type ApiKey, State } from 'types'
import * as useApiKeysModule from 'hooks/useApiKeys'

const mockApiKeys: ApiKey[] = [
	{
		id: 1,
		uuid: '1',
		name: 'Api Key 1',
		state: State.ACTIVE,
		role: UserRole.ADMIN,
		key: 'abc-123-1',
		merchantId: 1,
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	},
	{
		id: 2,
		uuid: '2',
		name: 'Api Key 2',
		state: State.ACTIVE,
		role: UserRole.ADMIN,
		key: 'abc-123-2',
		merchantId: 1,
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	}
]

export default function mockUseApiKeys(
	mockApiKeysList: ApiKey[] = mockApiKeys
): void {
	vi.spyOn(useApiKeysModule, 'useApiKeys').mockImplementation(() => ({
		results: mockApiKeysList,
		totalResults: mockApiKeysList.length,
		isLoading: false,
		isFetching: false,
		getNameById: (id: number): string =>
			mockApiKeysList.find(user => user.id === id)?.name ?? '',
		applyPagination: (pagination: PaginationObject): void => {
			void pagination
		},
		refresh: (): void => {}
	}))
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/hooks/__mocks__/mockUseUsers.ts
import { vi } from 'vitest'
import type { PaginationObject } from 'components/Pagination'
import { MFAState, UserRole, type User, State } from 'types'
import * as useUsersModule from 'hooks/useUsers'

export const mockUsers: User[] = [
	{
		id: 1,
		uuid: '1',
		name: 'User name 1',
		email: 'username1@test.local',
		state: State.ACTIVE,
		role: UserRole.ADMIN,
		merchantId: 1,
		mfa: true,
		mfaState: MFAState.VERIFIED,
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	},
	{
		id: 2,
		uuid: '2',
		name: 'User name 2',
		email: 'username2@test.local',
		state: State.ACTIVE,
		role: UserRole.ADMIN,
		merchantId: 1,
		mfa: true,
		mfaState: MFAState.VERIFIED,
		createdAt: new Date().toISOString(),
		updatedAt: new Date().toISOString()
	}
]

export default function mockUseUsers(mockUsersList: User[] = mockUsers): void {
	vi.spyOn(useUsersModule, 'useUsers').mockImplementation(() => ({
		results: mockUsersList,
		totalResults: mockUsersList.length,
		isLoading: false,
		isFetching: false,
		getUserName: (id: number): string =>
			mockUsersList.find(user => user.id === id)?.name ?? '',
		applyPagination: (pagination: PaginationObject): void => {
			void pagination
		},
		refresh: (): void => {}
	}))
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/setupTests.ts
import '@testing-library/jest-dom'
import mediaQuery from 'css-mediaquery'
import { DESKTOP_RESOLUTION_HEIGHT, DESKTOP_RESOLUTION_WIDTH } from 'testUtils'
import { afterAll } from 'vitest'
import 'whatwg-fetch'

beforeAll(() => {
	Object.defineProperty(window, 'matchMedia', {
		writable: true,
		value: (query: string) => {
			function matchQuery(): boolean {
				return mediaQuery.match(query, {
					width: window.innerWidth,
					height: window.innerHeight
				})
			}

			const listeners: (() => void)[] = []
			const instance = {
				matches: matchQuery(),
				addEventListener: (_: 'change', listener: () => void): void => {
					listeners.push(listener)
				},
				removeEventListener: (_: 'change', listener: () => void): void => {
					const index = listeners.indexOf(listener)
					if (index >= 0) {
						listeners.splice(index, 1)
					}
				},
				// Alias addEventListener and removeEventListener as addListener and removeListener
				addListener: (_: 'change', listener: () => void): void => {
					listeners.push(listener)
				},
				removeListener: (_: 'change', listener: () => void): void => {
					const index = listeners.indexOf(listener)
					if (index >= 0) {
						listeners.splice(index, 1)
					}
				}
			}
			window.addEventListener('resize', () => {
				const change = matchQuery()
				if (change !== instance.matches) {
					instance.matches = change
					for (const listener of listeners) listener()
				}
			})

			return instance
		}
	})
	Object.defineProperty(window, 'scrollTo', {
		writable: true,
		value: () => {}
	})
	Object.defineProperty(window, 'resizeTo', {
		writable: true,
		value: (width: number, height: number) => {
			Object.assign(window, {
				innerWidth: width,
				innerHeight: height
			}).dispatchEvent(new window.Event('resize'))
		}
	})
})

beforeEach(() => {
	window.resizeTo(DESKTOP_RESOLUTION_WIDTH, DESKTOP_RESOLUTION_HEIGHT)
})

afterEach(() => {})

afterAll(() => {})


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/dashboard/src/config/index.ts
export interface ProjectConfig {
	api: {
		url: string
	}
	general: {
		environment: string
	}
	sentry: {
		dsn: string
	}
}

export interface MetaInterface extends ImportMetaEnv {
	VITE_API_URL: string | undefined
	VITE_ENVIRONMENT: string | undefined
	VITE_SENTRY_DSN: string | undefined
}

const environment = import.meta.env as MetaInterface

const config: ProjectConfig = {
	api: {
		url: environment.VITE_API_URL ?? 'http://localhost:5000/api'
	},
	general: {
		environment: environment.VITE_ENVIRONMENT ?? 'development'
	},
	sentry: {
		dsn: environment.VITE_SENTRY_DSN ?? ''
	}
}

export default config


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/.vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "attach",
      "name": "Debug NestJS",
      "port": 9229,
      "localRoot": "${workspaceFolder}",
      "remoteRoot": "/app",
      "restart": true,
      "sourceMaps": true,
      "outFiles": ["${workspaceFolder}/dist/**/*.js"],
      "skipFiles": [
        "${workspaceFolder}/node_modules/**/*.js",
        "<node_internals>/**/*.js"
      ]
    },
    {
      "type": "node",
      "request": "launch",
      "name": "Jest: e2e Test File",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": [
        "--config",
        "${workspaceFolder}/test/jest-e2e.json",
        "${fileBasenameNoExtension}"
      ],
      "console": "integratedTerminal",
      "skipFiles": [
        "${workspaceFolder}/node_modules/**/*.js",
        "<node_internals>/**/*.js"
      ],
      "envFile": "${workspaceRoot}/.env"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "Jest: Unit Test File",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["${fileBasenameNoExtension}"],
      "console": "integratedTerminal",
      "skipFiles": [
        "${workspaceFolder}/node_modules/**/*.js",
        "<node_internals>/**/*.js"
      ]
    }
  ]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/.vscode/settings.json
{
  "eslint.workingDirectories": [
    {
      "mode": "auto"
    }
  ]
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/.devcontainer/devcontainer.json
// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at:
// https://github.com/microsoft/vscode-dev-containers/tree/v0.241.1/containers/docker-existing-docker-compose
// If you want to run as a non-root user in the container, see .devcontainer/docker-compose.yml.
{
  "name": "Existing Docker Compose (Extend)",
  // Update the 'dockerComposeFile' list if you have more compose files or use different names.
  // The .devcontainer/docker-compose.yml file contains any overrides you need/want to make.
  "dockerComposeFile": ["../docker-compose.dev.yml", "docker-compose.yml"],
  // The 'service' property is the name of the service for the container that VS Code should
  // use. Update this value and .devcontainer/docker-compose.yml to the real service name.
  "service": "api",
  // The optional 'workspaceFolder' property is the path VS Code should open by default when
  // connected. This is typically a file mount in .devcontainer/docker-compose.yml
  "workspaceFolder": "/workspace",
  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],
  // Uncomment the next line if you want start specific services in your Docker Compose config.
  // "runServices": [],
  // Uncomment the next line if you want to keep your containers running after VS Code shuts down.
  // "shutdownAction": "none",
  // Uncomment the next line to run commands after the container is created - for example installing curl.
  // "postCreateCommand": "apk add openssh git; cp /root/gitconfig /root/.gitconfig; chown -R root /root; git config --global --add safe.directory /workspace; cp -R /usr/src/app/node_modules /workspace/",
  "customizations": {
    "vscode": {
      "settings": {
        "git.path": "/usr/bin/git"
      },
      "extensions": [
        "dbaeumer.vscode-eslint",
        "ms-azuretools.vscode-docker",
        "eamodio.gitlens",
        "VisualStudioExptTeam.vscodeintellicode",
        "ms-vscode.vscode-typescript-next",
        "christian-kohler.npm-intellisense",
        "esbenp.prettier-vscode"
      ]
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/package.json
{
  "name": "api",
  "version": "1.21.0",
  "description": "Payouts Engine API",
  "author": "Buk Adelantos",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "start": "nest start",
    "dev": "NODE_ENV=development nest start --watch | npx pino-pretty",
    "debug": "nest start --debug 0.0.0.0:9229 --watch",
    "prebuild": "rimraf dist",
    "build": "nest build",
    "precommit": "lint-staged",
    "prepush": "pnpm build && jest --detectOpenHandles --forceExit",
    "lint": "pnpm eslint:check && npm run prettier:check",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "workers": "nest start -c nest-cli.workers.json",
    "workers:dev": "nest start -c nest-cli.workers.json --watch",
    "workers:prod": "node dist/workers/main",
    "docker:test": "docker compose -f docker-compose.test.yml up --build --force-recreate --exit-code-from api",
    "docker:dev": "docker compose -f docker-compose.dev.yml up --build --force-recreate --exit-code-from api",
    "jest": "node --expose-gc --no-compilation-cache ./node_modules/jest/bin/jest.js",
    "test": "pnpm test:unit && pnpm test:e2e",
    "test:unit": "pnpm jest --config ./test/config/unit.jest.config.ts",
    "test:e2e": "pnpm jest --config ./test/config/e2e.jest.config.ts",
    "test:worker": "jest --config ./test/config/e2e.jest.config.ts /test/workers",
    "typeorm": "typeorm-ts-node-commonjs",
    "migration:create": "NODE_ENV=development pnpm typeorm migration:create",
    "migration:generate": "NODE_ENV=development pnpm typeorm migration:generate -d src/database/dataSource.ts",
    "migration:revert": "NODE_ENV=development pnpm typeorm migration:revert -d src/database/dataSource.ts",
    "db:create:dev": "NODE_ENV=development ts-node ./src/database/utils/createDatabase.ts",
    "db:show:dev": "NODE_ENV=development pnpm typeorm migration:show -d src/database/dataSource.ts",
    "db:migrate:dev": "NODE_ENV=development pnpm typeorm migration:run -d src/database/dataSource.ts",
    "db:drop:dev": "NODE_ENV=development ts-node ./src/database/utils/dropDatabase.ts",
    "db:create:test": "NODE_ENV=test ts-node ./src/database/utils/createDatabase.ts",
    "db:show:test": "NODE_ENV=test pnpm typeorm migration:show -d src/database/dataSource.ts",
    "db:migrate:test": "NODE_ENV=test pnpm typeorm migration:run -d src/database/dataSource.ts",
    "db:seed:test": "NODE_ENV=test ts-node ./test/utils/loadTestSeedDump.ts",
    "db:setup:test": "pnpm db:drop:test && pnpm db:create:test && pnpm db:migrate:test && pnpm db:seed:test",
    "db:drop:test": "NODE_ENV=test ts-node ./src/database/utils/dropDatabase.ts",
    "eslint:check": "eslint \"{src,apps,libs,test}/**/*.ts\"",
    "eslint:fix": "pnpm eslint:check -- --fix",
    "prettier:check": "prettier --check \"{src,apps,libs,test}/**/*.ts\""
  },
  "dependencies": {
    "@aws-sdk/client-batch": "^3.441.0",
    "@aws-sdk/client-secrets-manager": "^3.465.0",
    "@aws-sdk/client-sns": "^3.288.0",
    "@bull-board/api": "^3.10.0",
    "@bull-board/express": "^3.10.7",
    "@nestjs/axios": "^0.0.4",
    "@nestjs/bull": "^0.4.2",
    "@nestjs/common": "^8.0.0",
    "@nestjs/config": "^1.1.5",
    "@nestjs/core": "^8.0.0",
    "@nestjs/event-emitter": "^1.4.1",
    "@nestjs/jwt": "8.0.0",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^8.0.0",
    "@nestjs/schedule": "^1.0.2",
    "@nestjs/swagger": "^5.2.1",
    "@nestjs/terminus": "^8.0.4",
    "@nestjs/typeorm": "10.0.2",
    "@ngneat/falso": "^6.0.3",
    "@sendgrid/mail": "^7.7.0",
    "@sentry/integrations": "^7.77.0",
    "@sentry/node": "^7.77.0",
    "@sentry/profiling-node": "^7.103.0",
    "@slack/web-api": "^6.7.2",
    "@slack/webhook": "^6.1.0",
    "@types/bcrypt": "^5.0.0",
    "@types/node-forge": "^1.3.2",
    "@types/speakeasy": "^2.0.7",
    "axios": "^0.26.0",
    "bcrypt": "^5.0.1",
    "bull": "^3.29.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.13.2",
    "configcat-node": "^10.1.1",
    "cron": "^3.1.6",
    "generate-password": "^1.7.0",
    "jose": "^4.11.2",
    "jsonwebtoken": "8.5.1",
    "jws": "^4.0.0",
    "lodash": "^4.17.21",
    "moment": "^2.29.1",
    "moment-timezone": "^0.5.34",
    "mysql2": "^2.3.3",
    "nanoid": "^3.3.4",
    "nestjs-cls": "^3.5.0",
    "nestjs-pino": "^2.5.0",
    "node-forge": "^1.3.1",
    "pino-http": "^6.6.0",
    "pino-noir": "^2.2.1",
    "promise-mysql": "^5.2.0",
    "reflect-metadata": "^0.1.13",
    "rimraf": "^3.0.2",
    "rxjs": "^7.2.0",
    "shelljs": "^0.8.5",
    "speakeasy": "^2.0.0",
    "swagger-ui-express": "^4.3.0",
    "twilio": "^3.72.0",
    "typeorm": "^0.3.20",
    "uuid": "^9.0.1",
    "xlsx": "https://cdn.sheetjs.com/xlsx-0.19.3/xlsx-0.19.3.tgz"
  },
  "devDependencies": {
    "@aws-sdk/types": "^3.110.0",
    "@commitlint/cli": "^17.4.2",
    "@commitlint/config-conventional": "^17.4.2",
    "@golevelup/ts-jest": "^0.4.0",
    "@nestjs/cli": "^8.0.0",
    "@nestjs/schematics": "^8.0.0",
    "@nestjs/testing": "^8.0.0",
    "@repo/eslint-config": "*",
    "@sentry/types": "^7.77.0",
    "@types/bull": "^3.15.7",
    "@types/express": "^4.17.13",
    "@types/jest": "^29.5.12",
    "@types/lodash": "^4.14.182",
    "@types/node": "^20.10.0",
    "@types/passport-local": "^1.0.34",
    "@types/supertest": "^2.0.11",
    "@types/uuid": "^9.0.0",
    "jest": "^29.7.0",
    "mysqldump": "^3.2.0",
    "nodemon": "^2.0.15",
    "pino-pretty": "^7.6.1",
    "prettier": "2.8.3",
    "source-map-support": "^0.5.20",
    "supertest": "^6.2.2",
    "ts-jest": "^29.1.2",
    "ts-loader": "^9.2.3",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^3.14.1",
    "typescript": "4.9.5"
  },
  "volta": {
    "node": "20.10.0",
    "pnpm": "8.15.1"
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/nest-cli.json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "plugins": [
      {
        "name": "@nestjs/swagger",
        "options": {
          "classValidatorShim": false,
          "introspectComments": true
        }
      }
    ]
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/workers/services/accountFundingService.e2e-spec.ts
import { randUuid } from '@ngneat/falso';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { ScraperPWProviderAdapter } from 'src/providers/scraperPW/scraperPW.provider';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import { AccountFundingService } from 'src/workers/services/account-funding/account-funding.service';
import { AccountFundingDto } from 'src/workers/services/account-funding/dto/account-funding.dto';
import { SecretManagerService } from 'src/workers/services/secret-manager/secret-manager/secret-manager.service';
import { randNumberString } from 'test/utils/testUtils';
import { workersApp, workersConnection } from 'test/worker.setup';
import { Repository } from 'typeorm';

describe('given a AccountFundingService', () => {
  let accountFundingService: AccountFundingService;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let merchantRepository: Repository<MerchantEntity>;

  const originAccountBase: Partial<AccountEntity> = {
    bankCode: 'cl_banco_santander',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Origin Account Must Fail',
    identifier: '123912391',
    state: State.ACTIVE,
  };
  const baseAccount: Partial<AccountEntity> = {
    bankCode: 'cl_banco_santander',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912435345345',
    holderId: '324234234',
    state: State.ACTIVE,
  };
  const createPayout: Partial<PayoutEntity> = {
    amount: 1000,
    concept: 'Testing Funding',
    destinationEmail: 'carloso@buk.cl',
    destinationName: 'Carlos Carloso',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_santander',
    currency: Currency.CHILE,
    trackingCode: 'undefined345234532452345435',
    destinationPhone: '3212312312',
    state: PayoutState.COMPLETED,
  };

  const createTransfer: Partial<TransferEntity> = {
    amount: 1000,
    currency: Currency.CHILE,
    concept: 'Testing Funding',
    destinationHolderId: '72028164',
    destinationName: 'Carlos Carloso',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_santander',
    destinationPhone: '3212312312',
    trackingCode: 'undefined345234532452345435',
    state: TransferState.COMPLETED,
  };

  const createProviderDto = {
    providerType: ProviderType.ScraperPW,
    state: State.ACTIVE,
    capabilities: [ProviderCapability.READ_TRANSFER],
  };

  let originAccount: AccountEntity;
  let destinationAccount: AccountEntity;
  let originProvider: ProviderEntity;
  let balanceProvider: ProviderEntity;
  let payout: PayoutEntity;
  let transfer: TransferEntity;
  let originMerchant: MerchantEntity;
  let destinationMerchant: MerchantEntity;
  let accountFundingDto: AccountFundingDto;
  let mockProviderGetBalance: jest.SpyInstance;

  process.env.AWS_REGION = 'us-east-1';
  process.env.AWS_ACCESS_KEY_ID = 'test';
  process.env.AWS_SECRET_ACCESS_KEY = 'test';

  beforeAll(async () => {
    payoutRepository = workersConnection.getRepository(PayoutEntity);
    accountRepository = workersConnection.getRepository(AccountEntity);
    transferRepository = workersConnection.getRepository(TransferEntity);
    providerRepository = workersConnection.getRepository(ProviderEntity);
    merchantRepository = workersConnection.getRepository(MerchantEntity);

    originMerchant = await merchantRepository.save({
      name: 'Origin Merchant',
      identifier: randUuid(),
      state: State.ACTIVE,
    });

    destinationMerchant = await merchantRepository.save({
      name: 'Destination Merchant',
      identifier: randUuid(),
      state: State.ACTIVE,
    });
    accountFundingService = await workersApp.get(AccountFundingService);

    originAccount = await accountRepository.save({
      ...originAccountBase,
      merchantId: originMerchant.id,
    });
    destinationAccount = await accountRepository.save({
      ...baseAccount,
      merchantId: destinationMerchant.id,
    });

    originProvider = await providerRepository.save({
      ...createProviderDto,
      accountId: originAccount.id,
      name: 'Origin Fund Provider',
      capabilities: [
        ProviderCapability.CREATE_TRANSFER,
        ProviderCapability.READ_TRANSFER,
      ],
    });

    balanceProvider = await providerRepository.save({
      ...createProviderDto,
      name: 'Account Balance Provider',
      accountId: destinationAccount.id,
    });

    payout = await payoutRepository.save({
      ...createPayout,
      providerId: originProvider.id,
      merchantId: originMerchant.id,
    });

    transfer = await transferRepository.save({
      ...createTransfer,
      payoutId: payout.id,
      merchantId: originMerchant.id,
    });
    accountFundingDto = {
      minBalance: '20' as unknown as number,
      originAccountId: originAccount.id.toString() as unknown as number,
      originProviderId: originProvider.id.toString() as unknown as number,
      amount: '12000',
      maxAmountAllowed: '30000',
      concept: 'Funding Payout',
      trackingCode: randNumberString(),
      currency: Currency.CHILE,
      originMerchantId: originMerchant.id.toString() as unknown as number,
      destinationHolderName: 'John Funding',
      destinationAccountEmail: 'destination@gmail.com',
      destinationAccountHolderId: 'destinationAccountHolderId',
      destinationAccountBankCode: BankCode.BANCO_SANTANDER,
      destinationAccountIdentifier: 'identifier',
      destinationMerchantId:
        destinationMerchant.id.toString() as unknown as number,
      destinationAccountId:
        destinationAccount.id.toString() as unknown as number,
    };
  });
  afterAll(async () => {
    try {
      await transferRepository.delete(transfer.id);
      await payoutRepository.delete(payout.id);
      await providerRepository.delete(originProvider.id);
      await providerRepository.delete(balanceProvider.id);

      await accountRepository.delete(destinationAccount.id);
      await accountRepository.delete(originAccount.id);

      await merchantRepository.delete(originMerchant.id);
      await merchantRepository.delete(destinationMerchant.id);
    } catch (e) {
      console.log(e);
    }
  });

  beforeEach(() => {
    mockProviderGetBalance = jest
      .spyOn(ScraperPWProviderAdapter.prototype, 'getBalance')
      .mockResolvedValue({
        balance: 9999,
        currency: baseAccount.currency,
        retrievedAt: new Date(),
      });

    accountFundingService['fundingDto'] = undefined;
  });

  describe('when a worker run isFundNeeded', () => {
    beforeEach(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(false)); // FEATURE FLAG CAN USE NEW PAYOUT CREATION
    });
    it('should return undefined if the account balance dont need funding', async () => {
      jest
        .spyOn(SecretManagerService.prototype, 'getSecret')
        .mockResolvedValueOnce(Promise.resolve(accountFundingDto));

      const result = await accountFundingService.fundAccount();
      expect(result).toBeUndefined();
    });

    it('should create a payout and a transfer if account balance need it', async () => {
      jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
        Promise.resolve({
          ...accountFundingDto,
          destinationAccountIdentifier: destinationAccount.identifier,
          destinationAccountHolderId: destinationAccount.holderId,
          minBalance: '20000' as unknown as number,
        } as AccountFundingDto),
      );

      mockProviderGetBalance.mockResolvedValueOnce({
        balance: '9999',
        retrievedAt: new Date(),
        currency: destinationAccount.currency,
      });

      jest
        .spyOn(ScraperPWProviderAdapter.prototype, 'createTransaction')
        .mockReturnValue(
          Promise.resolve({
            jobId: 'jobId',
            externalId: 'ABCD1',
            state: TransferState.ASSIGNED,
          }),
        );
      const fundResult = await accountFundingService.fundAccount();
      const payoutCreated = await payoutRepository.findOne({
        where: { id: fundResult.payoutId },
      });
      const transferCreated = await transferRepository.findOne({
        where: { id: fundResult.transferId },
      });

      // Ensure that get balance was called for the destination account
      expect(mockProviderGetBalance).toHaveBeenCalledWith(
        expect.objectContaining({
          id: balanceProvider.id,
          accountId: destinationAccount.id,
        }),
      );

      expect(payoutCreated.merchantId).toBe(originMerchant.id);
      expect(payoutCreated.destinationAccount).toEqual(
        destinationAccount.identifier,
      );
      expect(payoutCreated.destinationHolderId).toEqual(
        destinationAccount.holderId,
      );
      expect(fundResult).toStrictEqual({
        payoutId: expect.any(Number),
        transferId: expect.any(Number),
        jobId: expect.any(String),
        externalId: expect.any(String),
      });

      expect(fundResult).toStrictEqual({
        payoutId: transferCreated.payoutId,
        transferId: transferCreated.id,
        jobId: transferCreated.metadata.jobId,
        externalId: transferCreated.externalId,
      });

      expect(transferCreated.providerId).toBe(originProvider.id);

      expect(transferCreated.currency).toBe(destinationAccount.currency);

      await transferRepository.delete(fundResult.transferId);
      await payoutRepository.delete(fundResult.payoutId);
    });

    it('should call createTransaction(from provider) 1 time', async () => {
      jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
        Promise.resolve({
          ...accountFundingDto,
          minBalance: '200000',
        }),
      );
      const createTransactionMock = jest
        .spyOn(ScraperPWProviderAdapter.prototype, 'createTransaction')
        .mockReturnValue(
          Promise.resolve({
            jobId: 'jobId',
            externalId: 'ABCD1',
            state: TransferState.ASSIGNED,
          }),
        );
      const fundResult = await accountFundingService.fundAccount();

      expect(createTransactionMock).toHaveBeenCalledTimes(1);
      await transferRepository.delete(fundResult.transferId);
      await payoutRepository.delete(fundResult.payoutId);
    });

    const cases = [-1, 19898765];

    test.each(cases)(
      'should throw error if the origin account with Id %s is not found',
      async (mainAccountId) => {
        jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
          Promise.resolve({
            ...accountFundingDto,
            minBalance: '20000' as unknown as number,
            originAccountId: mainAccountId,
          } as AccountFundingDto),
        );

        await expect(accountFundingService.fundAccount()).rejects.toThrow(
          `Origin account with id ${mainAccountId} was not found`,
        );
      },
    );

    test.each(cases)(
      'should throw error if destination AccountId with Id %s is not found',
      async (destinationAccountId) => {
        jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
          Promise.resolve({
            ...accountFundingDto,
            minBalance: '20000' as unknown as number,
            destinationAccountId: destinationAccountId,
          } as AccountFundingDto),
        );

        await expect(accountFundingService.fundAccount()).rejects.toThrow(
          `Destination account with id ${destinationAccountId} was not found`,
        );
      },
    );

    test.each(cases)(
      'should throw error if the provider with ID %s is not found',
      async (providerId) => {
        jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
          Promise.resolve({
            ...accountFundingDto,
            originProviderId: providerId,
            minBalance: '20000' as unknown as number,
          } as AccountFundingDto),
        );

        await expect(accountFundingService.fundAccount()).rejects.toThrow(
          `Provider with id ${providerId} was not found`,
        );
      },
    );

    test('should throw an error if the balance date is older than one hour', async () => {
      jest.spyOn(SecretManagerService.prototype, 'getSecret').mockReturnValue(
        Promise.resolve({
          ...accountFundingDto,
          minBalance: '20000' as unknown as number,
        } as AccountFundingDto),
      );

      const currentDate = new Date();

      mockProviderGetBalance.mockResolvedValue({
        balance: 100,
        currency: baseAccount.currency,
        retrievedAt: new Date().setHours(currentDate.getHours() - 2),
      });

      await expect(accountFundingService.fundAccount()).rejects.toThrow(
        'Balance must be less than one hour ago',
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/jobs/minkaProviderJob.e2e-spec.ts
import moment = require('moment');
import { LessThan, MoreThanOrEqual } from 'typeorm';

import { app } from '../app.setup';
import { MinkaProviderJob } from 'src/providers/jobs/minka.provider.job';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';

describe('given a MinkaProviderJob', () => {
  let minkaProviderJob: MinkaProviderJob;
  let transferProviderService: TransferProviderService;

  beforeAll(async () => {
    try {
      minkaProviderJob = app.get(MinkaProviderJob);
      transferProviderService = app.get<TransferProviderService>(
        TransferProviderService,
      );
    } catch (error) {
      console.log(error);
    }
  });

  describe('when call longTermUpdateTransactions', () => {
    it('The transferProvider Service getTransactionsUpdate method is called with providerType: minka, lookupTime: some typeOrm FindOperator', async () => {
      const spy = jest
        .spyOn(transferProviderService, 'getTransactionsUpdate')
        .mockReturnValue(Promise.resolve([]));
      await minkaProviderJob.longTermUpdateTransactions();

      const oneHourAgo = moment().subtract(1, 'hour').toDate();
      const findOperatorParam = LessThan(oneHourAgo);

      expect(spy).toHaveBeenCalled();
      expect(spy).toHaveBeenCalledWith({
        providerType: 'minka',
        lookupTime: findOperatorParam,
      });
    });
  });
  describe('when call shortTermUpdateTransactions', () => {
    it('then eventEmitter emit an event with providerType: minka, lookupTime: some typeOrm FindOperator', async () => {
      const spy = jest
        .spyOn(transferProviderService, 'getTransactionsUpdate')
        .mockReturnValue(Promise.resolve([]));

      await minkaProviderJob.shortTermUpdateTransactions();

      const oneHourAgo = moment().subtract(1, 'hour').toDate();
      const findOperatorParam = MoreThanOrEqual(oneHourAgo);

      expect(spy).toHaveBeenCalled();

      expect(spy).toHaveBeenCalledWith({
        providerType: 'minka',
        lookupTime: findOperatorParam,
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/global.teardown.ts
async function teardown() {
  console.log('Test teardown starting');
  // TODO: decide if we want to clean up the database after all tests run, or leave it as is
  console.log('Test teardown completed');
}

export default teardown;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/metricsController.e2e-spec.ts
import { Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { UserEntity } from 'src/models/user/entities/user.entity';
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { randUuid } from '@ngneat/falso';
import { State } from 'src/common/enums/state.enum';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { AuthService } from 'src/services/auth/auth.service';
import moment = require('moment');
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

describe('given MetricsController v2', () => {
  let merchantRepository: Repository<MerchantEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let userRepository: Repository<UserEntity>;

  let authService: AuthService;

  const createMerchantDto = {
    state: State.ACTIVE,
    name: 'Test Merchant',
    identifier: randUuid(),
  };

  const createUserDto: Partial<UserEntity> = {
    password: 'hola',
    name: 'UserAdmin',
    email: 'UserAdmin@gmail.com',
    role: UserRole.SUPER,
  };

  const createAccountDto: Partial<AccountEntity> = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '45912391',
  };

  const createProviderDto: Partial<ProviderEntity> = {
    name: 'Test Provider',
    providerType: ProviderType.ScraperCG,
  };

  const createPayoutDto: Partial<PayoutEntity> = {
    amount: 1000,
    concept: 'Pago Buk Adelantos',
    destinationName: 'Vicente Fuenzalida',
    destinationPhone: '999999999',
    destinationEmail: 'vfuenzalida@buk.cl',
    destinationAccount: '00000111111222223333',
    destinationHolderId: '189340223',
    destinationBankCode: BankCode.BANCO_SANTANDER,
    currency: Currency.CHILE,
    version: EntityVersion.v2,
  };

  const createTransferDto: Partial<TransferEntity> = {
    amount: 1000,
    concept: 'Pago Buk Adelantos',
    destinationName: 'Vicente Fuenzalida',
    destinationPhone: '999999999',
    destinationEmail: 'vfuenzalida@buk.cl',
    destinationAccount: '00000111111222223333',
    destinationHolderId: '189340223',
    destinationBankCode: BankCode.BANCO_SANTANDER,
    currency: Currency.CHILE,
    version: EntityVersion.v2,
  };

  async function createPayout(
    payoutDto: Partial<PayoutEntity>,
  ): Promise<PayoutEntity> {
    const trackingCode = payoutDto.trackingCode ?? randUuid();

    return await payoutRepository.save({
      ...createPayoutDto,
      trackingCode,
      ...payoutDto,
    });
  }

  async function createTransfer(
    transferDto: Partial<TransferEntity> = {},
  ): Promise<TransferEntity> {
    const trackingCode = transferDto.trackingCode ?? randUuid();
    const merchantId = transferDto.merchantId ?? merchant.id;

    if (!transferDto.payoutId) {
      const payout = await createPayout({
        ...createPayoutDto,
        merchantId,
        trackingCode,
      });

      transferDto.payoutId = payout.id;
    }

    return await transferRepository.save({
      ...createTransferDto,
      trackingCode,
      merchantId,
      providerId: providerOne.id,
      state: TransferState.PENDING,
      ...transferDto,
    });
  }

  let merchant: MerchantEntity;
  let user: UserEntity;
  let account: AccountEntity;
  let providerOne: ProviderEntity;

  beforeAll(async () => {
    authService = app.get<AuthService>(AuthService);

    merchantRepository = connection.getRepository(MerchantEntity);
    userRepository = connection.getRepository(UserEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  beforeEach(async () => {
    merchant = await merchantRepository.save({ ...createMerchantDto });
    const merchantId = merchant.id;

    user = await userRepository.save({ ...createUserDto, merchantId });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId,
    });

    providerOne = await providerRepository.save({
      ...createProviderDto,
      capabilities: [ProviderCapability.CREATE_TRANSFER],
      merchantId,
      accountId: account.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ merchantId: merchant.id });
    await payoutRepository.delete({ merchantId: merchant.id });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: merchant.id });

    await userRepository.delete({ merchantId: merchant.id });
    await merchantRepository.delete({ id: merchant.id });
  });

  describe('When a non authenticated user calls the metrics endpoints', () => {
    it('then should throw 401 status code for the time endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/time`)
        .expect(401);
    });

    it('then should throw 401 status code for the state endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/state`)
        .expect(401);
    });

    it('then should throw 401 status code for the amount endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/amount`)
        .expect(401);
    });

    it('then should throw 401 status code for the management endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/management`)
        .expect(401);
    });
  });

  describe('When an ADMIN user calls the metrics endpoints', () => {
    let jwtToken: string;

    beforeEach(async () => {
      await userRepository.update({ id: user.id }, { role: UserRole.ADMIN });
      jwtToken = authService.generateToken(user);
    });

    it('then should throw 403 status code for the time endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/time`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(403);
    });

    it('then should throw 403 status code for the state endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/state`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(403);
    });

    it('then should throw 403 status code for the amount endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/amount`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(403);
    });

    it('then should throw 403 status code for the management endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/management`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(403);
    });
  });

  describe('When a SUPER user calls the metrics endpoints', () => {
    let jwtToken: string;

    beforeEach(async () => {
      await userRepository.update({ id: user.id }, { role: UserRole.SUPER });
      jwtToken = authService.generateToken(user);
    });

    it('then should return 200 status code for the time endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/time`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });

    it('then should return 200 status code for the state endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/state`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });

    it('then should return 200 status code for the amount endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/amount`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });

    it('then should return 200 status code for the management endpoint', async () => {
      await request(app.getHttpServer())
        .get(`/v2/metrics/${providerOne.id}/management`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });

    describe('with date filters', () => {
      let from: string;
      let to: string;

      let validTransfer: TransferEntity;
      let invalidTransfer: TransferEntity;

      beforeEach(async () => {
        const transferDate = moment('2024-01-10 00:00:00.000');

        const startDate = transferDate.clone().subtract(1, 'day');
        const endDate = transferDate.clone().add(1, 'day');

        from = startDate.toISOString();
        to = endDate.toISOString();

        validTransfer = await createTransfer();
        invalidTransfer = await createTransfer();

        await transferRepository.update(validTransfer.id, {
          createdAt: transferDate.clone().toDate(),
          startedAt: transferDate.clone().add(10, 'seconds').toDate(),
          finishedAt: transferDate.clone().add(20, 'seconds').toDate(),
          state: TransferState.COMPLETED,
          errorCode: TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
          amount: 1000,
        });
        const futureDay = endDate.clone().add(1, 'day');
        await transferRepository.update(invalidTransfer.id, {
          createdAt: futureDay.toDate(),
          startedAt: futureDay.clone().add(60, 'seconds').toDate(),
          finishedAt: futureDay.clone().add(120, 'seconds').toDate(),
          state: TransferState.COMPLETED,
          errorCode: TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
          amount: 2000,
        });
      });

      it('then should return 200 status code for the time endpoint', async () => {
        const response = await request(app.getHttpServer())
          .get(`/v2/metrics/${providerOne.id}/time?from=${from}&to=${to}`)
          .set('Authorization', `Bearer ${jwtToken}`)
          .expect(200);

        expect(response.body).toEqual({
          avg: 10,
          max: 10,
          min: 10,
        });
      });

      it('then should return 200 status code for the amount endpoint', async () => {
        const response = await request(app.getHttpServer())
          .get(`/v2/metrics/${providerOne.id}/amount?from=${from}&to=${to}`)
          .set('Authorization', `Bearer ${jwtToken}`)
          .expect(200);

        expect(response.body).toEqual({
          avg: 1000,
          max: 1000,
          min: 1000,
          sum: 1000,
        });
      });

      it('then should return 200 status code for the state endpoint', async () => {
        const response = await request(app.getHttpServer())
          .get(`/v2/metrics/${providerOne.id}/state?from=${from}&to=${to}`)
          .set('Authorization', `Bearer ${jwtToken}`)
          .expect(200);

        expect(response.body).toEqual({
          [TransferState.COMPLETED]: 1,
          [TransferState.FAILED]: 0,
          [TransferState.PENDING]: 0,
          [TransferState.PROCESSING]: 0,
          [TransferState.ASSIGNED]: 0,
          [TransferState.CANCELED]: 0,
        });
      });

      it('then should return 200 status code for the management endpoint', async () => {
        await transferRepository.update(validTransfer.id, {
          state: TransferState.CANCELED,
        });

        await payoutRepository.update(validTransfer.payoutId, {
          state: PayoutState.CANCELED,
        });

        await transferRepository.update(invalidTransfer.id, {
          state: TransferState.CANCELED,
        });

        await payoutRepository.update(invalidTransfer.payoutId, {
          state: PayoutState.CANCELED,
        });

        const response = await request(app.getHttpServer())
          .get(`/v2/metrics/${providerOne.id}/management?from=${from}&to=${to}`)
          .set('Authorization', `Bearer ${jwtToken}`)
          .expect(200);

        expect(response.body).toEqual({
          retry: 0,
          reassign: 0,
          cancel: 1,
          complete: 0,
        });
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/transferMethodController.e2e-spec.ts
import { Repository } from 'typeorm';
import * as request from 'supertest';
import { changeEnv, randNumberString } from '../../../utils/testUtils';
import { app, connection } from '../../../app.setup';
import { Environment } from 'src/common/enums/environment.enum';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { State } from 'src/common/enums/state.enum';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';
import { AccessType } from 'src/common/enums/access-type.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';

const createBankAccessDto = {
  name: 'Created from test',
  state: State.INACTIVE,
  credentials: { a: '1' },
  capabilities: [],
  bankAccountIds: [3],
  merchantId: null,
  bankCode: 'cl_banco_falabella',
  accessType: AccessType.BUSINESS,
};

const baseTransferMethod: Partial<TransferMethodEntity> = {
  identifier: randNumberString(),
  merchantId: null,
  bankAccessId: null,
  state: State.ACTIVE,
  methodType: TransferMethodType.MOBILE,
  signingKeys: '1',
};

describe('given a TransferMethodController', () => {
  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUserWithMFA: TestUserWithTokenUtil;
  let testUserWithNoMFA: TestUserWithTokenUtil;

  let transferMethod: TransferMethodEntity;
  let bankAccess: BankAccessEntity;
  let merchant: MerchantEntity;
  let tokenUserSuper: string;
  let jwtTokenNoMFA: string;
  let apiKey: string;

  let transferMethodRepository: Repository<TransferMethodEntity>;
  let bankAccessRepository: Repository<BankAccessEntity>;

  beforeAll(async () => {
    try {
      testMerchant = await createTestMerchant();
      merchant = testMerchant.merchant;
      testApiKey = await createTestApiKey(merchant.id);
      testUserWithMFA = await useTestUser(UserRole.SUPER, true, {
        merchantId: merchant.id,
      });
      testUserWithNoMFA = await useTestUser(UserRole.SUPER, false, {
        merchantId: merchant.id,
      });

      apiKey = testApiKey.mockData.key;
      tokenUserSuper = testUserWithMFA.token;
      jwtTokenNoMFA = testUserWithNoMFA.token;

      transferMethodRepository = connection.getRepository(TransferMethodEntity);
      bankAccessRepository = connection.getRepository(BankAccessEntity);

      bankAccess = await bankAccessRepository.save({
        ...createBankAccessDto,
        merchantId: merchant.id,
      });
    } catch (error) {
      console.log(error);
    }
  });

  beforeEach(async () => {
    transferMethod = await transferMethodRepository.save({
      ...baseTransferMethod,
      merchantId: merchant.id,
      bankAccessId: bankAccess.id,
      identifier: randNumberString(),
    });
  });

  afterEach(async () => {
    await transferMethodRepository.remove(transferMethod);
  });

  afterAll(async () => {
    await bankAccessRepository.remove(bankAccess);
    await testApiKey.deleteApiKey();
    await testUserWithMFA.deleteUser();
    await testUserWithNoMFA.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('when a user using JWT MFA strategy calls GET /v2/transfer-methods', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-methods')
        .set('Authorization', `Bearer ${tokenUserSuper}`)
        .expect(200);
    });
    it('then it should throw an UnauthorizedException if mfa is false', async () => {
      changeEnv();
      await request(app.getHttpServer())
        .get('/v2/transfer-methods')
        .set('Authorization', `Bearer ${jwtTokenNoMFA}`)
        .expect(401);
      changeEnv(Environment.TEST);
    });
    it('then it should return the paginated transfer methods', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/transfer-methods?merchantId=${merchant.id}`)
        .set('Authorization', `Bearer ${tokenUserSuper}`)
        .expect(200);

      const headers = response.headers;

      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
    });
    it('then it should return only merchant transfer methods if the corresponding merchant id is provided', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/transfer-methods?merchantId=${merchant.id}`)
        .set('Authorization', `Bearer ${tokenUserSuper}`)
        .expect(200);

      const transferMethods: TransferMethodEntity[] = response.body;

      expect(transferMethods.length).toBeGreaterThan(0);
      const everyFromMerchant = transferMethods.every(
        (payout) => payout.merchantId === merchant.id,
      );
      expect(everyFromMerchant).toBeTruthy();
    });
  });

  describe('when a user using API key strategy calls GET /v2/transfer-methods', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-methods')
        .set('X-API-KEY', apiKey)
        .expect(200);
    });
  });

  describe('when a user using both JWT and API key strategy calls GET /v2/transfer-methods', () => {
    it('then it should not allow access (400)', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-methods')
        .set('Authorization', `Bearer ${tokenUserSuper}`)
        .set('X-API-KEY', apiKey)
        .expect(400);
    });
  });

  describe('when a user using no authentication strategy calls GET /v2/transfer-methods', () => {
    it('then it should not allow access (401)', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-methods')
        .expect(401);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/accountController.e2e-spec.ts
import * as request from 'supertest';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { app, connection } from 'test/app.setup';
import { In, Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

import { UserRole } from 'src/common/enums/user-role.enum';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';

describe('Given an AccountController', () => {
  let userRepository: Repository<UserEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;

  const baseAccount: Partial<AccountEntity> = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '45912391',
  };

  const baseProvider = {
    name: 'Test Provider',
    credentials: { username: 'a', password: 'b' },
    rules: {},
    providerType: ProviderType.ScraperCG,
    capabilities: [ProviderCapability.READ_TRANSFER],
    accountId: undefined,
  };

  let testMerchant: TestMerchantUtil;
  let otherTestMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUserWithToken: TestUserWithTokenUtil;

  beforeAll(async () => {
    userRepository = connection.getRepository(UserEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    otherTestMerchant = await createTestMerchant();
    testApiKey = await createTestApiKey(testMerchant.merchant.id);
    testUserWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });
  });

  afterEach(async () => {
    const merchantIds = [
      testMerchant.merchant.id,
      otherTestMerchant.merchant.id,
    ];

    const accounts = await accountRepository.findBy({
      merchantId: In(merchantIds),
    });

    const accountIds = accounts.map((a) => a.id);

    await providerRepository.delete({
      accountId: In(accountIds),
    });

    await accountStatementJobRepository.delete({
      accountId: In(accountIds),
    });

    await accountRepository.delete({ merchantId: In(merchantIds) });

    await userRepository.delete({ merchantId: In(merchantIds) });
    await testApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
    await otherTestMerchant.deleteMerchant();
  });

  describe('when a user calls GET /v2/accounts', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).get('/v2/accounts').expect(401);
    });
    // TODO: when account controller is fixed regarding the merchantId filter undo skip test
    it.skip('then should throw 400 status code if merchant its not provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/accounts')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(400);
    });
    it('then should return the paginated accounts if valid credentials are provided', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/accounts`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      const headers = response.headers;

      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
    });
    it('then should return only the merchant accounts that have a user with admin role', async () => {
      const { token } = await useTestUser(UserRole.ADMIN, false, {
        merchantId: otherTestMerchant.merchant.id,
      });

      await accountRepository.save({
        ...baseAccount,
        merchantId: otherTestMerchant.merchant.id,
      });

      let pageCount = 1;
      let page = 1;

      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get('/v2/accounts')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);
        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const accounts: AccountEntity[] = response.body;
        expect(
          accounts.every(
            (account) => account.merchantId === otherTestMerchant.merchant.id,
          ),
        ).toBeTruthy();
        page++;
      }
    });

    it('then should return only merchant accounts if the corresponding merchant id is provided', async () => {
      await accountRepository.save({
        ...baseAccount,
        merchantId: otherTestMerchant.merchant.id,
      });
      const response = await request(app.getHttpServer())
        .get(`/v2/accounts?merchantId=${otherTestMerchant.merchant.id}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);
      const accounts = response.body;
      expect(accounts).toHaveLength(1);
    });
  });

  describe('when a user calls GET /v2/accounts/:id', () => {
    let newAccount;

    beforeEach(async () => {
      newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/v2/accounts/${newAccount.id}`)
        .expect(401);
    });
    it('then should throw 404 status code if the account is not found', async () => {
      await accountRepository.delete({ id: newAccount.id });

      await request(app.getHttpServer())
        .get(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(404);
    });

    it('then should return an account', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);
      const account = response.body;
      expect(account.id).toBeDefined();
    });

    it('then should throw 404 status code if the account does not exist for merchant if the corresponding merchant id is provided', async () => {
      await accountRepository.update(
        { id: newAccount.id },
        { merchantId: otherTestMerchant.merchant.id },
      );

      await request(app.getHttpServer())
        .get(
          `/v2/accounts/${newAccount.id}?merchantId=${testMerchant.merchant.id}`,
        )
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(404);
    });
  });

  describe('when a user calls POST /v2/accounts', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).post('/v2/accounts').expect(401);
    });
    it('then should fail if invalid dto is provided', async () => {
      await request(app.getHttpServer())
        .post('/v2/accounts')
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(400);
    });
    it('then should fail if empty dto is provided', async () => {
      await request(app.getHttpServer())
        .post('/v2/accounts')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({})
        .expect(400);
    });
    it('then create a new account with empty rules', async () => {
      const createAccountDto = {
        ...baseAccount,
      };

      const response = await request(app.getHttpServer())
        .post('/v2/accounts')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(createAccountDto)
        .expect(201);

      const account = response.body;
      expect(account.id).toBeDefined();
      expect(account.rules).toBeNull();
    });
    it('then create a new account with rules', async () => {
      const createAccountDto = {
        ...baseAccount,
        rules: {
          type: 'amount',
          value: { lt: 1000 },
          operator: 'range',
        },
      };

      const response = await request(app.getHttpServer())
        .post('/v2/accounts')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(createAccountDto)
        .expect(201);

      const account = response.body;
      expect(account.id).toBeDefined();
      expect(account.rules).toEqual(createAccountDto.rules);
    });
  });
  describe('when a user calls PATCH /v2/accounts/:id', () => {
    let newAccount;

    beforeEach(async () => {
      newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/accounts/${newAccount.id}`)
        .expect(401);
    });

    it('then should throw 403 status code if the account is not found', async () => {
      const updateAccountDto = { name: 'Update' };

      await accountRepository.delete({ id: newAccount.id });

      await request(app.getHttpServer())
        .patch(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(updateAccountDto)
        .expect(403);
    });

    it('then should update the account rules', async () => {
      const updateAccountDto = {
        rules: {
          type: 'amount',
          value: { lt: 1000000 },
          operator: 'range',
        },
      };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(updateAccountDto)
        .expect(200);

      const account = response.body;

      expect(account.rules).toEqual(updateAccountDto.rules);
    });

    it('then should update the account', async () => {
      const updateAccountDto = { name: 'Update' };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(updateAccountDto)
        .expect(200);
      const account = response.body;

      expect(account).toBeDefined();
      expect(account.name).toEqual('Update');
    });
  });

  describe('when a user calls DELETE /v2/accounts/:id', () => {
    let newAccount;

    beforeEach(async () => {
      newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).delete(
        `/v2/accounts/${newAccount.id}`,
      );
    });

    it('then should throw 403 if the account is not found', async () => {
      await accountRepository.delete({ id: newAccount.id });

      await request(app.getHttpServer())
        .delete(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(403);
    });

    it('then should remove the account', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/accounts/${newAccount.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      const deletedAccount = await accountRepository.findOneBy({
        id: newAccount.id,
      });
      expect(deletedAccount).toBeNull();
    });
  });

  describe('when a user calls POST /v2/accounts/{id}/statements', () => {
    const startDate = '2023-08-06';
    const endDate = '2023-08-08';
    const params = { startDate, endDate };
    const env = process.env.NODE_ENV as Environment;

    it('then it should create an account statement job if there is no other running', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });
      jest
        .spyOn(AwsBatchService.prototype, 'getBatchJobQueue')
        .mockReturnValue(Promise.resolve([]));
      jest.spyOn(AwsBatchService.prototype, 'submitBatchJob').mockReturnValue(
        Promise.resolve({
          jobId: '123',
          jobName: `bank-account-statements-job-cl-banco-security-${account.id}-${env}-${startDate}-${endDate}`,
          $metadata: undefined,
        }),
      );
      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(200);
    });
    it('then it should return 422 if other account statement job is running in aws', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
      const provider = await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });
      jest.spyOn(AwsBatchService.prototype, 'getBatchJobQueue').mockReturnValue(
        Promise.resolve([
          {
            jobId: '123',
            jobName: `bank-account-statements-job-cl-banco-santander-${provider.id}-${account.id}-${env}-${startDate}-${endDate}`,
          },
        ]),
      );
      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(422);
    });
    it('then it should return 503 if aws is unavailable', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });
      jest
        .spyOn(AwsBatchService.prototype, 'getBatchJobQueue')
        .mockReturnValue(Promise.resolve([]));
      jest
        .spyOn(AwsBatchService.prototype, 'submitBatchJob')
        .mockImplementation(async () => {
          throw new Error('Fake AWS Error');
        });
      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(503);
    });
    it('then it should return 422 if account bankCode is unsupported', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        bankCode: BankCode.BANCO_FALABELLA,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });

      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(422);
    });
    it('then it should return 422 if other account statement job is running', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        bankCode: BankCode.BANCO_FALABELLA,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });

      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params);

      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(422);
    });
    it('then it should return 422 if account does not have any active provider with "read_transfer" capability', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
        capabilities: [ProviderCapability.CREATE_TRANSFER],
      });

      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(params)
        .expect(422);
    });

    it('then it should return 400 status code if invalid date format is provided', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant.merchant.id,
      });
      await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
        capabilities: [ProviderCapability.CREATE_TRANSFER],
      });

      await request(app.getHttpServer())
        .post(`/v2/accounts/${account.id}/statements`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          startDate: '2023-09-07T00:00:00.000Z',
          endDate: '2023-09-07T02:59:59.999Z',
        })
        .expect(400);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/merchantController.e2e-spec.ts
import * as request from 'supertest';
import { changeEnv } from '../../../utils/testUtils';
import { app } from '../../../app.setup';
import { Environment } from 'src/common/enums/environment.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

describe('given a MerchantController', () => {
  let jwtToken: string;
  let jwtTokenNoMFA: string;
  let apiKey: string;

  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUserWithMFA: TestUserWithTokenUtil;
  let testUserWithNoMFA: TestUserWithTokenUtil;

  beforeAll(async () => {
    try {
      testMerchant = await createTestMerchant();
      testUserWithMFA = await useTestUser(UserRole.SUPER, true, {
        merchantId: testMerchant.merchant.id,
      });
      testUserWithNoMFA = await useTestUser(UserRole.SUPER, false, {
        merchantId: testMerchant.merchant.id,
      });
      testApiKey = await createTestApiKey(testMerchant.merchant.id);

      jwtToken = testUserWithMFA.token;
      jwtTokenNoMFA = testUserWithNoMFA.token;
      apiKey = testApiKey.mockData.key;
    } catch (error) {
      console.log(error);
    }
  });
  afterAll(async () => {
    await testUserWithNoMFA.deleteUser();
    await testApiKey.deleteApiKey();
    await testUserWithMFA.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('when a user using JWT MFA strategy calls GET /v2/merchants', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/merchants')
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });
    it('then it should throw an UnauthorizedException if mfa is false', async () => {
      changeEnv();
      await request(app.getHttpServer())
        .get('/v2/merchants')
        .set('Authorization', `Bearer ${jwtTokenNoMFA}`)
        .expect(401);
      changeEnv(Environment.TEST);
    });
  });

  describe('when a user using API key strategy calls GET /v2/merchants', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/merchants')
        .set('X-API-KEY', apiKey)
        .expect(200);
    });
  });

  describe('when a user using both JWT and API key strategy calls GET /v2/merchants', () => {
    it('then it should not allow access (400)', async () => {
      await request(app.getHttpServer())
        .get('/v2/merchants')
        .set('Authorization', `Bearer ${jwtToken}`)
        .set('X-API-KEY', apiKey)
        .expect(400);
    });
  });

  describe('when a user using no authentication strategy calls GET /v2/merchants', () => {
    it('then it should not allow access (401)', async () => {
      await request(app.getHttpServer()).get('/v2/merchants').expect(401);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/authController.e2e-spec.ts
import { randEmail } from '@ngneat/falso';
import { ChangeUserPasswordDto } from 'src/api/v2/auth/dto/change-user-password.dto';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { AuthService } from 'src/services/auth/auth.service';
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import {
  createTestUser,
  useTestUser,
  type TestUserUtil,
  type TestUserWithTokenUtil,
} from 'test/utils/userTestUtils';
import { Repository } from 'typeorm';

describe('Given an AuthController', () => {
  let userRepository: Repository<UserEntity>;
  let testMerchant: TestMerchantUtil;
  let testSuperUser: TestUserWithTokenUtil;

  let authService: AuthService;

  const loginDto = { email: randEmail(), password: 'pass' };

  beforeAll(async () => {
    userRepository = connection.getRepository(UserEntity);
    authService = app.get(AuthService);
  });

  beforeEach(async () => {
    jest.spyOn(authService, 'mfaEnforced', 'get').mockReturnValue(false);

    testMerchant = await createTestMerchant();

    testSuperUser = await useTestUser(UserRole.SUPER, false, {
      ...loginDto,
      merchantId: testMerchant.merchant.id,
    });
  });

  afterEach(async () => {
    await userRepository.delete({ merchantId: testMerchant.merchant.id });
    await testMerchant.deleteMerchant();
  });

  describe('POST /v2/auth/login', () => {
    it('returns a JWT token when provided with valid user credentials', async () => {
      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/login')
        .send(loginDto)
        .expect(200);

      expect(body).toHaveProperty('token');
      expect(typeof body.token).toBe('string');
    });

    it('returns a 401 error when provided with invalid user credentials', async () => {
      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/login')
        .send({ email: randEmail(), password: 'wrong' })
        .expect(401);
      expect(body).toHaveProperty('message', 'Invalid credentials');
    });

    it('returns a 401 error when a non-active user attempts to log in', async () => {
      await userRepository.update(
        { id: testSuperUser.user.id },
        { state: State.INACTIVE },
      );

      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/login')
        .send(loginDto)
        .expect(401);

      expect(body).toHaveProperty('message', 'Unauthorized');
    });
  });

  describe('POST /v2/auth/register', () => {
    it('should return a user when given valid data', async () => {
      const registerDto = {
        email: randEmail(),
        name: 'Test User',
        merchantId: testMerchant.merchant.id,
        role: UserRole.SUPER,
      };

      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/register')
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .send(registerDto)
        .expect(201);
      expect(body).toHaveProperty('email', registerDto.email);
      expect(body).toHaveProperty('name', registerDto.name);
      expect(body).toHaveProperty('id');
    });

    it('should return a 409 when given invalid data (used email)', async () => {
      const registerDto = {
        email: testSuperUser.user.email,
        name: 'Test User',
        merchantId: testSuperUser.user.merchantId,
        role: UserRole.SUPER,
      };
      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/register')
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .send(registerDto)
        .expect(409);
      expect(body).toHaveProperty(
        'message',
        `User with email ${testSuperUser.user.email} already exists`,
      );
    });

    it('should return a 400 when given invalid data (not valid email)', async () => {
      const registerDto = {
        email: 'invalidEmail',
        name: 'Test User',
        merchantId: testMerchant.merchant.id,
        role: UserRole.SUPER,
      };
      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/register')
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .send(registerDto)
        .expect(400);
      expect(body.message).toContainEqual('email must be an email');
    });

    it('should return a 400 when given invalid data (incomplete dto)', async () => {
      const registerDto = {
        email: 'superwww@example.com',
        name: 'Test User',
        role: UserRole.SUPER,
      };
      const { body } = await request(app.getHttpServer())
        .post('/v2/auth/register')
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .send(registerDto)
        .expect(400);
      expect(body.message.length).toBeGreaterThan(0);
    });
  });

  describe('PATCH /v2/auth/mfa/reset/:id', () => {
    let createdUserUtil: TestUserUtil;

    it('resets MFA when provided with a valid user ID', async () => {
      // Create a user with a mock MFA setup
      createdUserUtil = await createTestUser({
        useMfa: true,
        user: {
          email: randEmail(),
          name: 'Test User',
          password: 'TestPassword',
          merchantId: testMerchant.merchant.id,
          role: UserRole.USER,
          state: State.ACTIVE,
        },
      });

      // Make a PATCH request to the resetMFA endpoint
      const { body } = await request(app.getHttpServer())
        .patch(`/v2/auth/mfa/reset/${createdUserUtil.user.id}`)
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .expect(200);
      expect(body).toHaveProperty(
        'message',
        `MFA for user ${createdUserUtil.user.id} was reset successfully`,
      );

      // Verify that the user's MFA has been reset
      const updatedUser = await userRepository.findOneBy({
        id: createdUserUtil.user.id,
      });
      expect(updatedUser.mfa).toBe(false);
      expect(updatedUser.mfaState).toBe(MFAState.DISABLED);
      expect(updatedUser.seed).toBeFalsy();
    });

    it('should return 404 when given an invalid user ID', async () =>
      request(app.getHttpServer())
        .patch(`/v2/auth/mfa/reset/${-1}`)
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .expect(404));
  });

  describe('PATCH /v2/auth/reset-password/:id', () => {
    it('should reset password when given a valid user ID', async () => {
      // Create a user with a mock setup
      const { deleteUser, user } = await createTestUser({
        useMfa: false,
        user: {
          email: randEmail(),
          name: 'Test User',
          password: 'TestPassword',
          merchantId: testMerchant.merchant.id,
          role: UserRole.USER,
          state: State.ACTIVE,
        },
      });

      // Make a PATCH request to the resetPassword endpoint
      const { body } = await request(app.getHttpServer())
        .patch(`/v2/auth/reset-password/${user.id}`)
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .expect(200);

      // Expect a success message in the response body
      expect(body).toEqual({
        message: `Password for user ${user.id} was reset successfully`,
      });

      // Cleanup: delete the user
      await deleteUser();
    });

    it('should return 404 when given an invalid user ID', async () =>
      request(app.getHttpServer())
        .patch(`/v2/auth/reset-password/${-1}`)
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .expect(404));

    it('should return 403 when accessed by a user without SUPER role', async () => {
      const { token, deleteUser } = await useTestUser(UserRole.USER, false, {
        merchantId: testMerchant.merchant.id,
      });
      await request(app.getHttpServer())
        .patch(`/v2/auth/reset-password/${1}`)
        .set('Authorization', `Bearer ${token}`)
        .expect(403);
      await deleteUser();
    });
  });

  describe('PATCH /v2/auth/change-password', () => {
    let testUser: TestUserWithTokenUtil;

    beforeEach(async () => {
      testUser = await useTestUser(UserRole.USER, false, {
        merchantId: testMerchant.merchant.id,
      });
    });

    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .expect(401);
    });

    it('then should return 400 status code if invalid Dto is provided', async () => {
      const { body } = await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send({ invalidProp: 'value' })
        .expect(400);
      expect(body.message.length).toBeGreaterThan(0);
    });

    it('then should return 400 status code if password is too weak', async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: testUser.mockData.password,
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
      };

      await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send(changePasswordDto)
        .expect(400);
    });
    it('then should return 400 if the new password is less than 8 characters', async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: testUser.mockData.password,
        newPassword: 'newPas1',
        confirmNewPassword: 'newPas1',
      };

      await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send(changePasswordDto)
        .expect(400);
    });
    it('then should return 400 if the new password is more than 50 characters', async () => {
      const longPassword = 'a'.repeat(51);
      const changePasswordDto = {
        oldPassword: testUser.mockData.password,
        newPassword: longPassword,
        confirmNewPassword: longPassword,
      };

      const { body } = await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send(changePasswordDto)
        .expect(400);
      expect(body.message).toContainEqual(
        'Password is too long, maximum length is 50 characters.',
      );
    });

    it('then should return 400 if the new password is missing', async () => {
      const changePasswordDto = {
        oldPassword: testUser.mockData.password,
        confirmNewPassword: 'newPassword1',
      } as ChangeUserPasswordDto;

      const { body } = await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send(changePasswordDto)
        .expect(400);
      expect(body.message).toContainEqual('newPassword should not be empty');
    });
    it('then should return 400 if the password confirmation is missing', async () => {
      const changePasswordDto = {
        oldPassword: testUser.mockData.password,
        newPassword: 'newPassword1',
      } as ChangeUserPasswordDto;

      const { body } = await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUser.token}`)
        .send(changePasswordDto)
        .expect(400);
      expect(body.message.length).toBeGreaterThan(0);
    });

    it('then should return 401 if the mfa code is wrong and the user has mfa enabled', async () => {
      const testUserWithMFA = await useTestUser(UserRole.USER, true, {
        merchantId: testMerchant.merchant.id,
      });

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: testUserWithMFA.mockData.password,
        newPassword: 'newPassword1',
        confirmNewPassword: 'newPassword1',
        mfaCode: 'wrongCode',
      };

      jest.spyOn(authService, 'mfaEnforced', 'get').mockReturnValue(true);

      const { body } = await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${testUserWithMFA.token}`)
        .send(changePasswordDto)
        .expect(401);
      expect(body.message).toBe('Invalid Code');

      await testUserWithMFA.deleteUser();
    });

    it('then should return 200 status after successfully changed the user password', async () => {
      const newUser = await useTestUser(UserRole.USER, false, {
        merchantId: testMerchant.merchant.id,
      });

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: newUser.mockData.password,
        newPassword: 'newPassword1',
        confirmNewPassword: 'newPassword1',
      };

      await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${newUser.token}`)
        .send(changePasswordDto)
        .expect(200);
    });

    it('then should return 401 status after password change with old token', async () => {
      const newUser = await useTestUser(UserRole.USER, false, {
        merchantId: testMerchant.merchant.id,
      });

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: newUser.mockData.password,
        newPassword: 'newPassword1',
        confirmNewPassword: 'newPassword1',
      };

      // Change password
      await request(app.getHttpServer())
        .patch('/v2/auth/change-password')
        .set('Authorization', `Bearer ${newUser.token}`)
        .send(changePasswordDto)
        .expect(200);

      // Try to access a protected route with the old token
      await request(app.getHttpServer())
        .get('/v2/users/me')
        .set('Authorization', `Bearer ${newUser.token}`)
        .expect(401);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/accountStatementController.e2e-spec.ts
import * as request from 'supertest';
import { Repository } from 'typeorm';
import { app, connection } from '../../../app.setup';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { randUuid } from '@ngneat/falso';
import * as moment from 'moment';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { State } from 'src/common/enums/state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';

const accountIdentifier = '1239123423';

const createAccountDto = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: accountIdentifier,
  state: State.ACTIVE,
};

const baseAccountStatementJob = {
  endDate: new Date('2022-11-12T16:54:05.000Z'),
  startDate: new Date('2022-11-12T16:59:05.000Z'),
  state: AccountStatementJobState.FINISHED,
  startedAt: new Date('2022-12-12T10:50:05.000Z'),
  endedAt: new Date('2022-12-12T10:55:05.000Z'),
  retrievedAt: new Date('2022-12-12T10:55:59.000Z'),
  totalRetrieved: 3,
  jobId: 'ABC123JobId',
};

const baseAccountStatement = {
  date: new Date('2022-11-12T16:54:05.000Z'),
  originBankCode: BankCode.BANCO_SANTANDER,
  originBankAccountIdentifier: accountIdentifier,
  concept: '114455164 pago Buk Adelantos',
  currency: Currency.CHILE,
  countryCode: CountryCode.CHILE,
  state: TransferState.COMPLETED,
  amount: 374000,
  transactionCode: '20221211130208435347',
  destinationHolderId: '111111111',
  destinationName: 'Usuario Prueba',
  destinationAccount: '87654321',
  destinationEmail: 'user.test@bukadelantos.cl',
  destinationBankCode: BankCode.BANCO_CONSORCIO,
  metadata: {
    status: 'Realizada',
    destinationBank: 'Banco de Chile',
  },
  accountStatementJobId: null,
};

describe('given an AccountStatementController', () => {
  let accountRepository: Repository<AccountEntity>;
  let accountStatementRepository: Repository<AccountStatementEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;

  let account: AccountEntity;
  let accountStatementJob: AccountStatementJobEntity;

  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testApiKey = await createTestApiKey(testMerchant.merchant.id);
    accountStatementRepository = connection.getRepository(
      AccountStatementEntity,
    );
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
    accountRepository = connection.getRepository(AccountEntity);
  });

  beforeEach(async () => {
    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchant.id,
    });
    accountStatementJob = await accountStatementJobRepository.save({
      ...baseAccountStatementJob,
      accountId: account.id,
    });

    baseAccountStatement.accountStatementJobId = accountStatementJob.id;
  });

  afterEach(async () => {
    await accountStatementRepository.delete({
      accountStatementJobId: accountStatementJob.id,
    });
    await accountStatementJobRepository.delete({ id: accountStatementJob.id });
    await accountRepository.delete({ id: account.id });
  });
  afterAll(async () => {
    await testApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
  });
  describe('when a user calls POST /v2/account-statements', () => {
    it('then return an array of created accountStatements', async () => {
      const amount = 370000;
      const response = await request(app.getHttpServer())
        .post('/v2/account-statements')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send([
          {
            ...baseAccountStatement,
            accountStatementJobId: accountStatementJob.id,
          },
          {
            ...baseAccountStatement,
            amount,
            date: new Date('2022-11-12T17:00:05.000Z'),
            transactionCode: randUuid(),
            accountStatementJobId: accountStatementJob.id,
          },
        ]);

      const accountStatementsCreated = response.body;

      expect(response.statusCode).toBe(201);
      expect(accountStatementsCreated.length).toBe(2);
    });

    it('then should create an account statement with only valid CreateAccountStatementDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/account-statements')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send([
          {
            ...baseAccountStatement,
            date: new Date('2022-11-12T17:05:05.000Z'),
            transactionCode: '20221211130208435344',
            amount: 300000,
            invalidProp: 300,
          },
        ]);

      expect(response.statusCode).toBe(201);
      expect(response.body.length).toBe(1);
      expect(response.body[0].invalidProp).toBe(undefined);
    });

    it('then not return the error data if invalid data is given', async () => {
      await request(app.getHttpServer())
        .post('/v2/account-statements')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send([{ ...baseAccountStatement, state: 'invalidState' }])
        .expect(400);
    });

    it('then updated the duplicated data if duplicated data is given', async () => {
      const thisAccount = await accountStatementRepository.save({
        ...baseAccountStatement,
      });

      const response = await request(app.getHttpServer())
        .post('/v2/account-statements')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send([{ ...baseAccountStatement }]);

      expect(response.statusCode).toBe(201);
      expect(response.body).toHaveLength(1);
      await accountStatementRepository.delete(thisAccount.id);
    });

    it('then save the account statements even if destinationBankCode is missing', async () => {
      const conflictingAccountStatement = { ...baseAccountStatement };
      delete conflictingAccountStatement.destinationBankCode;

      const response = await request(app.getHttpServer())
        .post('/v2/account-statements')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send([conflictingAccountStatement]);

      expect(response.statusCode).toBe(201);
      expect(response.body).toHaveLength(1);
    });
  });
  describe('when a user calls GET /v2/account-statements', () => {
    it('then should return only account statements with finished job', async () => {
      const originBankAccountIdentifier = '12345123123';
      const failedJob = await accountStatementJobRepository.save({
        ...baseAccountStatementJob,
        state: AccountStatementJobState.ERROR,
      });

      const finishedJob = await accountStatementJobRepository.save({
        ...baseAccountStatement,
        state: AccountStatementJobState.FINISHED,
      });

      const accountStatements = accountStatementRepository.create([
        {
          ...baseAccountStatement,
          originBankAccountIdentifier,
          transactionCode: randUuid(),
          accountStatementJobId: failedJob.id,
        },
        {
          ...baseAccountStatement,
          originBankAccountIdentifier,
          transactionCode: randUuid(),
          accountStatementJobId: finishedJob.id,
        },
      ]);

      await accountStatementRepository.save(accountStatements);

      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statements?originBankAccountIdentifier=${originBankAccountIdentifier}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key);

      expect(response.statusCode).toBe(200);
      expect(response.body).toHaveLength(1);
      const accountIds = accountStatements.map((i) => i.id);
      for (const accountId of accountIds) {
        await accountStatementRepository.delete(accountId);
      }
      await accountStatementJobRepository.delete(failedJob.id);
      await accountStatementJobRepository.delete(finishedJob.id);
    });
    it('then return default page array of accountStatements for specified bankAccountId ordered by date', async () => {
      const totalAccountStatements = 3;
      const newAccountStatements = Array(totalAccountStatements)
        .fill(baseAccountStatement)
        .map((base, index) => ({
          ...base,
          transactionCode: `20221211130208435341232${index}`,
        }));

      await accountStatementRepository.save(newAccountStatements);
      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statements?originBankAccountIdentifier=${accountIdentifier}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key);

      expect(response.statusCode).toBe(200);
      expect(response.body).toHaveLength(totalAccountStatements);
    });

    it('then return an array of accountStatements for specific date range', async () => {
      const totalAccountStatements = 2;
      const newAccountStatements = Array(totalAccountStatements)
        .fill(baseAccountStatement)
        .map((base, index) => ({
          ...base,
          transactionCode: randUuid(),
          date: moment('2000-11-01T16:55:00.000Z')
            .add(index, 'day')
            .toISOString(),
        }));

      await accountStatementRepository.save(newAccountStatements);

      const from = new Date('2000-11-01T16:55:00.000Z').toISOString();
      const to = new Date('2000-11-02T16:56:10.000Z').toISOString();
      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statements?originBankAccountIdentifier=${accountIdentifier}&from=${from}&to=${to}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key);

      const accountStatements = response.body;

      expect(accountStatements).toHaveLength(totalAccountStatements);
    });

    it('then return an array of accountStatements for specific destinationBankCode', async () => {
      const totalAccountStatements = 4;
      const newAccountStatements = Array(totalAccountStatements)
        .fill(baseAccountStatement)
        .map((base) => ({
          ...base,
          transactionCode: randUuid(),
        }));
      await accountStatementRepository.save(newAccountStatements);
      const { destinationBankCode } = baseAccountStatement;
      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statements?originBankAccountIdentifier=${accountIdentifier}&destinationBankCode=${destinationBankCode}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key);
      expect(response.body.length).toBe(totalAccountStatements);
      const accountIds = response.body.map((i) => i.id);

      for (const accountId of accountIds) {
        await accountStatementRepository.delete(accountId);
      }
      await accountStatementJobRepository.delete({
        id: accountStatementJob.id,
      });
    });

    it('then return an array of accountStatements for specific amount', async () => {
      const totalAccountStatements = 4;
      const amount = 9999.14;
      const newAccountStatements = Array(totalAccountStatements)
        .fill(baseAccountStatement)
        .map((base) => ({
          ...base,
          amount: 9999.14,
          transactionCode: randUuid(),
        }));

      await accountStatementRepository.save(newAccountStatements);

      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statements?originBankAccountIdentifier=${accountIdentifier}&amount=${amount}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key);

      expect(response.body.length).toBe(totalAccountStatements);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/transferErrorController.e2e-spec.ts
import * as request from 'supertest';
import { Repository } from 'typeorm';
import { app, connection } from 'test/app.setup';
import { UserRole } from 'src/common/enums/user-role.enum';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';

describe('Given a TransferError Controller', () => {
  let testMerchant: TestMerchantUtil;
  let testUserAdmin: TestUserWithTokenUtil;
  let testUserSuper: TestUserWithTokenUtil;
  let transferErrorRepository: Repository<TransferErrorEntity>;
  let transferErrors: TransferErrorEntity[] = []; // Initial data
  let merchant: MerchantEntity;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    testUserAdmin = await useTestUser(UserRole.ADMIN, true, {
      merchantId: merchant.id,
    });
    testUserSuper = await useTestUser(UserRole.SUPER, true, {
      merchantId: merchant.id,
    });
    transferErrorRepository = connection.getRepository(TransferErrorEntity);

    transferErrors = await transferErrorRepository.find();
    await transferErrorRepository.clear();
  });

  afterAll(async () => {
    await testUserAdmin.deleteUser();
    await testUserSuper.deleteUser();
    await transferErrorRepository.clear();
    await transferErrorRepository.save(transferErrors); // Restore initial data
  });

  describe('GET /v2/transfer-errors', () => {
    it('should return 401 if no credentials are provided', async () => {
      await request(app.getHttpServer()).get('/v2/transfer-errors').expect(401);
    });
    it('should return 403 when a user with invalid role', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-errors')
        .set('Authorization', `Bearer ${testUserAdmin.token}`)
        .expect(403);
    });
    it('should return 400 if invalid query is sent', async () => {
      await request(app.getHttpServer())
        .get('/v2/transfer-errors?invalidProp=1')
        .set('Authorization', `Bearer ${testUserSuper.token}`)
        .expect(400);
    });
    it('should return 200 with the paginated transfer errors', async () => {
      // Setup your test scenario here
      await transferErrorRepository.save([
        {
          errorRaw: 'Error 1',
          errorCode: TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
          errorType: 'DESTINATION_BANK_IN_MAINTENANCE',
          externalErrorCode: '',
        },
        {
          errorRaw: 'Error 2',
          errorType: 'DESTINATION_BANK_TIMEOUT',
          errorCode: TransferErrorCode.DESTINATION_BANK_TIMEOUT,
          externalErrorCode: '',
        },
      ]);

      // Test execution
      const response = await request(app.getHttpServer())
        .get('/v2/transfer-errors')
        .set('Authorization', `Bearer ${testUserSuper.token}`)
        .expect(200);

      // Assertions
      const headers = response.headers;
      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();

      expect(response.body.length).toBeGreaterThan(0);

      expect(response.body[0]).toEqual(
        expect.objectContaining({
          id: expect.any(Number),
          uuid: expect.any(String),
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
          errorRaw: expect.any(String),
          errorCode: expect.any(String),
          externalErrorCode: expect.any(String),
          providerType: null,
          errorType: expect.any(String),
        }),
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/transferJobController.e2e-spec.ts
import { Repository } from 'typeorm';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';
import { CreateTransferJobDto } from 'src/api/v2/transfer-job/dtos/create-transfer-job.dto';
import * as request from 'supertest';
import { app, connection } from '../../../app.setup';
import { Currency } from 'src/common/enums/currency.enum';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { State } from 'src/common/enums/state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

describe('given a TransferJobController', () => {
  let apiKey: string;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let transferJobRepository: Repository<TransferJobEntity>;

  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: null,
    state: State.ACTIVE,
  };
  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.Minka,
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const createTransferJobDto: CreateTransferJobDto = {
    startedAt: new Date().toISOString(),
    state: TransferJobState.CREATED,
    jobId: 'testJobId',
    providerId: undefined,
  };

  beforeAll(async () => {
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    transferJobRepository = connection.getRepository(TransferJobEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    testApiKey = await createTestApiKey(testMerchant.merchant.id);

    apiKey = testApiKey.mockData.key;

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchant.id,
    });
    provider = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    createTransferJobDto.providerId = provider.id;
  });

  afterEach(async () => {
    const merchantId = testMerchant.merchant.id;

    await transferJobRepository.delete({ providerId: provider.id });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId });
    await testApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
  });

  describe('when a user tries to create a new transfer job record', () => {
    it('then should return 401 status code if no credentials are provided', async () => {
      await request(app.getHttpServer()).post('/v2/transfer-jobs').expect(401);
    });

    it('then should return 404 status code if invalid apiKey is provided', async () => {
      await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', 'invalidApiKey')
        .expect(404);
    });

    it('then should fail with status 400 if required createTransferJobDto is missing', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send({});

      expect(response.statusCode).toBe(400);
    });

    it('then should fail with status 400 if invalid createTransferJobDto is given', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send({ invalidProperty: 1 });

      expect(response.statusCode).toBe(400);
    });

    it('then should create a transfer job if valid apiKey is provided', async () => {
      const { body } = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send(createTransferJobDto);

      expect(body.id).toBeDefined();
      expect(body.providerId).toEqual(createTransferJobDto.providerId);
      expect(body.startedAt).toEqual(createTransferJobDto.startedAt);
    });
  });

  describe('when a user tries to update an existing transfer job', () => {
    it('then should return 401 status code if no credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch('/v2/transfer-jobs/1')
        .expect(401);
    });

    it('then should return 404 status code if invalid apiKey is propvided', async () => {
      await request(app.getHttpServer())
        .patch('/v2/transfer-jobs/1')
        .set('X-API-KEY', 'invalidApiKey')
        .expect(404);
    });

    it("then shouldn't update the transfer job is an empty updateTransferJobDto is provided", async () => {
      const payload = {
        ...createTransferJobDto,
        jobId: 'UpdatedAWSBAtch',
      };
      const { body: createdTransferJob } = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send(payload);

      const { body: updatedTransferJob } = await request(app.getHttpServer())
        .patch(`/v2/transfer-jobs/${createdTransferJob.id}`)
        .set('X-API-KEY', apiKey);

      expect(createdTransferJob).toStrictEqual(updatedTransferJob);
    });

    it('then should fail with status 400 if invalid updateTransferJobDto is given', async () => {
      const response = await request(app.getHttpServer())
        .patch('/v2/transfer-jobs/1')
        .set('X-API-KEY', apiKey)
        .send({ invalidProperty: 1 });

      expect(response.statusCode).toBe(400);
    });

    it('then should update a transfer job if valid apiKey is provided', async () => {
      const totalCompleted = 10;
      const totalFailed = 7;
      const updatedJobId = 'updatedJobId';
      const { body: createdTransferJob } = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send(createTransferJobDto);

      const { body: updatedTransferJob } = await request(app.getHttpServer())
        .patch(`/v2/transfer-jobs/${createdTransferJob.id}`)
        .set('X-API-KEY', apiKey)
        .send({
          state: TransferJobState.STARTED,
          jobId: updatedJobId,
          totalCompleted,
          totalFailed,
        })
        .expect(200);

      expect(updatedTransferJob.state).toEqual(TransferJobState.STARTED);
      expect(updatedTransferJob.totalCompleted).toEqual(totalCompleted);
      expect(updatedTransferJob.totalFailed).toEqual(totalFailed);
      expect(updatedTransferJob.jobId).toEqual(updatedJobId);
    });

    it("then shouldn't update an optional property missing in the updateTransferJobDto", async () => {
      const { body: createdTransferJob } = await request(app.getHttpServer())
        .post('/v2/transfer-jobs')
        .set('X-API-KEY', apiKey)
        .send(createTransferJobDto);

      const startedAt = new Date().toISOString();
      const { body: updatedTransferJob } = await request(app.getHttpServer())
        .patch(`/v2/transfer-jobs/${createdTransferJob.id}`)
        .set('X-API-KEY', apiKey)
        .send({ state: TransferJobState.STARTED, startedAt })
        .expect(200);

      expect(updatedTransferJob.jobId).toEqual(createdTransferJob.jobId);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/accountStatementJobController.e2e-spec.ts
import * as request from 'supertest';
import { In, Repository } from 'typeorm';

import { app, connection } from '../../../app.setup';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

const baseAccountStatementJob = {
  endDate: new Date('2022-11-12T16:54:05.000Z'),
  startDate: new Date('2022-11-12T16:59:05.000Z'),
  state: AccountStatementJobState.STARTED,
  startedAt: new Date('2022-12-12T10:50:05.000Z'),
  endedAt: new Date('2022-12-12T10:55:05.000Z'),
  retrievedAt: new Date('2022-12-12T10:55:59.000Z'),
  totalRetrieved: 3,
  jobId: 'ABC123JobId',
  accountId: undefined,
};
const { endedAt, retrievedAt, totalRetrieved, jobId, ...rest } =
  baseAccountStatementJob;

const accountStatementJobDto = { ...rest };

describe('given an AccountStatementJobController', () => {
  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let merchant: MerchantEntity;
  let testApiKey: TestApiKeyUtil;

  let accountRepository: Repository<AccountEntity>;
  let accountStatementRepository: Repository<AccountStatementEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;

  let accountStatementJobService: AccountStatementJobService;

  beforeAll(async () => {
    accountStatementJobService = app.get(AccountStatementJobService);
    accountRepository = connection.getRepository(AccountEntity);
    accountStatementRepository = connection.getRepository(
      AccountStatementEntity,
    );
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    testApiKey = await createTestApiKey(merchant.id, UserRole.SUPER);

    account = await accountRepository.save({
      bankCode: BankCode.BANCO_SANTANDER,
      name: 'Nueva Cuenta',
      identifier: '1191239941',
      currency: Currency.CHILE,
      countryCode: CountryCode.CHILE,
      merchantId: merchant.id,
    });

    accountStatementJobDto.accountId = account.id;
    baseAccountStatementJob.accountId = account.id;
  });

  afterEach(async () => {
    const jobs = await accountStatementJobRepository.findBy({
      accountId: account.id,
    });

    const jobIds = jobs.map((job) => job.id);

    await accountStatementRepository.delete({
      accountStatementJobId: In(jobIds),
    });
    await accountStatementJobRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: merchant.id });
    await testApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
  });

  describe('when a user calls POST /v2/account-statement-jobs', () => {
    it('then return a new accountStatementjob record with required CreateAccountStatementJobDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/account-statement-jobs')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({ ...accountStatementJobDto });

      expect(response.statusCode).toBe(201);
      expect(response.body.id).toBeDefined();
    });
    it('then return a new accountStatementjob record with all CreateAccountStatementJobDto', async () => {
      const payload = { ...accountStatementJobDto, jobId };
      const response = await request(app.getHttpServer())
        .post('/v2/account-statement-jobs')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(payload);

      expect(response.statusCode).toBe(201);
      expect(response.body.id).toBeDefined();
    });

    it('then should fail with status 400 if required CreateAccountStatementJobDto is missing', async () => {
      const payload = { ...accountStatementJobDto };
      delete payload.accountId;
      const response = await request(app.getHttpServer())
        .post('/v2/account-statement-jobs')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send(payload);

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(1);
      expect(response.body.message).toEqual([
        'accountId must be a number conforming to the specified constraints',
      ]);
    });

    it('then should fail with status 400 if invalid CreateAccountStatementJobDto is given', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/account-statement-jobs')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({ ...baseAccountStatementJob, accountId: account.id });

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(3);
      expect(response.body.message).toEqual([
        'property endedAt should not exist',
        'property retrievedAt should not exist',
        'property totalRetrieved should not exist',
      ]);
    });
    it('then should fail with status 400 if invalid data is given', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/account-statement-jobs')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          ...accountStatementJobDto,
          jobId: 'ABC123JobI2',
          state: 'invalidState',
        });

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(1);
      expect(response.body.message).toEqual([
        'state must be a valid enum value',
      ]);
    });
  });

  describe('when a user calls PATCH /v2/account-statement-jobs', () => {
    it('then update account statement job with required PatchAccountStatementJobDto', async () => {
      const createdJob = await accountStatementJobService.create({
        ...accountStatementJobDto,
      });
      const response = await request(app.getHttpServer())
        .patch(`/v2/account-statement-jobs/${createdJob.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          state: AccountStatementJobState.FINISHED,
        });
      const updatedAccountStatementJob = response.body;

      expect(response.statusCode).toBe(200);
      expect(updatedAccountStatementJob.totalRetrieved).toBe(null);
      expect(updatedAccountStatementJob.state).toBe(
        AccountStatementJobState.FINISHED,
      );
      expect(updatedAccountStatementJob.retrievedAt).toStrictEqual(null);
      expect(updatedAccountStatementJob.endedAt).toStrictEqual(null);
    });
    it('then update account statement job with all PatchAccountStatementJobDto', async () => {
      const startDate = new Date('2022-11-12T20:54:05.000Z');
      const endDate = new Date('2022-11-12T20:59:05.000Z');
      const startedAt = new Date('2022-11-12T20:55:05.000Z');
      const createdJob = await accountStatementJobService.create({
        ...accountStatementJobDto,
      });

      const response = await request(app.getHttpServer())
        .patch(`/v2/account-statement-jobs/${createdJob.id}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          state: AccountStatementJobState.FINISHED,
          startDate,
          endDate,
          startedAt,
          endedAt,
          balance: 99999999,
          retrievedAt,
          jobId,
          totalRetrieved,
        });
      const accountStatementJobUpdated = response.body;

      expect(response.statusCode).toBe(200);
      expect(accountStatementJobUpdated).toMatchObject({
        state: AccountStatementJobState.FINISHED,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        balance: 99999999,
        retrievedAt: retrievedAt.toISOString(),
        endedAt: endedAt.toISOString(),
        startedAt: startedAt.toISOString(),
        totalRetrieved,
      });
    });

    it('then should fail with status 400 if required PatchAccountStatementJobDto is missing', async () => {
      const response = await request(app.getHttpServer())
        .patch('/v2/account-statement-jobs/3')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          endedAt,
          retrievedAt,
          jobId,
          totalRetrieved,
        });

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(2);
      expect(response.body.message).toEqual([
        'state should not be empty',
        'state must be a valid enum value',
      ]);
    });
    it('then should fail with status 400 if invalid PatchAccountStatementJobDto is given', async () => {
      const response = await request(app.getHttpServer())
        .patch('/v2/account-statement-jobs/3')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          state: AccountStatementJobState.FINISHED,
          endDate: baseAccountStatementJob.endDate,
          startDate: baseAccountStatementJob.startDate,
          startedAt: baseAccountStatementJob.startedAt,
          jobId: baseAccountStatementJob.jobId,
          accountId: account.id,
        });

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(1);
      expect(response.body.message).toEqual([
        'property accountId should not exist',
      ]);
    });

    it('then should fail with status 400 if invalid data is given', async () => {
      const response = await request(app.getHttpServer())
        .patch('/v2/account-statement-jobs/3')
        .set('X-API-KEY', testApiKey.mockData.key)
        .send({
          endedAt,
          retrievedAt,
          totalRetrieved,
          state: 'invalidState',
        });

      expect(response.statusCode).toBe(400);
      expect(response.body.message.length).toBe(1);
      expect(response.body.message).toEqual([
        'state must be a valid enum value',
      ]);
    });
  });
  describe('when a user calls GET /v2/account-statement-jobs?accountId=accountId', () => {
    it('then should set the pagination headers on the response', async () => {
      const response = await request(app.getHttpServer())
        .get('/v2/account-statement-jobs?accountId=0')
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      expect(response.headers['x-pagination-page']).toEqual('1');
      expect(response.headers['x-pagination-itemcount']).toEqual('0');
      expect(response.headers['x-pagination-limit']).toEqual('10');
      expect(response.headers['x-pagination-pagecount']).toEqual('0');
    });

    it('then should return last success account statement job from specified account', async () => {
      await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.FINISHED,
        jobId: 'ABC123JobId',
      });

      const lastAccountStatementJob = await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.FINISHED,
        jobId: 'ABC123JobIdLAST',
      });
      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statement-jobs?accountId=${account.id}&limit=1&sort=DESC&states[]=finished`,
        )
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      expect(response.body[0].jobId).toEqual(lastAccountStatementJob.jobId);
    });

    it('then should allow to filter account statement jobs by state', async () => {
      const finishedJob = await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.FINISHED,
        jobId: 'ABC123JobIdLAST',
      });

      const startedJob = await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.STARTED,
        jobId: 'ABC123JobIdLAST',
      });

      const response = await request(app.getHttpServer())
        .get(
          `/v2/account-statement-jobs?states[]=${AccountStatementJobState.FINISHED}`,
        )
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      expect(
        response.body.every(
          (item) => item.state === AccountStatementJobState.FINISHED,
        ),
      ).toBe(true);

      expect(response.body.some((item) => item.id === finishedJob.id)).toBe(
        true,
      );
      expect(response.body.some((item) => item.id === startedJob.id)).toBe(
        false,
      );
    });

    it('then should return an account statement jobs array ordered DESC', async () => {
      await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.FINISHED,
        jobId: '1235',
      });

      await accountStatementJobService.create({
        ...baseAccountStatementJob,
        accountId: account.id,
        state: AccountStatementJobState.FINISHED,
        jobId: '1234',
      });

      const response = await request(app.getHttpServer())
        .get('/v2/account-statement-jobs?sort=DESC')
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);

      const dates = response.body.map((item) => item.createdAt);
      const sortedDates = dates.sort((a, b) => (a > b ? -1 : 1));

      expect(dates).toEqual(sortedDates);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/payoutActionController.e2e-spec.ts
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import { UserRole } from 'src/common/enums/user-role.enum';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { Repository } from 'typeorm';
import { PayoutActionEntity } from 'src/models/payout-actions/entities/payout-action.entity';
import { PayoutAction } from 'src/common/enums/payout-action.enum';
import {
  MAPPED_ERROR_TYPE,
  TransferErrorCode,
} from 'src/models/transfer-error/error.definition.type';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('Given a PayoutAction Controller', () => {
  let testMerchant: TestMerchantUtil;
  let testUserAdmin: TestUserWithTokenUtil;
  let testUserSuper: TestUserWithTokenUtil;
  let payoutActionRepository: Repository<PayoutActionEntity>;
  let payoutActions: PayoutActionEntity[] = []; // Initial data

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testUserAdmin = await useTestUser(UserRole.ADMIN, true, {
      merchantId: testMerchant.merchant.id,
    });
    testUserSuper = await useTestUser(UserRole.SUPER, true, {
      merchantId: testMerchant.merchant.id,
    });
    payoutActionRepository = connection.getRepository(PayoutActionEntity);

    payoutActions = await payoutActionRepository.find();
    await payoutActionRepository.clear();
  });

  afterAll(async () => {
    await testUserAdmin.deleteUser();
    await testUserSuper.deleteUser();
    await payoutActionRepository.clear();
    await payoutActionRepository.save(payoutActions); // Restore initial data
  });

  describe('GET /v2/payout-actions', () => {
    it('should return 401 if no credentials are provided', async () => {
      await request(app.getHttpServer()).get('/v2/payout-actions').expect(401);
    });
    it('should return 403 when a user with invalid role', async () => {
      await request(app.getHttpServer())
        .get('/v2/payout-actions')
        .set('Authorization', `Bearer ${testUserAdmin.token}`)
        .expect(403);
    });
    it('should return 400 if invalid query is sent', async () => {
      await request(app.getHttpServer())
        .get('/v2/payout-actions?invalidProp=1')
        .set('Authorization', `Bearer ${testUserSuper.token}`)
        .expect(400);
    });
    it('should return 200 with the paginated payout actions', async () => {
      // Setup your test scenario here
      const targetErrorCode = TransferErrorCode.DESTINATION_BANK_TIMEOUT;
      await payoutActionRepository.save([
        {
          action: PayoutAction.AUTO_CANCEL,
          errorCode: TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
        },
        {
          action: PayoutAction.AUTO_RETRY,
          errorCode: targetErrorCode,
        },
      ]);

      // Test execution
      const response = await request(app.getHttpServer())
        .get('/v2/payout-actions')
        .set('Authorization', `Bearer ${testUserSuper.token}`)
        .expect(200);

      // Assertions
      const headers = response.headers;
      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();

      expect(response.body.length).toBeGreaterThan(0);

      const payoutAction = response.body.find(
        (payoutAction) => payoutAction.errorCode === targetErrorCode,
      );

      expect(payoutAction).toEqual(
        expect.objectContaining({
          id: expect.any(Number),
          uuid: expect.any(String),
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
          errorCode: targetErrorCode,
          action: PayoutAction.AUTO_RETRY,
          errorType: MAPPED_ERROR_TYPE[targetErrorCode],
          suggestion: null,
        }),
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/reconciliationController.e2e-spec.ts
import { Repository } from 'typeorm';
import * as moment from 'moment';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { TransferReconciliationService } from 'src/services/transfer-reconciliation/transfer-reconciliation.service';
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';

describe('Given a ReconciliationController', () => {
  const currentDate = new Date();

  let testMerchant: TestMerchantUtil;
  let testUserWithMFA: TestUserWithTokenUtil;
  let testUserSupportWithMFA: TestUserWithTokenUtil;
  let userWithForbiddenRole: string;
  let userSupportJWT: string;
  let account: AccountEntity;

  let accountRepository: Repository<AccountEntity>;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testUserWithMFA = await useTestUser(UserRole.USER, true, {
      merchantId: testMerchant.merchant.id,
    });
    testUserSupportWithMFA = await useTestUser(UserRole.SUPPORT, true, {
      merchantId: testMerchant.merchant.id,
    });

    userWithForbiddenRole = testUserWithMFA.token;
    userSupportJWT = testUserSupportWithMFA.token;

    accountRepository = connection.getRepository(AccountEntity);
    account = await accountRepository.save({
      name: 'Test account',
      identifier: '112312312-1',
      bankCode: BankCode.BANCO_SANTANDER,
      countryCode: CountryCode.CHILE,
      merchantId: testMerchant.merchant.id,
      state: State.ACTIVE,
    });
  });

  afterAll(async () => {
    await accountRepository.remove(account);
    await testUserSupportWithMFA.deleteUser();
    await testUserWithMFA.deleteUser();
    await testMerchant.deleteMerchant();
  });

  const startDate = moment(currentDate).startOf('day').toISOString();
  const endDate = moment(currentDate).add(2, 'days').endOf('day').toISOString();

  it('Then should return 401 status code if no credentials are provided', async () => {
    await request(app.getHttpServer()).get('/v2/reconciliations').expect(401);
  });
  it('Then should return 401 status code if invalid JWT is provided', async () => {
    await request(app.getHttpServer())
      .get('/v2/reconciliations')
      .set('Authorization', 'Bearer invalidJWT')
      .expect(401);
  });
  it('Then should return 404 status code if invalid apiKey is provided', async () => {
    await request(app.getHttpServer())
      .get('/v2/reconciliations')
      .set('x-api-key', 'invalidApiKey')
      .expect(404);
  });
  it('Then should return 403 status code if invalid user role is provided', async () => {
    await request(app.getHttpServer())
      .get('/v2/reconciliations')
      .set('Authorization', `Bearer ${userWithForbiddenRole}`)
      .expect(403);
  });
  it('Then should return 400 status code if an invalid DTO is provided', async () => {
    await request(app.getHttpServer())
      .get('/v2/reconciliations?invalidProp=invalid')
      .set('Authorization', `Bearer ${userSupportJWT}`)
      .expect(400);
  });
  it('Then should return 400 status code if invalid dates are provided', async () => {
    await request(app.getHttpServer())
      .get('/v2/reconciliations?startDate=date&endDate=date')
      .set('Authorization', `Bearer ${userSupportJWT}`)
      .expect(400);
  });
  it('Then should return 400 status code if invalid date range is provided', async () => {
    const startDate = new Date('2023-01-02').toISOString();
    const endDate = new Date('2023-01-01').toISOString();
    await request(app.getHttpServer())
      .get(`/v2/reconciliations?startDate=${startDate}&endDate=${endDate}`)
      .set('Authorization', `Bearer ${userSupportJWT}`)
      .expect(400);
  });
  it('Then should return 400 status code if date with invalid format are provided', async () => {
    await request(app.getHttpServer())
      .get(`/v2/reconciliations?startDate=2023-08-08&endDate=2023-08-09`)
      .set('Authorization', `Bearer ${userSupportJWT}`)
      .expect(400);
  });
  // TODO: Enable this when add the feature for request account statement for payouts v2
  it.skip('Then should return 200 status code with ', async () => {
    await request(app.getHttpServer())
      .get(`/v2/reconciliations?startDate=${startDate}&endDate=${endDate}`)
      .set('Authorization', `Bearer ${userSupportJWT}`)
      .expect(200);
  });
  it('Then should call the reconciliate method from TransferReconciliationService', async () => {
    const mock = jest.spyOn(
      TransferReconciliationService.prototype,
      'reconciliate',
    );
    await request(app.getHttpServer())
      .get(`/v2/reconciliations?startDate=${startDate}&endDate=${endDate}`)
      .set('Authorization', `Bearer ${userSupportJWT}`);

    expect(mock).toHaveBeenCalled();
    expect(mock).toHaveBeenCalledWith({ startDate, endDate });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/providerController.e2e-spec.ts
import * as request from 'supertest';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { app, connection } from 'test/app.setup';
import { changeEnv } from 'test/utils/testUtils';
import { In, Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { createTestApiKey, TestApiKeyUtil } from 'test/utils/apiKeyTestUtils';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { randUuid } from '@ngneat/falso';
import { UserEntity } from 'src/models/user/entities/user.entity';

const baseProvider = {
  name: 'Test Provider',
  credentials: { username: 'a', password: 'b' },
  rules: {},
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  providerType: ProviderType.ScraperCG,
  accountId: undefined,
};

const baseAccount = {
  state: State.ACTIVE,
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  merchantId: undefined,
};

const baseMerchant: Partial<MerchantEntity> = {
  name: 'Base Merchant',
  identifier: randUuid(),
};

describe('Given an ProviderController', () => {
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let apiKeyRepository: Repository<ApiKeyEntity>;
  let merchantRepository: Repository<MerchantEntity>;
  let userRepository: Repository<UserEntity>;

  let testSuperUser: TestUserWithTokenUtil;
  let testAdminUser: TestUserWithTokenUtil;
  let testApiKey: TestApiKeyUtil;
  let testMerchant: TestMerchantUtil;
  let testMerchant2: TestMerchantUtil;

  let apiKey: string;
  let jwtAdminToken: string;
  let jwtSuperToken: string;

  let accountId: number;
  let merchantId: number;

  beforeAll(async () => {
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    apiKeyRepository = connection.getRepository(ApiKeyEntity);
    merchantRepository = connection.getRepository(MerchantEntity);
    userRepository = connection.getRepository(UserEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    testMerchant2 = await createTestMerchant();

    merchantId = testMerchant.merchant.id;

    testApiKey = await createTestApiKey(merchantId);
    testSuperUser = await useTestUser(UserRole.SUPER, false, {
      merchantId,
    });
    testAdminUser = await useTestUser(UserRole.ADMIN, false, {
      merchantId,
    });

    apiKey = testApiKey.mockData.key;
    jwtAdminToken = testAdminUser.token;
    jwtSuperToken = testSuperUser.token;

    const accountOne = await accountRepository.save({
      ...baseAccount,
      merchantId,
    });
    accountId = accountOne.id;

    baseProvider.accountId = accountId;
  });

  afterEach(async () => {
    const merchantIds = [merchantId, testMerchant2.merchant.id];

    const merchantAccounts = await accountRepository.findBy({
      merchantId: In(merchantIds),
    });

    const accountIds = merchantAccounts.map((account) => account.id);

    await providerRepository.delete({
      accountId: In(accountIds),
    });

    await accountRepository.delete({
      merchantId: In(merchantIds),
    });

    await userRepository.delete({ merchantId: In(merchantIds) });
    await apiKeyRepository.delete({ merchantId: In(merchantIds) });
    await testMerchant.deleteMerchant();
    await testMerchant2.deleteMerchant();
  });

  describe('when a user calls GET /v2/accounts/:id/providers', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers`)
        .expect(401);
    });

    it('then should throw 403 status code if no merchantId its given', async () => {
      await apiKeyRepository.update(
        { id: testApiKey.apiKey.id },
        { merchantId: null },
      );

      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .expect(403);

      await apiKeyRepository.update(
        { id: testApiKey.apiKey.id },
        { merchantId },
      );
    });
    it('then should return an empty array if there is no provider for the merchant and account', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(0);
    });
    it("then shouldn't return a deleted provider", async () => {
      const deletedProvider = await providerRepository.save({
        ...baseProvider,
        deletedAt: new Date(),
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      const providers = response.body;

      expect(providers).not.toEqual(expect.arrayContaining([deletedProvider]));
    });
    it('then should return an array with providers filtered by name', async () => {
      const providerName = 'Shinkansen Provider';
      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider, name: providerName },
        { ...baseProvider, name: 'Test' },
      ]);

      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers?search=${providerName}`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].name).toEqual(providerName);
    });
    it('then should return an array with providers if no search value dto is given', async () => {
      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider },
        { ...baseProvider },
      ]);

      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers?search=`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(3);
    });
    it('then should return only the providers of merchant`s account that have a user with admin role', async () => {
      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider },
        { ...baseProvider },
      ]);
      let pageCount = 1;
      let page = 1;

      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get(`/v2/accounts/${accountId}/providers`)
          .set('Authorization', `Bearer ${jwtAdminToken}`)
          .expect(200);

        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const providers: ProviderEntity[] = response.body;
        expect(
          providers.every(
            (provider) => provider.account.merchantId === merchantId,
          ),
        ).toBeTruthy();
        page++;
      }
    });
    it('then should return only the providers of merchant`s account if the corresponding merchant id is provided', async () => {
      const otherMerchant = await merchantRepository.save({ ...baseMerchant });
      const otherAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: otherMerchant.id,
      });
      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider },
        { ...baseProvider, accountId: otherAccount.id },
      ]);
      let pageCount = 1;
      let page = 1;

      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get(`/v2/accounts/${accountId}/providers?merchantId=${merchantId}`)
          .set('Authorization', `Bearer ${jwtSuperToken}`)
          .expect(200);

        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const providers: ProviderEntity[] = response.body;
        expect(
          providers.every(
            (provider) => provider.account.merchantId === merchantId,
          ),
        ).toBeTruthy();
        page++;
      }
    });
  });

  describe('when a user calls GET /v2/providers', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).get(`/v2/providers`).expect(401);
    });
    it("then shouldn't return a deleted provider", async () => {
      const deletedProvider = await providerRepository.save({
        ...baseProvider,
        deletedAt: new Date(),
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/providers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      const providers = response.body;

      expect(providers).not.toEqual(expect.arrayContaining([deletedProvider]));
    });
    it("then should return an array of providers from the user's merchant if the user is admin", async () => {
      const accounts = await accountRepository.save([
        {
          ...baseAccount,
          merchantId,
        },
        {
          ...baseAccount,
          merchantId: testMerchant2.merchant.id,
        },
      ]);

      await providerRepository.save([
        { ...baseProvider, accountId: accounts[0].id },
        { ...baseProvider, accountId: accounts[1].id },
      ]);

      const response = await request(app.getHttpServer())
        .get(`/v2/providers`)
        .set('Authorization', `Bearer ${jwtAdminToken}`)
        .expect(200);

      expect(response.body).toHaveLength(1);
    });

    it('then should return an array providers from every merchant if the user is super', async () => {
      const accounts = await accountRepository.save([
        {
          ...baseAccount,
          merchantId,
        },
        {
          ...baseAccount,
          merchantId: testMerchant2.merchant.id,
        },
      ]);

      await providerRepository.save([
        { ...baseProvider, accountId: accounts[0].id },
        { ...baseProvider, accountId: accounts[1].id },
      ]);

      const response = await request(app.getHttpServer())
        .get(`/v2/providers`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(200);

      const accountIds = response.body.map((provider) => provider.accountId);
      expect(accountIds).toEqual(
        expect.arrayContaining([accounts[0].id, accounts[1].id]),
      );
    });
  });

  describe('when a user calls GET /v2/merchants/:id/providers', () => {
    let merchantIdTwo: number;

    beforeEach(async () => {
      merchantIdTwo = testMerchant2.merchant.id;
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/v2/merchants/${merchantIdTwo}/providers`)
        .expect(401);
    });
    it('then should return an empty array if there is no provider for the merchant', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/merchants/${merchantIdTwo}/providers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(0);
    });
    it('then should throw 403 status code if the user is trying to retrieve providers from another merchant', async () => {
      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider },
        { ...baseProvider, merchantId: merchantIdTwo },
      ]);

      // User belongs to merchant 2 and merchantId is equals to 1
      await request(app.getHttpServer())
        .get(`/v2/merchants/${merchantIdTwo}/providers`)
        .set('Authorization', `Bearer ${jwtAdminToken}`)
        .expect(403);
    });
    it("then should return an array with providers, even if the user doesn't belong to the merchant but has a super role", async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: merchantIdTwo,
      });

      await providerRepository.save([
        { ...baseProvider },
        { ...baseProvider },
        { ...baseProvider, accountId: newAccount.id },
      ]);

      // User belongs to merchant 1 and merchantId is equals to 2
      const response = await request(app.getHttpServer())
        .get(`/v2/merchants/${merchantIdTwo}/providers`)
        .set('Authorization', `Bearer ${testSuperUser.token}`)
        .expect(200);

      expect(response.body).toHaveLength(1);
    });
    it("then shouldn't return a deleted provider", async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId,
      });
      const deletedProvider = await providerRepository.save({
        ...baseProvider,
        deletedAt: new Date(),
        accountId: account.id,
      });

      const newApiKey = await createTestApiKey(merchantId);
      const response = await request(app.getHttpServer())
        .get(`/v2/merchants/${merchantId}/providers`)
        .set('X-API-KEY', newApiKey.mockData.key)
        .expect(200);
      const providers = response.body;

      expect(providers).not.toEqual(expect.arrayContaining([deletedProvider]));
    });

    it('then should return an array with providers that belongs to a merchant', async () => {
      const newMerchantId = testMerchant2.merchant.id;

      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: newMerchantId,
      });

      await providerRepository.save([
        { ...baseProvider, accountId: newAccount.id },
        { ...baseProvider, accountId: newAccount.id },
        { ...baseProvider, accountId: accountId },
      ]);

      const supportUser = await useTestUser(UserRole.SUPPORT, false, {
        merchantId: newMerchantId,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/merchants/${newMerchantId}/providers`)
        .set('Authorization', `Bearer ${supportUser.token}`)
        .expect(200);

      expect(response.body).toHaveLength(2);

      const accountIds = response.body.map((provider) => provider.accountId);
      const accounts = await accountRepository.findBy({ id: In(accountIds) });

      expect(
        accounts.every((account) => account.merchantId === newMerchantId),
      ).toBeTruthy();
    });
  });

  describe('when a user calls GET /accounts/:accountId/providers/:id', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers/1`)
        .expect(401);
    });
    it('then should throw 403 status code if no merchantId its given', async () => {
      await apiKeyRepository.update(
        { id: testApiKey.apiKey.id },
        { merchantId: null },
      );
      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers/1`)
        .set('X-API-KEY', apiKey)
        .expect(403);
      await apiKeyRepository.update(
        { id: testApiKey.apiKey.id },
        { merchantId },
      );
    });
    it('then should throw 404 status code if the provider is not found', async () => {
      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers/9999999`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
    it('then should throw 403 status code if the account does not belong to the merchant', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant2.merchant.id,
      });
      await request(app.getHttpServer())
        .get(`/v2/accounts/${newAccount.id}/providers/1`)
        .set('X-API-KEY', apiKey)
        .expect(403);
    });
    it("then shouldn't return a deleted provider", async () => {
      const provider = await providerRepository.save({
        ...baseProvider,
        deletedAt: new Date(),
      });

      await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers/${provider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
    it('then should return a provider', async () => {
      const newProvider = await providerRepository.save({ ...baseProvider });

      const response = await request(app.getHttpServer())
        .get(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(200);
      const provider = response.body;
      expect(provider.id).toBeDefined();
      expect(provider.credentials).toBeUndefined();
    });
  });

  describe('When a user call GET /providers/:id', () => {
    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).get(`/v2/providers/1`).expect(401);
    });
    it('then should return 404 status code if the provider does not exists', async () => {
      await request(app.getHttpServer())
        .get(`/v2/providers/12130123001`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
    it('then should return 404 status code if the provider does not belong to the merchant', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant2.merchant.id,
      });

      const provider = await providerRepository.save({
        ...baseProvider,
        accountId: account.id,
      });

      await request(app.getHttpServer())
        .get(`/v2/providers/${provider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
  });

  describe('when a user calls POST /providers', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .expect(401);
    });
    it('then should fail if invalid dto is provided', async () => {
      await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .expect(400);
    });
    it('then should fail if empty dto is provided', async () => {
      await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .send({})
        .expect(400);
    });
    it('should throw 403 status code if the account does not belong to the merchant', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant2.merchant.id,
      });
      const createProviderDto = baseProvider;
      await request(app.getHttpServer())
        .post(`/v2/accounts/${newAccount.id}/providers`)
        .set('X-API-KEY', apiKey)
        .send(createProviderDto)
        .expect(403);
    });
    it('then should fail if the name provided is too long', async () => {
      const createProviderDto = {
        ...baseProvider,
        name: 'a'.repeat(130),
      };
      await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .send(createProviderDto)
        .expect(400);
    });
    it('then should return 400 status code for "thomas" as providerType on production environment', async () => {
      changeEnv(Environment.PRODUCTION);

      const createProviderDto = {
        ...baseProvider,
        providerType: ProviderType.Thomas,
      };

      await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .send(createProviderDto)
        .expect(400);

      changeEnv(Environment.TEST);
    });
    it('then create a new provider', async () => {
      const createProviderDto = baseProvider;

      const response = await request(app.getHttpServer())
        .post(`/v2/accounts/${accountId}/providers`)
        .set('X-API-KEY', apiKey)
        .send(createProviderDto)
        .expect(201);

      const provider = response.body;
      expect(provider.id).toBeDefined();
    });
  });

  describe('when a user calls PATCH /providers/:id', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/1`)
        .expect(401);
    });
    it('then should throw 404 if the provider is not found', async () => {
      const updateProviderDto = { state: State.ACTIVE };
      await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/0`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(404);
    });
    it('should throw 403 if the account does not belong to the merchant', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant2.merchant.id,
      });
      const updateProviderDto = { state: State.ACTIVE };
      await request(app.getHttpServer())
        .patch(`/v2/accounts/${newAccount.id}/providers/1`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(403);
    });
    it('then should fail if the name provided is too long', async () => {
      const updateProviderDto = {
        name: 'a'.repeat(130),
      };
      await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/1`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(400);
    });
    it("then shouldn't update a deleted provider", async () => {
      const provider = await providerRepository.save({
        ...baseProvider,
        deletedAt: new Date(),
      });

      await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${provider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
    it("then shouldn't allow to update to the 'deleted' state", async () => {
      const provider = await providerRepository.save({
        ...baseProvider,
        state: State.ACTIVE,
      });

      const updateProviderDto = { state: State.DELETED };

      await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${provider.id}`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(422);
    });
    it('then should update the provider priority', async () => {
      const newProvider = await providerRepository.save({
        ...baseProvider,
        priority: 1,
      });
      const updateProviderDto = {
        priority: 2,
      };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(200);

      const provider = response.body;

      expect(provider).toBeDefined();
      expect(provider.priority).toEqual(2);
    });
    it('then should accept to update the provider rules', async () => {
      const newProvider = await providerRepository.save({
        ...baseProvider,
        priority: 1,
      });
      const updateProviderDto = {
        rules: {
          type: 'currency',
          value: 'cop',
          operator: 'limit',
        },
      };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(200);

      const provider = response.body;

      expect(provider).toBeDefined();
      expect(provider.rules).toEqual(updateProviderDto.rules);
    });
    it('then should update the provider', async () => {
      const newProvider = await providerRepository.save({
        ...baseProvider,
        state: State.INACTIVE,
      });

      const updateProviderDto = {
        state: State.ACTIVE,
      };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(200);
      const provider = response.body;

      expect(provider).toBeDefined();
      expect(provider.state).toEqual(State.ACTIVE);
    });
    it('then should allow to update the provider capability', async () => {
      const newProvider = await providerRepository.save({
        ...baseProvider,
        capabilities: [ProviderCapability.READ_TRANSFER],
      });
      const updateProviderDto = {
        capabilities: [ProviderCapability.CREATE_TRANSFER],
      };

      const response = await request(app.getHttpServer())
        .patch(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .send(updateProviderDto)
        .expect(200);

      const provider = response.body;

      expect(provider).toBeDefined();
      expect(provider.capabilities).toEqual([
        ProviderCapability.CREATE_TRANSFER,
      ]);
    });
  });

  describe('when a user calls DELETE /providers/:id', () => {
    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/accounts/${accountId}/providers/1`)
        .expect(401);
    });
    it('then should throw 404 if the provider is not found', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/accounts/${accountId}/providers/99999999999`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });
    it('should throw 403 if the provider does not belong to the merchant', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        merchantId: testMerchant2.merchant.id,
      });

      await request(app.getHttpServer())
        .delete(`/v2/accounts/${newAccount.id}/providers/1`)
        .set('X-API-KEY', apiKey)
        .expect(403);
    });
    it('then should remove the provider', async () => {
      const newProvider = await providerRepository.save({ ...baseProvider });

      await request(app.getHttpServer())
        .delete(`/v2/accounts/${accountId}/providers/${newProvider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      const deletedProvider = await providerRepository.findOne({
        where: { id: newProvider.id },
        withDeleted: true,
      });

      expect(deletedProvider.deletedAt).not.toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/apiKeyController.e2e-spec.ts
import * as request from 'supertest';
import { app } from '../../../app.setup';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { UserRole } from 'src/common/enums/user-role.enum';
import { State } from 'src/common/enums/state.enum';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { ApiKeyService } from 'src/models/apikey/apikey.service';
import { CreatedApiKeyDto } from 'src/models/apikey/dto/created-apikey.dto';

const baseApiKey: Partial<ApiKeyEntity> = {
  name: 'api-key-name',
  state: State.ACTIVE,
  merchantId: undefined,
  role: UserRole.SUPER,
};

describe('Given an ApiKeyController', () => {
  let testMerchant: TestMerchantUtil;
  let testUserWithToken: TestUserWithTokenUtil;

  let merchant: MerchantEntity;
  let apiKeyService: ApiKeyService;
  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    baseApiKey.merchantId = merchant.id;
    testUserWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: merchant.id,
    });
    apiKeyService = app.get(ApiKeyService);
  });

  afterAll(async () => {
    await testUserWithToken.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('when a user calls GET /v2/api-keys', () => {
    describe('when a user using JWT MFA strategy calls GET /v2/api-keys', () => {
      it('should return the paginated API Keys if valid credentials are provided', async () => {
        const response = await request(app.getHttpServer())
          .get('/v2/api-keys')
          .set('Authorization', `Bearer ${testUserWithToken.token}`)
          .expect(200);

        const headers = response.headers;

        expect(
          headers[PaginationHeader.PAGE.toLocaleLowerCase()],
        ).toBeDefined();
        expect(
          headers[PaginationHeader.LIMIT.toLocaleLowerCase()],
        ).toBeDefined();
        expect(
          headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
        ).toBeDefined();
        expect(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        ).toBeDefined();
      });
      it('should return only the merchant api keys that have a user with admin role', async () => {
        const testAdminUserWithToken = await useTestUser(
          UserRole.ADMIN,
          false,
          {
            merchantId: merchant.id,
          },
        );
        const otherMerchant = await createTestMerchant();
        const otherApiKey = await createTestApiKey(otherMerchant.merchant.id);
        let pageCount = 1;
        let page = 1;

        while (page <= pageCount) {
          const response = await request(app.getHttpServer())
            .get(`/v2/api-keys?page=${page}`)
            .set('Authorization', `Bearer ${testAdminUserWithToken.token}`)
            .expect(200);
          const headers = response.headers;
          pageCount = Number(
            headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
          );
          const apiKeys: ApiKeyEntity[] = response.body;
          expect(
            apiKeys.every(
              (apiKey) => apiKey.merchantId === testMerchant.merchant.id,
            ),
          ).toBeTruthy();
          expect(apiKeys).not.toEqual(expect.arrayContaining([otherApiKey]));
          page++;
        }
        await testAdminUserWithToken.deleteUser();
        otherApiKey.deleteApiKey();
        otherMerchant.deleteMerchant();
      });
      it('should return only merchant api keys if the corresponding merchant id is provided', async () => {
        const otherApiKey = await createTestApiKey(merchant.id);
        let pageCount = 1;
        let page = 1;

        while (page <= pageCount) {
          const response = await request(app.getHttpServer())
            .get(`/v2/api-keys?page=${page}&merchantId=${merchant.id}`)
            .set('Authorization', `Bearer ${testUserWithToken.token}`)
            .expect(200);
          const headers = response.headers;
          pageCount = Number(
            headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
          );
          const apiKeys: ApiKeyEntity[] = response.body;
          expect(
            apiKeys.every((apiKey) => apiKey.merchantId === merchant.id),
          ).toBeTruthy();
          page++;
        }
        await otherApiKey.deleteApiKey();
      });
    });
  });
  describe('when a use POST /v2/api-keys', () => {
    it('should return the API Key dto', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/api-keys')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .send({ name: 'super@test.local', merchantId: merchant.id })
        .expect(201);

      const apiKeyCretedDto = response.body as CreatedApiKeyDto;
      await request(app.getHttpServer())
        .get('/v2/api-keys')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);
      await apiKeyService.remove(apiKeyCretedDto.id);
    });
    it('should return 401 if not send valid token', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/api-keys')
        .send({ merchantId: merchant.id });
      expect(response.status).toBe(401);
    });
    it('should return 403 if user is not Super', async () => {
      const invalidsRoles = [UserRole.USER, UserRole.ADMIN, UserRole.SUPPORT];
      for (const role of invalidsRoles) {
        const invalidRoleUser = await useTestUser(role, false, {
          merchantId: merchant.id,
        });
        const response = await request(app.getHttpServer())
          .post('/v2/api-keys')
          .set('Authorization', `Bearer ${invalidRoleUser.token}`)
          .send({ name: 'super@test.local', merchantId: merchant.id });
        expect(response.status).toBe(403);
        await invalidRoleUser.deleteUser();
      }
    });
  });

  describe('when a use PATCH /v2/api-keys', () => {
    it('should return the updatedApiKeyDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/api-keys')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .send({ name: 'super@test.local', merchantId: merchant.id })
        .expect(201);

      const apiKeyCretedDto = response.body as CreatedApiKeyDto;
      await request(app.getHttpServer())
        .patch(`/v2/api-keys/${apiKeyCretedDto.id}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .send({ name: 'someName', state: State.INACTIVE })
        .expect(200);
      await apiKeyService.remove(apiKeyCretedDto.id);
    });
    it('should return 401 if not send valid token', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/api-keys')
        .send({ merchantId: merchant.id });
      expect(response.status).toBe(401);
    });
    it('should return 403 if user is not Super', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/api-keys')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .send({ name: 'super@test.local', merchantId: merchant.id })
        .expect(201);

      const apiKeyCretedDto = response.body as CreatedApiKeyDto;

      const invalidsRoles = [UserRole.USER, UserRole.ADMIN, UserRole.SUPPORT];
      for (const role of invalidsRoles) {
        const invalidRoleUser = await useTestUser(role, false, {
          merchantId: merchant.id,
        });
        const response = await request(app.getHttpServer())
          .patch(`/v2/api-keys/${apiKeyCretedDto.id}`)
          .set('Authorization', `Bearer ${invalidRoleUser.token}`)
          .send({ name: 'super@test.local', merchantId: merchant.id });
        expect(response.status).toBe(403);
        await invalidRoleUser.deleteUser();
      }
      await apiKeyService.remove(apiKeyCretedDto.id);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/concurrent/payoutManagementController.concurrent.e2e-spec.ts
import { Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

import * as request from 'supertest';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { app, connection } from 'test/app.setup';

const createPayoutDto = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  currency: Currency.CHILE,
  trackingCode: 'OperablePayout',
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
  state: PayoutState.PROCESSING,
};

const createTransferDto: Partial<TransferEntity> = {
  amount: 1000,
  concept: 'Authorizing transfer',
  currency: Currency.CHILE,
  destinationAccount: '268784803',
  destinationBankCode: 'cl_banco_bice',
  destinationPhone: '1234456434',
  destinationHolderId: '268784803',
  destinationName: 'Antonia Flores',
  state: TransferState.FAILED,
  trackingCode: '12312312',
  version: EntityVersion.v2,
};

const createAccountDto = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  state: State.ACTIVE,
};

const baseProvider = {
  name: 'Test Provider',
  credentials: { username: 'a', password: 'b' },
  rules: {},
  providerType: ProviderType.Shinkansen,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  state: State.ACTIVE,
  accountId: null,
};

describe('given ManagementController v2', () => {
  let testMerchant: TestMerchantUtil;
  let testUserSuperWithToken: TestUserWithTokenUtil;
  let testUserSupportWithToken: TestUserWithTokenUtil;

  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let eventEmitterSpy: jest.SpyInstance;

  let provider: ProviderEntity;
  let account: AccountEntity;
  let payout: PayoutEntity;
  let transfer: TransferEntity;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testUserSuperWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });
    testUserSupportWithToken = await useTestUser(UserRole.SUPPORT, false, {
      merchantId: testMerchant.merchant.id,
    });

    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  afterAll(async () => {
    await accountRepository.delete(account.id);
    await testUserSuperWithToken.deleteUser();
    await testUserSupportWithToken.deleteUser();
    await testMerchant.deleteMerchant();
    eventEmitterSpy.mockRestore();
  });

  beforeEach(async () => {
    const eventEmitter = app.get(EventEmitter2);
    eventEmitterSpy = jest
      .spyOn(eventEmitter, 'emit')
      .mockImplementation(() => {
        return true;
      });
    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: testMerchant.merchant.id,
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchant.id,
    });
    baseProvider.accountId = account.id;

    provider = await providerRepository.save(baseProvider);

    createTransferDto.providerId = provider.id;
    createTransferDto.payoutId = payout.id;
    transfer = await transferRepository.save({
      ...createTransferDto,
      merchantId: testMerchant.merchant.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete({ id: payout.id });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ id: account.id });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/cancel', () => {});

  describe('When a user using call the endpoint PATCH /payouts/:id/complete', () => {});

  describe('When a user using call the endpoint PATCH /payouts/:id/reassign', () => {
    describe('when using new reassing flow', () => {
      let anotherProvider: ProviderEntity;

      beforeEach(async () => {
        await payoutRepository.update(payout.id, {
          state: PayoutState.PROCESSING,
        });
        await transferRepository.update(
          { payoutId: payout.id, providerId: provider.id },
          {
            state: TransferState.FAILED,
          },
        );
        const anotherBaseProvider = {
          ...baseProvider,
          name: 'Test another Provider',
        };
        anotherProvider = await providerRepository.save(anotherBaseProvider);
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION
      });

      afterEach(async () => {
        await transferRepository.delete({ payoutId: payout.id });
        await payoutRepository.delete({ id: payout.id });
        await providerRepository.delete({ id: anotherProvider.id });
      });

      it.only('then handle concurrent', async () => {
        const cancelationRequest = request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/cancel`)
          .send({ transferId: transfer.id })
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`);

        const reassignationRequest = request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
          .send({ providerId: anotherProvider.id });

        const [cancelationResponse, reassignationResponse] = await Promise.all([
          cancelationRequest,
          reassignationRequest,
        ]);

        expect(cancelationResponse.status).toBe(200);
        expect(reassignationResponse.status).toBe(422);
      });
    });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/retry', () => {
    beforeEach(async () => {
      await payoutRepository.update(payout.id, {
        state: PayoutState.PROCESSING,
      });
      await transferRepository.update(
        { payoutId: payout.id },
        {
          state: TransferState.FAILED,
        },
      );
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch('/v2/management/payouts/1/retry')
        .expect(401);
    });

    it('then should 200 if Role is Super ', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/management/payouts/${payout.id}/retry`)
        .set('Authorization', `Bearer ${testUserSuperWithToken.token}`);
    });

    it('then should 200 if Role is Support', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/management/payouts/${payout.id}/retry`)
        .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
        .expect(200);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/providerWebhooksController.e2e-spec.ts
import * as supertest from 'supertest';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ConfigService } from '@nestjs/config';
import { generatePayloadSignature } from 'src/utils/secrets.util';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

describe('Given a ProviderWebhooksController', () => {
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;

  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;
  let shinkansenProvider: ProviderEntity;
  let liquidoProvider: ProviderEntity;

  const trackingCode = 'providerWebhooks';

  let testMerchant: TestMerchantUtil;
  let merchantId: number;
  let hmacToken: string;

  const baseShinkansenProvider = {
    credentials: {
      webhookCertificate: 'certificate',
      apiUrl: 'https://dev.shinkansen.finance/v1',
      apiKey: 'bukApiKey',
      certificate: 'bukCertificate',
      privateKey: 'bukPrivateKey',
      name: 'Buk Spa',
      email: 'buk@buk.cl',
      holderId: '76691442k',
      senderId: 'BUK',
      bankCode: 'cl_banco_bice',
      account: '60000007',
    },
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    rules: {},
    name: 'Shinkansen Test',
    providerType: ProviderType.Shinkansen,
    state: State.ACTIVE,
  };

  const baseLiquidoProvider = {
    credentials: {
      authUrl: 'LiquidoauthUrl',
      baseUrl: 'LiquidobaseUrl',
      clientId: 'LiquidoclientId',
      clientSecret: 'LiquidoclientSecret',
      apiKey: 'LiquidoapiKey',
    },
    rules: {},
    name: 'Liquido Test',
    providerType: ProviderType.Liquido,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    state: State.ACTIVE,
  };

  const createPayoutDto: Partial<CreatePayoutDto> = {
    amount: 1001,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto: Partial<CreateTransferDto> = {
    amount: 100,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode,
    destinationHolderId: '120123123',
    destinationName: 'oblandon',
    destinationAccount: '1201231',
    destinationBankCode: 'cl_banco_falabella',
    destinationPhone: '001239912312',
    payoutId: undefined,
    providerId: undefined,
    version: EntityVersion.v2,
    state: TransferState.ASSIGNED,
  };

  const createAccountDto: Partial<CreateAccountDto> = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    state: State.ACTIVE,
  };
  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    providerType: ProviderType.ScraperPW,
    accountId: undefined,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    priority: 1,
    state: State.ACTIVE,
  };

  beforeAll(async () => {
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);

    hmacToken = app.get(ConfigService).get<string>('scraper.token');
  });

  beforeEach(async () => {
    jest
      .spyOn(TransferProviderService.prototype, 'updatePayoutState')
      .mockImplementation((_transferUpdatedDto) =>
        Promise.resolve({} as PayoutEntity),
      );

    jest
      .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
      .mockReturnValue(Promise.resolve(false)); // FEATURE FLAG CAN USE NEW PAYOUT CREATION

    testMerchant = await createTestMerchant();
    merchantId = testMerchant.merchant.id;

    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId,
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId,
    });

    provider = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    shinkansenProvider = await providerRepository.save({
      ...baseShinkansenProvider,
      accountId: account.id,
    });

    liquidoProvider = await providerRepository.save({
      ...baseLiquidoProvider,
      accountId: account.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ merchantId });
    await providerRepository.delete({ accountId: account.id });
    await payoutRepository.delete({ merchantId });
    await accountRepository.delete({ merchantId });
    await testMerchant.deleteMerchant();
  });

  // TODO: When PYT-909 is finished, add missing test for complete transaction using new complete payout method
  describe('when a user calls POST /api/v2/providers/:providerId/scrapers/updates', () => {
    it('then should return 404 status code if the transfer does not exists', async () => {
      const payload = {
        transferId: 120021221209,
        state: TransferState.COMPLETED,
      };
      const signature = generatePayloadSignature(payload, hmacToken);

      await supertest(app.getHttpServer())
        .post(`/v2/providers/${provider.id}/scrapers/updates`)
        .set('x-payouts-signature', signature)
        .send(payload)
        .expect(404);
    });
    it('then should return 404 status code if the transfer entity version is not v2', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        version: EntityVersion.v1,
        merchantId,
      });

      const payload = {
        transferId: transfer.id,
        state: TransferState.ASSIGNED,
      };
      const signature = generatePayloadSignature(payload, hmacToken);

      await supertest(app.getHttpServer())
        .post(`/v2/providers/${provider.id}/scrapers/updates`)
        .set('x-payouts-signature', signature)
        .send(payload)
        .expect(404);
    });
    it('then should return 403 status code if an invalid signature is provided', async () => {
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${provider.id}/scrapers/updates`)
        .set('x-payouts-signature', 'signature')
        .send({ transferId: 1 })
        .expect(403);
    });
    it('then should update the transaction with the provider data', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        merchantId,
      });

      const payload = {
        transferId: transfer.id,
        state: TransferState.COMPLETED,
      };
      const signature = generatePayloadSignature(payload, hmacToken);

      const response = await supertest(app.getHttpServer())
        .post(`/v2/providers/${provider.id}/scrapers/updates`)
        .set('x-payouts-signature', signature)
        .send(payload)
        .expect(200);

      const updatedTransaction = response.body;
      expect(updatedTransaction).toBeDefined();
      expect(updatedTransaction.state).toEqual(TransferState.COMPLETED);
      expect(updatedTransaction.id).toEqual(transfer.id);
      expect(updatedTransaction.amount).toEqual(transfer.amount);
      expect(updatedTransaction.destinationName).toEqual(
        transfer.destinationName,
      );
      expect(updatedTransaction.destinationEmail).toEqual(
        transfer.destinationEmail,
      );
      expect(updatedTransaction.destinationHolderId).toEqual(
        transfer.destinationHolderId,
      );
      expect(updatedTransaction.currency).toEqual(transfer.currency);
      expect(updatedTransaction.providerId).toEqual(transfer.providerId);
    });
  });

  describe('when a user calls POST /api/v2/providers/webhooks/shinkansen', () => {
    it('then should return 403 status code if invalid header key is provided', async () => {
      await supertest(app.getHttpServer())
        .post(`/v2/providers/webhooks/shinkansen`)
        .expect(403);
    });

    it('then should return 400 status code if the payload is incorrect', async () => {
      // expect bad request with message 'Invalid payload'

      jest
        .spyOn(ShinkansenProvider.prototype, 'validateSignature')
        .mockReturnValue(Promise.resolve(true));
      const response = await supertest(app.getHttpServer())
        .post(`/v2/providers/webhooks/shinkansen`)
        .set('shinkansen-jws-signature', 'signature')
        .send({ id: 100 });

      expect(response.status).toBe(400);
      expect(response.body.message).toBe('Invalid payload');
    });

    it('then should return 200 status code if the payload is correct', async () => {
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.PROCESSING,
        providerId: shinkansenProvider.id,
        externalId: '53c773c1-6fe8-452e-b4a1-0c0e2d0b1eb9',
        merchantId,
      });

      const spy = jest
        .spyOn(ShinkansenProvider.prototype, 'validateSignature')
        .mockReturnValue(Promise.resolve(true));

      await supertest(app.getHttpServer())
        .post(`/v2/providers/webhooks/shinkansen`)
        .set('shinkansen-jws-signature', 'signature')
        .send({
          document: {
            header: {
              creation_date: '2023-03-16T18:29:15Z',
              message_id: 'd632a0e6-3682-4dcd-bca5-323b1c646010',
              receiver: { fin_id: 'BUK', fin_id_schema: 'SHINKANSEN' },
              sender: { fin_id: 'SHINKANSENsdsd', fin_id_schema: 'SHINKANSEN' },
              shinkansen_message_id: '1b3e3b1a-8875-42f1-9d26-8d05a7c2a6fe',
            },
            responses: [
              {
                response_id: 'ec7fcad2-7121-4541-8632-758e4952be6a',
                response_message: '',
                response_status: 'ok',
                shinkansen_transaction_id:
                  '53c773c1-6fe8-452e-b4a1-0c0e2d0b1eb9',
                shinkansen_transaction_message: '',
                shinkansen_transaction_status: 'ok',
                transaction_id: '7e559a1d-385b-40e1-a058-2b05da80b462',
                transaction_type: 'payout',
              },
            ],
          },
        })
        .expect(200);
    });
  });

  describe('when a user calls POST /api/v2/providers/:id/shinkansen/updates', () => {
    it('then should return 403 status code if invalid header key is provided', async () => {
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${shinkansenProvider.id}/shinkansen/updates`)
        .expect(403);
    });
    it('then should return 400 status code if the payload is incorrect', async () => {
      jest
        .spyOn(ShinkansenProvider.prototype, 'validateSignature')
        .mockReturnValue(Promise.resolve(true));
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${shinkansenProvider.id}/shinkansen/updates`)
        .set('shinkansen-jws-signature', 'signature')
        .send({ id: 100 })
        .expect(400);
    });
    it('then should return 200 status code if the payload is correct', async () => {
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.PROCESSING,
        providerId: shinkansenProvider.id,
        externalId: '53c773c1-6fe8-452e-b4a1-0c0e2d0b1eb9',
        merchantId,
      });

      const spy = jest
        .spyOn(ShinkansenProvider.prototype, 'validateSignature')
        .mockReturnValue(Promise.resolve(true));
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${shinkansenProvider.id}/shinkansen/updates`)
        .set('shinkansen-jws-signature', 'signature')
        .send({
          document: {
            header: {
              creation_date: '2023-03-16T18:29:15Z',
              message_id: 'd632a0e6-3682-4dcd-bca5-323b1c646010',
              receiver: { fin_id: 'BUK', fin_id_schema: 'SHINKANSEN' },
              sender: { fin_id: 'SHINKANSENsdsd', fin_id_schema: 'SHINKANSEN' },
              shinkansen_message_id: '1b3e3b1a-8875-42f1-9d26-8d05a7c2a6fe',
            },
            responses: [
              {
                response_id: 'ec7fcad2-7121-4541-8632-758e4952be6a',
                response_message: '',
                response_status: 'ok',
                shinkansen_transaction_id:
                  '53c773c1-6fe8-452e-b4a1-0c0e2d0b1eb9',
                shinkansen_transaction_message: '',
                shinkansen_transaction_status: 'ok',
                transaction_id: '7e559a1d-385b-40e1-a058-2b05da80b462',
                transaction_type: 'payout',
              },
            ],
          },
        })
        .expect(200);
    });
  });
  describe('when a user calls POST /api/v2/providers/:id/liquido/updates', () => {
    it('then should return 400 status code if payload is invalid', async () => {
      const spy = jest
        .spyOn(LiquidoProviderAdapter.prototype, 'verifySignature')
        .mockReturnValue(Promise.resolve(true));
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${liquidoProvider.id}/liquido/updates`)
        .set(
          'liquido-signature',
          'algorithm=HmacSHA256,timestamp={{timestamp_in_seconds}},signature={{signature}}',
        )
        .expect(400);
    });
    it('then should return 400 status code if payload is correct but transfer not found', async () => {
      const spy = jest
        .spyOn(LiquidoProviderAdapter.prototype, 'verifySignature')
        .mockReturnValue(Promise.resolve(true));
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${liquidoProvider.id}/liquido/updates`)
        .send({
          transferStatus: 'SETTLED',
          idempotencyKey: 'transfer.externalId',
        })
        .set(
          'liquido-signature',
          'algorithm=HmacSHA256,timestamp={{timestamp_in_seconds}},signature={{signature}}',
        )
        .expect(400);
    });
    it('then should return 200 status code if payload is correct and transfer is updated', async () => {
      const spy = jest
        .spyOn(LiquidoProviderAdapter.prototype, 'verifySignature')
        .mockReturnValue(Promise.resolve(true));
      const transfer: TransferEntity = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: liquidoProvider.id,
        state: TransferState.PROCESSING,
        externalId: 'string',
        version: EntityVersion.v2,
        merchantId,
      });
      await supertest(app.getHttpServer())
        .post(`/v2/providers/${liquidoProvider.id}/liquido/updates`)
        .send({
          transferStatus: 'SETTLED',
          idempotencyKey: transfer.externalId,
        })
        .set(
          'liquido-signature',
          'algorithm=HmacSHA256,timestamp={{timestamp_in_seconds}},signature={{signature}}',
        )
        .expect(200);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/managementController.e2e-spec.ts
import { Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

import * as request from 'supertest';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { PayoutManagementService } from 'src/services/payout-management/payout-management.service';
import { app, connection } from 'test/app.setup';

const createPayoutDto = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  currency: Currency.CHILE,
  trackingCode: 'OperablePayout',
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
  state: PayoutState.PROCESSING,
};

const createTransferDto: Partial<TransferEntity> = {
  amount: 1000,
  concept: 'Authorizing transfer',
  currency: Currency.CHILE,
  destinationAccount: '268784803',
  destinationBankCode: 'cl_banco_bice',
  destinationPhone: '1234456434',
  destinationHolderId: '268784803',
  destinationName: 'Antonia Flores',
  state: TransferState.FAILED,
  trackingCode: '12312312',
  version: EntityVersion.v2,
};

const createAccountDto = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  state: State.ACTIVE,
};

const baseProvider = {
  name: 'Test Provider',
  credentials: { username: 'a', password: 'b' },
  rules: {},
  providerType: ProviderType.Shinkansen,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  state: State.ACTIVE,
  accountId: null,
};

describe('given ManagementController v2', () => {
  let testMerchant: TestMerchantUtil;
  let testUserSuperWithToken: TestUserWithTokenUtil;
  let testUserSupportWithToken: TestUserWithTokenUtil;

  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let eventEmitterSpy: jest.SpyInstance;

  let provider: ProviderEntity;
  let account: AccountEntity;
  let payout: PayoutEntity;
  let transfer: TransferEntity;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testUserSuperWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });
    testUserSupportWithToken = await useTestUser(UserRole.SUPPORT, false, {
      merchantId: testMerchant.merchant.id,
    });

    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  afterAll(async () => {
    await accountRepository.delete(account.id);
    await testUserSuperWithToken.deleteUser();
    await testUserSupportWithToken.deleteUser();
    await testMerchant.deleteMerchant();
    eventEmitterSpy.mockRestore();
  });

  beforeEach(async () => {
    const eventEmitter = app.get(EventEmitter2);
    eventEmitterSpy = jest
      .spyOn(eventEmitter, 'emit')
      .mockImplementation(() => {
        return true;
      });
    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: testMerchant.merchant.id,
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchant.id,
    });
    baseProvider.accountId = account.id;

    provider = await providerRepository.save(baseProvider);

    createTransferDto.providerId = provider.id;
    createTransferDto.payoutId = payout.id;
    transfer = await transferRepository.save({
      ...createTransferDto,
      merchantId: testMerchant.merchant.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete({ id: payout.id });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ id: account.id });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/cancel', () => {
    describe('when using old cancel flow', () => {
      beforeEach(async () => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(false));
      });
      it('then should throw 401 status code if invalid credentials are provided', async () => {
        await request(app.getHttpServer())
          .patch('/v2/management/payouts/1/cancel')
          .expect(401);
      });

      it('then should 200 if Role is Super', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/cancel`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(200);
      });

      it('then should 200 if Role is Support', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/cancel`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(200);
      });
    });

    describe('when using new cancel flow', () => {
      beforeEach(async () => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION
      });
      it('then should 200 if payout transfer are previously canceled', async () => {
        await transferRepository.update(
          { id: transfer.id },
          {
            state: TransferState.CANCELED,
          },
        );
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/cancel`)
          .send({ transferId: transfer.id })
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(200);
      });
    });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/complete', () => {
    describe('when using old complete flow', () => {
      beforeEach(async () => {
        await payoutRepository.update(payout.id, {
          state: PayoutState.PROCESSING,
        });
        await transferRepository.update(
          { payoutId: payout.id },
          {
            state: TransferState.FAILED,
          },
        );
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(false)); // CAN_USE_NEW_PAYOUT_CREATION
      });

      it('then should throw 401 status code if invalid credentials are provided', async () => {
        await request(app.getHttpServer())
          .patch('/v2/management/payouts/1/complete')
          .expect(401);
      });

      it('then should 200 if Role is Super ', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/complete`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(200);
      });

      it('then should 200 if Role is Support', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/complete`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(200);
      });
    });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/reassign', () => {
    describe('when using old reassing flow', () => {
      let anotherProvider: ProviderEntity;

      beforeEach(async () => {
        await payoutRepository.update(payout.id, {
          state: PayoutState.PROCESSING,
        });
        await transferRepository.update(
          { payoutId: payout.id, providerId: provider.id },
          {
            state: TransferState.FAILED,
          },
        );
        const anotherBaseProvider: Partial<ProviderEntity> = {
          name: 'Test another Provider',
          credentials: { username: 'a', password: 'b' },
          providerType: ProviderType.Shinkansen,
          capabilities: [ProviderCapability.CREATE_TRANSFER],
          state: State.ACTIVE,
          accountId: account.id,
        };
        anotherProvider = await providerRepository.save(anotherBaseProvider);

        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(false)); // CAN_USE_NEW_PAYOUT_CREATION
      });

      it('then should throw 401 status code if invalid credentials are provided', async () => {
        await request(app.getHttpServer())
          .patch('/v2/management/payouts/1/reassign')
          .expect(401);
      });

      it('then should 200 if Role is Super ', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .send({ providerId: anotherProvider.id })
          .expect(200);
      });

      it('then should 200 if Role is Support', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
          .send({ providerId: anotherProvider.id })
          .expect(200);
      });
    });
    describe('when using new reassign flow', () => {
      let anotherProvider: ProviderEntity;

      beforeEach(async () => {
        await payoutRepository.update(payout.id, {
          state: PayoutState.PROCESSING,
        });
        await transferRepository.update(
          { payoutId: payout.id, providerId: provider.id },
          {
            state: TransferState.FAILED,
          },
        );
        const anotherBaseProvider = {
          ...baseProvider,
          name: 'Test another Provider',
        };
        anotherProvider = await providerRepository.save(anotherBaseProvider);
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION
      });

      afterEach(async () => {
        await transferRepository.delete({ payoutId: payout.id });
        await payoutRepository.delete({ id: payout.id });
        await providerRepository.delete({ id: anotherProvider.id });
      });

      it('then should throw 401 status code if invalid credentials are provided', async () => {
        await request(app.getHttpServer())
          .patch('/v2/management/payouts/1/reassign')
          .expect(401);
      });

      it('then should 400 if no provider id is sent', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .expect(400);
      });

      it('then should 200 if Role is Super ', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
          .send({ providerId: anotherProvider.id })
          .expect(200);
      });

      it('then should 200 if Role is Support', async () => {
        await request(app.getHttpServer())
          .patch(`/v2/management/payouts/${payout.id}/reassign`)
          .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
          .send({ providerId: anotherProvider.id })
          .expect(200);
      });
    });
  });

  describe('When a user using call the endpoint PATCH /payouts/:id/retry', () => {
    beforeEach(async () => {
      await payoutRepository.update(payout.id, {
        state: PayoutState.PROCESSING,
      });
      await transferRepository.update(
        { payoutId: payout.id },
        {
          state: TransferState.FAILED,
        },
      );
    });

    it('then should throw 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .patch('/v2/management/payouts/1/retry')
        .expect(401);
    });

    it('then should 200 if Role is Super ', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/management/payouts/${payout.id}/retry`)
        .set('Authorization', `Bearer ${testUserSuperWithToken.token}`)
        .expect(200);
    });

    it('then should 200 if Role is Support', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/management/payouts/${payout.id}/retry`)
        .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
        .expect(200);
    });

    // TODO: remove this when feature flag had deleted
    it('then should call new reassign method if feature is enabled', async () => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION

      const newReassignSpy = jest.spyOn(
        PayoutManagementService.prototype,
        'newReassignPayout',
      );
      const oldReassignSpy = jest.spyOn(
        PayoutManagementService.prototype,
        'reassignPayout',
      );

      await request(app.getHttpServer())
        .patch(`/v2/management/payouts/${payout.id}/retry`)
        .set('Authorization', `Bearer ${testUserSupportWithToken.token}`)
        .expect(200);

      expect(newReassignSpy).toHaveBeenCalledTimes(1);
      expect(oldReassignSpy).not.toHaveBeenCalled();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/auditLogController.e2e-spec.ts
import * as request from 'supertest';
import { CreateAuditLogDto } from 'src/api/v2/audit-log/dto/create-audit-log.dto';
import { AuditLogEntityType } from 'src/api/v2/audit-log/dto/get-audit-log.dto';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

describe('Given an AuditLogController', () => {
  let jwtSuperToken: string;
  let auditLogRepository: Repository<AuditLogEntity>;
  let testMerchant: TestMerchantUtil;
  let testUserWithToken: TestUserWithTokenUtil;

  const createAuditLogDto = {
    entityType: AuditLogEntityType.PayoutEntity,
    entityId: '1',
    event: AuditLogEvent.INSERT,
  };

  beforeAll(async () => {
    auditLogRepository = connection.getRepository(AuditLogEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    testUserWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });

    jwtSuperToken = testUserWithToken.token;
  });

  afterEach(async () => {
    await auditLogRepository.delete({});
    await testUserWithToken.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('When some user calls GET /audit-logs', () => {
    it('Then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer()).get('/v2/audit-logs').expect(401);
    });

    it('Then should return 401 status code if invalid authorization is provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/audit-logs')
        .set('Authorization', 'Bearer invalidJWT')
        .expect(401);
    });

    it('Then should return 400 status code if the entityType is missing on the queryString', async () => {
      await request(app.getHttpServer())
        .get('/v2/audit-logs?entityId=1')
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(400);
    });
    it('Then should 400 status code if the entityId is missing on the queryString', async () => {
      await request(app.getHttpServer())
        .get(`/v2/audit-logs?entityType=${AuditLogEntityType.PayoutEntity}`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(400);
    });
    it('Then should return 400 status code if invalid entityType is provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/audit-logs?entityType=invalidEntityType&entityId=1')
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(400);
    });
    it("Then return an empty array if there aren't any logs for the entityType and entityId provided", async () => {
      const auditLogs = Array(2)
        .fill(createAuditLogDto)
        .map((createAuditLogDto: CreateAuditLogDto) =>
          auditLogRepository.create({
            ...createAuditLogDto,
          }),
        );

      await auditLogRepository.save(auditLogs);

      const entityType = AuditLogEntityType.TransferEntity;

      const response = await request(app.getHttpServer())
        .get(`/v2/audit-logs?entityType=${entityType}&entityId=1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`);
      expect(200);

      expect(response.body).toHaveLength(0);
    });

    it('Then should set the pagination headers on the response', async () => {
      await auditLogRepository.save({ ...createAuditLogDto });
      const entityType = AuditLogEntityType.PayoutEntity;

      const response = await request(app.getHttpServer())
        .get(`/v2/audit-logs?entityType=${entityType}&entityId=1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`);
      expect(200);

      expect(response.headers['x-pagination-page']).toEqual('1');
      expect(response.headers['x-pagination-itemcount']).toEqual('1');
      expect(response.headers['x-pagination-limit']).toEqual('10');
      expect(response.headers['x-pagination-pagecount']).toEqual('1');
    });

    it('Then should return the audit-logs for the entityType and entityId provided', async () => {
      const auditLogs = Array(2)
        .fill(createAuditLogDto)
        .map((createAuditLogDto: CreateAuditLogDto) =>
          auditLogRepository.create({
            ...createAuditLogDto,
          }),
        );

      await auditLogRepository.save(auditLogs);

      const entityType = AuditLogEntityType.PayoutEntity;

      const response = await request(app.getHttpServer())
        .get(`/v2/audit-logs?entityType=${entityType}&entityId=1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(200);

      expect(response.body).toHaveLength(2);
    });

    describe('And the user request audit logs for an enabled entityType', () => {
      test.each(Object.values(AuditLogEntityType))(
        'then should allow to fetch audit logs for %s',
        async (entityType) => {
          const auditLog = auditLogRepository.create({
            ...createAuditLogDto,
            entityType,
          });

          await auditLogRepository.save(auditLog);

          const response = await request(app.getHttpServer())
            .get(`/v2/audit-logs?entityType=${entityType}&entityId=1`)
            .set('Authorization', `Bearer ${jwtSuperToken}`)
            .expect(200);

          expect(response.body.length).toBeGreaterThan(0);
        },
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/webhookEndpointController.e2e-spec.ts
import * as request from 'supertest';
import { changeEnv } from '../../../utils/testUtils';
import { app } from '../../../app.setup';
import { Environment } from 'src/common/enums/environment.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

describe('given a WebhookEndpointController', () => {
  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUserWithToken: TestUserWithTokenUtil;

  beforeAll(async () => {
    try {
      testMerchant = await createTestMerchant();
      testApiKey = await createTestApiKey(testMerchant.merchant.id);
      testUserWithToken = await useTestUser(UserRole.SUPER, false, {
        merchantId: testMerchant.merchant.id,
      });
    } catch (error) {
      console.log(error);
    }
  });
  afterAll(async () => {
    await testUserWithToken.deleteUser();
    await testApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
  });
  describe('when a user using JWT MFA strategy calls GET /v2/webhook-endpoints', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/webhook-endpoints')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);
    });
    it('then it should throw an UnauthorizedException if mfa is false', async () => {
      changeEnv();
      await request(app.getHttpServer())
        .get('/v2/webhook-endpoints')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(401);
      changeEnv(Environment.TEST);
    });
  });

  describe('when a user using API key strategy calls GET /v2/webhook-endpoints', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/webhook-endpoints')
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(200);
    });
  });

  describe('when a user using both JWT and API key strategy calls GET /v2/webhook-endpoints', () => {
    it('then it should not allow access (400)', async () => {
      await request(app.getHttpServer())
        .get('/v2/webhook-endpoints')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(400);
    });
  });

  describe('when a user using no authentication strategy calls GET /v2/webhook-endpoints', () => {
    it('then it should not allow access (401)', async () => {
      await request(app.getHttpServer())
        .get('/v2/webhook-endpoints')
        .expect(401);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/bankController.e2e-spec.ts
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import * as request from 'supertest';
import { app } from '../../../app.setup';

describe('given a BankController', () => {
  //  WHEN a user using no authentication strategy calls GET /v2/banks
  //  THEN it should allow access (200)

  describe('when a user using no authentication strategy calls GET /v2/banks', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer()).get('/v2/banks').expect(200);
    });
  });

  describe('when a user call get /v2/banks', () => {
    it('should return a list of banks', async () => {
      const response = await request(app.getHttpServer()).get('/v2/banks');
      expect(response.status).toBe(200);
      expect(
        parseInt(response.headers[PaginationHeader.ITEM_COUNT.toLowerCase()]),
      ).toStrictEqual(expect.any(Number));
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/userController.e2e-spec.ts
import { UserRole } from 'src/common/enums/user-role.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import * as request from 'supertest';
import { app } from 'test/app.setup';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import {
  TestUserUtil,
  TestUserWithTokenUtil,
  createTestUser,
  useTestUser,
} from 'test/utils/userTestUtils';

describe('Given a UserController', () => {
  describe('GET /v2/users', () => {
    it('should return an array', async () => {
      const testMerchant = await createTestMerchant();
      const {
        token,
        deleteUser,
        user: { id: testUserId },
      } = await useTestUser(UserRole.ADMIN, false, {
        merchantId: testMerchant.merchant.id,
      });

      const { body } = await request(app.getHttpServer())
        .get('/v2/users')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
      expect(Array.isArray(body)).toBe(true);

      const users = body as UserEntity[];
      expect(users.some(({ id }) => id === testUserId)).toBe(true);

      await deleteUser();
      await testMerchant.deleteMerchant();
    });
  });

  describe('GET /v2/users', () => {
    let testUser: TestUserWithTokenUtil;
    let otherUser: TestUserUtil;
    let testMerchant: TestMerchantUtil;

    beforeAll(async () => {
      testMerchant = await createTestMerchant();
      testUser = await useTestUser(UserRole.ADMIN, false, {
        role: UserRole.ADMIN,
        name: 'José Pérez',
        email: `jose.perez@userController.test`,
        merchantId: testMerchant.merchant.id,
      });
      otherUser = await createTestUser({
        useMfa: false,
        user: {
          role: UserRole.USER,
          name: 'Juan García',
          email: 'juan.garcia@userController.test',
          merchantId: testMerchant.merchant.id,
        },
      });
    });

    afterAll(async () => {
      await testUser.deleteUser();
      await otherUser.deleteUser();
      await testMerchant.deleteMerchant();
    });

    describe('when searching', () => {
      const shouldMatch = [
        'josé',
        'JOSÉ',
        'jose.perez@userController.test',
        'JOSE.PEREZ@USERCONTROLLER.TEST',
      ];
      it.each(shouldMatch)('should find the user for %s', async (search) => {
        const safeSearch = encodeURIComponent(search);

        const { body } = await request(app.getHttpServer())
          .get(`/v2/users?search=${safeSearch}`)
          .set('Authorization', `Bearer ${testUser.token}`)
          .expect(200);

        const users = body as UserEntity[];

        expect(users.some(({ id }) => id === testUser.user.id)).toBeTruthy();
      });

      const shouldNotMatch = ['juan', 'correoDeNadie@userController.test'];
      it.each(shouldNotMatch)(
        'should not find the user for %s',
        async (search) => {
          const { body } = await request(app.getHttpServer())
            .get(`/v2/users?search=${search}`)
            .set('Authorization', `Bearer ${testUser.token}`)
            .expect(200);

          const users = body as UserEntity[];

          expect(users.some(({ id }) => id === testUser.user.id)).toBeFalsy();
        },
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/merchantLimitController.e2e-spec.ts
import * as request from 'supertest';
import { Repository } from 'typeorm';

import { CreateMerchantLimitDto } from 'src/api/v2/merchant-limit/dto/create-limit.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import {
  MerchantLimitDefinition,
  MerchantLimitEntity,
} from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { connection, app } from 'test/app.setup';
import { PatchMerchantLimitDto } from 'src/api/v2/merchant-limit/dto/patch-merchant-limit.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';

const baseDefinition: MerchantLimitDefinition = {
  value: 1000,
  criteria: LimitCriteria.AMOUNT,
  currency: Currency.CHILE,
  scope: LimitScope.PERSON,
  aggregation: LimitAggregation.HOUR,
};

const baseMerchantLimit: Partial<MerchantLimitEntity> = {
  limitType: MerchantLimitType.RATE,
  limitDefinition: baseDefinition,
};

describe('Given an LimitController', () => {
  let jwtSuperToken: string;
  let merchant: MerchantEntity;

  let testMerchant: TestMerchantUtil;
  let otherTestMerchant: TestMerchantUtil;
  let testSuperUserWithMFA: TestUserWithTokenUtil;
  let testAdminUserWithMFA: TestUserWithTokenUtil;

  let merchantLimitRepository: Repository<MerchantLimitEntity>;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    otherTestMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;

    testSuperUserWithMFA = await useTestUser(UserRole.SUPER, true, {
      merchantId: merchant.id,
    });
    jwtSuperToken = testSuperUserWithMFA.token;

    testAdminUserWithMFA = await useTestUser(UserRole.ADMIN, true, {
      merchantId: otherTestMerchant.merchant.id,
    });

    merchantLimitRepository = connection.getRepository(MerchantLimitEntity);
  });

  afterEach(async () => {
    await merchantLimitRepository.delete({
      merchantId: merchant.id,
    });
    await merchantLimitRepository.delete({
      merchantId: otherTestMerchant.merchant.id,
    });
  });

  afterAll(async () => {
    await testSuperUserWithMFA.deleteUser();
    await testAdminUserWithMFA.deleteUser();
    await testMerchant.deleteMerchant();
    await otherTestMerchant.deleteMerchant();
  });

  describe('when a user calls POST /v2/merchants/:merchantId/limits', () => {
    it('then should throw 401 status code if credentials are not provided', async () => {
      await request(app.getHttpServer())
        .post(`/v2/merchants/1/limits`)
        .expect(401);
    });
    it('then should throw 404 status code if the merchant is not found', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: baseDefinition,
      };
      await request(app.getHttpServer())
        .post('/v2/merchants/99/limits')
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(404);
    });
    it('then should throw 400 status code if value is less or equal than 0', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: { ...baseDefinition, value: 0 },
      };

      await request(app.getHttpServer())
        .post(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(400);
    });
    it('then should throw 400 status code if invalid criteria is provided', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: {
          ...baseDefinition,
          criteria: 'invalidCriteria' as LimitCriteria,
        },
      };

      await request(app.getHttpServer())
        .post(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(400);
    });
    it('then should throw 400 status code if invalid scope is provided', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: {
          ...baseDefinition,
          scope: 'invalidScope' as LimitScope,
        },
      };

      await request(app.getHttpServer())
        .post(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(400);
    });
    it('then should throw 400 status code if invalid aggregation is provided', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: {
          ...baseDefinition,
          aggregation: 'invalidAggregation' as LimitAggregation,
        },
      };

      await request(app.getHttpServer())
        .post(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(400);
    });
    it('then should create a merchant limit for specific merchant', async () => {
      const createLimitDto: CreateMerchantLimitDto = {
        limitType: MerchantLimitType.RATE,
        limitDefinition: { ...baseDefinition },
      };

      await request(app.getHttpServer())
        .post(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(createLimitDto)
        .expect(201);
    });
  });

  describe('when a user calls GET /v2/merchants/:merchantId/limits', () => {
    it('then should throw 401 status code if credentials are not provided', async () => {
      await request(app.getHttpServer())
        .get(`/v2/merchants/1/limits`)
        .expect(401);
    });
    it('then should throw 404 status code if the merchant is not found', async () => {
      await request(app.getHttpServer())
        .get('/v2/merchants/99/limits')
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(404);
    });
    it('then should return the paginated merchant limits of specific merchant', async () => {
      const createdLimits = Array(10)
        .fill(baseMerchantLimit)
        .map((merchantLimit: CreateMerchantLimitDto) =>
          merchantLimitRepository.create({
            ...merchantLimit,
            merchantId: merchant.id,
          }),
        );
      await merchantLimitRepository.save(createdLimits);

      const response = await request(app.getHttpServer())
        .get(`/v2/merchants/${merchant.id}/limits`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(200);

      const merchantLimits = response.body;
      const headers = response.headers;

      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(merchantLimits.length).toBeGreaterThan(0);
    });
    it('then should return only the merchant limits that have a user with admin role', async () => {
      const allMerchants = [merchant.id, otherTestMerchant.merchant.id];
      const createdLimits = Array(10)
        .fill(baseMerchantLimit)
        .map((merchantLimit: CreateMerchantLimitDto, index) =>
          merchantLimitRepository.create({
            ...merchantLimit,
            merchantId: allMerchants[index % 2],
          }),
        );
      await merchantLimitRepository.save(createdLimits);

      let pageCount = 1;
      let page = 1;
      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get(`/v2/merchants/${otherTestMerchant.merchant.id}/limits`)
          .set('Authorization', `Bearer ${testAdminUserWithMFA.token}`)
          .expect(200);

        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const merchantLimits: MerchantLimitEntity[] = response.body;

        const sameMerchant = merchantLimits.every(
          (merchantLimit) =>
            merchantLimit.merchantId === otherTestMerchant.merchant.id,
        );
        expect(sameMerchant).toBeTruthy();
        page++;
      }
    });
    it('then should return the merchant limits only of specific merchant', async () => {
      Array(5)
        .fill(baseMerchantLimit)
        .map((merchantLimit: CreateMerchantLimitDto) =>
          merchantLimitRepository.create({
            ...merchantLimit,
            merchantId: otherTestMerchant.merchant.id,
          }),
        );

      const createdLimits = Array(5)
        .fill(baseMerchantLimit)
        .map((merchantLimit: CreateMerchantLimitDto) =>
          merchantLimitRepository.create({
            ...merchantLimit,
            merchantId: merchant.id,
          }),
        );

      await merchantLimitRepository.save(createdLimits);
      let pageCount = 1;
      let page = 1;
      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get(`/v2/merchants/${merchant.id}/limits`)
          .set('Authorization', `Bearer ${jwtSuperToken}`)
          .expect(200);
        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const merchantLimits: MerchantLimitEntity[] = response.body;

        const sameMerchant = merchantLimits.every(
          (merchantLimit) => merchantLimit.merchantId === merchant.id,
        );
        expect(sameMerchant).toBeTruthy();
        page++;
      }
    });
  });

  describe('when a user calls PATCH /v2/merchants/:merchantId/limits/:id', () => {
    it('then should throw 401 status code if credentials are not provided', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/merchants/1/limits/1`)
        .expect(401);
    });
    it('then should throw 404 status code if the merchant is not found', async () => {
      const merchantLimitDto: PatchMerchantLimitDto = {
        limitDefinition: {
          value: 4000,
        },
      };
      await request(app.getHttpServer())
        .patch(`/v2/merchants/99/limits/1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(merchantLimitDto)
        .expect(404);
    });
    it('then should throw 404 status code if the merchant limit is not found', async () => {
      const merchantLimitDto: PatchMerchantLimitDto = {
        limitDefinition: {
          value: 4000,
        },
      };
      await request(app.getHttpServer())
        .patch(`/v2/merchants/${merchant.id}/limits/99`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(merchantLimitDto)
        .expect(404);
    });
    it('then should throw 400 status code if invalid dto is given', async () => {
      await request(app.getHttpServer())
        .patch(`/v2/merchants/99/limits/1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send({ limitDefinition: { aggregation: 'hour' } })
        .expect(400);
    });
    it('then should return the merchant limit updated of specific merchant', async () => {
      const createdLimit = merchantLimitRepository.create({
        ...baseMerchantLimit,
        merchantId: merchant.id,
      });
      await merchantLimitRepository.save(createdLimit);

      const merchantLimitDto: PatchMerchantLimitDto = {
        limitDefinition: {
          value: 4000,
        },
      };

      await request(app.getHttpServer())
        .patch(`/v2/merchants/${merchant.id}/limits/${createdLimit.id}`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .send(merchantLimitDto)
        .expect(200);
    });
  });

  describe('when a user calls DELETE /v2/merchants/:merchantId/limits/:id', () => {
    it('then should throw 401 status code if credentials are not provided', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/merchants/1/limits/1`)
        .expect(401);
    });
    it('then should throw 404 status code if the merchant is not found', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/merchants/99/limits/1`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(404);
    });
    it('then should throw 404 status code if the merchant limit is not found', async () => {
      await request(app.getHttpServer())
        .delete(`/v2/merchants/${merchant.id}/limits/99`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(404);
    });
    it('then should return the merchant limit deleted of specific merchant', async () => {
      const createdLimit = merchantLimitRepository.create({
        ...baseMerchantLimit,
        merchantId: merchant.id,
      });
      await merchantLimitRepository.save(createdLimit);

      const response = await request(app.getHttpServer())
        .delete(`/v2/merchants/${merchant.id}/limits/${createdLimit.id}`)
        .set('Authorization', `Bearer ${jwtSuperToken}`)
        .expect(200);

      const limitResponse = response.body as MerchantLimitEntity;
      const { id } = limitResponse;
      expect(id).toEqual(createdLimit.id);

      const deletedMerchantLimit = await merchantLimitRepository.findOne({
        where: { id: createdLimit.id },
      });
      expect(deletedMerchantLimit).toBeUndefined;
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/payoutController.e2e-spec.ts
import * as request from 'supertest';
import { app, connection } from '../../../app.setup';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { changeEnv } from '../../../utils/testUtils';
import { Environment } from 'src/common/enums/environment.enum';
import { PaginationHeader } from 'src/common/enums/pagination-header.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { In, Repository } from 'typeorm';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { randBetweenDate, randUserName } from '@ngneat/falso';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { UserRole } from 'src/common/enums/user-role.enum';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { State } from 'src/common/enums/state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

const createPayoutDto: Partial<CreatePayoutDto> = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  currency: Currency.CHILE,
  trackingCode: undefined,
  version: EntityVersion.v2,
  destinationPhone: '3212312312',
};

const createTransferDto: Partial<CreateTransferDto> = {
  amount: 100,
  currency: Currency.CHILE,
  concept: 'Testing',
  trackingCode: '',
  destinationHolderId: '120123123',
  destinationName: 'oblandon',
  destinationAccount: '1201231',
  destinationBankCode: 'cl_banco_falabella',
  destinationPhone: '001239912312',
  payoutId: undefined,
  providerId: undefined,
  version: EntityVersion.v2,
  state: TransferState.ASSIGNED,
};

const createAccountDto: Partial<CreateAccountDto> = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
};

const createProviderDto: Partial<ProviderEntity> = {
  name: 'Test Provider',
  state: State.ACTIVE,
  credentials: { username: 'a', password: 'b' },
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  providerType: ProviderType.ScraperCG,
};

describe('given a PayoutController', () => {
  let payoutRepository: Repository<PayoutEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let transferRepository: Repository<TransferEntity>;
  let userRepository: Repository<UserEntity>;
  let testMerchant: TestMerchantUtil;
  let testAnotherMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUserWithToken: TestUserWithTokenUtil;
  let testSuperWithToken: TestUserWithTokenUtil;

  let account: AccountEntity;
  let provider: ProviderEntity;

  async function createPayouts(quantity: number): Promise<PayoutEntity[]> {
    const payouts = Array(quantity)
      .fill(createPayoutDto)
      .map((createPayoutDto: CreatePayoutDto, index: number) =>
        payoutRepository.create({
          ...createPayoutDto,
          trackingCode: `testByPayoutv2-${index}`,
        }),
      );

    return await payoutRepository.save(payouts);
  }

  beforeAll(async () => {
    userRepository = connection.getRepository(UserEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  beforeEach(async () => {
    const eventEmitter = app.get(EventEmitter2);

    jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
      return true;
    });
    jest
      .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
      .mockReturnValue(Promise.resolve(false));

    testMerchant = await createTestMerchant();
    testAnotherMerchant = await createTestMerchant();

    testApiKey = await createTestApiKey(testMerchant.merchantId);
    testUserWithToken = await useTestUser(UserRole.ADMIN, false, {
      merchantId: testMerchant.merchantId,
    });

    testSuperWithToken = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchantId,
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchantId,
    });

    provider = await providerRepository.save({
      ...createProviderDto,
      providerType: ProviderType.Minka,
      accountId: account.id,
    });

    createPayoutDto.merchantId = testMerchant.merchantId;
    createTransferDto.merchantId = testMerchant.merchantId;
  });

  afterEach(async () => {
    const merchantIds = [
      testMerchant.merchantId,
      testAnotherMerchant.merchantId,
    ];

    await transferRepository.delete({ merchantId: In(merchantIds) });
    await payoutRepository.delete({ merchantId: In(merchantIds) });

    const accounts = await accountRepository.find({
      where: { merchantId: In(merchantIds) },
    });

    const accountIds = accounts.map((account) => account.id);

    await providerRepository.delete({ accountId: In(accountIds) });
    await accountRepository.delete({ merchantId: In(merchantIds) });

    await testApiKey.deleteApiKey();
    await testUserWithToken.deleteUser();
    await testSuperWithToken.deleteUser();
    await testMerchant.deleteMerchant();
    await testAnotherMerchant.deleteMerchant();
  });

  // TODO: add test cases for JWT Auth strategy
  // TODO: When PYT-909 is finished, add missing test for create payout using new create payout method
  describe('when a user calls POST /v2/payouts', () => {
    it('then should return 401 if invalid apiKey is provided', async () => {
      await request(app.getHttpServer())
        .post('/v2/payouts')
        .send({ ...createPayoutDto })
        .expect(401);
    });

    it('then should create and return a v2 payout', async () => {
      const response = await request(app.getHttpServer())
        .post('/v2/payouts')
        .send({
          ...createPayoutDto,
          trackingCode: 'testByPayoutv2',
        })
        .set('X-API-KEY', testApiKey.mockData.key)
        .expect(201);

      const payout = response.body;

      expect(payout.version).toEqual(EntityVersion.v2);
    });
  });

  describe('when a user calls GET /v2/payouts', () => {
    it('Then should return 401 status code if invalid JWT is provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/payouts')
        .set('Authorization', 'Bearer invalidJWT')
        .expect(401);
    });

    it('Then should return 401 status code if MFA is false with JWT', async () => {
      changeEnv();
      await request(app.getHttpServer())
        .get('/v2/payouts')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(401);

      changeEnv(Environment.TEST);
    });

    it('Then should return 401 status code if invalid api key is provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/payouts')
        .set('X-API-KEY', 'invalidKey')
        .expect(404);
    });

    it('Then should return 401 status code if no credentials are provided', async () => {
      await request(app.getHttpServer()).get('/v2/payouts').expect(401);
    });

    it('Then should return 400 status code if invalid dto is provided', async () => {
      await request(app.getHttpServer())
        .get('/v2/payouts?unkownKey=invalidPage')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(400);
    });

    it('Then should return the paginated payouts', async () => {
      await createPayouts(5);

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?version[]=v2')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const retrievedPayouts = response.body;
      const headers = response.headers;

      expect(headers[PaginationHeader.PAGE.toLocaleLowerCase()]).toBeDefined();
      expect(headers[PaginationHeader.LIMIT.toLocaleLowerCase()]).toBeDefined();
      expect(
        headers[PaginationHeader.ITEM_COUNT.toLocaleLowerCase()],
      ).toBeDefined();
      expect(
        headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
      ).toBeDefined();

      expect(retrievedPayouts.length).toBeGreaterThan(0);
      expect(retrievedPayouts[0].version).toEqual(EntityVersion.v2);
    });

    it('Then should return v1 & v2 payouts using the version query', async () => {
      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        trackingCode: `testByPayoutv2`,
      });

      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
        trackingCode: `testByPayoutv1`,
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?version[]=v1&version[]=v2&limit=999')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const retrievedPayouts = response.body;

      expect(retrievedPayouts.length).toBeGreaterThan(0);

      const payoutV1 = retrievedPayouts.find(
        (payout) => payout.version === 'v1',
      );
      const payoutV2 = retrievedPayouts.find(
        (payout) => payout.version === 'v2',
      );

      expect(payoutV1).toBeDefined();
      expect(payoutV2).toBeDefined();
    });

    it('Then should allow to search payouts by state', async () => {
      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        state: PayoutState.PENDING,
        trackingCode: `testByPayoutv1`,
      });

      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        state: PayoutState.PROCESSING,
        trackingCode: `testByPayoutv2`,
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?state=pending')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const payouts = response.body;

      expect(payouts.length).toEqual(1);

      expect(payouts[0].state).toEqual('pending');
    });

    it('Then should allow to search payouts by an array of states', async () => {
      const payouts = Array(2)
        .fill(createPayoutDto)
        .map((createPayoutDto: CreatePayoutDto, index: number) =>
          payoutRepository.create({
            ...createPayoutDto,
            trackingCode: `testByPayoutStatev2-${index}`,
          }),
        );
      payouts[0].state = PayoutState.PENDING;
      payouts[1].state = PayoutState.PROCESSING;

      await payoutRepository.save(payouts);
      const response = await request(app.getHttpServer())
        .get('/v2/payouts?version[]=v2&states[]=pending&states[]=processing')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const retrievedPayouts = response.body;

      expect(retrievedPayouts.length).toBeGreaterThan(0);

      const pendingPayout = retrievedPayouts.find(
        (payout: PayoutEntity) => payout.state === 'pending',
      );
      const processingPayout = retrievedPayouts.find(
        (payout: PayoutEntity) => payout.state === 'processing',
      );

      expect(pendingPayout).toBeDefined();
      expect(processingPayout).toBeDefined(); // DIES HERE
    });

    it('Then should allow to search payouts by destinationBankCode', async () => {
      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        destinationBankCode: 'cl_banco_falabella',
        trackingCode: `testByPayoutv2`,
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?destinationBankCode=cl_banco_falabella')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const payouts = response.body;

      expect(payouts.length).toBeGreaterThan(0);

      expect(payouts[0].destinationBankCode).toEqual('cl_banco_falabella');
    });

    it('Then should allow to search payouts by transfer.originBankCode', async () => {
      await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByOriginBankCodev2',
        transfers: [
          {
            ...createTransferDto,
            originBankCode: 'cl_banco_itau_chile',
          },
        ],
      });
      const response = await request(app.getHttpServer())
        .get('/v2/payouts?transfer[originBankCode]=cl_banco_itau_chile')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const payouts = response.body;

      expect(payouts.length).toBeGreaterThan(0);

      expect(payouts[0].transfers[0].originBankCode).toEqual(
        'cl_banco_itau_chile',
      );
    });

    it('Then should allow to search payouts by destinationName using the search query', async () => {
      const destinationName = 'v2searchByDestinationName';
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByDestinationNamev2',
        destinationName,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${destinationName}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const foundPayout = response.body;

      expect(foundPayout).toHaveLength(1);
      expect(foundPayout[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by destinationAccount using the search query', async () => {
      const destinationAccount = 'v21122334455';
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByDestinationAccountv2',
        destinationAccount,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${destinationAccount}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const foundPayout = response.body;

      expect(foundPayout).toHaveLength(1);
      expect(foundPayout[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by destinationEmail using the search query', async () => {
      const destinationEmail = 'v2searchByDestinationEmail';
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByDestinationEmailv2',
        destinationEmail,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${destinationEmail}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const foundPayout = response.body;

      expect(foundPayout).toHaveLength(1);
      expect(foundPayout[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by id using the search query', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByPayoutIdv2',
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${payout.id}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const foundPayout = response.body;

      expect(foundPayout).toHaveLength(1);
      expect(foundPayout[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by amount using the search query', async () => {
      const amount = 999.95;
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByAmountv2',
        amount,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${amount}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const payouts = response.body;

      expect(payouts).toHaveLength(1);
      expect(payouts[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by metadata.paymentId using the search query', async () => {
      const paymentId = 12344321;
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByMetadataPaymentIdv2',
        metadata: { paymentId },
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?search=${paymentId}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by trackingCode', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'v2testByTrackingCode',
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?trackingCode=${payout.trackingCode}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts from date', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByFromDatev2',
        createdAt: new Date('3050-01-01'),
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?from=${payout.createdAt.toISOString()}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts to date', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByToDatev2',
        createdAt: new Date('1900-01-01'),
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?to=${payout.createdAt.toISOString()}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].id).toEqual(payout.id);
    });

    it('Then should allow to search payouts by date range', async () => {
      const dateFrom = new Date('1980-01-01T00:00:00Z');
      const dateTo = new Date('1980-02-01T00:00:00Z');
      const payouts = Array(5)
        .fill(createPayoutDto)
        .map((createPayoutDto: CreatePayoutDto, index) => {
          const trackingCode = `testByDateRangev2${index}`;
          return payoutRepository.create({
            ...createPayoutDto,
            trackingCode,
            createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
          });
        });

      await payoutRepository.save(payouts);

      const response = await request(app.getHttpServer())
        .get(
          `/v2/payouts?from=${dateFrom.toISOString()}&to=${dateTo.toISOString()}`,
        )
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body).toHaveLength(5);
    });

    it('Then should allow to search payouts by currency', async () => {
      const currency = Currency.CHILE;

      await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByDestinationEmailv2',
        currency,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?currency=${currency}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body.length).toEqual(1);
      expect(response.body[0]).toHaveProperty('currency', currency);
    });

    it('Then should allow to search payouts by merchantId', async () => {
      const payouts = Array(2)
        .fill(createPayoutDto)
        .map((createPayoutDto: CreatePayoutDto, index) => {
          const trackingCode = `testByMerchantId${index}`;
          return payoutRepository.create({
            ...createPayoutDto,
            trackingCode,
          });
        });
      payouts[1].merchantId = testAnotherMerchant.merchant.id;
      await payoutRepository.save(payouts);

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?merchantId=${testMerchant.merchantId}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(
        response.body.every(
          (payout) => payout.merchantId === testMerchant.merchantId,
        ),
      ).toBeTruthy();
    });

    it('Then should allow to search payouts by providerId', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'testByProviderIdv2',
        transfers: [
          {
            ...createTransferDto,
            providerId: provider.id,
          },
        ],
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts?transfer[providerId]=${provider.id}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      expect(response.body).toHaveLength(1);
    });

    it('Then should return payouts from v1 and v2 by default', async () => {
      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        trackingCode: `testByPayoutv2`,
      });

      await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
        trackingCode: `testByPayoutv1`,
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?page=1&limit=999')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);

      const payouts: PayoutEntity[] = response.body;

      expect(payouts).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ version: EntityVersion.v1 }),
          expect.objectContaining({ version: EntityVersion.v2 }),
        ]),
      );
    });

    it('Then should return payouts from multiple merchants when user is super', async () => {
      const payoutOne = await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v2,
        trackingCode: `testByPayoutv2`,
      });

      const payoutTwo = await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
        merchantId: testAnotherMerchant.merchant.id,
        trackingCode: `testByPayoutv1`,
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts?page=1&limit=999')
        .set('Authorization', `Bearer ${testSuperWithToken.token}`)
        .expect(200);

      const payouts: PayoutEntity[] = response.body;

      expect(payouts).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ id: payoutOne.id }),
          expect.objectContaining({ id: payoutTwo.id }),
        ]),
      );
    });

    it('Then should return only payouts if the corresponding merchant id is provided', async () => {
      let pageCount = 1;
      let page = 1;

      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get(`/v2/payouts?merchantId=${testUserWithToken.user.merchantId}`)
          .set('Authorization', `Bearer ${testUserWithToken.token}`)
          .expect(200);
        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );
        const payouts: PayoutEntity[] = response.body;
        const fromMerchantOne = payouts.every(
          (payout) => payout.merchantId === testMerchant.merchantId,
        );
        expect(fromMerchantOne).toBeTruthy();
        page++;
      }
    });
    it('Then should return only the merchant payouts that have a user with admin role', async () => {
      await userRepository.update(testUserWithToken.user.id, {
        role: UserRole.ADMIN,
        merchantId: testAnotherMerchant.merchant.id,
      });

      let pageCount = 1;
      let page = 1;

      while (page <= pageCount) {
        const response = await request(app.getHttpServer())
          .get('/v2/payouts')
          .set('Authorization', `Bearer ${testUserWithToken.token}`)
          .expect(200);

        const headers = response.headers;
        pageCount = Number(
          headers[PaginationHeader.PAGE_COUNT.toLocaleLowerCase()],
        );

        const payouts: PayoutEntity[] = response.body;
        const fromMerchant = payouts.every((payout) => payout.merchantId === 2);
        expect(fromMerchant).toBeTruthy();
        page++;
      }
    });
  });

  describe('when a user call GET /v2/payouts/:id', () => {
    test('then should return 401 status code if invalid credentials are provider', async () => {
      await request(app.getHttpServer())
        .get('/v2/payouts/1')
        .set('Authorization', 'Bearer invalidJWT')
        .expect(401);
    });
    test('then should return 404 status code if the request payout does not exists', async () => {
      await request(app.getHttpServer())
        .get('/v2/payouts/999')
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(404);
    });
    test('then should return 200 status code', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: 'getSinglePayout',
      });
      await request(app.getHttpServer())
        .get(`/v2/payouts/${payout.id}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`)
        .expect(200);
    });
  });

  describe('When a user using JWT strategy call GET /v2/payouts/export', () => {
    const dateFrom = new Date('2020-01-01T00:00:00Z');
    const dateTo = new Date('2020-02-01T00:00:00Z');

    it('then should return 401 if no credentials are provided', async () => {
      const response = await request(app.getHttpServer()).get(
        '/v2/payouts/export',
      );

      expect(response.statusCode).toBe(401);
    });

    it('then should return 204 empty response if there are not any payouts', async () => {
      const response = await request(app.getHttpServer())
        .get('/v2/payouts/export?to=1999-01-01T00:00:00Z')
        .set('Authorization', `Bearer ${testUserWithToken.token}`);
      expect(response.statusCode).toBe(204);
    });

    it('then should return 200 status code with the xlsx file if there are any payouts with transfers', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode: 'getSinglePayout',
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        trackingCode: 'getSinglePayout',
        createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
      });

      const response = await request(app.getHttpServer())
        .get('/v2/payouts/export')
        .set('Authorization', `Bearer ${testUserWithToken.token}`);
      expect(response.statusCode).toBe(200);

      const content = response.body;
      expect(content).toBeDefined();

      expect(response.headers['content-type']).toEqual(
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      );
    });

    it('then should return 200 status code if there are any payouts that match with the state query', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode: 'getSinglePayout',
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        trackingCode: 'getSinglePayout',
        createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/payouts/export?state=${PayoutState.PENDING}`)
        .set('Authorization', `Bearer ${testUserWithToken.token}`);

      expect(response.statusCode).toBe(200);
    });

    it('then should return 200 status code if there are any payouts on the date range specified', async () => {
      const payouts = Array(5)
        .fill(createPayoutDto)
        .map((createPayoutDto: CreatePayoutDto, index) => {
          const trackingCode = randUserName() + index;
          return payoutRepository.create({
            ...createPayoutDto,
            trackingCode,
            createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
            transfers: [
              {
                ...createTransferDto,
                trackingCode,
              },
            ],
          });
        });

      await payoutRepository.save(payouts);

      const response = await request(app.getHttpServer())
        .get(
          `/v2/payouts/export?from=${dateFrom.toISOString()}&to=${dateTo.toISOString()}`,
        )
        .set('Authorization', `Bearer ${testUserWithToken.token}`);
      expect(response.statusCode).toBe(200);
    });

    it('then should return 200 status code if there are any payouts that match with all the queries sent', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode: 'getSinglePayout',
        createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        trackingCode: 'getSinglePayout',
        createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
      });

      const response = await request(app.getHttpServer())
        .get(
          `/v2/payouts/export?state=pending&from=${dateFrom.toISOString()}&to=${dateTo.toISOString()}`,
        )
        .set('Authorization', `Bearer ${testUserWithToken.token}`);
      expect(response.statusCode).toBe(200);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/v2/controllers/authorizationCodeController.e2e-spec.ts
import { Repository } from 'typeorm';
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { createTestApiKey, TestApiKeyUtil } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { BankCode } from 'src/common/enums/bank-code.enum';

describe('given a AuthorizationCodeController', () => {
  let jwtToken: string;
  let apiKey: string;

  let transferMethodRepository: Repository<TransferMethodEntity>;
  let authorizationCodeRepository: Repository<AuthorizationCodeEntity>;
  let bankAccessRepository: Repository<BankAccessEntity>;
  let testMerchant: TestMerchantUtil;
  let testApiKey: TestApiKeyUtil;
  let testUser: TestUserWithTokenUtil;

  const createTransferMethodDto = {
    identifier: '123456789542',
    methodType: TransferMethodType.CARD,
    merchantId: undefined,
    bankAccessId: undefined,
  };

  const createAuthorizationCodeDto = {
    code: '12345',
    expiresAt: new Date('2222-02-02'),
  };

  let transferMethod: TransferMethodEntity;
  let bankAccess: BankAccessEntity;
  let authorizationCode: AuthorizationCodeEntity;

  beforeAll(async () => {
    testMerchant = await createTestMerchant();
    testUser = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });

    testApiKey = await createTestApiKey(testMerchant.merchant.id);

    jwtToken = testUser.token;
    apiKey = testApiKey.mockData.key;

    authorizationCodeRepository = connection.getRepository(
      AuthorizationCodeEntity,
    );

    transferMethodRepository = connection.getRepository(TransferMethodEntity);
    bankAccessRepository = connection.getRepository(BankAccessEntity);
  });

  beforeEach(async () => {
    bankAccess = await bankAccessRepository.save({
      name: 'bankAccess',
      merchantId: testMerchant.merchant.id,
      bankCode: BankCode.BANCO_SANTANDER,
    });

    transferMethod = await transferMethodRepository.save({
      ...createTransferMethodDto,
      bankAccessId: bankAccess.id,
      merchantId: testMerchant.merchant.id,
    });

    authorizationCode = await authorizationCodeRepository.save({
      ...createAuthorizationCodeDto,
      transferMethodId: transferMethod.id,
    });
  });

  afterEach(async () => {
    await authorizationCodeRepository.delete({
      transferMethodId: transferMethod.id,
    });
    await transferMethodRepository.delete(transferMethod.id);
    await bankAccessRepository.delete(bankAccess.id);
  });

  afterAll(async () => {
    await testApiKey.deleteApiKey();
    await testUser.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('when a user using JWT strategy calls GET /v2/authorization-codes', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/authorization-codes')
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });
  });

  describe('when a user using API key strategy calls GET /v2/authorization-codes', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get('/v2/authorization-codes')
        .set('X-API-KEY', apiKey)
        .expect(200);
    });
  });

  describe('when a user using both JWT and API key strategy calls GET /v2/authorization-codes', () => {
    it('then it should not allow access (400)', async () => {
      await request(app.getHttpServer())
        .get('/v2/authorization-codes')
        .set('Authorization', `Bearer ${jwtToken}`)
        .set('X-API-KEY', apiKey)
        .expect(400);
    });
  });

  describe('when a user using no authentication strategy calls GET /v2/authorization-codes', () => {
    it('then it should not allow access (401)', async () => {
      await request(app.getHttpServer())
        .get('/v2/authorization-codes')
        .expect(401);
    });
  });

  describe('when a user using JWT strategy and a valid authorization code, calls GET /v2/authorization-codes/:id', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get(`/v2/authorization-codes/${authorizationCode.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200);
    });
  });

  describe('when a user using API key strategy and a valid authorization code, calls GET /v2/authorization-codes/:id', () => {
    it('then it should allow access (200)', async () => {
      await request(app.getHttpServer())
        .get(`/v2/authorization-codes/${authorizationCode.id}`)
        .set('X-API-KEY', apiKey)
        .expect(200);
    });
  });

  describe('when a user using both JWT and API key strategy and a valid authorization code, calls GET /v2/authorization-codes/:id', () => {
    it('then it should not allow access (400)', async () => {
      await request(app.getHttpServer())
        .get(`/v2/authorization-codes/${authorizationCode.id}`)
        .set('Authorization', `Bearer ${jwtToken}`)
        .set('X-API-KEY', apiKey)
        .expect(400);
    });
  });

  describe('when a user using no authentication strategy and a valid authorization code, calls GET /v2/authorization-codes/:id', () => {
    it('then it should not allow access (401)', async () => {
      await request(app.getHttpServer())
        .get(`/v2/authorization-codes/${authorizationCode.id}`)
        .expect(401);
    });
  });

  describe('when a user call get /v2/authorization-codes/:id', () => {
    it('then should return not found status code if the code does not exits', async () => {
      const response = await request(app.getHttpServer())
        .get(`/v2/authorization-codes/-1`)
        .set('Authorization', `Bearer ${jwtToken}`);

      expect(response.statusCode).toBe(404);
    });

    it('then should return forbiden resource status code if the code has not active state', async () => {
      await authorizationCodeRepository.update(authorizationCode.id, {
        state: AuthorizationCodeState.EXPIRED,
      });

      const response = await request(app.getHttpServer())
        .get(`/v2/authorization-codes/${authorizationCode.id}`)
        .set('Authorization', `Bearer ${jwtToken}`);

      expect(response.statusCode).toBe(403);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/internal/featureFlagController.e2e-spec.ts
import * as request from 'supertest';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { app } from 'test/app.setup';
import { changeEnv } from 'test/utils/testUtils';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

const flag = FEATURE_FLAG.CAN_EVALUATE_MERCHANT_LIMIT;

describe('Given a FeatureFlagController', () => {
  let testMerchant: TestMerchantUtil;
  let testUserWithTokenNoMfa: TestUserWithTokenUtil;
  let testUserWithTokenMfa: TestUserWithTokenUtil;

  describe('When a user calls GET /internal/feature-flags/:featureFlag', () => {
    beforeAll(async () => {
      try {
        testMerchant = await createTestMerchant();
        testUserWithTokenNoMfa = await useTestUser(UserRole.SUPER, false, {
          merchantId: testMerchant.merchant.id,
        });
        testUserWithTokenMfa = await useTestUser(UserRole.SUPER, true, {
          merchantId: testMerchant.merchant.id,
        });
      } catch (error) {
        console.log(error);
      }
    });
    afterAll(async () => {
      await testUserWithTokenMfa.deleteUser();
      await testUserWithTokenNoMfa.deleteUser();
      await testMerchant.deleteMerchant();
    });
    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/internal/feature-flags/${flag}`)
        .expect(401);
    });
    describe('And a user using JWT MFA', () => {
      it('then it should throw UnauthorizedException if mfa is false', async () => {
        changeEnv(Environment.PRODUCTION);

        await request(app.getHttpServer())
          .get(`/internal/feature-flags/${flag}`)
          .set('Authorization', `Bearer ${testUserWithTokenNoMfa.token}`)
          .expect(401);
        changeEnv(Environment.TEST);
      });
      it('then should return the feature flag value', async () => {
        const response = await request(app.getHttpServer())
          .get(`/internal/feature-flags/${flag}`)
          .set('Authorization', `Bearer ${testUserWithTokenMfa.token}`)
          .expect(200);

        const result = response.body;
        expect(result.value).toBeTruthy();
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/internal/providerController.e2e-spec.ts
import * as supertest from 'supertest';
import { Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { app, connection } from 'test/app.setup';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { randNumberString } from 'test/utils/testUtils';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { State } from 'src/common/enums/state.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { TestApiKeyUtil, createTestApiKey } from 'test/utils/apiKeyTestUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

const createAccountDto: Partial<AccountEntity> = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  state: State.ACTIVE,
  name: 'Base Account',
  identifier: '123912391',
};

const createProviderDto: Partial<ProviderEntity> = {
  name: 'Test Provider',
  state: State.ACTIVE,
  credentials: { username: 'a', password: 'b' },
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  providerType: ProviderType.ScraperCG,
};

describe('Given a ProviderController', () => {
  let merchantRepository: Repository<MerchantEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;

  let testApiKey: TestApiKeyUtil;
  let merchantTest: TestMerchantUtil;
  let merchant: MerchantEntity;
  let account: AccountEntity;
  let apiKey: string;

  beforeAll(async () => {
    merchantRepository = connection.getRepository(MerchantEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    merchantTest = await createTestMerchant();
    merchant = merchantTest.merchant;
    testApiKey = await createTestApiKey(merchant.id);
    apiKey = testApiKey.mockData.key;

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: merchant.id,
    });
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: merchant.id });
    await testApiKey.deleteApiKey();
    await merchantTest.deleteMerchant();
  });

  describe('When a user call GET /api/internal/providers/:id/scrapers', () => {
    it('then should return 401 status code if invalid credentials are provided', async () => {
      await supertest(app.getHttpServer())
        .get(`/internal/providers/1/scrapers`)
        .expect(401);
    });

    it('then should return 404 status code if the provider does not exists', async () => {
      await supertest(app.getHttpServer())
        .get(`/internal/providers/12130123001/scrapers`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });

    it('then should return providers that belong to other merchants', async () => {
      const otherMerchant = await merchantRepository.save({
        name: 'Other Merchant',
        identifier: randNumberString(),
      });

      const otherAccount = await accountRepository.save({
        ...createAccountDto,
        merchantId: otherMerchant.id,
      });

      const otherProvider = await providerRepository.save({
        ...createProviderDto,
        accountId: otherAccount.id,
      });

      await supertest(app.getHttpServer())
        .get(`/internal/providers/${otherProvider.id}/scrapers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      await providerRepository.delete({ accountId: otherAccount.id });
      await accountRepository.delete({ id: otherAccount.id });
      await merchantRepository.delete({ id: otherMerchant.id });
    });

    it('then should return 404 status code if the providerType is not "scraperPW" or "scraperCG"', async () => {
      const provider = await providerRepository.save({
        ...createProviderDto,
        providerType: ProviderType.Minka,
        accountId: account.id,
      });

      await supertest(app.getHttpServer())
        .get(`/internal/providers/${provider.id}/scrapers`)
        .set('X-API-KEY', apiKey)
        .expect(404);
    });

    it('then should return a scraper provider', async () => {
      const provider = await providerRepository.save({
        ...createProviderDto,
        accountId: account.id,
      });

      const response = await supertest(app.getHttpServer())
        .get(`/internal/providers/${provider.id}/scrapers`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toBeDefined();
      expect(response.body.credentials).toBeDefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/api/internal/transactionsController.e2e-spec.ts
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { DeviceService } from 'src/services/device/device.service';
import { TransferFirebreakService } from 'src/services/transfer-firebreak/transfer-firebreak.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { plainToClass } from 'class-transformer';
import { ASCENDING_ORDER } from 'src/database/query.constants';
import { randUuid } from '@ngneat/falso';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { UserRole } from 'src/common/enums/user-role.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { createTestApiKey, TestApiKeyUtil } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

const trackingCode = 'transactionsController';
const totalTransfers = 3;

const createBankAccessDto: Partial<BankAccessEntity> = {
  bankCode: 'cl_banco_bci',
  name: 'Base BankAccess',
  state: State.ACTIVE,
};

const createTransferMethodDto = {
  identifier: '123456789542',
  methodType: TransferMethodType.CARD,
};

const createPayoutDto: Partial<CreatePayoutDto> = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  merchantId: undefined,
  currency: Currency.CHILE,
  trackingCode,
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
};

const createTransferDto: Partial<CreateTransferDto> = {
  amount: 100,
  currency: Currency.CHILE,
  concept: 'Testing',
  trackingCode,
  destinationHolderId: '120123123',
  destinationName: 'oblandon',
  destinationAccount: '1201231',
  destinationBankCode: 'cl_banco_falabella',
  destinationPhone: '001239912312',
  merchantId: undefined,
  payoutId: undefined,
  providerId: undefined,
  version: EntityVersion.v2,
  state: TransferState.ASSIGNED,
};

const createAccountDto: Partial<CreateAccountDto> = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  merchantId: undefined,
  state: State.ACTIVE,
};
const createProviderDto: CreateProviderDto = {
  name: 'Test Provider',
  credentials: null,
  rules: null,
  providerType: ProviderType.Minka,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  accountId: undefined,
  priority: 1,
  state: State.ACTIVE,
};

describe('Given a TransactionsController', () => {
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let transferMethodRepository: Repository<TransferMethodEntity>;
  let bankAccessRepository: Repository<BankAccessEntity>;
  let authorizationCodeRepository: Repository<AuthorizationCodeEntity>;

  let apiKey: string;
  let account: AccountEntity;
  let provider: ProviderEntity;
  let payout: PayoutEntity;
  let bankAccess: BankAccessEntity;
  let transferMethod: TransferMethodEntity;
  let testMerchant: TestMerchantUtil;
  let createdApiKey: TestApiKeyUtil;
  let testUser: TestUserWithTokenUtil;
  beforeAll(async () => {
    bankAccessRepository = connection.getRepository(BankAccessEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    transferMethodRepository = connection.getRepository(TransferMethodEntity);
    authorizationCodeRepository = connection.getRepository(
      AuthorizationCodeEntity,
    );
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    createdApiKey = await createTestApiKey(testMerchant.merchant.id);
    testUser = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });

    apiKey = createdApiKey.mockData.key;

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: testMerchant.merchant.id,
    });

    provider = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: testMerchant.merchant.id,
    });

    const transfers = Array(totalTransfers)
      .fill({ ...createTransferDto })
      .map((createTransferDto: CreateTransferDto) =>
        transferRepository.create({
          ...createTransferDto,
          payoutId: payout.id,
          providerId: provider.id,
          merchantId: testMerchant.merchant.id,
        }),
      );

    await transferRepository.save(transfers);

    bankAccess = await bankAccessRepository.save({
      ...createBankAccessDto,
      merchantId: testMerchant.merchant.id,
    });

    transferMethod = await transferMethodRepository.save({
      ...createTransferMethodDto,
      merchantId: testMerchant.merchant.id,
      bankAccessId: bankAccess.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete(payout.id);
    await providerRepository.delete(provider.id);
    await accountRepository.delete(account.id);
    await authorizationCodeRepository.delete({
      transferMethodId: transferMethod.id,
    });
    await transferMethodRepository.delete(transferMethod.id);
    await bankAccessRepository.delete(bankAccess.id);
    await createdApiKey.deleteApiKey();
    await testUser.deleteUser();
    await testMerchant.deleteMerchant();
  });

  describe('When a user calls GET /internal/transactions', () => {
    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .get(`/internal/transactions?providerId=${provider.id}`)
        .expect(401);
    });

    it('then should return transactions from other merchants', async () => {
      const newMerchant = await createTestMerchant();

      const newApiKey = await createTestApiKey(newMerchant.merchant.id);

      const newTransfer = await transferRepository.save({
        ...createTransferDto,
        trackingCode: randUuid(),
        payoutId: payout.id,
        providerId: provider.id,
        merchantId: newMerchant.merchant.id,
        state: TransferState.ASSIGNED,
      });

      const response = await request(app.getHttpServer())
        .get(`/internal/transactions?providerId=${provider.id}`)
        .set('X-API-KEY', newApiKey.mockData.key)
        .expect(200);

      expect(response.body).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            id: newTransfer.id,
          }),
        ]),
      );
    });

    it('then should return the transactions for the specified provider', async () => {
      const response = await request(app.getHttpServer())
        .get(`/internal/transactions?providerId=${provider.id}`)
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(totalTransfers);
      expect(response.body[0].originBankAcess).toBeUndefined();
    });

    it('then should return the transactions for the specified provider filtered by state', async () => {
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        merchantId: testMerchant.merchant.id,
        state: TransferState.PROCESSING,
      });

      const response = await request(app.getHttpServer())
        .get(
          `/internal/transactions?providerId=${provider.id}&state=${TransferState.PROCESSING}`,
        )
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(1);
    });

    it('then should return the transactions for the specified provider arranged in ascending order', async () => {
      const sort = ASCENDING_ORDER;
      await transferRepository.save({
        ...createTransferDto,
        trackingCode: randUuid(),
        payoutId: payout.id,
        providerId: provider.id,
        merchantId: testMerchant.merchant.id,
        state: TransferState.ASSIGNED,
      });
      await transferRepository.save({
        ...createTransferDto,
        trackingCode: randUuid(),
        payoutId: payout.id,
        providerId: provider.id,
        merchantId: testMerchant.merchant.id,
        state: TransferState.ASSIGNED,
      });

      const response = await request(app.getHttpServer())
        .get(
          `/internal/transactions?providerId=${provider.id}&state=${TransferState.ASSIGNED}&sort=${sort}`,
        )
        .set('X-API-KEY', apiKey)
        .expect(200);
      const transactions = response.body;

      const sortedTransactions = [...transactions].sort((a, b) => a.id - b.id);
      expect(transactions).toStrictEqual(sortedTransactions);
    });

    it('then should return a specific transaction for a given provider', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        merchantId: testMerchant.merchant.id,
        state: TransferState.PROCESSING,
      });

      const response = await request(app.getHttpServer())
        .get(
          `/internal/transactions?providerId=${provider.id}&transferId=${transfer.id}`,
        )
        .set('X-API-KEY', apiKey)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].id).toEqual(transfer.id);
    });
  });

  describe('when a user calls POST /api/internal/transactions/firebreak', () => {
    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .post('/internal/transactions/firebreak')
        .expect(401);
    });

    it('then should return 400 status code if invalid dto is provided', async () => {
      const transactionDto = {
        currency: Currency.CHILE,
        providerId: 1,
        state: TransferState.PROCESSING,
      };

      await request(app.getHttpServer())
        .post('/internal/transactions/firebreak')
        .set('X-API-KEY', apiKey)
        .send(transactionDto)
        .expect(400);
    });

    it('then should return 200 status code', async () => {
      jest
        .spyOn(TransferFirebreakService.prototype, 'validate')
        .mockReturnValue(Promise.resolve({ valid: true }));

      const transactionDto = plainToClass(TransactionDto, {
        amount: '100',
        currency: Currency.CHILE,
        providerId: 1,
        state: TransferState.PROCESSING,
      });

      await request(app.getHttpServer())
        .post('/internal/transactions/firebreak')
        .set('X-API-KEY', apiKey)
        .send(transactionDto)
        .expect(200);
    });
  });

  describe('when a user calls POST /api/internal/transactions/authorize', () => {
    const methodType = TransferMethodType.DIGIPASS;
    const wrongMethodType = TransferMethodType.CARD;

    beforeEach(async () => {
      await transferMethodRepository.update(transferMethod.id, {
        methodType,
      });
    });

    it('then should return 401 status code if invalid credentials are provided', async () => {
      await request(app.getHttpServer())
        .post('/internal/transactions/authorize')
        .send({
          bankAccessId: transferMethod.bankAccessId,
          transferMethodType: methodType,
        })
        .expect(401);
    });

    it("then should return 404 status code if the transferMethod doesn't exists for the provided BankAccess", async () => {
      await request(app.getHttpServer())
        .post('/internal/transactions/authorize')
        .set('X-API-KEY', apiKey)
        .send({
          bankAccessId: transferMethod.bankAccessId,
          transferMethodType: wrongMethodType,
        })
        .expect(404);
    });

    it('then should return 400 status code if an invalid dto is provided', async () => {
      await request(app.getHttpServer())
        .post('/internal/transactions/authorize')
        .set('X-API-KEY', apiKey)
        .send({
          transferMethodType: wrongMethodType,
        })
        .expect(400);
    });

    it('then should return 200 status code', async () => {
      jest
        .spyOn(DeviceService.prototype, 'requestDeviceCode')
        .mockReturnValue(Promise.resolve(true));

      await request(app.getHttpServer())
        .post('/internal/transactions/authorize')
        .set('X-API-KEY', apiKey)
        .send({
          bankAccessId: transferMethod.bankAccessId,
          transferMethodType: methodType,
        })
        .expect(200);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/setupDatabase.ts
import * as shell from 'shelljs';

const shellConfig = {
  silent: true,
};

function printLine(text: string): void {
  console.log(`\n${text}\n`);
}

export default function setupDatabase() {
  printLine('****** Database setup starting ******');
  return;
  printLine('[STEP 1] Drop database');
  shell.exec('pnpm db:drop:test');

  printLine('[STEP 2] Create database');
  shell.exec('pnpm db:create:test');

  printLine('[STEP 3] Migrate database');
  const migrateResult = shell.exec('pnpm db:migrate:test', shellConfig);

  if (migrateResult.code === 0) {
    console.log('Database migrated successfully');
  } else {
    return console.error('Database migration failed');
  }

  printLine('[STEP 4] Seed database');
  const seedResult = shell.exec('pnpm db:seed:test', shellConfig);

  if (seedResult.code === 0) {
    console.log('Database seeded successfully');
  } else {
    return console.error('Database seeding failed');
  }

  printLine('****** Database setup complete ******');
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/entityUtils.ts
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

export function createEntity<T>(entity: Partial<T>): T {
  const newEntity = new (entity.constructor as { new (): T })();
  Object.assign(newEntity, entity);
  return newEntity;
}

export function createAccountEntity(
  account: Partial<AccountEntity>,
): AccountEntity {
  const entity = new AccountEntity();
  Object.assign(entity, account);
  return entity;
}

export function createTransferEntity(
  transfer: Partial<TransferEntity>,
): TransferEntity {
  const entity = new TransferEntity();
  Object.assign(entity, transfer);
  return entity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/truncateDatabase.ts
import * as mysql from 'mysql2/promise';
import { parsePort } from '../../src/utils/string-methods.util';

const database = 'payments_engine_test';
const tablesToPreserve = ['migrations', 'bank'];
const tablesToTruncate = [];

export default async function truncateDatabase(env?): Promise<void> {
  const connectionName: string = env ? env : process.env.NODE_ENV;

  const connection = await mysql.createConnection({
    host: process.env.DATABASE_HOST ?? 'localhost',
    port: parsePort(process.env.DATABASE_PORT) ?? 3306,
    password: 'root',
    user: 'root',
    database,
  });

  if (connectionName === 'production') {
    throw new Error('Forbidden action for production environment');
  }

  if (connection) {
    try {
      // Disable foreign key checks
      await connection.query('SET FOREIGN_KEY_CHECKS = 0;');

      // Fetch the list of tables in the database
      const tables = await connection.query(`SHOW TABLES FROM ${database};`);

      if (!tables) {
        console.warn('No tables to truncate');
        return;
      }

      const tablesFromTest = tables[0];

      for (const key in tablesFromTest) {
        if (typeof tablesFromTest[key] === 'object') {
          tablesToTruncate.push(
            tablesFromTest[key].Tables_in_payments_engine_test,
          );
        }
      }
      const filteredTables = tablesToTruncate.filter(
        (table: string) => !tablesToPreserve.includes(table),
      );

      // Truncate each table
      for (const table of filteredTables) {
        console.log(`TRUNCATE TABLE ${table}`);
        await connection.query(`TRUNCATE TABLE ${table};`);
      }

      // Re-enable foreign key checks
      await connection.query('SET FOREIGN_KEY_CHECKS = 1;');

      console.log(
        `Database content for '${connectionName}' environment reset correctly.`,
      );
    } catch (error) {
      console.error(
        'An error occurred while truncating database:',
        error.message,
      );
    } finally {
      await connection.destroy();
    }
  } else {
    console.log(
      `Connection options not found for '${connectionName}' environment`,
    );
  }
}

truncateDatabase()
  .then(() => {
    // The script ended gracefully
  })
  .catch((err) => {
    // The script ended with errors
    console.log('The script ended with errors:', err.message);
  });


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/merchantTestUtils.ts
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { Repository } from 'typeorm';
import { connection } from 'test/app.setup';
import { randUuid } from '@ngneat/falso';

export interface TestMerchantUtil {
  merchant: MerchantEntity;
  merchantId: number;
  deleteMerchant: () => Promise<void>;
}

/**
 * Creates a test merchant entity for use in e2e tests.
 *
 * @example
 * ```
 * import { createTestMerchant } from './merchantTestUtils';
 *
 * describe('Some e2e test', () => {
 *   let testMerchant: TestMerchantUtil;
 *
 *   beforeAll(async () => {
 *     testMerchant = await createTestMerchant();
 *   });
 *
 *   afterAll(async () => {
 *     await testMerchant.deleteMerchant();
 *   });
 *
 *   it('should do something with the test merchant', async () => {
 *     // ... test implementation ...
 *   });
 * });
 * ```
 *
 * @returns A promise that resolves to a TestMerchantUtil object containing the created merchant entity and a cleanup function.
 */
export async function createTestMerchant(): Promise<TestMerchantUtil> {
  const merchantRepository: Repository<MerchantEntity> =
    connection.getRepository(MerchantEntity);

  // Create a new merchant entity
  const newMerchant = await merchantRepository.save({
    name: 'Test Merchant',
    identifier: randUuid(),
  });

  // protect id from object mutation
  const merchantId = newMerchant.id;

  // Utility function to delete the merchant
  const deleteMerchant = async () => {
    await merchantRepository.delete(merchantId);
  };

  return {
    merchantId,
    merchant: newMerchant,
    deleteMerchant,
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/loadTestSeedDump.ts
import 'tsconfig-paths/register';
import * as fs from 'fs';

import path = require('path');
import { getMysqlConnection } from './testUtils';

// Execute the SQL file
export async function loadTestSeedDump(): Promise<void> {
  return new Promise((resolve, reject) => {
    // Read the SQL file
    const fileLocation = path.join(__dirname, './test-seed-dump.sql');
    // Check if the SQL file exists
    console.log(fileLocation);
    if (!fs.existsSync(fileLocation)) {
      reject('SQL file not found');
      return;
    }

    console.log(`Found SQL file at: ${fileLocation}'`);

    const connection = getMysqlConnection();
    connection.connect((error) => {
      if (error) {
        reject('Error connecting to MySQL: ' + error.message);
        return;
      }

      const sqlFile = fs.readFileSync(fileLocation, 'utf8');

      if (sqlFile.trim() === '') throw new Error('SQL file is empty');

      connection.query(sqlFile, (err, _results) => err && reject(err));

      // Close the MySQL connection
      connection.end((err) => {
        if (err) {
          reject(err);
          return;
        } else {
          resolve();
        }
      });
    });
  });
}

loadTestSeedDump();


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/dumpDatabase.ts
// Create a MySQL connection
import * as fs from 'fs';
import mysqldump from 'mysqldump';
import path = require('path');

export async function dumpDatabase(): Promise<void> {
  console.log('Dumping database');

  const cacheDirectory = path.join(__dirname, '../../cache');

  if (!fs.existsSync(cacheDirectory)) {
    fs.mkdirSync(cacheDirectory);
  }
  mysqldump({
    connection: {
      host: process.env.DATABASE_HOST ?? 'localhost',
      port: parseInt(process.env.DATABASE_PORT) ?? 3306,
      password: 'root',
      user: 'root',
      database: 'payments_engine_test',
      charset: 'utf8mb4',
    },
    dumpToFile: `${cacheDirectory}/payments_engine_test.sql`,
  });
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/loadDatabaseDump.ts
import * as fs from 'fs';

import path = require('path');
import { getMysqlConnection } from './testUtils';

// Execute the SQL file
export async function loadDatabaseDump(): Promise<void> {
  return new Promise((resolve, reject) => {
    // Read the SQL file
    const fileLocation = path.join(
      __dirname,
      '../../cache/payments_engine_test.sql',
    );
    // Check if the SQL file exists
    console.log(fileLocation);
    if (!fs.existsSync(fileLocation)) {
      reject('SQL file not found');
      return;
    }

    console.log(`Found SQL file at: ${fileLocation}'`);

    const connection = getMysqlConnection();
    connection.connect((error) => {
      if (error) {
        reject('Error connecting to MySQL: ' + error.message);
        return;
      }

      const sqlFile = fs.readFileSync(fileLocation, 'utf8');

      if (sqlFile.trim() === '') throw new Error('SQL file is empty');

      connection.query(sqlFile, (err, _results) => err && reject(err));

      // Close the MySQL connection
      connection.end((err) => {
        if (err) {
          reject(err);
          return;
        } else {
          resolve();
        }
      });
    });
  });
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/testUtils.ts
import * as mysql from 'mysql2';
import { randNumber } from '@ngneat/falso';

import { Environment } from 'src/common/enums/environment.enum';

export function getMysqlConnection(): mysql.Connection {
  const connection = mysql.createConnection({
    host: process.env.DATABASE_HOST ?? 'localhost',
    port: parseInt(process.env.DATABASE_PORT) ?? 3306,
    password: 'root',
    user: 'root',
    database: 'payments_engine_test',
    multipleStatements: true,
  });

  return connection;
}

export const changeEnv = (enviroment?: Environment) => {
  process.env['NODE_ENV'] = enviroment ?? Environment.PRODUCTION;
  process.env['SECURITY_KEY'] =
    '36d787deeaa212960d09ca77634407e2775dbf8530effb9e2416fe365dec267e';
  process.env['JWT_SECRET'] = 'jwt_secret_dev';
};

export const randNumberString = () =>
  randNumber({ min: 200, max: 2500 }).toString();


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/apiKeyTestUtils.ts
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { Repository } from 'typeorm';
import { nanoid } from 'nanoid';
import { connection } from 'test/app.setup';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { hashApiKey } from 'src/utils/hash-apiKey.util';

export interface TestApiKeyUtil {
  apiKey: ApiKeyEntity;
  mockData: {
    id: number;
    name: string;
    key: string;
    state: State;
    merchantId: number;
    role: UserRole;
  };
  deleteApiKey: () => Promise<void>;
}

/**
 * Creates a test API key entity for use in e2e tests.
 *
 * @param merchantId The ID of an existing merchant to associate with the API key.
 *                   It is the caller's responsibility to ensure that the merchant ID corresponds to an existing merchant in the database.
 * @example
 * ```
 * import { createTestApiKey } from './apiKeyTestUtils';
 *
 * describe('Some e2e test', () => {
 *   let testApiKey: TestApiKeyUtil;
 *
 *   beforeAll(async () => {
 *     testApiKey = await createTestApiKey(1); // Pass the merchant ID
 *   });
 *
 *   afterAll(async () => {
 *     await testApiKey.deleteApiKey();
 *   });
 *
 *   it('should authenticate with the test API key', async () => {
 *     // ... test implementation ...
 *   });
 * });
 * ```
 *
 * @returns A promise that resolves to a TestApiKeyUtil object containing the created API key entity and a cleanup function.
 */
export async function createTestApiKey(
  merchantId?: number,
  role?: UserRole,
): Promise<TestApiKeyUtil> {
  const apiKeyRepository: Repository<ApiKeyEntity> =
    connection.getRepository(ApiKeyEntity);

  const nanoKey = nanoid();
  const hashedKey = hashApiKey(nanoKey);

  const apiKey = await apiKeyRepository.save({
    name: 'Test API Key',
    key: hashedKey,
    state: State.ACTIVE,
    merchantId: merchantId,
    role: role ?? UserRole.SUPER,
  });
  const mockData = {
    key: nanoKey,
    id: apiKey.id,
    name: apiKey.name,
    role: apiKey.role,
    state: apiKey.state,
    merchantId: apiKey.merchantId,
  };

  const apiKeyId = apiKey.id;

  const deleteApiKey = async () => {
    await apiKeyRepository.delete(apiKeyId);
  };

  return {
    apiKey,
    mockData,
    deleteApiKey,
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/utils/userTestUtils.ts
import * as request from 'supertest';
import { app, connection } from 'test/app.setup';
import { UserRole } from 'src/common/enums/user-role.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { Repository } from 'typeorm';
import { randEmail, randFullName } from '@ngneat/falso';
import * as speakeasy from 'speakeasy';
import { changeEnv } from 'test/utils/testUtils';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { hash } from 'bcrypt';

export interface TestUserUtil {
  user: UserEntity;
  mockData: {
    email: string;
    password: string;
    seed?: string;
  };
  mfaCode: () => string;
  deleteUser: () => Promise<void>;
}

export interface TestUserWithTokenUtil extends TestUserUtil {
  token: string;
}

type PartialUserWithRole = Partial<UserEntity> & { role: UserRole };

interface CreateTestUserOptions {
  useMfa?: boolean;
  user: PartialUserWithRole;
}

/**
 * Asynchronously creates a test user in the database with specified role and other optional properties.
 * The function accepts an options object.
 *
 * @param options - An object containing the MFA usage flag, and user overrides including role.
 * @returns {Promise<TestUserUtil>} An object containing the created user entity, mock data, MFA code generation function (if applicable), and a user deletion function.
 */
export async function createTestUser({
  useMfa = false,
  user,
}: CreateTestUserOptions): Promise<TestUserUtil> {
  const userRepository: Repository<UserEntity> =
    connection.getRepository(UserEntity);

  // Create a new user
  const email = user.email ? user.email : randEmail();
  const password = user.password ? user.password : 'password';
  const hashedPassword = await hash(password, 10);
  const seed = useMfa
    ? speakeasy.generateSecret({ name: 'payouts-engine-mfa-name-dev' }).ascii
    : undefined;

  const newUser = await userRepository.save({
    ...user,
    email,
    password: hashedPassword,
    name: randFullName(),
    seed,
    mfa: useMfa,
    mfaState: useMfa ? MFAState.ENROLLED : MFAState.DISABLED,
  });

  const newUserId = newUser.id;

  const mfaCode = () =>
    speakeasy.totp({
      secret: newUser.seed,
      encoding: 'ascii',
    });

  // Utility function to delete the user
  const deleteUser = async () => {
    const userRepository: Repository<UserEntity> =
      connection.getRepository(UserEntity);
    await userRepository.delete(newUserId);
  };

  return {
    user: newUser,
    mockData: {
      email: email,
      password: password,
      seed: seed,
    },
    mfaCode,
    deleteUser,
  };
}

/**
 * Asynchronously creates a test user in the database with specified role and other optional properties.
 * Returns an object containing the user instance, mock data used for user creation, a JWT token for authentication,
 * a function to generate MFA code (if MFA is enabled), and a function to delete the user.
 *
 * @param role - The role to be assigned to the user.
 * @param useMfa - Flag to indicate whether Multi-Factor Authentication (MFA) should be enabled for the user. Defaults to false.
 * @param user - Optional parameters to override default user properties.
 *
 * @returns {Promise<TestUserWithTokenUtil>} An object containing the created user entity, mock data, JWT token,
 * MFA code generation function (if applicable), and a user deletion function.
 */
export const useTestUser = async (
  role: UserRole,
  useMfa = false,
  user: Partial<UserEntity> = {},
): Promise<TestUserWithTokenUtil> => {
  const testUser = await createTestUser({ useMfa, user: { role, ...user } });

  useMfa && changeEnv(Environment.PRODUCTION);

  // Login with the new user's credentials and MFA code
  const loginDto = {
    email: testUser.user.email,
    password: testUser.mockData.password,
    mfaCode: useMfa ? testUser.mfaCode() : undefined,
  };

  const response = await request(app.getHttpServer())
    .post('/v2/auth/login')
    .send(loginDto);

  useMfa && changeEnv(Environment.TEST);

  // Return the JWT token
  const token = response.body.token;

  return {
    ...testUser,
    token,
  };
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/app.setup.ts
import { DataSource } from 'typeorm';
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import configureApp from 'src/configure-app';
import { AppModule } from '../src/app.module';
import { ChangeAuditSubscriber } from 'src/database/subscribers/change-audit.subscriber';
import { ChangeAuditSubscriberMock } from 'src/database/subscribers/__mocks__/change-audit.subscriber.mock';

export let app: INestApplication;
export let connection: DataSource;

async function initServer() {
  if (app) await app.close();

  const moduleBuilder = Test.createTestingModule({
    imports: [AppModule],
  })
    .overrideProvider(ChangeAuditSubscriber)
    .useClass(ChangeAuditSubscriberMock);

  const module = await moduleBuilder.compile();

  app = module.createNestApplication();

  configureApp(app);

  await app.init();

  connection = app.get(DataSource);
}

async function closeServer() {
  if (app) {
    const connection = app.get(DataSource);
    await connection.destroy();
  }
}

global.beforeAll(async () => {
  await initServer();
});

global.afterAll(async () => {
  console.time();
  await closeServer();
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/worker.setup.ts
import { DataSource } from 'typeorm';
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { WorkersModule } from 'src/workers/workers.module';

export let workersApp: INestApplication;
export let workersConnection: DataSource;

async function initServer() {
  if (workersApp) await workersApp.close();

  const moduleBuilder = Test.createTestingModule({
    imports: [WorkersModule],
  });

  const module = await moduleBuilder.compile();

  workersApp = module.createNestApplication();

  await workersApp.init();

  workersConnection = workersApp.get(DataSource);
}

async function closeServer() {
  if (workersApp) {
    const connection = workersApp.get(DataSource);
    await connection.destroy();
  }
}

global.beforeAll(async () => {
  await initServer();
});

global.afterAll(async () => {
  console.time();
  await closeServer();
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/automatedPayoutActionService.e2e-spec.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutActionSuggestion } from 'src/common/enums/payout-action-suggestion.enum';
import { PayoutAction } from 'src/common/enums/payout-action.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutActionEntity } from 'src/models/payout-actions/entities/payout-action.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { AutomatedPayoutActionService } from 'src/services/automated-payout-action/automated-payout-action.service';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PayoutManagementService } from 'src/services/payout-management/payout-management.service';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given an AutomatedPayoutActionService', () => {
  let automatedPayoutActionService: AutomatedPayoutActionService;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payoutActionRepository: Repository<PayoutActionEntity>;

  let provider: ProviderEntity;
  let payout: PayoutEntity;
  let account: AccountEntity;

  let testMerchant: TestMerchantUtil;

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  const basePayout = {
    version: EntityVersion.v2,
    concept: 'Automated',
    amount: 1001,
    destinationEmail: 'automated@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    merchantId: undefined,
    currency: Currency.CHILE,
    trackingCode: '12312312',
    destinationPhone: '3212312312',
    state: PayoutState.PROCESSING,
  };

  const baseTransfer = {
    amount: 1000,
    concept: 'Authorizing transfer',
    currency: Currency.CHILE,
    destinationAccount: '268784803',
    destinationBankCode: 'cl_banco_bice',
    destinationPhone: '1234456434',
    destinationHolderId: '268784803',
    destinationName: 'Autotune',
    merchantId: undefined,
    payoutId: null,
    providerId: null,
    state: TransferState.CANCELED,
    trackingCode: '12312312',
    version: EntityVersion.v2,
  };

  const baseProvider = {
    name: 'Shinkansen Provider',
    credentials: {
      apiKey: 'apiKey',
      apiUrl: 'https://dev.shinkansen.finance/v1',
      certificate:
        'fgnlskdfngkljhdfkjghkdjsfgkjdfkgjkdsfgkdfgdsfgkdfsgkdsfgdskfjgkjdsfgkjdfgkjdksjfgkljsdfgbkjdfgkjdsfbgkjsdfgkjjdkfsgbkjreuitio3479682389gcjkxvkvjbre987yt4235876',
      privateKey:
        '39407523j234hjk562h3i8p54v89n7524n7d98346dm365d065342025346d023n50234n65c346n465d8065034256nddsfahfklsdioruq340-57-87[oirtjhlkhrjthi4[o597y90-8745y',
      createEndpoint: 'messages/payouts',
      getStatusEndpoint: 'transactions',
      algorithm: 'PS256',
      debtor: {
        name: 'Buk Spa',
        email: 'buk@buk.cl',
        identification: {
          id_schema: 'CLID',
          id: 'string',
        },
        financial_institution: {
          fin_id_schema: 'SHINKANSEN',
          fin_id: 'BANCO_BICE_CL',
        },
        account_type: 'current_account',
        account: '60000007',
      },
    },
    rules: {},
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.Shinkansen,
    accountId: null,
  };

  beforeAll(async () => {
    automatedPayoutActionService = app.get(AutomatedPayoutActionService);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    accountRepository = connection.getRepository(AccountEntity);
    payoutActionRepository = connection.getRepository(PayoutActionEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();

    baseAccount.merchantId = testMerchant.merchant.id;
    basePayout.merchantId = testMerchant.merchant.id;
    baseTransfer.merchantId = testMerchant.merchant.id;

    account = await accountRepository.save({ ...baseAccount });

    baseProvider.accountId = account.id;
    provider = await providerRepository.save({
      ...baseProvider,
    });
    payout = await payoutRepository.save({ ...basePayout });
  });

  afterEach(async () => {
    const merchantId = testMerchant.merchant.id;

    await transferRepository.delete({ merchantId });
    await payoutRepository.delete({ merchantId });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId });
    await payoutActionRepository.delete({});

    await testMerchant.deleteMerchant();
  });

  describe('when applyAutomatedAction is called', () => {
    let transfer: TransferEntity;

    // could be any code
    const transferErrorCode = TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS;

    beforeEach(async () => {
      await payoutRepository.update(
        { id: payout.id },
        {
          state: PayoutState.PROCESSING,
          metadata: null,
        },
      );

      transfer = await transferRepository.save({
        ...baseTransfer,
        state: TransferState.FAILED,
        payoutId: payout.id,
        providerId: provider.id,
        errorCode: transferErrorCode,
      });
    });

    describe('and a payoutAction with AUTO_CANCEL action matches a FAILED transfer errorCode', () => {
      beforeEach(async () => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValueOnce(Promise.resolve(true)) // CAN_APPLY_AUTOMATED_ACTION
          .mockReturnValue(Promise.resolve(false)); // CAN_USE_NEW_PAYOUT_CREATION

        await payoutActionRepository.save({
          errorCode: TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS,
          action: PayoutAction.AUTO_CANCEL,
          suggestion: null,
        });
      });

      it('then the Payout should be automatically canceled', async () => {
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.state).toBe(PayoutState.CANCELED);
      });

      it('then the Payout metadata should save the action applied', async () => {
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.metadata).toStrictEqual({
          action: PayoutAction.AUTO_CANCEL,
        });
      });
    });

    describe('and a payoutAction with AUTO_RETRY suggestion matches a FAILED transfer errorCode', () => {
      beforeEach(async () => {
        await payoutActionRepository.save({
          errorCode: TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS,
          suggestion: PayoutActionSuggestion.AUTO_RETRY,
          action: null,
        });
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true)); // CAN_APPLY_AUTOMATED_ACTION
      });

      it('then the Payout should NOT be canceled', async () => {
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.state).toBe(PayoutState.PROCESSING);
      });

      it('then the Payout metadata should save the action suggested', async () => {
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.metadata).toStrictEqual({
          action: PayoutActionSuggestion.AUTO_RETRY,
        });
      });

      it('then should not emit a Payout event', async () => {
        const emitMock = jest.spyOn(EventEmitter2.prototype, 'emit');

        const payoutUpdated =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(payoutUpdated.state).toEqual(PayoutState.PROCESSING);
        expect(payoutUpdated.metadata).toMatchObject({
          action: PayoutActionSuggestion.AUTO_RETRY,
        });
        expect(emitMock).not.toHaveBeenCalled();
      });
    });

    describe('and a there is a payoutAction with AUTO_RETRY action', () => {
      beforeEach(() => {
        jest
          .spyOn(PayoutManagementService.prototype, 'autoRetryLimit', 'get')
          .mockReturnValue(1);
      });

      it('then should retry the payout automatically if matches a FAILED transfer errorCode', async () => {
        await payoutActionRepository.save({
          errorCode: TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS,
          action: PayoutAction.AUTO_RETRY,
          suggestion: null,
        });

        const createdPayout = await payoutRepository.findOne({
          relations: ['transfers'],
          where: {
            id: payout.id,
          },
        });

        expect(createdPayout.transfers).toHaveLength(1);
        expect(createdPayout.transfers[0].state).toEqual(TransferState.FAILED);

        const mockEventEmitter = jest.spyOn(EventEmitter2.prototype, 'emit');
        mockEventEmitter.mockImplementation(jest.fn());
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValueOnce(Promise.resolve(true)) // CAN_APPLY_AUTOMATED_ACTION
          .mockReturnValue(Promise.resolve(false)); // CAN_USE_NEW_PAYOUT_CREATION
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.transfers).toHaveLength(2);

        expect(updatedPayout.transfers).toEqual(
          expect.arrayContaining([
            expect.objectContaining({ id: transfer.id }),
            expect.objectContaining({
              id: expect.any(Number),
              state: TransferState.PENDING,
              autoRetried: true,
            }),
          ]),
        );
      });

      it('then should not retry the payout automatically if not matches a FAILED transfer errorCode', async () => {
        await payoutActionRepository.save({
          errorCode: TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS,
          action: null,
          suggestion: null,
        });

        const createdPayout = await payoutRepository.findOne({
          relations: ['transfers'],
          where: {
            id: payout.id,
          },
        });
        expect(createdPayout.transfers).toHaveLength(1);
        expect(createdPayout.transfers[0].state).toEqual(TransferState.FAILED);

        // mock event emitter
        const mockEventEmitter = jest.spyOn(EventEmitter2.prototype, 'emit');

        mockEventEmitter.mockImplementation(jest.fn());

        await automatedPayoutActionService.applyAutomatedAction(transfer);

        const updatedPayout = await payoutRepository.findOne({
          relations: ['transfers'],
          where: {
            id: payout.id,
          },
        });

        expect(updatedPayout.transfers).toHaveLength(1);
        expect(updatedPayout.transfers).toEqual(
          expect.arrayContaining([
            expect.objectContaining({ id: transfer.id }),
          ]),
        );

        expect(updatedPayout.metadata).not.toEqual(
          expect.objectContaining({ action: expect.any(String) }),
        );
      });
      // it('then should retry the payout instead of apply a suggestion when both action and suggestion are present', async () => {});
    });

    describe('and a payoutAction with AUTO_CANCEL action matches a CANCELED transfer errorCode', () => {
      beforeEach(async () => {
        await payoutActionRepository.save({
          errorCode: TransferErrorCode.PROVIDER_INSUFFICIENT_FUNDS,
          suggestion: PayoutActionSuggestion.AUTO_RETRY,
          action: null,
        });

        await transferRepository.update(transfer.id, {
          state: TransferState.CANCELED,
        });
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValueOnce(Promise.resolve(true)); // CAN_APPLY_AUTOMATED_ACTION
      });

      it('then the Payout should NOT be canceled', async () => {
        const updatedPayout =
          await automatedPayoutActionService.applyAutomatedAction(transfer);

        expect(updatedPayout.state).toBe(PayoutState.PROCESSING);
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/providerService.e2e-spec.ts
import { ProviderService } from 'src/models/provider/provider.service';
import { app, connection } from '../app.setup';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { UpdateProviderDto } from 'src/api/v2/provider/dto/update-provider.dto';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { Repository } from 'typeorm';
import { State } from 'src/common/enums/state.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import {
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given ProviderService', () => {
  let providerService: ProviderService;

  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  const baseProvider: Partial<ProviderEntity> = {
    name: 'someProvider',
    providerType: ProviderType.Shinkansen,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    state: State.ACTIVE,
    accountId: undefined,
    credentials: { pass: 'pass', user: 'someUser' },
  };

  beforeAll(async () => {
    providerService = app.get<ProviderService>(ProviderService);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...baseAccount });
    baseProvider.accountId = account.id;

    provider = await providerRepository.save({ ...baseProvider });
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });
    await testMerchant.deleteMerchant();
  });

  describe('when some code execute findAll', () => {
    it('then ProviderService response with an array of ProviderEntity', async () => {
      const result = await providerService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });
  describe('when some code execute create', () => {
    it('then ProviderService response with ProviderEntity', async () => {
      const providerDto: CreateProviderDto = {
        name: 'HolaProvider',
        providerType: ProviderType.ScraperPW,
        accountId: account.id,
        credentials: {
          pass: 'holamundo',
          user: 'me',
        },
      };
      const result = await providerService.create(providerDto);
      expect(result.accountId).toEqual(account.id);
    });
  });
  describe('when some code execute update', () => {
    it('then ProviderService response with ProviderEntity and update only NOT undefined properties of UpdateProviderDto', async () => {
      const updateProviderDto: UpdateProviderDto = {
        state: State.INACTIVE,
      };
      const result = await providerService.update(
        provider.id,
        updateProviderDto,
      );
      expect(result.state).toBe(State.INACTIVE);
    });
    it('then ProviderService response with ProviderEntity and update all credential keys', async () => {
      const updateProviderDto: UpdateProviderDto = {
        state: State.INACTIVE,
        credentials: {
          pass: 'somePass',
        },
      };

      const result = await providerService.update(
        provider.id,
        updateProviderDto,
      );
      expect(result.state).toBe(State.INACTIVE);
      expect(Object.keys(result.credentials).length).toBe(
        Object.keys(updateProviderDto.credentials).length,
      );
    });
    it('then should throw UnprocessableEntityException if state is DELETED', async () => {
      const updateProviderDto: UpdateProviderDto = { state: State.DELETED };
      await expect(
        providerService.update(1, updateProviderDto),
      ).rejects.toThrow(UnprocessableEntityException);
    });

    it('then should throw NotFoundException if provider is not found', async () => {
      await expect(
        providerService.update(20, {} as UpdateProviderDto),
      ).rejects.toThrow(NotFoundException);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/accountStatementService.e2e-spec.ts
import { randUuid } from '@ngneat/falso';
import { FindManyOptions, In, Repository } from 'typeorm';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { buildAccountStatementQuery } from 'src/common/queries/accountStatement.query';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { AccountStatementService } from 'src/models/account-statement/account-statement.service';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';

import { app, connection } from '../app.setup';
import { QueryAccountStatementQueryDto } from 'src/api/v2/account-statement/dto/query-account-statement.dto';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given AccountStatementService', () => {
  let accountStatementService: AccountStatementService;
  let accountStatementRepository: Repository<AccountStatementEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;
  let accountRepository: Repository<AccountEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let accountStatementJob: AccountStatementJobEntity;

  const date = new Date().toISOString();
  const transactionCode = randUuid();
  const identifier = '45912391';

  const baseAccount = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier,
  };

  const baseAccountStatementJob = {
    endDate: new Date('2022-11-12T16:54:05.000Z'),
    startDate: new Date('2022-11-12T16:54:05.000Z'),
    state: AccountStatementJobState.STARTED,
    startedAt: new Date('2022-12-12T10:50:05.000Z'),
    endedAt: new Date('2022-12-12T10:55:05.000Z'),
    retrievedAt: new Date('2022-12-12T10:55:59.000Z'),
    totalRetrieved: 3,
    jobId: 'ABC123JobId',
    accountId: undefined,
  };

  const baseAccountStatement = {
    date,
    originBankCode: BankCode.BANCO_SANTANDER,
    originBankAccountIdentifier: identifier,
    concept: '114455164 pago Buk Adelantos',
    currency: Currency.CHILE,
    countryCode: CountryCode.CHILE,
    state: TransferState.COMPLETED,
    amount: 374000,
    transactionCode: transactionCode,
    destinationHolderId: '111111111',
    destinationName: 'Usuario Prueba',
    destinationAccount: '87654321',
    destinationEmail: 'user.test@bukadelantos.cl',
    destinationBankCode: BankCode.BANCO_CONSORCIO,
    retrievedAt: date,
    metadata: {
      status: 'Realizada',
      destinationBank: 'Banco de Chile',
    },
    accountStatementJobId: undefined,
  };

  beforeAll(async () => {
    accountStatementService = app.get(AccountStatementService);
    accountStatementRepository = connection.getRepository(
      AccountStatementEntity,
    );
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
    accountRepository = connection.getRepository(AccountEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    account = await accountRepository.save({
      ...baseAccount,
      merchantId: testMerchant.merchantId,
    });

    baseAccountStatementJob.accountId = account.id;

    accountStatementJob = await accountStatementJobRepository.save({
      ...baseAccountStatementJob,
    });

    baseAccountStatement.accountStatementJobId = accountStatementJob.id;
  });

  afterEach(async () => {
    const jobs = await accountStatementJobRepository.find({
      where: { accountId: account.id },
    });
    const jobIds = jobs.map((job) => job.id);

    await accountStatementRepository.delete({
      accountStatementJobId: In(jobIds),
    });
    await accountStatementJobRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('when some code execute createMany', () => {
    it('then it should create and save a new account statements', async () => {
      const transactionCode = randUuid();
      await accountStatementService.createMany([
        {
          ...baseAccountStatement,
          transactionCode,
          accountStatementJobId: accountStatementJob.id,
        },
      ]);

      const accountStatements = await accountStatementRepository.find();

      expect(accountStatements.length).toEqual(1);

      expect(accountStatements).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            id: expect.any(Number),
            amount: String(baseAccountStatement.amount.toFixed(2)),
            originBankCode: baseAccountStatement.originBankCode,
            date: new Date(baseAccountStatement.date),
            originBankAccountIdentifier:
              baseAccountStatement.originBankAccountIdentifier,
            concept: baseAccountStatement.concept,
            currency: baseAccountStatement.currency,
            countryCode: baseAccountStatement.countryCode,
            state: baseAccountStatement.state,
            destinationHolderId: baseAccountStatement.destinationHolderId,
            destinationName: baseAccountStatement.destinationName,
            destinationEmail: baseAccountStatement.destinationEmail,
            destinationBankCode: baseAccountStatement.destinationBankCode,
            accountStatementJobId: accountStatementJob.id,
            transactionCode,
          }),
        ]),
      );
    });

    it('then should update the accountStatementJobId for existing records', async () => {
      const newAccountStatementJob = await accountStatementJobRepository.save({
        ...baseAccountStatementJob,
        accountId: account.id,
      });

      const existingAccountStatement = await accountStatementRepository.save({
        ...baseAccountStatement,
        transactionCode: randUuid(),
        accountStatementJobId: accountStatementJob.id,
      });

      await accountStatementService.createMany([
        {
          ...baseAccountStatement,
          transactionCode: existingAccountStatement.transactionCode,
          accountStatementJobId: newAccountStatementJob.id,
        },
      ]);

      const accountStatements = await accountStatementRepository.find();

      expect(accountStatements).toHaveLength(1);

      const updatedAccountStatement = accountStatements[0];

      expect(updatedAccountStatement).toBeDefined();
      expect(updatedAccountStatement.accountStatementJobId).toEqual(
        newAccountStatementJob.id,
      );
    });

    it('then should update existing records and create new ones', async () => {
      const existingAccountStatement = await accountStatementRepository.save({
        ...baseAccountStatement,
        transactionCode: randUuid(),
        accountStatementJobId: accountStatementJob.id,
      });

      const newAccountStatementJob = await accountStatementJobRepository.save({
        ...baseAccountStatementJob,
        accountId: account.id,
      });

      await accountStatementService.createMany([
        {
          ...baseAccountStatement,
          transactionCode: existingAccountStatement.transactionCode,
          accountStatementJobId: newAccountStatementJob.id,
        },
        {
          ...baseAccountStatement,
          transactionCode: randUuid(),
          accountStatementJobId: accountStatementJob.id,
        },
      ]);

      const accountStatements = await accountStatementRepository.find();

      expect(accountStatements).toHaveLength(2);
    });
  });

  describe('when some code execute findAllPaginated', () => {
    it('then return default result array of accountStatements for specified originBankAccountIdentifier', async () => {
      await accountStatementRepository.save({
        ...baseAccountStatement,
        date: new Date().toISOString(),
        transactionCode: randUuid(),
        accountStatementJobId: accountStatementJob.id,
      });
      const query: QueryAccountStatementQueryDto = {
        originBankAccountIdentifier: account.identifier.toString(),
      };
      const options: FindManyOptions<AccountStatementEntity> =
        buildAccountStatementQuery(query);

      const result = await accountStatementService.findAllPaginated({
        page: 1,
        limit: 10,
        options,
      });
      const allAccountStatement = await accountStatementRepository.count();
      expect(result.data.length).toEqual(allAccountStatement);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/merchantService.e2e-spec.ts
import { MerchantService } from '../../src/models/merchant/merchant.service';
import { app } from '../app.setup';

describe('given MerchantService', () => {
  let merchantService: MerchantService;

  beforeAll(async () => {
    try {
      merchantService = app.get<MerchantService>(MerchantService);
    } catch (error) {
      console.log(error);
    }
  });
  describe('when some code execute findAll', () => {
    it('then MerchantService response with an array of MerchantEntity', async () => {
      const result = await merchantService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/webhookEndpointService.e2e-spec.ts
import { WebhookEndpointService } from '../../src/models/webhook-endpoint/webhook-endpoint.service';
import { app } from '../app.setup';

describe('given WebhookEndpointService', () => {
  let webhookEndpointService: WebhookEndpointService;

  beforeAll(async () => {
    try {
      webhookEndpointService = app.get<WebhookEndpointService>(
        WebhookEndpointService,
      );
    } catch (error) {
      console.log(error);
    }
  });
  describe('when some code execute findAll', () => {
    it('then WebhookEndpointService response with an array of WebhookEndpointEntity', async () => {
      const result = await webhookEndpointService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferFirebreakService.e2e-spec.ts
import { v4 as uuid } from 'uuid';
import { Repository } from 'typeorm';
import { app, connection } from 'test/app.setup';

import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { TransferFirebreakService } from 'src/services/transfer-firebreak/transfer-firebreak.service';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('Given a TransferFirebreakService', () => {
  let service: TransferFirebreakService;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;
  let payout: PayoutEntity;

  const trackingCode = 'transferFirebreakService';

  const createPayoutDto: CreatePayoutDto = {
    amount: 1001,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    merchantId: undefined,
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto: CreateTransferDto = {
    amount: 100,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode,
    destinationHolderId: '120123123',
    destinationName: 'oblandon',
    destinationAccount: '1201231',
    destinationBankCode: 'cl_banco_falabella',
    destinationPhone: '001239912312',
    merchantId: undefined,
    payoutId: undefined,
    providerId: undefined,
    version: EntityVersion.v2,
    state: TransferState.ASSIGNED,
  };

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    providerType: ProviderType.Minka,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const transactionDto: TransactionDto = {
    uuid: uuid(),
    amount: 100,
    currency: Currency.CHILE,
    providerId: undefined,
    state: TransferState.ASSIGNED,
    id: undefined,
  };

  beforeAll(async () => {
    service = app.get(TransferFirebreakService);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    createPayoutDto.merchantId = testMerchant.merchantId;
    createAccountDto.merchantId = testMerchant.merchantId;
    createTransferDto.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;

    provider = await providerRepository.save({ ...createProviderDto });
    createTransferDto.providerId = provider.id;

    payout = await payoutRepository.save({ ...createPayoutDto });
    createTransferDto.payoutId = payout.id;
  });

  afterEach(async () => {
    const merchantId = testMerchant.merchant.id;

    await transferRepository.delete({ merchantId });
    await payoutRepository.delete({ merchantId });

    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('When some code calls validate method', () => {
    it('then should return false if the provider does not exists', async () => {
      const validation = await service.validate({
        ...transactionDto,
        providerId: -1,
      });

      expect(validation).toEqual({
        message: 'No se encontró el proveedor especificado',
        valid: false,
      });
    });
    it('then should return false if the provider is not active', async () => {
      await providerRepository.update(
        { id: provider.id },
        { state: State.INACTIVE },
      );

      const validation = await service.validate({
        ...transactionDto,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: `El proveedor ${provider.id} se encuentra inactivo`,
        valid: false,
      });

      await providerRepository.update(
        { id: provider.id },
        { state: State.ACTIVE },
      );
    });
    it('then should return false if the account is not active', async () => {
      await accountRepository.update(
        { id: account.id },
        { state: State.INACTIVE },
      );

      const validation = await service.validate({
        ...transactionDto,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: `La cuenta ${account.id} se encuentra inactiva`,
        valid: false,
      });

      await accountRepository.update(
        { id: account.id },
        { state: State.ACTIVE },
      );
    });
    it('then should return false if cannot get trasfer updates', async () => {
      const validation = await service.validate({
        ...transactionDto,
        id: -1,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message:
          'No se pudo obtener la información actualizada de la transferencia',
        valid: false,
      });
    });
    it('then should return false if the transaction provider does not match', async () => {
      const provider2 = await providerRepository.save({
        ...createProviderDto,
        accountId: account.id,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        providerId: provider2.id,
        payoutId: payout.id,
      });

      const validation = await service.validate({
        ...transactionDto,
        id: transfer.id,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: `El proveedor de la transferencia no coincide con el esperado. Esperado '${provider.id}', Recibido: '${transfer.providerId}'`,
        valid: false,
      });

      await transferRepository.delete(transfer.id);
      await providerRepository.delete(provider2.id);
    });
    it('then should return false if the transaction state does not match', async () => {
      const updatedState = TransferState.PROCESSING;

      const transfer = await transferRepository.save({
        ...createTransferDto,
        providerId: provider.id,
        payoutId: payout.id,
      });

      const validation = await service.validate({
        ...transactionDto,
        id: transfer.id,
        state: updatedState,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: `El estado de la transferencia no coincide con el estado esperado. Esperado: '${updatedState}', Recibido: '${transfer.state}'`,
        valid: false,
      });
    });
    it('then should return false if the transaction currency does not match', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        currency: Currency.COLOMBIA,
        providerId: provider.id,
        payoutId: payout.id,
      });

      const validation = await service.validate({
        ...transactionDto,
        id: transfer.id,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: `No se puede procesar la transferencia, moneda inválida. Esperado: '${account.currency}', Recibdo: '${transactionDto.currency}'`,
        valid: false,
      });
    });
    it('then should return true', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        providerId: provider.id,
        payoutId: payout.id,
      });

      const validation = await service.validate({
        ...transactionDto,
        id: transfer.id,
        providerId: provider.id,
      });

      expect(validation).toEqual({
        message: 'La transferencia se ha validado exitosamente!',
        valid: true,
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferErrorService.e2e-spec.ts
import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import {
  MAPPED_ERROR_TYPE,
  TransferErrorCode,
} from 'src/models/transfer-error/error.definition.type';
import { TransferErrorService } from 'src/models/transfer-error/transfer-error.service';
import { app, connection } from 'test/app.setup';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { Repository } from 'typeorm';

describe('Given a TransferErrorService', () => {
  let transferErrorRepository: Repository<TransferErrorEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let service: TransferErrorService;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;

  const baseAccount = {
    name: 'Test account',
    bankCode: BankCode.BANCO_CONSORCIO,
    currency: Currency.CHILE,
    merchantId: undefined,
    holderId: '',
    identifier: '',
  };

  beforeAll(async () => {
    service = app.get(TransferErrorService);

    transferErrorRepository = connection.getRepository(TransferErrorEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    await transferErrorRepository.clear();
    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...baseAccount });
  });

  afterEach(async () => {
    await transferErrorRepository.clear();
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });
    await testMerchant.deleteMerchant();
  });

  describe('when some code executes findOrCreateError', () => {
    it('then should match and return an error', async () => {
      const expectedErrorCode =
        TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE;

      await transferErrorRepository.save([
        {
          errorCode: TransferErrorCode.DESTINATION_BANK_TIMEOUT,
          errorType: 'DESTINATION_BANK_TIMEOUT',
          errorRaw:
            'Estimado cliente, hemos tenido un inconveniente al procesar su transacción (Cód. SKT0804).',
        },
        {
          errorCode: expectedErrorCode,
          errorType: 'DESTINATION_BANK_IN_MAINTENANCE',
          errorRaw:
            'Estimado cliente, hemos tenido un inconveniente al procesar la transacción (Cód. SKT0804).',
        },
        {
          errorCode: TransferErrorCode.MERCHANT_LIMIT_EXCEED,
          errorType: 'MERCHANT_LIMIT_EXCEED',
          errorRaw:
            'Hemos tenido un inconveniente al procesar la transacción  (Cód. SKT0804).',
        },
      ]);

      const result = await service.findOrCreateError(
        'ESTIMADO CLIENTE, HEMOS TENIDO UN INCONVENIENTE AL PROCESAR LA TRANSACCIÓN (CÓD. SKT0804).',
      );

      expect(result).toEqual(
        expect.objectContaining({
          id: expect.any(Number),
          errorCode: expectedErrorCode,
          errorType: MAPPED_ERROR_TYPE[expectedErrorCode],
        }),
      );
    });

    it('then should save and return an unknown error', async () => {
      const errorRaw = 'Complete error';
      const error = await service.findOrCreateError(errorRaw);

      expect(error).toEqual(
        expect.objectContaining({
          id: expect.any(Number),
          errorRaw,
          errorCode: TransferErrorCode.UNKNOWN_ERROR,
          createdAt: expect.any(Date),
          updatedAt: expect.any(Date),
          uuid: expect.any(String),
          pattern: null,
          description: null,
          issuer: null,
        }),
      );
    });

    it('then should not duplicate errors that already exists', async () => {
      const expectedErrorCode = TransferErrorCode.RECIPIENT_FIRST_TRANSFER;

      await transferErrorRepository.save({
        errorCode: expectedErrorCode,
        errorRaw:
          'Estimado cliente, hemos tenido un inconveniente al procesar la transacción (Cód. SKT0804).',
      });

      const result = await service.findOrCreateError(
        'Estimado cliente, hemos tenido un inconveniente al procesar la transacción (Cód. SKT0804).',
      );

      expect(result.errorCode).toEqual(expectedErrorCode);

      const errors = await transferErrorRepository.find();

      expect(errors).toHaveLength(1);
    });

    it('then should not duplicate errors that match with patterns', async () => {
      const expectedErrorCode = TransferErrorCode.RECIPIENT_FIRST_TRANSFER;

      await transferErrorRepository.save({
        errorCode: expectedErrorCode,
        errorRaw:
          'Error: Shinkansen transaction 0c1deb94-36ab-4d3d-8950-12562399d1e3 failed after 4 attempts',
        pattern: `Error: Shinkansen transaction .* failed after 4 attempts`,
      });

      const result = await service.findOrCreateError(
        'Error: Shinkansen transaction 83216f8a-20ad-4588-b2e5-3a27c3e51b11 failed after 4 attempts',
      );

      expect(result.errorCode).toEqual(expectedErrorCode);

      const errors = await transferErrorRepository.find();

      expect(errors).toHaveLength(1);
    });
    it('then should save an error with externalErrorCode when provided', async () => {
      const expectedErrorCode = TransferErrorCode.RECIPIENT_FIRST_TRANSFER;
      const providerError = 'ETX_0';
      const createdError = await transferErrorRepository.save({
        errorCode: expectedErrorCode,
        errorRaw: 'Error with externalErrorCode',
        externalErrorCode: providerError,
      });

      const result = await service.findOrCreateError(
        'Another error',
        null,
        providerError,
      );
      const errors = await transferErrorRepository.find();
      expect(errors).toHaveLength(1);

      expect(result).toEqual(
        expect.objectContaining({
          id: createdError.id,
          errorCode: createdError.errorCode,
          externalErrorCode: createdError.externalErrorCode,
        }),
      );
    });
    it('then should save and error with providerId when provided', async () => {
      const expectedProviderErrorCode = 'SHK_0001';

      // Create provider
      const provider = await providerRepository.save({
        accountId: account.id,
        name: 'Test provider',
        capabilities: [ProviderCapability.CREATE_TRANSFER],
        providerType: ProviderType.Thomas,
      });

      const result = await service.findOrCreateError(
        'Another error',
        provider.providerType,
        expectedProviderErrorCode,
      );
      const errors = await transferErrorRepository.find();
      expect(errors).toHaveLength(1);

      expect(result).toEqual(
        expect.objectContaining({
          id: expect.any(Number),
          errorCode: TransferErrorCode.UNKNOWN_ERROR,
          externalErrorCode: expectedProviderErrorCode,
          providerType: provider.providerType,
        }),
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/apiKeyService.e2e-spec.ts
import { NotFoundException } from '@nestjs/common';
import { Errors } from 'src/common/enums/errors.enum';
import { State } from 'src/common/enums/state.enum';
import { ApiKeyService } from 'src/models/apikey/apikey.service';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { createTestApiKey, TestApiKeyUtil } from 'test/utils/apiKeyTestUtils';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { Repository } from 'typeorm';
import { app, connection } from '../app.setup';

describe('given ApiKeyService', () => {
  let apiKeyService: ApiKeyService;

  let apiKeyRepository: Repository<ApiKeyEntity>;
  let testMerchant: TestMerchantUtil;
  let createdApiKey: TestApiKeyUtil;
  beforeAll(async () => {
    try {
      apiKeyService = app.get(ApiKeyService);

      apiKeyRepository = connection.getRepository(ApiKeyEntity);
      testMerchant = await createTestMerchant();
      createdApiKey = await createTestApiKey(testMerchant.merchant.id);
    } catch (error) {
      console.log(error);
    }
  });
  afterAll(async () => {
    await createdApiKey.deleteApiKey();
    await testMerchant.deleteMerchant();
  });
  describe('when some code execute findOneByKey', () => {
    it('then it should return valid apiKey for correct api key', async () => {
      const rawKey = createdApiKey.mockData.key;
      const result = await apiKeyService.findOneByKey(rawKey);
      expect(result.id).toEqual(createdApiKey.apiKey.id);
    });
    it('then it should throw an NotFoundException for deleted state', async () => {
      const deletedApiKey = await apiKeyRepository.findOne({
        where: { state: State.DELETED },
      });
      try {
        await apiKeyService.findOneByKey(deletedApiKey.key);
      } catch (error) {
        expect(error instanceof NotFoundException).toBe(true);
        expect(error.message).toBe(
          `ApiKey with key ${deletedApiKey.key} not found`,
        );
        expect(error.response.statusCode).toBe(404);
        expect(error.response.error).toBe(Errors.NOT_FOUND);
      }
    });
    it('then it should throw an NotFoundException for inactive state', async () => {
      const inactiveApiKey = await apiKeyRepository.findOne({
        where: { state: State.INACTIVE },
      });
      try {
        await apiKeyService.findOneByKey(inactiveApiKey.key);
      } catch (error) {
        expect(error instanceof NotFoundException).toBe(true);
        expect(error.message).toBe(
          `ApiKey with key ${inactiveApiKey.key} not found`,
        );
        expect(error.response.statusCode).toBe(404);
        expect(error.response.error).toBe(Errors.NOT_FOUND);
      }
    });
  });

  describe('when some code execute findAll', () => {
    it('then AoiKeyService response with an array of ApiKeys', async () => {
      const result = await apiKeyService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferMethodService.e2e-spec.ts
import { TransferMethodService } from '../../src/models/transfer-method/transfer-method.service';
import { app } from '../app.setup';

describe('given TransferMethodService', () => {
  let transferMethodService: TransferMethodService;

  beforeAll(async () => {
    try {
      transferMethodService = app.get<TransferMethodService>(
        TransferMethodService,
      );
    } catch (error) {
      console.log(error);
    }
  });
  describe('when some code execute findAll', () => {
    it('then TransferMethodService response with an array of TransferMethodEntity', async () => {
      const result = await transferMethodService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/payoutManagementService.e2e-spec.ts
import {
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { MockProviderService } from 'src/providers/mock/mock-provider.service';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import { PayoutManagementService } from 'src/services/payout-management/payout-management.service';
import { TransferAssignmentNewService } from 'src/services/transfer-assignment/transfer-assignment.new.service';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { SlackService } from 'src/services/slack/slack.service';
import { app, connection } from 'test/app.setup';
import { Not, Repository } from 'typeorm';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { randNumberString } from 'test/utils/testUtils';
import { ProviderService } from 'src/models/provider/provider.service';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { TransferService } from 'src/models/transfer/transfer.service';

const trackingCode = 'payoutManagement';

const createMerchantDto: Partial<MerchantEntity> = {
  name: 'Base Merchant',
  identifier: randNumberString(),
};

const createPayoutDto = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  merchantId: null,
  currency: Currency.CHILE,
  trackingCode,
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
  state: PayoutState.PROCESSING,
};

const createTransferDto: CreateTransferDto = {
  amount: 1001,
  currency: Currency.CHILE,
  concept: 'Testing',
  trackingCode,
  destinationHolderId: '120123123',
  destinationName: 'oblandon',
  destinationAccount: '1201231',
  destinationBankCode: 'cl_banco_falabella',
  destinationPhone: '001239912312',
  merchantId: null,
  payoutId: undefined,
  providerId: undefined,
  version: EntityVersion.v2,
  state: TransferState.ASSIGNED,
};

const createAccountDto: CreateAccountDto = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  merchantId: null,
  state: State.ACTIVE,
};

const createProviderDto: CreateProviderDto = {
  name: 'Test Provider',
  credentials: null,
  rules: null,
  providerType: ProviderType.Shinkansen,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  accountId: undefined,
  priority: 1,
  state: State.ACTIVE,
};

describe('Given a PayoutManagementService', () => {
  let service: PayoutManagementService;
  let transferProviderService: TransferProviderService;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let merchantRepository: Repository<MerchantEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let eventEmitter: EventEmitter2;

  let account: AccountEntity;
  let provider: ProviderEntity;
  let _provider: ProviderEntity;
  let merchant: MerchantEntity;

  let getProviderAdapterSpy: jest.SpyInstance;
  let mockProviderServiceSpy: jest.SpyInstance;
  let transferProviderServiceSpy: jest.SpyInstance;

  const mockProviderService = new MockProviderService();

  beforeAll(async () => {
    service = app.get<PayoutManagementService>(PayoutManagementService);
    transferProviderService = app.get<TransferProviderService>(
      TransferProviderService,
    );
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    merchantRepository = connection.getRepository(MerchantEntity);

    merchant = await merchantRepository.save({ ...createMerchantDto });
    createAccountDto.merchantId = merchant.id;

    account = await accountRepository.save({ ...createAccountDto });

    createPayoutDto.merchantId = merchant.id;
    createProviderDto.accountId = account.id;
    provider = await providerRepository.save({ ...createProviderDto });
    _provider = await providerRepository.save({ ...createProviderDto });

    createTransferDto.providerId = provider.id;
    createTransferDto.merchantId = merchant.id;

    transferProviderServiceSpy = jest
      .spyOn(transferProviderService, 'createTransaction')
      .mockImplementation((_transfer: TransferEntity) => {
        return Promise.resolve();
      });
    eventEmitter = app.get(EventEmitter2);
  });

  beforeEach(async () => {
    getProviderAdapterSpy = jest
      .spyOn(ProviderService.prototype, 'getProviderAdapter')
      .mockReturnValue(mockProviderService);

    mockProviderServiceSpy = jest
      .spyOn(mockProviderService, 'canCancelTransaction')
      .mockReturnValue({ capable: true });

    jest
      .spyOn(SlackService.prototype, 'postMessage')
      .mockImplementation((_message) =>
        Promise.resolve({ success: true, response: undefined }),
      );

    jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
      return true;
    });

    await providerRepository.update(
      { id: provider.id },
      { providerType: ProviderType.Shinkansen, rules: null },
    );

    await accountRepository.update({ id: account.id }, { rules: null });
  });

  afterEach(async () => {
    mockProviderServiceSpy.mockRestore();

    await transferRepository.delete({ trackingCode });
    await payoutRepository.delete({ trackingCode });
    jest.clearAllMocks();
  });

  afterAll(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: merchant.id });

    getProviderAdapterSpy.mockRestore();
    transferProviderServiceSpy.mockRestore();
  });

  describe('when some code call the complete method', () => {
    // TODO: Remove `when using old complete method` test when feature flag CAN_USE_NEW_PAYOUT_CREATION is enabled
    describe('when using old complete method', () => {
      beforeEach(() => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(false));
      });
      it("then should fail if the payout doesn't exists", async () => {
        const payoutId = 9999;
        await expect(service.completePayout(payoutId)).rejects.toThrow(
          NotFoundException,
        );
      });
      it('then should fail if the payout is already completed', async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.COMPLETED,
        });

        await expect(service.completePayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it("then should fail if the payout entity version isn't v2", async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          version: EntityVersion.v1,
        });

        await expect(service.completePayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it("then should fail if the payout doesn't have any transfer", async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
        });

        await expect(service.completePayout(payout.id)).rejects.toThrow(
          `Payout with id ${payout.id} does not have any transfers`,
        );
      });
      it('then should fail if the provider throws a validation error', async () => {
        mockProviderServiceSpy = jest
          .spyOn(mockProviderService, 'canCompleteTransaction')
          .mockReturnValue({ capable: false });

        const payout = await payoutRepository.save({
          ...createPayoutDto,
        });

        await expect(service.completePayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it('then should complete the payout', async () => {
        const transfer = transferRepository.create({
          ...createTransferDto,
          state: TransferState.PROCESSING,
        });
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [transfer],
        });

        const result = await service.completePayout(payout.id);

        expect(result.state).toEqual(PayoutState.COMPLETED);
      });

      it('then should complete the payout last transfer', async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [
            { ...createTransferDto, state: TransferState.CANCELED },
            { ...createTransferDto, state: TransferState.FAILED },
          ],
        });

        await service.completePayout(payout.id);

        const payoutTransfers = await transferRepository.find({
          where: { payoutId: payout.id },
        });

        const [lastTransfer] = payoutTransfers.slice(-1);

        expect(lastTransfer.state).toEqual(TransferState.COMPLETED);
      });
    });
    describe('when using new complete method', () => {
      let payout: PayoutEntity;
      beforeEach(() => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true));
      });

      afterEach(async () => {
        await transferRepository.delete({ payoutId: payout.id });
        await payoutRepository.delete({ id: payout.id });
      });

      it("then should fail if the payout doesn't exists", async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.PROCESSING,
        });
        await payoutRepository.delete({ id: payout.id });
        const completeTransferSpy = jest
          .spyOn(PayoutNewService.prototype as any, 'completeTransfer')
          .mockImplementation(() => Promise.resolve({} as TransferEntity));

        await expect(
          service.completePayoutAndTransfer(payout.id, 9999),
        ).rejects.toThrow(
          new UnprocessableEntityException(
            'Pago no encontrado con dichos parámetro de búsqueda',
          ),
        );
        completeTransferSpy.mockRestore();
      });
      it('then should fail if the payout is already completed but still complete the transfer', async () => {
        getProviderAdapterSpy = jest
          .spyOn(MockProviderService.prototype, 'completableStates', 'get')
          .mockReturnValue([TransferState.PROCESSING]);

        payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.COMPLETED,
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.PROCESSING,
          payoutId: payout.id,
          providerId: provider.id,
        });
        await expect(
          service.completePayoutAndTransfer(payout.id, transfer.id),
        ).rejects.toThrow(
          new UnprocessableEntityException(
            `El pago ${payout.id} se encuentra en estado inválido`,
          ),
        );
        const updatedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        expect(updatedTransfer.state).toBe(TransferState.COMPLETED);
      });
      it("then should fail if the payout entity version isn't v2 but still complete the transfer", async () => {
        getProviderAdapterSpy = jest
          .spyOn(MockProviderService.prototype, 'completableStates', 'get')
          .mockReturnValue([TransferState.PROCESSING]);
        payout = await payoutRepository.save({
          ...createPayoutDto,
          version: EntityVersion.v1,
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.PROCESSING,
          payoutId: payout.id,
          providerId: provider.id,
        });
        await expect(
          service.completePayoutAndTransfer(payout.id, transfer.id),
        ).rejects.toThrow(
          new UnprocessableEntityException('La versión del pago no es v2'),
        );
        const completedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        expect(completedTransfer.state).toBe(TransferState.COMPLETED);
      });
      it("then should fail if the payout doesn't have any transfer", async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });

        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.PROCESSING,
          payoutId: payout.id,
          providerId: provider.id,
        });

        await transferRepository.delete({ id: transfer.id });

        await expect(
          service.completePayoutAndTransfer(payout.id, transfer.id),
        ).rejects.toThrow(
          'Payout completeness failed due transfer completeness failure',
        );
      });

      describe('when provider does allow to complete', () => {
        const cases = [TransferState.PROCESSING, TransferState.FAILED];
        beforeEach(() => {
          getProviderAdapterSpy = jest
            .spyOn(MockProviderService.prototype, 'completableStates', 'get')
            .mockReturnValue(cases);
        });

        it.each(cases)(
          "then should complete the payout if given transfer it's completable as it has %s state",
          async (state) => {
            payout = await payoutRepository.save({
              ...createPayoutDto,
            });

            const transfer = await transferRepository.save({
              ...createTransferDto,
              state,
              payoutId: payout.id,
              providerId: provider.id,
            });

            const serviceResult = await service.completePayoutAndTransfer(
              payout.id,
              transfer.id,
            );

            const completedTransfer = await transferRepository.findOneBy({
              payoutId: payout.id,
            });

            expect(completedTransfer.state).toEqual(TransferState.COMPLETED);
            expect(serviceResult.state).toEqual(PayoutState.COMPLETED);
          },
        );
      });
      describe('when provider does not allow to complete', () => {
        beforeEach(async () => {
          getProviderAdapterSpy = jest
            .spyOn(MockProviderService.prototype, 'completableStates', 'get')
            .mockReturnValue([TransferState.PROCESSING]);
        });

        const cases = [TransferState.COMPLETED, TransferState.CANCELED];
        it.each(cases)(
          'then should fail if given transfer has not completable state like %s',
          async (state) => {
            payout = await payoutRepository.save({
              ...createPayoutDto,
              state: PayoutState.PROCESSING,
            });

            const transfer = await transferRepository.save({
              ...createTransferDto,
              state,
              payoutId: payout.id,
              providerId: provider.id,
            });

            await expect(
              service.completePayoutAndTransfer(payout.id, transfer.id),
            ).rejects.toThrow(
              new UnprocessableEntityException(
                'Payout completeness failed due transfer completeness failure',
              ),
            );
          },
        );
      });
    });
  });
  describe('when some code call the cancel method', () => {
    // TODO: Remove `when using old cancel method` test when feature flag CAN_USE_NEW_PAYOUT_CREATION is enabled
    describe('when using old cancel method', () => {
      beforeEach(() => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(false));
      });
      it("then it should fail if the payout doesn't exists", async () => {
        await expect(service.cancelPayout(9999)).rejects.toThrow(
          NotFoundException,
        );
      });

      it('then should fail if the payout state is completed', async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.COMPLETED,
        });

        await expect(service.cancelPayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it("then should fail if the payout doesn't have any transfer", async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
        });

        await expect(service.cancelPayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it('then should fail if the entity version of the payout is not v2', async () => {
        const transfer = transferRepository.create({
          ...createTransferDto,
        });

        const payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.PROCESSING,
          version: EntityVersion.v1,
          transfers: [transfer],
        });

        await expect(service.cancelPayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it("then should fail if the provider can't cancel the transaction", async () => {
        mockProviderServiceSpy = jest
          .spyOn(mockProviderService, 'canCancelTransaction')
          .mockReturnValue({ capable: false });

        const transfer = transferRepository.create({
          ...createTransferDto,
          state: TransferState.COMPLETED,
        });

        const payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.PROCESSING,
          transfers: [transfer],
        });

        await expect(service.cancelPayout(payout.id)).rejects.toThrow(
          UnprocessableEntityException,
        );
      });

      it('then should cancel the payout', async () => {
        const transfer = transferRepository.create({
          ...createTransferDto,
          state: TransferState.FAILED,
        });

        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [transfer],
        });

        const result = await service.cancelPayout(payout.id);

        expect(result.state).toEqual(PayoutState.CANCELED);
      });

      it("then should cancel the payout's last transfer if its not failed", async () => {
        await providerRepository.update(
          { id: provider.id },
          { providerType: ProviderType.ScraperPW },
        );

        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [
            { ...createTransferDto, state: TransferState.CANCELED },
            { ...createTransferDto, state: TransferState.PROCESSING },
          ],
        });

        await service.cancelPayout(payout.id);

        const payoutTransfers = await transferRepository.findBy({
          payoutId: payout.id,
        });

        const [lastTransfer] = payoutTransfers.slice(-1);

        expect(lastTransfer.state).toEqual(TransferState.CANCELED);
      });

      it('then should cancel the payout even if last transfers does not have provider', async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [{ ...createTransferDto, state: TransferState.FAILED }],
        });
        const serviceResult = await service.cancelPayout(payout.id);

        const canceledPayout = await payoutRepository.findOneBy({
          id: payout.id,
        });

        expect(canceledPayout.state).toEqual(PayoutState.CANCELED);
        expect(serviceResult.state).toEqual(PayoutState.CANCELED);
      });
      it('then should not cancel the last transfer if failed', async () => {
        const payout = await payoutRepository.save({
          ...createPayoutDto,
          transfers: [
            { ...createTransferDto, state: TransferState.CANCELED },
            { ...createTransferDto, state: TransferState.FAILED },
          ],
        });

        await service.cancelPayout(payout.id);

        const payoutTransfers = await transferRepository.findBy({
          payoutId: payout.id,
        });

        const [lastTransfer] = payoutTransfers.slice(-1);

        expect(lastTransfer.state).toEqual(TransferState.FAILED);
      });
    });

    describe('when using new cancel method', () => {
      let payout: PayoutEntity;
      beforeEach(() => {
        jest
          .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
          .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION
      });

      afterEach(async () => {
        await transferRepository.delete({ payoutId: payout.id });
        await payoutRepository.delete({ id: payout.id });
        jest.restoreAllMocks();
      });

      it("then should fail if the payout doesn't exists", async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });

        await payoutRepository.delete({ id: payout.id });
        jest
          .spyOn(TransferService.prototype, 'findOneOrFail')
          .mockImplementation(() => Promise.resolve({} as TransferEntity));
        jest
          .spyOn(PayoutNewService.prototype, 'cancelTransfer')
          .mockImplementation(() => Promise.resolve({} as TransferEntity));

        await expect(
          service.cancelPayoutAndTransfer(9999, 9999999),
        ).rejects.toThrow(
          new UnprocessableEntityException(
            'Pago no encontrado con dichos parámetro de búsqueda',
          ),
        );
      });
      it('then should fail if transfer does not belong to payout', async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });
        const otherPayout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: randNumberString(),
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.PROCESSING,
          payoutId: payout.id,
          providerId: provider.id,
        });

        await expect(
          service.cancelPayoutAndTransfer(otherPayout.id, transfer.id),
        ).rejects.toThrow(
          new UnprocessableEntityException(
            'Payout cancellation failed due transfer cancellation failure',
          ),
        );
        await payoutRepository.delete({ id: otherPayout.id });
      });

      const cases = [
        PayoutState.COMPLETED,
        PayoutState.FAILED,
        PayoutState.CANCELED,
      ];
      it.each(cases)(
        'then should fail if the payout has finished state %s',
        async (state) => {
          payout = await payoutRepository.save({
            ...createPayoutDto,
            state,
          });
          const transfer = await transferRepository.save({
            ...createTransferDto,
            state: TransferState.FAILED,
            payoutId: payout.id,
            providerId: provider.id,
          });

          await expect(
            service.cancelPayoutAndTransfer(payout.id, transfer.id),
          ).rejects.toThrow(
            new UnprocessableEntityException(
              `El pago ${payout.id} se encuentra en estado inválido`,
            ),
          );
        },
      );

      it("then should fail if the payout doesn't have specified transfer", async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.FAILED,
          payoutId: payout.id,
          providerId: provider.id,
        });

        await transferRepository.delete({ id: transfer.id });

        await expect(
          service.cancelPayoutAndTransfer(payout.id, transfer.id),
        ).rejects.toThrow(
          new UnprocessableEntityException(`Transfer ${transfer.id} not found`),
        );
      });

      it('then should fail if the entity version of the payout is not v2', async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
          state: PayoutState.PROCESSING,
          version: EntityVersion.v1,
        });

        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.FAILED,
          payoutId: payout.id,
          providerId: provider.id,
        });

        await expect(
          service.cancelPayoutAndTransfer(payout.id, transfer.id),
        ).rejects.toThrow(
          new UnprocessableEntityException(
            'Payout cancellation failed due transfer cancellation failure',
          ),
        );
      });

      describe('when provider does allow to cancel', () => {
        const cases = [
          TransferState.PENDING,
          TransferState.PROCESSING,
          TransferState.FAILED,
        ];
        beforeEach(() => {
          getProviderAdapterSpy = jest
            .spyOn(MockProviderService.prototype, 'cancelableStates', 'get')
            .mockReturnValue([
              TransferState.PENDING,
              TransferState.PROCESSING,
              TransferState.FAILED,
            ]);
        });

        it.each(cases)(
          "then should cancel the payout if given transfer it's cancelable as it has %s state",
          async (state) => {
            payout = await payoutRepository.save({
              ...createPayoutDto,
            });

            const transfer = await transferRepository.save({
              ...createTransferDto,
              state,
              payoutId: payout.id,
              providerId: provider.id,
            });

            const result = await service.cancelPayoutAndTransfer(
              payout.id,
              transfer.id,
            );

            const canceledTransfer = await transferRepository.findOneBy({
              payoutId: payout.id,
            });

            expect(canceledTransfer.state).toEqual(TransferState.CANCELED);
            expect(result.state).toEqual(PayoutState.CANCELED);
          },
        );
      });

      describe('when provider does not allow to cancel', () => {
        beforeEach(async () => {
          getProviderAdapterSpy = jest
            .spyOn(MockProviderService.prototype, 'cancelableStates', 'get')
            .mockReturnValue([TransferState.FAILED]);
        });
        const cases = [TransferState.PROCESSING];
        it.each(cases)(
          'then should fail if given transfer has not cancelable state like %s',
          async (state) => {
            payout = await payoutRepository.save({
              ...createPayoutDto,
              state: PayoutState.PROCESSING,
            });

            const transfer = await transferRepository.save({
              ...createTransferDto,
              state,
              payoutId: payout.id,
              providerId: provider.id,
            });

            await expect(
              service.cancelPayoutAndTransfer(payout.id, transfer.id),
            ).rejects.toThrow(
              new UnprocessableEntityException(
                'Payout cancellation failed due transfer cancellation failure',
              ),
            );
          },
        );
      });

      it('then should cancel the payout even if given transfer does not have provider', async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.ASSIGNED,
          payoutId: payout.id,
          providerId: null,
        });

        const serviceResult = await service.cancelPayoutAndTransfer(
          payout.id,
          transfer.id,
        );

        const canceledPayout = await payoutRepository.findOneBy({
          id: payout.id,
        });

        expect(canceledPayout.state).toEqual(PayoutState.CANCELED);
        expect(serviceResult.state).toEqual(PayoutState.CANCELED);
      });
      it('then should cancel the payout even if given transfer has canceled state', async () => {
        payout = await payoutRepository.save({
          ...createPayoutDto,
        });
        const transfer = await transferRepository.save({
          ...createTransferDto,
          state: TransferState.CANCELED,
          payoutId: payout.id,
          providerId: null,
        });

        const serviceResult = await service.cancelPayoutAndTransfer(
          payout.id,
          transfer.id,
        );

        const canceledPayout = await payoutRepository.findOneBy({
          id: payout.id,
        });

        expect(canceledPayout.state).toEqual(PayoutState.CANCELED);
        expect(serviceResult.state).toEqual(PayoutState.CANCELED);
      });
    });
  });

  describe('when some code call the new reassign method', () => {
    let payout: PayoutEntity;
    beforeEach(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION
      jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
        return true;
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
    });
    it("then should fail if the payout doesn't exists", async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
      });
      await payoutRepository.delete({ id: payout.id });
      await expect(
        service.newReassignPayout(payout.id, provider.id),
      ).rejects.toThrow(
        new UnprocessableEntityException(`Payout ${payout.id} not found`),
      );
    });
    it('then should fail if the payout is already completed', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.COMPLETED,
      });

      await expect(
        service.newReassignPayout(payout.id, provider.id),
      ).rejects.toThrow(
        new UnprocessableEntityException(
          `El pago ${payout.id} se encuentra en estado inválido`,
        ),
      );
    });
    it("then should fail if the payout entity version isn't v2", async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
      });

      await expect(
        service.newReassignPayout(payout.id, provider.id),
      ).rejects.toThrow(
        new UnprocessableEntityException('La versión del pago no es v2'),
      );
    });
    it('then should reassign a payout and keep state as processing', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(provider);

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
      });

      const [updatedPayout, createdTransfer] = await service.newReassignPayout(
        payout.id,
        provider.id,
      );

      expect(createdTransfer.state).toBe(TransferState.ASSIGNED);
      expect(createdTransfer.providerId).toBe(provider.id);
      expect(updatedPayout.state).toBe(PayoutState.PROCESSING);
    });
    it("then should create a new transfer even if the account rules aren't met", async () => {
      const amount = 1000;

      await accountRepository.update(
        { id: account.id },
        {
          rules: {
            type: 'amount',
            value: { gt: amount },
            operator: 'range',
          },
        },
      );

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const toBeCanceledTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
      });

      const [, newCreatedTransfer] = await service.newReassignPayout(
        payout.id,
        provider.id,
      );
      const canceledTransfer = await transferRepository.findOneBy({
        id: toBeCanceledTransfer.id,
      });
      expect(canceledTransfer.state).toBe(TransferState.CANCELED);
      expect(newCreatedTransfer).toBeDefined();
    });
    it("then should create a new transfer even if the provider rules aren't met", async () => {
      const amount = 1000;

      await providerRepository.update(
        { id: provider.id },
        {
          rules: {
            type: 'amount',
            value: { gt: amount },
            operator: 'range',
          },
        },
      );

      payout = await payoutRepository.save({
        ...createPayoutDto,
        amount,
      });

      const toBeCanceledTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
      });

      const [, createdTransfer] = await service.newReassignPayout(
        payout.id,
        provider.id,
      );
      const canceledTransfer = await transferRepository.findOneBy({
        id: toBeCanceledTransfer.id,
      });
      expect(canceledTransfer.state).toBe(TransferState.CANCELED);
      expect(createdTransfer).toBeDefined();
    });
    it('then should create a new transfer and update it to canceled if the are not capable provider', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(undefined);

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
      });

      const [, createdTransfer] = await service.newReassignPayout(
        payout.id,
        provider.id,
      );

      expect(createdTransfer.state).toBe(TransferState.CANCELED);
      expect(createdTransfer.providerId).toBeNull();
    });
    it('then should create a new transfer and update it to assigned if the are capable provider', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(provider);

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
      });

      const [, createdTransfer] = await service.newReassignPayout(payout.id);

      expect(createdTransfer.state).toBe(TransferState.ASSIGNED);
      expect(createdTransfer.providerId).toBe(provider.id);
    });
    it('then should cancel all payout transfers when all validations passed', async () => {
      const cancelableStates = [
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
      ];
      jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
        return true;
      });
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'cancelableStates', 'get')
        .mockReturnValue(cancelableStates);

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const cancelableTransfers = Array(2)
        .fill(createTransferDto)
        .map((createTransferDto: TransferEntity, index: number) =>
          transferRepository.create({
            ...createTransferDto,
            payoutId: payout.id,
            state: cancelableStates[index],
            providerId: provider.id,
          }),
        );
      await transferRepository.save(cancelableTransfers);

      await service.newReassignPayout(payout.id, provider.id);
      for (const transfer of cancelableTransfers) {
        const canceledTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        expect(canceledTransfer.state).toBe(TransferState.CANCELED);
      }
    });
    it('then should fail if any payout transfer its not cancelable', async () => {
      const cancelableStates = [];
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'cancelableStates', 'get')
        .mockReturnValue(cancelableStates);

      payout = await payoutRepository.save({
        ...createPayoutDto,
      });
      const transfers = Array(2)
        .fill(createTransferDto)
        .map((createTransferDto: TransferEntity) =>
          transferRepository.create({
            ...createTransferDto,
            payoutId: payout.id,
            state: TransferState.PROCESSING,
            providerId: provider.id,
          }),
        );

      await transferRepository.save(transfers);

      await expect(service.newReassignPayout(payout.id)).rejects.toThrow(
        new UnprocessableEntityException('Transfer cancellation failed'),
      );
      mockProviderServiceSpy.mockReset();
    });
    it('then should fail if you try to reassign an account funding payout', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        concept: 'Payout Funding',
        metadata: {
          message: 'Account Funding Payout',
        },
      });
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await expect(
        service.newReassignPayout(payout.id, provider.id),
      ).rejects.toThrow('Cannot reassign a account funding payout');
    });
  });

  // TODO: Remove `when some code call the old reassign method` test when feature flag CAN_USE_NEW_PAYOUT_CREATION is enabled
  describe('when some code call the old reassign method', () => {
    beforeEach(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(false)); // CAN_USE_NEW_PAYOUT_CREATION
    });
    it("then should fail if the payout doesn't exists", async () => {
      const payoutId = 9999;
      await expect(
        service.reassignPayout(payoutId, provider.id),
      ).rejects.toThrow(NotFoundException);
    });

    it('then should fail if the payout is already completed', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.COMPLETED,
      });
      await expect(
        service.reassignPayout(payout.id, provider.id),
      ).rejects.toThrow(UnprocessableEntityException);
    });

    it("then should fail if the payout entity version isn't v2", async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
      });

      await expect(
        service.reassignPayout(payout.id, provider.id),
      ).rejects.toThrow(UnprocessableEntityException);
    });

    it("then should fail if the payout doesn't have any transfer", async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await expect(
        service.reassignPayout(payout.id, provider.id),
      ).rejects.toThrow(UnprocessableEntityException);
    });

    it('then should fail if the provider is not capable of retrying transactions', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: false });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await expect(
        service.reassignPayout(payout.id, provider.id),
      ).rejects.toThrow(UnprocessableEntityException);
    });

    it("then should create a transfer even if the account rules aren't met", async () => {
      const amount = 1000;

      await accountRepository.update(
        { id: account.id },
        { rules: { type: 'amount', value: { gt: amount }, operator: 'range' } },
      );

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        amount,
      });

      const firstTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id, provider.id);

      const lastTransfer = await transferRepository.findOne({
        where: { payoutId: payout.id, id: Not(firstTransfer.id) },
      });

      expect(lastTransfer).toBeDefined();
    });

    it("then should create a transfer even if the provider rules aren't met", async () => {
      const amount = 1000;

      await providerRepository.update(
        { id: provider.id },
        { rules: { type: 'amount', value: { gt: amount }, operator: 'range' } },
      );

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        amount,
      });

      const firstTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id, provider.id);

      const lastTransfer = await transferRepository.findOne({
        where: { payoutId: payout.id, id: Not(firstTransfer.id) },
      });

      expect(lastTransfer).toBeDefined();
    });

    it('then should cancel the last transfer when all validations passed', async () => {
      const newProvider = await providerRepository.save({
        ...createProviderDto,
      });

      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.PROCESSING,
        message: 'test',
      });

      await service.reassignPayout(payout.id, newProvider.id);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it('then should not cancel the last transfer if it was already failed', async () => {
      const newProvider = await providerRepository.save({
        ...createProviderDto,
      });

      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id, newProvider.id);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.FAILED);
    });

    it('then should fail if you try to reassign an account funding payout', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        concept: 'Payout Funding',
        metadata: {
          message: 'Account Funding Payout',
        },
      });
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        'Cannot reassign a account funding payout',
      );
    });
  });

  describe('When some code call the new retry (reassign) method', () => {
    beforeEach(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(true)); // CAN_USE_NEW_PAYOUT_CREATION --<-<@
    });

    afterEach(() => {
      jest.clearAllMocks();
    });

    it('then should cancel all the previous transfers', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(provider);

      const payout = await payoutRepository.save({ ...createPayoutDto });

      const transfers = Array(3)
        .fill(createTransferDto)
        .map((item: CreateTransferDto) =>
          transferRepository.create({
            ...item,
            payoutId: payout.id,
            providerId: undefined,
          }),
        );

      await transferRepository.save(transfers);

      const [updatedPayout] = await service.newReassignPayout(payout.id);
      // --<--<@
      for (const transfer of transfers) {
        const updatedTransfer = updatedPayout.transfers.find(
          (t) => t.id === transfer.id,
        );

        expect(updatedTransfer.state).toEqual(TransferState.CANCELED);
      }
    });
    it('then should keep the payout as processing after retried it', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(provider);

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });

      await transferRepository.save({
        ...createTransferDto,
        providerId: undefined,
        payoutId: payout.id,
      });

      const [updatedPayout] = await service.newReassignPayout(payout.id);

      expect(updatedPayout.state).toEqual(PayoutState.PROCESSING);
    });
    it('then should not retry the payout if it is completed', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.COMPLETED,
      });

      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
      });

      await expect(service.newReassignPayout(payout.id)).rejects.toThrow(
        `El pago ${payout.id} se encuentra en estado inválido`,
      );
    });
    it('then should create and update a transfer to assigned state on successful retry', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(provider);

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await transferRepository.save({
        ...createTransferDto,
        state: TransferState.FAILED,
        payoutId: payout.id,
      });

      const [updatedPayout] = await service.newReassignPayout(payout.id);

      const assignedTransfers = updatedPayout.transfers.filter(
        (t) => t.state === TransferState.ASSIGNED,
      );

      expect(assignedTransfers).toHaveLength(1);
      expect(assignedTransfers[0].providerId).toBeDefined();
    });
    it('then should create and update a transfer to canceled state if there are not capable providers', async () => {
      jest
        .spyOn(TransferAssignmentNewService.prototype, 'findCapableProvider')
        .mockResolvedValueOnce(undefined);

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.FAILED,
      });

      const [updatedPayout] = await service.newReassignPayout(payout.id);

      const canceledTransfer = updatedPayout.transfers.find(
        (t) => t.id !== transfer.id,
      );
      expect(canceledTransfer).toBeDefined();
      expect(canceledTransfer.state).toBe(TransferState.CANCELED);
    });
  });
  describe('when some code call the old retry method', () => {
    beforeAll(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(false));
    });
    it("then should fail if the payout doesn't exists", async () => {
      const payoutId = 9999;
      await expect(service.reassignPayout(payoutId)).rejects.toThrow(
        NotFoundException,
      );
    });

    it('then should fail if the payout is already completed', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.COMPLETED,
      });
      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        UnprocessableEntityException,
      );
    });

    it("then should fail if the payout entity version isn't v2", async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
        version: EntityVersion.v1,
      });

      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        UnprocessableEntityException,
      );
    });

    it("then should fail if the payout doesn't have any transfer", async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        UnprocessableEntityException,
      );
    });

    it('then should fail if the provider is not capable of retrying transactions', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: false });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        UnprocessableEntityException,
      );
    });

    it("then should create a transfer even if the account rules aren't met", async () => {
      const amount = 1000;

      await accountRepository.update(
        { id: account.id },
        { rules: { type: 'amount', value: { gt: amount }, operator: 'range' } },
      );

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        amount,
      });

      const firstTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id);

      const lastTransfer = await transferRepository.findOne({
        where: { payoutId: payout.id, id: Not(firstTransfer.id) },
      });

      expect(lastTransfer).toBeDefined();
    });

    it("then should create a transfer even if the provider rules aren't met", async () => {
      const amount = 1000;

      await providerRepository.update(
        { id: provider.id },
        { rules: { type: 'amount', value: { gt: amount }, operator: 'range' } },
      );

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        amount,
      });

      const firstTransfer = await transferRepository.save({
        ...createTransferDto,
        amount,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id);

      const lastTransfer = await transferRepository.findOne({
        where: { payoutId: payout.id, id: Not(firstTransfer.id) },
      });

      expect(lastTransfer).toBeDefined();
    });

    it('then should cancel the last transfer when all validations passed', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.PROCESSING,
        message: 'test',
      });

      await service.reassignPayout(payout.id);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it('then should not cancel the last transfer if it was already failed', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await service.reassignPayout(payout.id);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.FAILED);
    });

    it('then should fail if you try to retry an account funding payout', async () => {
      mockProviderServiceSpy = jest
        .spyOn(mockProviderService, 'canRetryTransaction')
        .mockReturnValue({ capable: true });

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        concept: 'Payout Funding',
        metadata: {
          message: 'Account Funding Payout',
        },
      });
      await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        providerId: provider.id,
        state: TransferState.FAILED,
        message: 'test',
      });

      await expect(service.reassignPayout(payout.id)).rejects.toThrow(
        'Cannot reassign a account funding payout',
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/merchantLimitService.e2e-spec.ts
import { Repository } from 'typeorm';
import { app, connection } from '../app.setup';
import { CreateMerchantLimitDto } from 'src/api/v2/merchant-limit/dto/create-limit.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { State } from 'src/common/enums/state.enum';
import {
  MerchantLimitDefinition,
  MerchantLimitEntity,
} from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { MerchantLimitService } from 'src/models/merchant-limit/merchant-limit.service';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

const baseDefinition: MerchantLimitDefinition = {
  value: 1000,
  criteria: LimitCriteria.AMOUNT,
  currency: Currency.CHILE,
  scope: LimitScope.PERSON,
  aggregation: LimitAggregation.HOUR,
};

const baseMerchantLimit: Partial<MerchantLimitEntity> = {
  limitType: MerchantLimitType.RATE,
  limitDefinition: baseDefinition,
  state: State.ACTIVE,
  merchantId: undefined,
};

describe('given MerchantLimitService', () => {
  let service: MerchantLimitService;

  let merchantLimitRepository: Repository<MerchantLimitEntity>;

  let testMerchant: TestMerchantUtil;
  let merchant: MerchantEntity;

  beforeAll(async () => {
    service = app.get<MerchantLimitService>(MerchantLimitService);
    merchantLimitRepository = connection.getRepository(MerchantLimitEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    baseMerchantLimit.merchantId = merchant.id;
  });

  afterEach(async () => {
    await merchantLimitRepository.delete({ merchantId: merchant.id });
    await testMerchant.deleteMerchant();
  });

  describe('when some code execute findAll', () => {
    it('then MerchantService response with an array of MerchantEntity', async () => {
      const result = await service.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });

  describe('when some code execute create', () => {
    it('then it should thrown an error if merchant does not exist', async () => {
      const { limitType, limitDefinition } = baseMerchantLimit;

      await expect(
        service.create(-1, { limitType, limitDefinition }),
      ).rejects.toThrow();
    });
    it('then it should thrown an error if invalid dto is provided', async () => {
      const createLimitDto = {} as CreateMerchantLimitDto;

      await expect(service.create(1, createLimitDto)).rejects.toThrow();
    });
    it('then MerchantLimitService response with MerchantLimitEntity', async () => {
      const { limitType, limitDefinition } = baseMerchantLimit;

      const createdMerchantLimit = await service.create(merchant.id, {
        limitType,
        limitDefinition,
      });

      const { limitDefinition: definitionCreated } = createdMerchantLimit;

      expect(createdMerchantLimit).toBeInstanceOf(MerchantLimitEntity);
      expect(definitionCreated.value).toEqual(limitDefinition.value);
      expect(definitionCreated.criteria).toEqual(limitDefinition.criteria);
      expect(definitionCreated.currency).toEqual(limitDefinition.currency);
      expect(definitionCreated.scope).toEqual(limitDefinition.scope);
      expect(definitionCreated.aggregation).toEqual(
        limitDefinition.aggregation,
      );
      expect(definitionCreated).toEqual(limitDefinition);
    });
  });

  describe('when some code execute findAllForMerchant', () => {
    it('then it should thrown an error if merchant does not exist', async () => {
      await expect(service.findAllForMerchant(-99, {})).rejects.toThrow();
    });

    it('then MerchantLimitService response with an array of MerchantLimitEntity', async () => {
      await merchantLimitRepository.save({
        ...baseMerchantLimit,
        updatedAt: new Date(),
        merchantId: merchant.id,
      });

      const result = await service.findAllForMerchant(merchant.id, {});
      const allMerchantLimits = await merchantLimitRepository.count({
        where: { merchantId: merchant.id },
      });
      expect(result.itemCount).toEqual(allMerchantLimits);
    });
  });

  describe('when some code execute update', () => {
    let createdMerchantLimit: MerchantLimitEntity;
    beforeEach(async () => {
      const { limitType, limitDefinition } = baseMerchantLimit;
      createdMerchantLimit = await service.create(merchant.id, {
        limitType,
        limitDefinition,
      });
    });

    it('then it should thrown an error if merchant does not exist', async () => {
      const { limitDefinition } = baseMerchantLimit;

      await expect(
        service.update(1, -1, { limitDefinition }),
      ).rejects.toThrow();
    });

    it('then it should thrown an error if merchant limit does not exist', async () => {
      const { limitDefinition } = baseMerchantLimit;

      await expect(
        service.update(99, merchant.id, { limitDefinition }),
      ).rejects.toThrow();
    });

    it('then it should thrown an error if invalid dto is provided', async () => {
      const updateLimitDto = {} as CreateMerchantLimitDto;

      await expect(service.create(1, updateLimitDto)).rejects.toThrow();
    });
    it('then MerchantLimitService response with the updated MerchantLimitEntity', async () => {
      const updatedMerchantLimit = await service.update(
        createdMerchantLimit.id,
        merchant.id,
        {
          limitDefinition: {
            value: 1,
          },
        },
      );

      expect(updatedMerchantLimit).toBeInstanceOf(MerchantLimitEntity);
    });
    it('then MerchantLimitService update only value of limit definition as its given', async () => {
      const serviceResult = await service.update(
        createdMerchantLimit.id,
        merchant.id,
        {
          limitDefinition: {
            value: 1,
          },
        },
      );

      const updatedMerchantLimit = await merchantLimitRepository.findOne({
        where: { id: serviceResult.id },
      });
      const {
        limitDefinition: { value: updatedValue, ...nonUpdatedProperties },
        state,
      } = updatedMerchantLimit;
      const {
        limitDefinition: { value: oldValue, ...restOldLimit },
        state: oldState,
      } = createdMerchantLimit;
      const { limitDefinition: serviceLimitDefinition } = serviceResult;
      const { value } = serviceLimitDefinition;

      expect(updatedValue).toBe(1);
      expect(oldValue).not.toBe(value);
      expect(restOldLimit).toStrictEqual(nonUpdatedProperties);
      expect(oldState).toBe(state);
    });
    it('then MerchantLimitService update an inactive merchant limit into an active limit', async () => {
      const serviceResult = await service.update(
        createdMerchantLimit.id,
        merchant.id,
        {
          state: State.ACTIVE,
        },
      );
      const merchantLimit = await merchantLimitRepository.findOne({
        where: { id: serviceResult.id },
      });
      const { limitDefinition } = merchantLimit;
      const { state: oldState, limitDefinition: oldLimits } =
        createdMerchantLimit;
      const { state: newState } = serviceResult;

      expect(newState).toBe(State.ACTIVE);
      expect(oldState).toBe(State.INACTIVE);
      expect(oldState).not.toBe(newState);
      expect(oldLimits).toStrictEqual(limitDefinition);
    });
  });

  describe('when some code execute delete', () => {
    let createdMerchantLimit: MerchantLimitEntity;
    beforeEach(async () => {
      const { limitType, limitDefinition } = baseMerchantLimit;
      createdMerchantLimit = await service.create(merchant.id, {
        limitType,
        limitDefinition,
      });
    });
    it('then it should thrown an error if merchant does not exist', async () => {
      await expect(service.remove(1, -1)).rejects.toThrow();
    });
    it('then it should thrown an error if merchant limit does not exist', async () => {
      await expect(service.remove(99, merchant.id)).rejects.toThrow();
    });

    it('then MerchantLimitService response with MerchantLimitEntity', async () => {
      const serviceResult = await service.remove(
        createdMerchantLimit.id,
        merchant.id,
      );
      const deletedMerchantLimit = await service.findAll({
        where: {
          id: createdMerchantLimit.id,
        },
      });

      expect(serviceResult).toBeInstanceOf(MerchantLimitEntity);
      expect(serviceResult.deletedAt).toBeDefined();
      expect(deletedMerchantLimit).toHaveLength(0);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferReconciliationService.e2e-spec.ts
import { randAlphaNumeric } from '@ngneat/falso';
import { UnprocessableEntityException } from '@nestjs/common';
import { CreateAccountStatementDto } from 'src/api/v2/account-statement/dto/create-account-statement.dto';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { TransferMismatchDto } from 'src/api/v2/transfer/dto/transfer-mismatch.dto';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import {
  ENABLE_RECONCILIATION_ACCOUNTS,
  RECONCILIATION_SUPPORTED_BANKS,
  TransferReconciliationService,
} from 'src/services/transfer-reconciliation/transfer-reconciliation.service';
import { app, connection } from 'test/app.setup';
import { In, Repository } from 'typeorm';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import moment = require('moment');
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { Errors } from 'src/common/enums/errors.enum';
import { endOfDateISOString, startOfDateISOString } from 'src/utils/date-util';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('Given a TransferReConciliationService', () => {
  let service: TransferReconciliationService;
  let transferRepository: Repository<TransferEntity>;
  let accountStatementRepository: Repository<AccountStatementEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;
  let bankRepository: Repository<BankEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;
  let accountStatementJob: AccountStatementJobEntity;

  let testMerchant: TestMerchantUtil;

  const unsupportedBankCode = 'unsupported-bank';
  const trackingCode = 'testTransferReconciliationService';
  const destinationHolderId = '72024321K';
  const amount = 1000;
  const currentDate = new Date();

  const transferReconciliationDto = {
    startDate: startOfDateISOString(
      currentDate.toISOString(),
      CountryCode.CHILE,
    ),
    endDate: endOfDateISOString(currentDate.toISOString(), CountryCode.CHILE),
  };

  const createPayoutDto: CreatePayoutDto = {
    amount,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId,
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    merchantId: undefined,
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto: CreateTransferDto = {
    amount,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode,
    destinationHolderId,
    destinationName: 'oblandon',
    destinationAccount: '1201231',
    destinationBankCode: 'cl_banco_falabella',
    destinationPhone: '001239912312',
    merchantId: undefined,
    payoutId: undefined,
    providerId: undefined,
    version: EntityVersion.v2,
    state: TransferState.COMPLETED,
  };

  const createAccountStatementJobDto = {
    startDate: transferReconciliationDto.startDate,
    endDate: transferReconciliationDto.endDate,
    state: AccountStatementJobState.FINISHED,
    createdAt: moment(currentDate).add(1, 'day').toISOString(),
    accountId: undefined,
    totalRetrieved: 3,
    jobId: 'ABC123JobId',
  };

  const createAccountStatementDto: Partial<AccountStatementEntity> = {
    date: currentDate,
    originBankCode: BankCode.BANCO_SANTANDER,
    originBankAccountIdentifier: ENABLE_RECONCILIATION_ACCOUNTS[0], // Take one supported
    concept: '114455164 pago Buk Adelantos',
    currency: Currency.CHILE,
    countryCode: CountryCode.CHILE,
    state: TransferState.COMPLETED,
    amount,
    accountStatementJobId: undefined,
    transactionCode: '20221211130208435349',
    destinationHolderId,
    destinationName: 'Usuario Prueba',
    destinationAccount: '87654321',
    destinationEmail: 'user.test@bukadelantos.cl',
    destinationBankCode: BankCode.BANCO_CONSORCIO,
    metadata: {
      status: 'Realizada',
      destinationBank: 'Banco de Chile',
    },
  };

  const createAccountDto: CreateAccountDto = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: ENABLE_RECONCILIATION_ACCOUNTS[0],
    holderId: '122334123',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    providerType: ProviderType.Minka,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const createTransfers = (
    qty: number,
    override?: Partial<TransferEntity>,
  ): TransferEntity[] => {
    return Array(qty)
      .fill(createTransferDto)
      .map((createTransferDto: CreateTransferDto) =>
        transferRepository.create({
          ...createTransferDto,
          payoutId: payout.id,
          providerId: provider.id,
          state: TransferState.COMPLETED,
          finishedAt: currentDate,
          ...override,
        }),
      );
  };

  const createAccountStatements = (
    qty: number,
    override?: Partial<AccountStatementEntity>,
  ): AccountStatementEntity[] => {
    return Array(qty)
      .fill(createAccountStatementDto)
      .map((createAccountStatementDto: CreateAccountStatementDto) =>
        accountStatementRepository.create({
          ...createAccountStatementDto,
          transactionCode: randAlphaNumeric({ length: 9 }).toString(),
          ...override,
        }),
      );
  };

  const expectArray = (
    received: Partial<{ id: number }>[],
  ): { toEqual: (expected: Partial<{ id: number }>[]) => void } => ({
    toEqual(expected) {
      received.forEach((value) => {
        expect(expected).toEqual(
          expect.arrayContaining([expect.objectContaining({ id: value.id })]),
        );
      });
    },
  });

  beforeAll(async () => {
    service = app.get(TransferReconciliationService);
    accountStatementRepository = connection.getRepository(
      AccountStatementEntity,
    );
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    accountRepository = connection.getRepository(AccountEntity);
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
    providerRepository = connection.getRepository(ProviderEntity);
    bankRepository = connection.getRepository(BankEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();

    const merchantId = testMerchant.merchantId;
    createAccountDto.merchantId = merchantId;
    createPayoutDto.merchantId = merchantId;
    createTransferDto.merchantId = merchantId;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;
    createAccountStatementJobDto.accountId = account.id;

    provider = await providerRepository.save({
      ...createProviderDto,
    });
    createTransferDto.providerId = provider.id;

    payout = await payoutRepository.save({ ...createPayoutDto });
    createTransferDto.payoutId = payout.id;

    accountStatementJob = await accountStatementJobRepository.save({
      ...createAccountStatementJobDto,
    });

    createAccountStatementDto.accountStatementJobId = accountStatementJob.id;
  });

  afterEach(async () => {
    const accounts = await accountRepository.find({
      where: { merchantId: testMerchant.merchantId },
    });
    const accountIds = accounts.map((account) => account.id);

    const jobs = await accountStatementJobRepository.find({
      where: { accountId: In(accountIds) },
    });
    const jobIds = jobs.map((job) => job.id);

    await accountStatementRepository.delete({
      accountStatementJobId: In(jobIds),
    });
    await accountStatementJobRepository.delete({ accountId: In(accountIds) });
    await transferRepository.delete({ merchantId: testMerchant.merchantId });
    await payoutRepository.delete({ merchantId: testMerchant.merchantId });
    await providerRepository.delete({ accountId: In(accountIds) });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await bankRepository.delete({ code: unsupportedBankCode });

    await testMerchant.deleteMerchant();
  });

  describe('When some code executes the method "reconciliate"', () => {
    it('Then should return an array of TransferMismatchDto', async () => {
      const reconciliations = await service.reconciliate(
        transferReconciliationDto,
      );

      expect(reconciliations).toBeInstanceOf(Array<TransferMismatchDto>);
    });

    it('Then should return an empty array if there are not mismatch', async () => {
      const reconciliations = await service.reconciliate(
        transferReconciliationDto,
      );

      expect(reconciliations).toHaveLength(0);
    });

    describe('Supported bank and account identifier related', () => {
      let unsupportedAccount: AccountEntity;
      let unsupportedProvider: ProviderEntity;
      let unsupportedBank: BankEntity;

      beforeEach(async () => {
        unsupportedBank = await bankRepository.save({
          code: unsupportedBankCode,
          name: 'Unsupported Bank',
          state: State.ACTIVE,
        });

        unsupportedAccount = await accountRepository.save({
          ...createAccountDto,
          bankCode: unsupportedBank.code,
        });

        unsupportedProvider = await providerRepository.save({
          ...createProviderDto,
          accountId: unsupportedAccount.id,
        });
      });

      it('Then should consider only reconciliation transfers/account-statements from enabled bank', async () => {
        const totalSupportedTransfers = 4;
        const totalAccountStatements = 2;

        const transfers = createTransfers(totalSupportedTransfers);
        const unsupportedBankTransfers = createTransfers(4, {
          providerId: unsupportedProvider.id,
        });

        const accountStatements = createAccountStatements(
          totalAccountStatements,
        );
        const unsupportedBankAccountStatements = createAccountStatements(2, {
          originBankCode: unsupportedBank.code,
        });

        await transferRepository.save(transfers);
        await transferRepository.save(unsupportedBankTransfers);
        await accountStatementRepository.save(accountStatements);
        await accountStatementRepository.save(unsupportedBankAccountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].amountMismatch).toEqual('2000.00');
        expect(reconciliations[0].diffCount).toEqual('2');
        expect(reconciliations[0].transfers).toHaveLength(
          totalSupportedTransfers,
        );
        expect(reconciliations[0].accountStatements).toHaveLength(
          totalAccountStatements,
        );

        // assert Ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });

      it('Then should consider only reconciliation transfers/account-statements from enabled account identifier', async () => {
        await accountRepository.update(unsupportedAccount.id, {
          bankCode: BankCode.BANCO_SANTANDER,
          identifier: 'unsupported-identifier',
        });

        const totalSupportedTransfers = 4;
        const totalAccountStatements = 2;

        const transfers = createTransfers(totalSupportedTransfers);
        const unsupportedIdentifierTransfers = createTransfers(4, {
          providerId: unsupportedProvider.id,
        });

        const accountStatements = createAccountStatements(
          totalAccountStatements,
        );
        const unsupportedBankAccountStatements = createAccountStatements(2, {
          originBankCode: unsupportedBank.code,
        });

        await transferRepository.save(transfers);
        await transferRepository.save(unsupportedIdentifierTransfers);
        await accountStatementRepository.save(accountStatements);
        await accountStatementRepository.save(unsupportedBankAccountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].amountMismatch).toEqual('2000.00');
        expect(reconciliations[0].diffCount).toEqual('2');
        expect(reconciliations[0].transfers).toHaveLength(
          totalSupportedTransfers,
        );
        expect(reconciliations[0].accountStatements).toHaveLength(
          totalAccountStatements,
        );

        // assert Ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });
    });

    it('Then should consider only transfers with v2 version', async () => {
      const totalSupportedTransfers = 4;
      const totalAccountStatements = 2;

      const transfers = createTransfers(totalSupportedTransfers);
      const unsupportedVersionTransfers = createTransfers(4, {
        version: EntityVersion.v1,
      });

      const accountStatements = createAccountStatements(totalAccountStatements);

      await transferRepository.save(transfers);
      await transferRepository.save(unsupportedVersionTransfers);
      await accountStatementRepository.save(accountStatements);

      const reconciliations = await service.reconciliate(
        transferReconciliationDto,
      );

      expect(reconciliations).toHaveLength(1);
      expect(reconciliations[0].amountMismatch).toEqual('2000.00');
      expect(reconciliations[0].diffCount).toEqual('2');
      expect(reconciliations[0].transfers).toHaveLength(
        totalSupportedTransfers,
      );
      expect(reconciliations[0].accountStatements).toHaveLength(
        totalAccountStatements,
      );

      // assert Ids
      expectArray(transfers).toEqual(reconciliations[0].transfers);
      expectArray(accountStatements).toEqual(
        reconciliations[0].accountStatements,
      );
    });

    it('Should throw an error when there is at least one account without account statement ', async () => {
      // TODO: Must test with multiple accounts after v2 migration
      const accounts = await accountRepository.find({
        where: {
          bankCode: In(RECONCILIATION_SUPPORTED_BANKS),
          identifier: In(ENABLE_RECONCILIATION_ACCOUNTS),
        },
      });

      const date = new Date('2020-01-01');
      const transferReConciliationDto = {
        startDate: moment(date).startOf('day').toISOString(),
        endDate: moment(date).endOf('day').toISOString(),
      };

      try {
        await service.reconciliate(transferReConciliationDto);
      } catch (error) {
        expect(error).toBeInstanceOf(UnprocessableEntityException);
        expect(error.response.error).toEqual(Errors.MISSING_ACCOUNT_STATEMENT);
        expect(error.response.message).toEqual(
          accounts.map((account) => account.name).toString(),
        );
      }
    });

    it('Should throw an error if there is one account that have an incomplete account statement', async () => {
      /**
       * Se pide la cartola para la fecha 18/09/2023
       * En la base de datos hay un registro de solicitud de cartola del 16/09/2023 al 18/09/2023 realizado el 18/09/2023 a las 11:34
       * La solicitud de conciliación es para el 18/09/2023 desde 00:00:00 a 23:59:59 UTC
       */
      expect.assertions(3);
      const targetDate = '2022-01-01';
      const transferReConciliationDto = {
        startDate: startOfDateISOString(targetDate, account.countryCode),
        endDate: endOfDateISOString(targetDate, account.countryCode),
      };

      const createdAtJob = moment(transferReConciliationDto.endDate)
        .subtract(1, 'h')
        .toISOString();

      const accountStatementJob = await accountStatementJobRepository.save({
        accountId: account.id,
        startDate: transferReConciliationDto.startDate,
        endDate: transferReConciliationDto.endDate,
        state: AccountStatementJobState.FINISHED,
        totalRetrieved: 10,
        createdAt: createdAtJob,
      });

      try {
        await service.reconciliate(transferReConciliationDto);
      } catch (error) {
        expect(error).toBeInstanceOf(UnprocessableEntityException);
        expect(error.response.error).toEqual(Errors.MISSING_ACCOUNT_STATEMENT);
        expect(error.response.message).toEqual(account.name);
      }

      await accountStatementJobRepository.delete({
        id: accountStatementJob.id,
      });
    });

    describe('And there are more account-statements than transfers', () => {
      it('Then should return the array mismatches when the amountMismatch is different from zero', async () => {
        const transfers = createTransfers(1);
        const accountStatements = createAccountStatements(2);

        await transferRepository.save(transfers);
        await accountStatementRepository.save(accountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].destinationHolderId).toEqual(
          destinationHolderId,
        );
        expect(reconciliations[0].amountMismatch).toEqual('1000.00');
        expect(reconciliations[0].diffCount).toEqual('1');
        expect(reconciliations[0].accountStatements).toHaveLength(2);
        expect(reconciliations[0].transfers).toHaveLength(1);

        // assert ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });

      it('Then should return the array mismatches when the amountMismatch is equal to zero', async () => {
        const accountStatements = createAccountStatements(2);
        const transfers = createTransfers(1, { amount: amount * 2 });

        await transferRepository.save(transfers);
        await accountStatementRepository.save(accountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].amountMismatch).toEqual('0.00');
        expect(reconciliations[0].diffCount).toEqual('1');

        expect(reconciliations[0].accountStatements).toHaveLength(2);
        expect(reconciliations[0].transfers).toHaveLength(1);

        // assert ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });
    });

    describe('And there are more transfers than account-statements', () => {
      it('Then should return the array mismatches when the amountMismatch is different from zero', async () => {
        const transfers = createTransfers(2);
        const accountStatements = createAccountStatements(1);

        await transferRepository.save(transfers);
        await accountStatementRepository.save(accountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].destinationHolderId).toEqual(
          destinationHolderId,
        );
        expect(reconciliations[0].amountMismatch).toEqual('1000.00');
        expect(reconciliations[0].diffCount).toEqual('1');
        expect(reconciliations[0].accountStatements).toHaveLength(1);
        expect(reconciliations[0].transfers).toHaveLength(2);

        // assert ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });

      it('Then should return the array mismatches when the amountMismatch is equal to zero', async () => {
        const accountStatements = createAccountStatements(1, {
          amount: amount * 2,
        });
        const transfers = createTransfers(2);

        await transferRepository.save(transfers);
        await accountStatementRepository.save(accountStatements);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(1);
        expect(reconciliations[0].destinationHolderId).toEqual(
          destinationHolderId,
        );
        expect(reconciliations[0].amountMismatch).toEqual('0.00');
        expect(reconciliations[0].diffCount).toEqual('1');

        expect(reconciliations[0].accountStatements).toHaveLength(1);
        expect(reconciliations[0].transfers).toHaveLength(2);

        // assert ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });

      it('Then should return the array mismatches when the amountMismatch is different from zero for multiple cases', async () => {
        const destinationHolderId2 = '1239123123';

        const accountStatements = createAccountStatements(1, {
          amount: amount * 2,
        });

        const accountStatementsCase2 = createAccountStatements(2, {
          destinationHolderId: destinationHolderId2,
        });
        const transfers = createTransfers(2);

        await transferRepository.save(transfers);
        await accountStatementRepository.save(accountStatements);
        await accountStatementRepository.save(accountStatementsCase2);

        const reconciliations = await service.reconciliate(
          transferReconciliationDto,
        );

        expect(reconciliations).toHaveLength(2);
        expect(reconciliations[0].destinationHolderId).toEqual(
          destinationHolderId,
        );
        expect(reconciliations[0].amountMismatch).toEqual('0.00');
        expect(reconciliations[0].diffCount).toEqual('1');

        expect(reconciliations[0].accountStatements).toHaveLength(1);
        expect(reconciliations[0].transfers).toHaveLength(2);

        expect(reconciliations[1].destinationHolderId).toEqual(
          destinationHolderId2,
        );
        expect(reconciliations[1].amountMismatch).toEqual('2000.00');
        expect(reconciliations[1].diffCount).toEqual('2');
        expect(reconciliations[1].transfers).toHaveLength(0);
        expect(reconciliations[1].accountStatements).toHaveLength(2);

        // assert ids
        expectArray(transfers).toEqual(reconciliations[0].transfers);
        expectArray(accountStatements).toEqual(
          reconciliations[0].accountStatements,
        );
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferService.e2e-spec.ts
import { Repository } from 'typeorm';
import { UnprocessableEntityException } from '@nestjs/common';
import { randUuid } from '@ngneat/falso';
import { EventEmitter2 } from '@nestjs/event-emitter';

import { app, connection } from 'test/app.setup';
import { TransferService } from '../../src/models/transfer/transfer.service';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { randNumberString } from 'test/utils/testUtils';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { LockMode } from 'src/common/enums/locks-mode.enum';

const trackingCode = randNumberString();

const createPayoutDto = {
  amount: 1000,
  destinationName: 'Test Transfer Service',
  destinationEmail: 'email@email.com',
  destinationAccount: '112301212',
  destinationHolderId: '123121212121',
  destinationBankCode: 'cl_banco_bice',
  destinationPhone: '56999695511',
  currency: Currency.CHILE,
  concept: 'Testing',
  trackingCode,
};

const createTransferDto: CreateTransferDto = {
  amount: 1000,
  destinationName: 'Test Transfer Service',
  destinationEmail: 'email@email.com',
  destinationAccount: '112301212',
  destinationHolderId: '123121212121',
  destinationBankCode: 'cl_banco_bice',
  destinationPhone: '56999695511',
  merchantId: null,
  currency: Currency.CHILE,
  concept: 'Testing',
  state: TransferState.ASSIGNED,
  trackingCode,
  payoutId: null,
  providerId: null,
};

describe('given TransferService', () => {
  let accountRepository: Repository<AccountEntity>;
  let transferService: TransferService;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let transferErrorRepository: Repository<TransferErrorEntity>;
  let providerRepository: Repository<ProviderEntity>;

  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;
  let merchant: MerchantEntity;
  let testMerchant: TestMerchantUtil;

  let mockEventEmitter;

  beforeAll(async () => {
    transferService = app.get<TransferService>(TransferService);
    accountRepository = connection.getRepository(AccountEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    transferErrorRepository = connection.getRepository(TransferErrorEntity);

    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    createTransferDto.merchantId = merchant.id;
  });

  beforeEach(async () => {
    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: merchant.id,
    });

    account = await accountRepository.save({
      bankCode: 'cl_banco_santander',
      countryCode: CountryCode.CHILE,
      currency: Currency.CHILE,
      name: 'Base Account',
      identifier: '123912391',
      state: State.ACTIVE,
      merchantId: merchant.id,
    });

    provider = await providerRepository.save({
      name: 'Test Provider',
      credentials: null,
      rules: null,
      providerType: ProviderType.ScraperPW,
      capabilities: [ProviderCapability.CREATE_TRANSFER],
      priority: 1,
      state: State.ACTIVE,
      accountId: account.id,
    });

    createTransferDto.payoutId = payout.id;
    mockEventEmitter = jest.spyOn(EventEmitter2.prototype, 'emit');
    mockEventEmitter.mockReturnValue(false);
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete({ id: payout.id });
    await providerRepository.delete({ id: provider.id });
    await accountRepository.delete({ id: account.id });
  });

  describe('when some code execute findAll', () => {
    it('then TransferService response with an array of transferService', async () => {
      const result = await transferService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });

  describe('when some code execute update', () => {
    it('then should throw an error if the transfer version is not v2', async () => {
      const transferDto = {
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v1,
        payoutId: payout.id,
        merchantId: merchant.id,
      };

      const transfer = await transferRepository.save({ ...transferDto });

      const promise = transferService.update(transfer.id, {
        state: TransferState.PROCESSING,
      });

      await expect(promise).rejects.toThrow(UnprocessableEntityException);
    });

    it('then should update the specified transfer object', async () => {
      const transferDto = {
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v2,
      };

      const transfer = await transferRepository.save({ ...transferDto });

      const updatedTransfer = await transferService.update(transfer.id, {
        state: TransferState.PROCESSING,
      });

      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer.state).toEqual(TransferState.PROCESSING);
      expect(mockEventEmitter).toHaveBeenCalledTimes(2);
    });

    it('then should update the error code correctly', async () => {
      const expectedErrorCode = TransferErrorCode.RECIPIENT_ACCOUNT_OVER_LIMIT;
      const errors = await transferErrorRepository.save([
        {
          errorCode: expectedErrorCode,
          errorRaw:
            'Error: Shinkansen transaction 0c1deb94-36ab-4d3d-8950-12562399d1e3',
          pattern: `^Error: Shinkansen transaction [0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$`,
          providerType: ProviderType.ScraperPW,
        },
        {
          errorCode: TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
          errorRaw: 'Banco destinatario se encuentra en mantenimiento',
        },
      ]);

      //
      const transfer = await transferRepository.save({
        ...createTransferDto,
        version: EntityVersion.v2,
      });

      const updatedTransfer = await transferService.update(transfer.id, {
        message: `Error: Shinkansen transaction ${randUuid()}`,
        state: TransferState.FAILED,
      });

      expect(updatedTransfer.errorCode).toEqual(expectedErrorCode);

      await transferErrorRepository.remove(errors);
    });
  });

  describe('when some code execute updateState', () => {
    it('then should fail if invalid state transition is provided', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
      });

      const promise = transferService.updateState(
        transfer.id,
        TransferState.COMPLETED,
      );
      await expect(promise).rejects.toThrow(UnprocessableEntityException);
    });

    it('then should update the transfer state', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
      });

      const updatedTransfer = await transferService.updateState(
        transfer.id,
        TransferState.ASSIGNED,
      );

      const { state } = transfer;
      const { state: newState } = updatedTransfer;

      expect(state).not.toBe(newState);
      expect(updatedTransfer.state).toEqual(TransferState.ASSIGNED);
    });

    it('should not emit any event', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
      });

      await transferService.updateState(transfer.id, TransferState.ASSIGNED);

      expect(eventEmitterSpy).toHaveBeenCalledTimes(0);
    });
  });

  // NEW METHODS
  describe('when some code executes assignTransfer', () => {
    it('should update the transfer from pending to assigned and emit TransferEvent.assigned', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
      });

      const queryRunner = connection.createQueryRunner();
      const manager = connection.manager;
      await queryRunner.startTransaction();
      const assignedTransfer = await transferService.assignTransfer(
        transfer,
        provider.id,
        manager,
      );

      await queryRunner.commitTransaction();
      await queryRunner.release();

      expect(assignedTransfer).toBeInstanceOf(TransferEntity);
      expect(assignedTransfer.trackingCode).toBe(payout.trackingCode);
      expect(assignedTransfer.payoutId).toBe(payout.id);
      expect(assignedTransfer.state).toBe(TransferState.ASSIGNED);
      expect(mockEventEmitter).toHaveBeenCalledWith(
        TransferEvent.ASSIGNED,
        expect.objectContaining({
          payoutId: payout.id,
          id: assignedTransfer.id,
          state: TransferState.ASSIGNED,
          providerId: provider.id,
        }),
      );
    });
    it('should fail transfer update if transfer does not have previous pending state', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.COMPLETED,
        version: EntityVersion.v2,
      });

      const queryRunner = connection.createQueryRunner();
      try {
        const manager = connection.manager;
        await queryRunner.startTransaction();
        await transferService.assignTransfer(transfer, provider.id, manager);
        await queryRunner.commitTransaction();
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        // new UnprocessableEntityException('Transfer assignment failed');
        await queryRunner.release();
      }
    });
  });

  describe.only('when some code executes createTransfer', () => {
    it.only('should create the new pending transfer and emit TransferEvent.created', async () => {
      const eventEmitterSpy = jest
        .spyOn(EventEmitter2.prototype, 'emit')
        .mockImplementation(() => true);

      jest.useFakeTimers();

      const queryRunner = connection.createQueryRunner();
      // Inicia una transacción con queryRunner
      await queryRunner.startTransaction();
      let createdTransfer;
      try {
        const manager = queryRunner.manager;

        createdTransfer = await transferService.createTransfer(payout, manager);

        await queryRunner.commitTransaction();
      } catch (error) {
        console.log('error: ', error);
        await queryRunner.rollbackTransaction();
      } finally {
        await queryRunner.release();
      }

      await queryRunner.commitTransaction();
      await queryRunner.release();
      expect(createdTransfer).toBeInstanceOf(TransferEntity);
      expect(createdTransfer.trackingCode).toBe(payout.trackingCode);
      expect(createdTransfer.payoutId).toBe(payout.id);
      expect(createdTransfer.state).toBe(TransferState.PENDING);
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        TransferEvent.CREATED,
        expect.objectContaining({
          payoutId: payout.id,
          id: createdTransfer.id,
          state: TransferState.PENDING,
        }),
      );
    });
    it('should NOT create transfer and NOT emit TransferEvent.CREATED', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transferDto = {
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v1,
        payoutId: payout.id,
        merchantId: merchant.id,
      };

      const transfer = await transferRepository.save({ ...transferDto });

      const queryRunner = connection.createQueryRunner();
      try {
        const manager = connection.manager;
        await queryRunner.startTransaction();
        await transferService.createTransfer(payout, manager);
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        // 'Payout has active transfers',
        await queryRunner.release();
      }

      expect(eventEmitterSpy).not.toHaveBeenCalled();
      await transferRepository.delete({ id: transfer.id });
    });
    it('should correctly handle concurrent transfer creations with locks to prevent race conditions', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transferDto = {
        ...createTransferDto,
        state: TransferState.CANCELED,
        version: EntityVersion.v1,
        payoutId: payout.id,
        merchantId: merchant.id,
      };

      const transfer = await transferRepository.save({ ...transferDto });

      const queryRunner = connection.createQueryRunner();
      const manager = connection.manager;
      await queryRunner.startTransaction();
      const createdTransfer = transferService.createTransfer(payout, manager);

      const createdTransferSecond = transferService.createTransfer(
        payout,
        manager,
      );
      await queryRunner.release();

      const result = await Promise.allSettled([
        createdTransfer,
        createdTransferSecond,
      ]);

      const fulfilledResults = result.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = result.filter(
        (result) => result.status === 'rejected',
      );

      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);
      const payoutUpdated = await payoutRepository.findOne({
        where: { id: payout.id },
      });
      expect(payoutUpdated.transfers.length).toBe(2);
      expect(eventEmitterSpy).toHaveBeenCalledTimes(1);
      await transferRepository.delete({ id: transfer.id });
    });
  });

  /**
  describe('when some code executes processTransfer', () => {
    // CHECK
    it('should update the transfer to processing and emit TransferEvent.processing', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v2,
      });

      const updatedTransfer = await transferService.processTransfer(
        transfer.id,
        { fromStates: [TransferState.ASSIGNED] },
      );

      expect(updatedTransfer).toBeDefined();
      expect(transfer.state).not.toBe(updatedTransfer.state);
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          trackingCode: payout.trackingCode,
          payoutId: payout.id,
          state: TransferState.PROCESSING,
        }),
      );
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        TransferEvent.PROCESSING,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.PROCESSING,
        }),
      );
    });
    it('should update the transfer to processing and update corresponding dto', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });

      const updatedTransfer = await transferService.processTransfer(
        transfer.id,
        {
          fromStates: [TransferState.ASSIGNED],
          metadata: {
            message: 'Update transfer to processing from test',
          },
        },
      );

      expect(updatedTransfer).toBeDefined();
      expect(transfer.state).not.toBe(updatedTransfer.state);
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          state: TransferState.PROCESSING,
          metadata: expect.objectContaining({
            message: 'Update transfer to processing from test',
            existingKey: 'existingValue',
          }),
        }),
      );
    });
    it('should fail if the transfer does not have a previous processable state', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
      });

      await expect(
        transferService.processTransfer(transfer.id, {
          fromStates: [TransferState.ASSIGNED],
        }),
      ).rejects.toThrow(
        new UnprocessableEntityException('Transfer process failed'),
      );

      const unchangedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });
      expect(unchangedTransfer.state).toBe(transfer.state);
    });
    it('should correctly handle concurrent processTransfer with locks to prevent race conditions', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v2,
      });

      const processTransfer = transferService.processTransfer(transfer.id, {
        fromStates: [TransferState.ASSIGNED],
        metadata: {
          message: 'Update transfer to processing from test',
        },
      });

      const processTransferSecond = transferService.processTransfer(
        transfer.id,
        {
          fromStates: [TransferState.ASSIGNED],
          metadata: {
            message: 'Update transfer to processing from test',
          },
        },
      );

      const result = await Promise.allSettled([
        processTransfer,
        processTransferSecond,
      ]);

      const fulfilledResults = result.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = result.filter(
        (result) => result.status === 'rejected',
      );

      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);

      expect(eventEmitterSpy).toHaveBeenCalledTimes(1);
      await transferRepository.delete({ id: transfer.id });
    });
  });
 */

  /**
  describe('when some code executes cancelTransfer', () => {
    it('should update the transfer to canceled and emit TransferEvent.canceled', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });

      const updatedTransfer = await transferService.cancelTransfer(
        transfer.id,
        { fromStates: [TransferState.PENDING] },
      );

      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer.state).not.toBe(transfer.state);
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          trackingCode: payout.trackingCode,
          payoutId: payout.id,
          state: TransferState.CANCELED,
        }),
      );
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        TransferEvent.CANCELED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.CANCELED,
        }),
      );
    });

    it('should update the transfer to canceled and update corresponding dto', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });

      const metadataDto: CancelTransferDto = {
        metadata: { message: 'Account Funding Payout' },
        message: 'Transferencia cancelada desde test',
        fromStates: [TransferState.PENDING],
      };

      const updatedTransfer = await transferService.cancelTransfer(
        transfer.id,
        metadataDto,
      );

      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          trackingCode: payout.trackingCode,
          state: TransferState.CANCELED,
          metadata: expect.objectContaining({
            message: metadataDto.metadata.message,
            existingKey: 'existingValue',
          }),
          message: metadataDto.message,
        }),
      );
    });

    it('should fail if the transfer does not have a previous cancelable state', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
      });

      const metadataDto: CancelTransferDto = {
        fromStates: [TransferState.PENDING],
      };

      await expect(
        transferService.cancelTransfer(transfer.id, metadataDto),
      ).rejects.toThrow(
        new UnprocessableEntityException('Transfer cancellation failed'),
      );
      expect(eventEmitterSpy).not.toHaveBeenCalled();
    });
  });
 */

  /**
  describe('when some code executes completeTransfer', () => {
    it('should update the transfer to complete and emit TransferEvent.completed', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });
      const updatedTransfer = await transferService.completeTransfer(
        transfer.id,
        { fromStates: [TransferState.PROCESSING] },
      );
      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          trackingCode: payout.trackingCode,
          payoutId: payout.id,
          state: TransferState.COMPLETED,
        }),
      );
      expect(transfer.state).not.toBe(updatedTransfer.state);
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        TransferEvent.COMPLETED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.COMPLETED,
        }),
      );
    });

    it('should update the transfer to complete and update corresponding dto', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });
      const metadataDto: CompleteTransferDto = {
        metadata: { message: 'Account Funding Payout' },
        fromStates: [TransferState.PROCESSING],
      };
      const updatedTransfer = await transferService.completeTransfer(
        transfer.id,
        metadataDto,
      );
      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          metadata: expect.objectContaining({
            message: metadataDto.metadata.message,
            existingKey: 'existingValue',
          }),
          state: TransferState.COMPLETED,
          message: 'Transferencia completada exitosamente',
        }),
      );
    });

    it('should fail if the transfer does not have a previous completable state', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        version: EntityVersion.v2,
      });
      const metadataDto: CancelTransferDto = {
        fromStates: [TransferState.PROCESSING],
      };
      await expect(
        transferService.completeTransfer(transfer.id, metadataDto),
      ).rejects.toThrow(
        new UnprocessableEntityException('Transfer completeness failed'),
      );
      expect(eventEmitterSpy).not.toHaveBeenCalled();
    });
    it('should correctly handle concurrent completeTransfer with locks to prevent race conditions', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });
      const processTransfer = transferService.completeTransfer(transfer.id, {
        fromStates: [TransferState.PROCESSING],
      });
      const processTransferSecond = transferService.completeTransfer(
        transfer.id,
        {
          fromStates: [TransferState.PROCESSING],
        },
      );
      const result = await Promise.allSettled([
        processTransfer,
        processTransferSecond,
      ]);
      const fulfilledResults = result.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = result.filter(
        (result) => result.status === 'rejected',
      );
      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);
      expect(eventEmitterSpy).toHaveBeenCalledTimes(1);
      await transferRepository.delete({ id: transfer.id });
    });
  });
  */

  /** 
  describe('when some code executes failTransfer', () => {
    it('should update the transfer from processing to failed and emit TransferEvent.failed', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });

      const updatedTransfer = await transferService.failTransfer(
        transfer.id,
        manager,
        {
          fromStates: [TransferState.PROCESSING],
        },
      );

      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          trackingCode: payout.trackingCode,
          payoutId: payout.id,
          state: TransferState.FAILED,
        }),
      );
      expect(transfer.state).not.toBe(updatedTransfer.state);
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        TransferEvent.FAILED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.FAILED,
        }),
      );
    });

    it('should fail if the transfer does not have a previous failable state', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.COMPLETED,
        version: EntityVersion.v2,
      });

      const metadataDto: FailTransferDto = {
        fromStates: [
          TransferState.PENDING,
          TransferState.ASSIGNED,
          TransferState.PROCESSING,
        ],
      };

      await expect(
        transferService.failTransfer(transfer.id, manager, metadataDto),
      ).rejects.toThrow(
        new UnprocessableEntityException('Transfer failure failed'),
      );
      expect(eventEmitterSpy).not.toHaveBeenCalled();
    });

    it('should add the transfer error code to the updated transfer and the emitted event', async () => {
      const expectedErrorCode = TransferErrorCode.RECIPIENT_DISABLED_ACCOUNT;

      jest.spyOn(transferErrorService, 'findOrCreateError').mockResolvedValue({
        errorRaw: 'Error: Cuenta de destino deshabilitada',
        errorCode: expectedErrorCode,
      } as TransferErrorEntity);

      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
      });

      const updatedTransfer = await transferService.failTransfer(
        transfer.id,
        manager,
        {
          fromStates: [TransferState.PROCESSING],
        },
      );
      // TODO: validar que el evento emitido tenga el error code

      expect(updatedTransfer.errorCode).toEqual(expectedErrorCode);
      expect(mockEventEmitter).toHaveBeenCalledWith(
        TransferEvent.FAILED,
        expect.objectContaining({
          id: transfer.id,
          state: TransferState.FAILED,
          errorCode: expectedErrorCode,
        }),
      );
    });
    it('should correctly handle concurrent failTransfer with locks to prevent race conditions', async () => {
      const eventEmitterSpy = jest.spyOn(EventEmitter2.prototype, 'emit');
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        version: EntityVersion.v2,
        metadata: {
          existingKey: 'existingValue',
        },
      });

      const processTransfer = transferService.failTransfer(
        transfer.id,
        manager,
        {
          fromStates: [TransferState.PROCESSING],
        },
      );

      const processTransferSecond = transferService.failTransfer(
        transfer.id,
        manager,
        {
          fromStates: [TransferState.PROCESSING],
        },
      );

      const result = await Promise.allSettled([
        processTransfer,
        processTransferSecond,
      ]);

      const fulfilledResults = result.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = result.filter(
        (result) => result.status === 'rejected',
      );

      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);

      expect(eventEmitterSpy).toHaveBeenCalledTimes(1);
      await transferRepository.delete({ id: transfer.id });
    });
  });
  */
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/merchantLimitEvaluatorService.e2e-spec.ts
import * as moment from 'moment';
import { Repository } from 'typeorm';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { State } from 'src/common/enums/state.enum';
import {
  MerchantLimitDefinition,
  MerchantLimitEntity,
} from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { MerchantLimitEvaluatorService } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.service';
import { app, connection } from 'test/app.setup';
import { randNumberString } from 'test/utils/testUtils';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

const baseDefinition: MerchantLimitDefinition = {
  value: 4000,
  criteria: LimitCriteria.AMOUNT,
  currency: Currency.CHILE,
  scope: LimitScope.PERSON,
  aggregation: LimitAggregation.HOUR,
};

const createPayoutDto = {
  state: PayoutState.COMPLETED,
  amount: 1000,
  currency: Currency.CHILE,
  concept: 'Payout Test 0009',
  trackingCode: 'nowWhere009',
  metadata: null,
  destinationEmail: 'test@test.com',
  destinationName: 'SuperMan',
  destinationHolderId: '174035229',
  destinationAccount: '19991285700',
  destinationBankCode: 'cl_banco_santander',
  merchantId: undefined,
  destinationPhone: null,
  version: EntityVersion.v2,
  errorCode: null,
  message: null,
  transfers: [],
};

const baseMerchantLimit: Partial<MerchantLimitEntity> = {
  limitType: MerchantLimitType.RATE,
  limitDefinition: baseDefinition,
  state: State.ACTIVE,
};

describe('Given a MerchantLimitEvaluatorService', () => {
  let service: MerchantLimitEvaluatorService;

  let merchantLimitRepository: Repository<MerchantLimitEntity>;
  let payoutRepository: Repository<PayoutEntity>;

  let getUtcDate: jest.SpyInstance;

  let testMerchant: TestMerchantUtil;
  let merchant: MerchantEntity;
  let payout: PayoutEntity;

  beforeAll(async () => {
    service = app.get<MerchantLimitEvaluatorService>(
      MerchantLimitEvaluatorService,
    );
    merchantLimitRepository = connection.getRepository(MerchantLimitEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
  });

  beforeEach(async () => {
    getUtcDate = jest.spyOn(
      service as unknown as {
        getUtcDate: MerchantLimitEvaluatorService['getUtcDate'];
      },
      'getUtcDate',
    );

    testMerchant = await createTestMerchant();
    merchant = testMerchant.merchant;
    createPayoutDto.merchantId = merchant.id;
    baseMerchantLimit.merchantId = merchant.id;
  });

  afterEach(async () => {
    await merchantLimitRepository.delete({ merchantId: merchant.id });
    await payoutRepository.delete({ merchantId: merchant.id });
    await testMerchant.deleteMerchant();
  });

  describe('when some code execute evaluateMerchantLimits', () => {
    describe('and merchant has limit for criteria amount, currency, value and aggregation per hour per person', () => {
      beforeEach(async () => {
        const { limitType, limitDefinition } = baseMerchantLimit;
        await merchantLimitRepository.save({
          merchantId: merchant.id,
          limitType,
          limitDefinition: {
            ...limitDefinition,
            value: 4002,
          },
          state: State.ACTIVE,
        });
      });
      it('then MerchantLimitEvaluatorService response with exceeds=false if new payout does not exceed the limit', async () => {
        // limite 4002
        // acumulado 4000
        // nuevo 1000 fuera de aggregation
        const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z
        getUtcDate.mockReturnValue(now);
        const oldPayouts = Array.from({ length: 4 }, (_item, index) => {
          return {
            ...createPayoutDto,
            trackingCode: `${randNumberString()}${index}`,
            merchantId: merchant.id,
            amount: 1000,
            createdAt: now.toISOString(),
          };
        });
        await payoutRepository.save(oldPayouts);

        const newDate = now.add(1, 'hours');
        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          amount: 1,
          state: PayoutState.PENDING,
          createdAt: newDate.toISOString(),
        });

        const { exceeds } = await service.evaluate(payout);
        expect(exceeds).toBeFalsy();
      });
      it('then MerchantLimitEvaluatorService response with exceeds=true if new payout exceed the limit', async () => {
        // limite 4002
        // acumulado 4000
        // nuevo 1000 dentro de aggregation
        const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z
        getUtcDate.mockReturnValue(now);
        const oldPayouts = Array.from({ length: 4 }, (_item, index) => {
          return {
            ...createPayoutDto,
            trackingCode: `${randNumberString()}${index}`,
            merchantId: merchant.id,
            amount: 1000,
            createdAt: now.toISOString(),
          };
        });
        await payoutRepository.save(oldPayouts);

        const newDate = now.add(20, 'minutes');
        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          amount: 3,
          state: PayoutState.PENDING,
          createdAt: newDate.toISOString(),
        });

        const { exceeds, errorMessage } = await service.evaluate(payout);
        expect(exceeds).toBeTruthy();
        expect(errorMessage).toBeDefined();
      });
      describe('and the limit currency does not match the payout currency', () => {
        it('then MerchantLimitEvaluatorService response with exceeds=false for new payout', async () => {
          // limite 4002
          // acumulado 0
          // nuevo 4003 no misma currency
          const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z
          getUtcDate.mockReturnValue(now);
          const oldPayouts = Array.from({ length: 4 }, (_item, index) => {
            return {
              ...createPayoutDto,
              trackingCode: `${randNumberString()}${index}`,
              merchantId: merchant.id,
              amount: 8000,
              createdAt: now.toISOString(),
            };
          });
          await payoutRepository.save(oldPayouts);

          const newDate = now.add(1, 'hours');
          payout = await payoutRepository.save({
            ...createPayoutDto,
            trackingCode: `${randNumberString()}`,
            merchantId: merchant.id,
            amount: 4003,
            createdAt: newDate.toISOString(),
            currency: Currency.COLOMBIA,
            state: PayoutState.PENDING,
          });

          const { exceeds } = await service.evaluate(payout);
          expect(exceeds).toBeFalsy();
        });
      });
    });
    describe('and merchant has limit for criteria count, value and aggregation per hour per person', () => {
      beforeEach(async () => {
        const { limitType, limitDefinition } = baseMerchantLimit;
        const { scope, aggregation } = limitDefinition;
        await merchantLimitRepository.save({
          merchantId: merchant.id,
          limitType,
          limitDefinition: {
            scope,
            aggregation,
            value: 2,
            criteria: LimitCriteria.COUNT,
          },
          state: State.ACTIVE,
        });
      });
      it('then MerchantLimitEvaluatorService response with exceeds=false if new payout does not exceed the limit', async () => {
        // limite 2
        // acumulado 2
        // nuevo fuera de aggregation
        const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z
        getUtcDate.mockReturnValue(now);
        const oldPayouts = Array.from({ length: 2 }, (_item, index) => {
          return {
            ...createPayoutDto,
            trackingCode: `${randNumberString()}${index}`,
            merchantId: merchant.id,
            amount: 1000,
            createdAt: now.toISOString(),
          };
        });
        await payoutRepository.save(oldPayouts);

        const newDate = now.add(1, 'hours');
        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          amount: 1,
          createdAt: newDate.toISOString(),
          state: PayoutState.PENDING,
        });

        const { exceeds } = await service.evaluate(payout);
        expect(exceeds).toBeFalsy();
      });
      it('then MerchantLimitEvaluatorService response with exceeds=true if new payout exceed the limit', async () => {
        // limite 2
        // acumulado 2
        // nuevo dentro de aggregation por hora
        const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z
        getUtcDate.mockReturnValue(now);
        const oldPayouts = Array.from({ length: 2 }, (_item, index) => {
          return {
            ...createPayoutDto,
            trackingCode: `${randNumberString()}${index}`,
            merchantId: merchant.id,
            amount: 1000,
            createdAt: now.toISOString(),
          };
        });
        await payoutRepository.save(oldPayouts);

        const newDate = now.add(20, 'minutes');
        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          amount: 3,
          createdAt: newDate.toISOString(),
          state: PayoutState.PENDING,
        });

        const { exceeds, errorMessage } = await service.evaluate(payout);
        expect(exceeds).toBeTruthy();
        expect(errorMessage).toBeDefined();
      });
    });
    describe('and merchant does not have any limit', () => {
      it('then MerchantLimitEvaluatorService response with exceeds=false for new payout', async () => {
        const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc(); // 2023-10-13T13:10:58.000Z

        const oldPayouts = Array.from({ length: 4 }, (_item, index) => {
          return {
            ...createPayoutDto,
            trackingCode: `${randNumberString()}${index}`,
            merchantId: merchant.id,
            amount: 1000,
            createdAt: now.toISOString(),
          };
        });
        await payoutRepository.save(oldPayouts);

        const newDate = now.add(1, 'hours');
        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          amount: 1,
          createdAt: newDate.toISOString(),
          state: PayoutState.PENDING,
        });
        const { exceeds } = await service.evaluate(payout);
        expect(exceeds).toBeFalsy();
      });
    });
    describe('and merchant have inactive limit', () => {
      it('then MerchantLimitEvaluatorService response with exceeds=false for new payout', async () => {
        // limite inactivo 999
        // nuevo 1000 dentro de aggregation
        const { limitType, limitDefinition } = baseMerchantLimit;
        await merchantLimitRepository.save({
          merchantId: merchant.id,
          limitType,
          limitDefinition: {
            ...limitDefinition,
            value: 999,
          },
          state: State.INACTIVE,
        });

        payout = await payoutRepository.save({
          ...createPayoutDto,
          trackingCode: `${randNumberString()}`,
          merchantId: merchant.id,
          state: PayoutState.PENDING,
        });

        const { exceeds, errorMessage } = await service.evaluate(payout);
        expect(exceeds).toBeFalsy();
        expect(errorMessage).not.toBeDefined();
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/userService.e2e-spec.ts
import { CreateUserDto } from 'src/api/v2/user/dto/create-user.dto';
import { UserService } from 'src/models/user/user.service';
import { app, connection } from '../app.setup';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { Repository } from 'typeorm';
import { UpdateUserDto } from 'src/api/v2/user/dto/update-user.dto';
import { State } from 'src/common/enums/state.enum';
import { NotFoundException } from '@nestjs/common';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given UserService', () => {
  let userService: UserService;
  let userRepository: Repository<UserEntity>;

  let testMerchant: TestMerchantUtil;

  const baseUser = {
    email: 'user@test.local',
    name: 'Test User',
    password: 'password',
    merchantId: undefined,
  };

  beforeAll(async () => {
    userService = app.get<UserService>(UserService);
    userRepository = connection.getRepository(UserEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    baseUser.merchantId = testMerchant.merchantId;
  });

  afterEach(async () => {
    await userRepository.delete({ merchantId: testMerchant.merchantId });
    await testMerchant.deleteMerchant();
  });

  describe('when findAll method is called', () => {
    it('then should respond with an array of users', async () => {
      const result = await userService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });

  describe('when create method is called with valid data', () => {
    it('then should return the created user', async () => {
      const createUserDto: CreateUserDto = { ...baseUser };
      const user = await userService.create(createUserDto);
      expect(user).toHaveProperty('email', createUserDto.email);
      expect(user).toHaveProperty('name', createUserDto.name);
    });
  });

  describe('when isEmailInUse method is called', () => {
    it('then should return true if email is in use', async () => {
      await userRepository.save({ ...baseUser });
      const result = await userService.isEmailInUse(baseUser.email);
      expect(result).toBeTruthy();
    });
  });

  describe('when findOne method is called with a valid ID', () => {
    it('then should return the user', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      const user = await userService.findOne(userEntity.id);
      expect(user).toHaveProperty('id', userEntity.id);
    });
  });

  describe('when findOneByEmail method is called with a valid email', () => {
    it('then should return the user', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      const user = await userService.findOneByEmail(userEntity.email);
      expect(user).toHaveProperty('email', userEntity.email);
    });
  });

  describe('when update method is called with valid data', () => {
    it('then should update the user', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      const updateUserDto: UpdateUserDto = { name: 'Updated Name' };
      const user = await userService.update(userEntity.id, updateUserDto);
      expect(user).toHaveProperty('name', updateUserDto.name);
    });
  });

  describe('when remove method is called with a valid ID', () => {
    it('then should remove the user', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      await userService.remove(userEntity.id);
      const user = await userRepository.findOne({
        where: { id: userEntity.id },
      });
      expect(user).toBeNull();
    });
  });

  describe('when update method is called with valid data and state', () => {
    it('then should update the user state', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      const updateUserDto: UpdateUserDto = { state: State.INACTIVE };
      const user = await userService.update(userEntity.id, updateUserDto);
      expect(user).toHaveProperty('state', updateUserDto.state);
    });
  });

  describe('when remove method is called', () => {
    it('then should soft delete the user', async () => {
      const userEntity = await userRepository.save({ ...baseUser });
      await userService.remove(userEntity.id);
      const user = await userRepository.findOne({
        where: { id: userEntity.id },
      });
      expect(user).toBeNull();
    });

    it('then should throw NotFoundException when user does not exist', async () => {
      await expect(userService.remove(-1)).rejects.toThrow(NotFoundException);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/authService.e2e-spec.ts
import { Repository } from 'typeorm';
import { randEmail } from '@ngneat/falso';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { AuthService } from 'src/services/auth/auth.service';
import { app, connection } from 'test/app.setup';
import { BadRequestException, NotFoundException } from '@nestjs/common';
import { MailService } from 'src/services/mail/mail.service';
import { ChangeUserPasswordDto } from 'src/api/v2/auth/dto/change-user-password.dto';
import { SecretTransformer } from 'src/common/transformers/secret.transformer';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('AuthService', () => {
  let authService: AuthService;
  let userRepository: Repository<UserEntity>;

  let testMerchant: TestMerchantUtil;
  let user: UserEntity;

  let mailServiceSpy: jest.SpyInstance;

  const createUserDto = {
    email: randEmail(),
    name: 'Test User',
    password: '',
    merchantId: undefined,
    role: UserRole.USER,
    state: State.ACTIVE,
    mfa: true,
    mfaState: MFAState.ENROLLED,
    seed: SecretTransformer.default().to('mockSeed'),
  };

  const password = 'oldPassword';

  beforeAll(async () => {
    authService = app.get(AuthService);
    userRepository = connection.getRepository(UserEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    createUserDto.merchantId = testMerchant.merchantId;

    const encryptedPassword = await authService.encrypt(password);
    user = await userRepository.save({
      ...createUserDto,
      password: encryptedPassword,
    });

    mailServiceSpy = jest
      .spyOn(MailService.prototype, 'sendEmail')
      .mockImplementation(() => Promise.resolve());
  });

  afterEach(async () => {
    await userRepository.delete({ merchantId: testMerchant.merchantId });
    await testMerchant.deleteMerchant();
  });

  describe('resetPassword', () => {
    it('should reset the password successfully', async () => {
      await authService.resetPassword(user.id);

      const updatedUser = await userRepository.findOne({
        where: { id: user.id },
      });
      expect(updatedUser.password).not.toEqual(user.password);
    });

    it('should throw an error if user not found', async () => {
      const userId = -1;
      await expect(authService.resetPassword(userId)).rejects.toThrow(
        NotFoundException,
      );
    });

    it('should send an email to the user', async () => {
      await authService.resetPassword(user.id);

      const updatedUser = await userRepository.findOne({
        where: { id: user.id },
      });

      expect(updatedUser.password).not.toEqual(user.password);
      expect(mailServiceSpy).toHaveBeenCalledWith(
        user.email,
        expect.stringContaining(`Contraseña nueva`),
        expect.stringContaining(`Tu nueva clave es`),
      );
    });
  });

  describe('when some code  executes changePassword', () => {
    it('then should throw an exception if the user does not exists', async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: password,
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
      };

      await expect(
        authService.changePassword(99, changePasswordDto),
      ).rejects.toThrow(NotFoundException);
    });

    it('then should throw an exception if the old password is invalid', async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'wrongPassword',
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
      };

      await expect(
        authService.changePassword(user.id, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('then should throw an exception if the old password is the same as the new', async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: password,
        newPassword: password,
        confirmNewPassword: 'newPassword',
      };

      await expect(
        authService.changePassword(user.id, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it("then should throw an exception if new password doesn't match with the password confirmation", async () => {
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: password,
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword2',
      };

      await expect(
        authService.changePassword(user.id, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('then should change the user password', async () => {
      const newPassword = 'newPassword';
      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: password,
        newPassword,
        confirmNewPassword: newPassword,
      };

      await authService.changePassword(user.id, changePasswordDto);

      const updatedUser = await userRepository.findOne({
        where: { id: user.id },
      });

      expect(updatedUser.password).not.toBe(newPassword);
      expect(user.password).not.toEqual(updatedUser.password);
      expect(updatedUser.passwordUpdatedAt).not.toStrictEqual(
        user.passwordUpdatedAt,
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/accountStatementJobService.e2e-spec.ts
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { In, Repository } from 'typeorm';
import { app, connection } from '../app.setup';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { endOfDateISOString, startOfDateISOString } from 'src/utils/date-util';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { BankEntity } from 'src/models/bank/entities/bank.entity';

function getMockedSubmitBatchResponse(accountId: number, providerId: number) {
  return {
    jobId: '123',
    jobName: `bank-account-statements-job-cl-banco-santander-${providerId}-${accountId}-test`,
    $metadata: undefined,
  };
}

describe('given AccountStatementJobService', () => {
  let service: AccountStatementJobService;
  let accountStatementRepository: Repository<AccountStatementEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let bankRepository: Repository<BankEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const baseAccountStatementJob = {
    endDate: new Date('2022-11-12T16:54:05.000Z'),
    startDate: new Date('2022-11-12T16:54:05.000Z'),
    state: AccountStatementJobState.STARTED,
    startedAt: new Date('2022-12-12T10:50:05.000Z'),
    endedAt: new Date('2022-12-12T10:55:05.000Z'),
    retrievedAt: new Date('2022-12-12T10:55:59.000Z'),
    totalRetrieved: 3,
    jobId: 'ABC123JobId',
    accountId: undefined,
  };

  const baseAccount = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '45912391',
    merchantId: undefined,
  };

  const baseProvider = {
    name: 'Test Provider',
    credentials: { username: 'a', password: 'b' },
    rules: {},
    providerType: ProviderType.ScraperCG,
    capabilities: [ProviderCapability.READ_TRANSFER],
    accountId: undefined,
  };

  const { endedAt, retrievedAt, totalRetrieved, ...rest } =
    baseAccountStatementJob;

  const accountStatementJobDto = { ...rest };

  beforeAll(async () => {
    service = app.get(AccountStatementJobService);
    bankRepository = connection.getRepository(BankEntity);
    accountStatementRepository = connection.getRepository(
      AccountStatementEntity,
    );
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    const merchantId = testMerchant.merchantId;

    baseAccount.merchantId = merchantId;
    account = await accountRepository.save({ ...baseAccount });

    baseProvider.accountId = account.id;
    baseAccountStatementJob.accountId = account.id;
    accountStatementJobDto.accountId = account.id;

    provider = await providerRepository.save({
      ...baseProvider,
    });
  });

  afterEach(async () => {
    const accounts = await accountRepository.find({
      where: { merchantId: testMerchant.merchantId },
    });
    const accountIds = accounts.map((account) => account.id);

    const jobs = await accountStatementJobRepository.findBy({
      accountId: In(accountIds),
    });
    const jobIds = jobs.map((job) => job.id);

    await accountStatementRepository.delete({
      accountStatementJobId: In(jobIds),
    });
    await accountStatementJobRepository.delete({ accountId: In(accountIds) });
    await providerRepository.delete({ accountId: In(accountIds) });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('when some code execute create', () => {
    it('then it should create a new account statement job record if valid data', async () => {
      const result = await service.create({
        ...accountStatementJobDto,
        accountId: account.id,
      });
      expect(result.id).toBeDefined();
    });
  });

  describe('when some code execute update', () => {
    it('then it should update an account statement job record', async () => {
      const newAccountStatementJob = accountStatementJobRepository.create({
        ...baseAccountStatementJob,
      });
      await accountStatementJobRepository.save(newAccountStatementJob);

      const result = await service.update(newAccountStatementJob.id, {
        endedAt,
        retrievedAt,
        totalRetrieved,
        state: AccountStatementJobState.ERROR,
      });

      const updatedAccountStatementJob =
        await accountStatementJobRepository.findOne({
          where: { id: newAccountStatementJob.id },
        });

      expect(result).toMatchObject(updatedAccountStatementJob);
    });
  });

  describe('when some code execute startScraper', () => {
    const params = {
      startDate: '2023-08-06',
      endDate: '2023-08-06',
    };

    let submitJobResponse;

    beforeEach(async () => {
      submitJobResponse = getMockedSubmitBatchResponse(account.id, provider.id);
      jest
        .spyOn(AwsBatchService.prototype, 'getBatchJobQueue')
        .mockReturnValue(Promise.resolve([]));
      jest
        .spyOn(AwsBatchService.prototype, 'submitBatchJob')
        .mockReturnValue(Promise.resolve(submitJobResponse));
    });

    it('then should return aws submit job response for specified account', async () => {
      const result = await service.startScraper(account.id, params);

      expect(result).toMatchObject(submitJobResponse);
    });

    it('then should convert the startDate, endDate params to the account country timezone', async () => {
      await service.startScraper(account.id, params);

      const convertedStartDate = startOfDateISOString(
        params.startDate,
        account.countryCode,
      );
      const convertedEndDate = endOfDateISOString(
        params.endDate,
        account.countryCode,
      );

      const accountStatementJob = await accountStatementJobRepository.findOne({
        where: { accountId: account.id },
      });

      expect(convertedStartDate).toEqual(
        accountStatementJob.startDate.toISOString(),
      );
      expect(convertedEndDate).toEqual(
        accountStatementJob.endDate.toISOString(),
      );
    });

    it('then should fail (UnprocessableEntityException) if origin bank code is not supported', async () => {
      const bank = await bankRepository.save({
        name: 'Fake Bank',
        code: 'invalidOriginBankCode',
      });

      await accountRepository.update(account.id, {
        bankCode: bank.code,
      });

      await expect(service.startScraper(account.id, params)).rejects.toThrow(
        `Can't start account statement job, unsupported bankCode '${bank.code}'`,
      );
    });

    it("then should fail (UnprocessableEntityException) if the specified account doesn't have any provider", async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        identifier: 'accountWithoutProvider',
      });
      await expect(service.startScraper(account.id, params)).rejects.toThrow(
        `Can't enqueue job, the account doesn't have any provider with the ${ProviderCapability.READ_TRANSFER} capability`,
      );
    });

    it("then should fail (UnprocessableEntityException) if the specified account doesn't have provider with 'read_transfer' capability", async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        identifier: 'accountWithoutProvider',
      });
      await providerRepository.save({
        ...baseProvider,
        capabilities: [ProviderCapability.CREATE_TRANSFER],
      });

      await expect(service.startScraper(account.id, params)).rejects.toThrow(
        `Can't enqueue job, the account doesn't have any provider with the ${ProviderCapability.READ_TRANSFER} capability`,
      );
    });

    it('then should fail (UnprocessableEntityException) if account has any running record job', async () => {
      await service.create({
        ...baseAccountStatementJob,
        state: AccountStatementJobState.CREATED,
      });
      await expect(service.startScraper(account.id, params)).rejects.toThrow(
        `There is an execution in process for the account ${account.id} - ${account.bankCode}.`,
      );
    });

    it('then should fail (ConflictException) if account has any running batch job', async () => {
      jest
        .spyOn(AwsBatchService.prototype, 'getBatchJobQueue')
        .mockReturnValue(Promise.resolve([submitJobResponse]));
      await expect(service.startScraper(account.id, params)).rejects.toThrow(
        `There is an execution in process for the account ${account.id} - ${account.bankCode}.`,
      );
    });

    it('then should call findUnfinishedJobByName with the cleaned jobName', async () => {
      const spy = jest
        .spyOn(AwsBatchService.prototype, 'findUnfinishedJobByName')
        .mockImplementation(() => Promise.resolve(undefined));

      await service.startScraper(account.id, params);

      const jobName = `bank-account-statements-job-cl-banco-santander-${provider.id}-${account.id}-test`;

      expect(spy).toHaveBeenCalledWith(jobName, 'accountStatements');
    });
  });

  describe('when some code execute enqueueJob', () => {
    it('then should return aws submit job response', async () => {
      const submitJobResponse = {
        jobId: '123',
        jobName: 'bank-account-statements-job-code-providerId-accountId',
        $metadata: undefined,
      };
      jest
        .spyOn(AwsBatchService.prototype, 'getBatchJobQueue')
        .mockReturnValue(Promise.resolve([]));
      const spiedBatchJob = jest.spyOn(
        AwsBatchService.prototype,
        'submitBatchJob',
      );
      spiedBatchJob.mockReturnValue(Promise.resolve(submitJobResponse));
      const result = await service.enqueueJob(
        submitJobResponse.jobName,
        account.id,
        [{ name: 'code', value: '' }],
      );

      expect(result).toMatchObject(submitJobResponse);
      expect(spiedBatchJob).toHaveBeenCalled();
    });
  });

  describe('when some code execute getExecutingFromAccount', () => {
    it('then should return if there is executing some account statement job for specified account', async () => {
      const runningJob = await service.create({
        ...accountStatementJobDto,
        accountId: account.id,
      });
      const result = await service.getExecutionFromAccount(account.id);

      expect(result.id).toEqual(runningJob.id);
      expect(result.state).toEqual(baseAccountStatementJob.state);
    });

    it('then should return undefined if there is no executuing job for specified account', async () => {
      const account = await accountRepository.save({
        ...baseAccount,
        identifier: 'nonexistingJob',
      });
      await providerRepository.save({
        ...baseProvider,
      });
      const result = await service.getExecutionFromAccount(account.id);

      expect(result).toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/webhookService.e2e-spec.ts
import { EventEmitter2 } from '@nestjs/event-emitter';
import { randUrl, randUuid } from '@ngneat/falso';
import axios from 'axios';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointState } from 'src/common/enums/webhook-endpoint-state.enum';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutService } from 'src/models/payout/payout.service';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { WebhookEndpointEntity } from 'src/models/webhook-endpoint/entities/webhook-endpoint.entity';
import { WebhookPayloadDto } from 'src/services/webhook/dto/webhook-payload.dto';
import { WebhookService } from 'src/services/webhook/webhook.service';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';

describe('Given a WebhookService', () => {
  let service: WebhookService;
  let payoutService: PayoutService;
  let postWebhookSpy: jest.SpyInstance;
  let webhookEndpointRepository: Repository<WebhookEndpointEntity>;
  let merchantRepository: Repository<MerchantEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let merchant: MerchantEntity;
  let webhookEndpoint: WebhookEndpointEntity;
  let eventEmitterSpy: jest.SpyInstance;

  const payoutWebhookEvents = Object.values(PayoutEvent);
  const trackingCode = randUuid();

  const createWebhookEndpointDto = {
    url: randUrl(),
    description: '',
    enabledEvents: Object.values(WebhookEvent),
    state: WebhookEndpointState.ENABLED,
    secret: 'secret',
  };

  const createPayoutDto: CreatePayoutDto = {
    amount: 1001,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    merchantId: undefined,
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto: CreateTransferDto = {
    amount: 100,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode,
    destinationHolderId: '120123123',
    destinationName: 'oblandon',
    destinationAccount: '1201231',
    destinationBankCode: 'cl_banco_falabella',
    destinationPhone: '001239912312',
    merchantId: undefined,
    payoutId: undefined,
    providerId: undefined,
    version: EntityVersion.v2,
    state: TransferState.ASSIGNED,
  };

  beforeAll(async () => {
    service = app.get(WebhookService);
    payoutService = app.get(PayoutService);

    webhookEndpointRepository = connection.getRepository(WebhookEndpointEntity);
    merchantRepository = connection.getRepository(MerchantEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);

    merchant = await merchantRepository.save({
      name: 'Webhook Test Merchant',
      identifier: '11230123012',
    });

    createPayoutDto.merchantId = merchant.id;
    createTransferDto.merchantId = merchant.id;

    webhookEndpoint = await webhookEndpointRepository.save({
      ...createWebhookEndpointDto,
      merchant,
    });
  });

  beforeEach(() => {
    postWebhookSpy = jest.spyOn(axios, 'post');
    eventEmitterSpy = jest
      .spyOn(EventEmitter2.prototype, 'emit')
      .mockImplementation();
  });

  afterEach(async () => {
    webhookEndpoint.state = WebhookEndpointState.ENABLED;
    webhookEndpoint.enabledEvents = Object.values(WebhookEvent);
    await webhookEndpointRepository.save(webhookEndpoint);

    await transferRepository.delete({ trackingCode });
    await payoutRepository.delete({ trackingCode });
  });

  afterAll(async () => {
    await webhookEndpointRepository.delete(webhookEndpoint.id);
    await merchantRepository.delete(merchant.id);
  });

  describe("When a payout changes it's state", () => {
    it('Then it should emit an event if payout version is v2', async () => {
      const payoutEntity = await payoutRepository.save({
        ...createPayoutDto,
      });
      const payout = await payoutService.updateState(
        payoutEntity.id,
        PayoutState.PROCESSING,
      );

      expect(eventEmitterSpy).toHaveBeenCalledTimes(1);
      expect(eventEmitterSpy).toHaveBeenCalledWith(
        PayoutEvent.PROCESSING,
        payout,
      );
    });
  });

  describe('When handling a payout event', () => {
    it("then shouldn't post webhook if there aren't any registered merchant webhook", async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      webhookEndpoint.state = WebhookEndpointState.DISABLED;
      await webhookEndpointRepository.save(webhookEndpoint);

      await service.handlePayoutEvent(PayoutEvent.COMPLETED, payout);

      expect(postWebhookSpy).not.toHaveBeenCalled();
    });

    it('then should post to the registered merchant webhook endpoints if the event is in enabledEvents', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const currentDate = new Date(2022, 10, 1);

      jest.setSystemTime(currentDate);

      for (const webhookEvent of payoutWebhookEvents) {
        await service.handlePayoutEvent(webhookEvent, payout);
        expect(postWebhookSpy).toHaveBeenCalledWith(
          webhookEndpoint.url,
          {
            timestamp: currentDate.getTime(),
            type: webhookEvent,
            data: {
              object: expect.any(WebhookPayloadDto),
            },
          },
          expect.anything(),
        );
      }

      expect(postWebhookSpy).toHaveBeenCalledTimes(payoutWebhookEvents.length);
    });

    it('then should post to the registered merchant webhook endpoints with the errorCode and message from the last transfer from the payout', async () => {
      const message = 'test message';
      const errorCode = TransferErrorCode.UNKNOWN_ERROR;

      const payout = await payoutRepository.save({
        ...createPayoutDto,
        transfers: [
          {
            ...createTransferDto,
            merchant,
            message,
            errorCode,
            createdAt: new Date('2050-01-01'),
          },
          {
            ...createTransferDto,
            merchant,
            createdAt: new Date('2030-01-02'),
          },
        ],
      });

      await service.handlePayoutEvent(PayoutEvent.FAILED, payout);

      expect(postWebhookSpy).toHaveBeenCalledWith(
        webhookEndpoint.url,
        expect.objectContaining({
          data: {
            object: expect.objectContaining({
              errorCode,
              message,
            }),
          },
        }),
        expect.anything(),
      );
    });

    it('then should not post to the registered merchant webhook endpoints if the webhook event is not in enabledEvents', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      webhookEndpoint.enabledEvents = [];
      await webhookEndpointRepository.save(webhookEndpoint);

      for (const webhookEvent of payoutWebhookEvents) {
        await service.handlePayoutEvent(webhookEvent, payout);
      }

      expect(postWebhookSpy).not.toHaveBeenCalled();
    });

    it('then should post to multiple registered merchant webhook endpoints if they exist', async () => {
      const payout = await payoutRepository.save({
        ...createPayoutDto,
      });

      const webhookEndpoint2 = await webhookEndpointRepository.save({
        ...createWebhookEndpointDto,
        merchant,
      });

      await service.handlePayoutEvent(PayoutEvent.COMPLETED, payout);

      expect(postWebhookSpy).toHaveBeenCalledTimes(2);

      await webhookEndpointRepository.delete(webhookEndpoint2.id);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferAssignmentServiceNew.e2e-spec.ts
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';

import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { TransferAssignmentNewService } from 'src/services/transfer-assignment/transfer-assignment.new.service';
import { app, connection } from 'test/app.setup';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { randNumberString } from 'test/utils/testUtils';

const trackingCode = 'testPayoutCreatedEventHandler';

const createMerchantDto: Partial<MerchantEntity> = {
  name: 'Base Merchant',
  identifier: randNumberString(),
};

const createPayoutDto = {
  amount: 1001,
  state: PayoutState.PENDING,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  currency: Currency.CHILE,
  trackingCode,
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
};

const createTransferDto = {
  amount: 1001,
  concept: 'Pago Buk Adelantos',
  destinationEmail: 'oblandon@buk.cl',
  destinationName: 'Cathia Castillo Quicaña',
  destinationHolderId: '72028164',
  destinationAccount: '00326101327274094052',
  destinationBankCode: 'cl_banco_bci',
  currency: Currency.CHILE,
  trackingCode,
  destinationPhone: '3212312312',
  version: EntityVersion.v2,
  state: TransferState.PENDING,
  payoutId: undefined,
  providerId: undefined,
};

const createAccountDto = {
  bankCode: 'cl_banco_falabella',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  state: State.ACTIVE,
};

const createProviderDto = {
  name: 'Test Provider',
  credentials: null,
  rules: null,
  providerType: ProviderType.ScraperCG,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  accountId: undefined,
  priority: 1,
  state: State.ACTIVE,
};

describe('Given a TransferAssignmentNewService', () => {
  let transferAssignmentNewService: TransferAssignmentNewService;
  let transferProviderService: TransferProviderService;

  let providerService: ProviderService;
  let accountService: AccountService;

  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let merchantRepository: Repository<MerchantEntity>;

  let account: AccountEntity;
  let provider: ProviderEntity;
  let payout: PayoutEntity;
  let transfer: TransferEntity;
  let merchant: MerchantEntity;

  beforeAll(async () => {
    transferAssignmentNewService = app.get(TransferAssignmentNewService);
    transferProviderService = app.get(TransferProviderService);
    accountService = app.get(AccountService);
    providerService = app.get(ProviderService);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    merchantRepository = connection.getRepository(MerchantEntity);

    merchant = await merchantRepository.save({ ...createMerchantDto });
  });

  beforeEach(async () => {
    jest
      .spyOn(transferProviderService, 'createTransaction')
      .mockImplementation((_transfer_id) => Promise.resolve());

    const eventEmitter = app.get(EventEmitter2);

    jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
      return true;
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: merchant.id,
    });

    provider = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: merchant.id,
    });

    transfer = await transferRepository.save({
      ...createTransferDto,
      merchantId: merchant.id,
      payoutId: payout.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete({ id: payout.id });
    await providerRepository.delete({ id: provider.id });
    await accountRepository.delete({ id: account.id });
  });

  afterAll(async () => {
    await merchantRepository.delete({ id: merchant.id });
  });

  describe('findAccountsByMerchantId', () => {
    it('should return only accounts for the passed merchant id', async () => {
      const merchantId = merchant.id;

      const accounts =
        await transferAssignmentNewService.findAccountsByMerchantId(merchantId);

      expect(accounts).toHaveLength(1);
      const merchantIds = accounts.map((a) => a.merchantId);
      expect(merchantIds.every((id) => id === merchantId)).toBe(true);
    });

    it('should return only active accounts', async () => {
      const accounts =
        await transferAssignmentNewService.findAccountsByMerchantId(1);

      expect(accounts.every((a) => a.state === State.ACTIVE)).toBe(true);
    });
  });

  describe('filterCapableAccounts', () => {
    it('should return only the accounts with rules that allow creating the transfer', async () => {
      const capableAccountId = account.id;

      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) =>
          Promise.resolve(_account.id === capableAccountId),
        );

      const accounts = [account, { ...account, id: 999 }];

      const capableAccounts =
        await transferAssignmentNewService.filterCapableAccounts(
          accounts,
          transfer,
        );

      expect(capableAccounts).toHaveLength(1);
      expect(capableAccounts[0].id).toEqual(account.id);
    });

    it('should not return an account that does not allow creating the transfer', async () => {
      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) => Promise.resolve(false));

      const accounts = [account];

      const capableAccounts =
        await transferAssignmentNewService.filterCapableAccounts(
          accounts,
          transfer,
        );

      expect(capableAccounts).toHaveLength(0);
    });
  });

  describe('filterCapableProviders', () => {
    beforeEach(async () => {
      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) =>
          Promise.resolve(_account.id === account.id),
        );
    });

    it('should return only the providers with rules that allow creating the transfer', async () => {
      const capableProviderId = provider.id;

      await transferAssignmentNewService.filterCapableAccounts(
        [account],
        transfer,
      );

      jest
        .spyOn(providerService, 'evaluateRules')
        .mockImplementation((_provider, _transfer) =>
          Promise.resolve(_provider.id === capableProviderId),
        );

      const providers = [
        provider,
        { ...provider, id: 999 },
      ] as ProviderEntity[];

      const capableProviders =
        await transferAssignmentNewService.filterCapableProviders(
          providers,
          transfer,
        );

      expect(capableProviders).toHaveLength(1);
      expect(capableProviders[0].id).toEqual(provider.id);
    });

    it('should not return an provider that does not allow creating the transfer', async () => {
      jest
        .spyOn(providerService, 'evaluateRules')
        .mockImplementation((_provider, _transfer) => Promise.resolve(false));

      const providers = [provider];

      const capableProviders =
        await transferAssignmentNewService.filterCapableProviders(
          providers,
          transfer,
        );

      expect(capableProviders).toHaveLength(0);
    });
  });

  describe('findCapableProvider', () => {
    it('should return a provider entity that can process the transfer', async () => {
      const capableAccountId = account.id;

      // force that only the current account has capabilities to process the transfer
      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) =>
          Promise.resolve(_account.id === capableAccountId),
        );

      const capableProvider =
        await transferAssignmentNewService.findCapableProvider(transfer);

      expect(capableProvider.id).toEqual(provider.id);
    });

    it('should return a provider entity that can process the transfer when it has more than one capability', async () => {
      const capableAccountId = account.id;

      // force that only the current account has capabilities to process the transfer
      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) =>
          Promise.resolve(_account.id === capableAccountId),
        );

      await providerRepository.update(
        { id: provider.id },
        { capabilities: Object.values(ProviderCapability) },
      );

      const capableProvider =
        await transferAssignmentNewService.findCapableProvider(transfer);

      expect(capableProvider.id).toEqual(provider.id);

      await providerRepository.update(
        { id: provider.id },
        { capabilities: [ProviderCapability.CREATE_TRANSFER] },
      );
    });

    it('should return null if there is no provider that can process the transfer', async () => {
      jest
        .spyOn(accountService, 'evaluateRules')
        .mockImplementation((_account, _transfer) => Promise.resolve(false));

      const capableProvider =
        await transferAssignmentNewService.findCapableProvider(transfer);

      expect(capableProvider).toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferJobService.e2e-spec.ts
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';
import { CreateTransferJobDto } from 'src/api/v2/transfer-job/dtos/create-transfer-job.dto';
import { UpdateTransferJobDto } from 'src/api/v2/transfer-job/dtos/update-transfer-job.dto';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import { TransferJobService } from 'src/models/transfer-job/transfer-job.service';
import { app, connection } from 'test/app.setup';
import { In, Not, Repository } from 'typeorm';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given a TransferJobService', () => {
  let service: TransferJobService;

  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let transferJobRepository: Repository<TransferJobEntity>;

  let defaultTransferJob: TransferJobEntity;
  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const createAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    providerType: ProviderType.ScraperCG,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const createTransferJobDto = {
    jobId: '12912991',
    startedAt: new Date().toISOString(),
    providerId: undefined,
  };

  beforeAll(async () => {
    service = app.get<TransferJobService>(TransferJobService);

    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    transferJobRepository = connection.getRepository(TransferJobEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    createAccountDto.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;

    provider = await providerRepository.save({ ...createProviderDto });
    createTransferJobDto.providerId = provider.id;

    defaultTransferJob = await transferJobRepository.save({
      ...createTransferJobDto,
    });
  });

  afterEach(async () => {
    await transferJobRepository.delete({
      providerId: provider.id,
    });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('when some code execute create', () => {
    it('should create a new transfer job record', async () => {
      const createTransferJobDto: CreateTransferJobDto = {
        jobId: '12912991',
        startedAt: new Date().toISOString(),
        providerId: provider.id,
      };

      const transferJob = await service.create(createTransferJobDto);

      expect(transferJob.id).toBeDefined();
      expect(transferJob.jobId).toEqual(createTransferJobDto.jobId);
      expect(transferJob.state).toEqual(TransferJobState.CREATED);
    });
  });

  describe('when some code execute update', () => {
    it('should fail if the transfer job does not exists', async () => {
      const transferJobId = -1;
      const updateTransferJobDto = {
        state: TransferJobState.STARTED,
        invalidProp: 1,
      } as UpdateTransferJobDto;

      await expect(
        service.update(transferJobId, updateTransferJobDto),
      ).rejects.toThrow();
    });

    it('should update the transfer job', async () => {
      const updatedTransferJob = await service.update(defaultTransferJob.id, {
        state: TransferJobState.FINISHED,
      });

      expect(updatedTransferJob.state).toEqual(TransferJobState.FINISHED);
    });
  });

  describe('when some code executes findOneByConditions', () => {
    it('should return undefined if there is not record that match with the specified options', async () => {
      const transferJob = await service.findOneByConditions({
        where: { id: -1 },
      });

      expect(transferJob).toBeNull();
    });

    it('should return a transfer job that match with the specified options', async () => {
      const transferJob = await service.findOneByConditions({
        where: {
          providerId: provider.id,
          state: Not(In([TransferJobState.FINISHED, TransferJobState.ERROR])),
        },
      });

      expect(transferJob).toBeDefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/payoutServiceNew.e2e-spec.ts
import { Repository } from 'typeorm';
import {
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { randBetweenDate, randUserName } from '@ngneat/falso';

import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutActionSuggestion } from 'src/common/enums/payout-action-suggestion.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { MerchantLimitEntity } from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { CreatePayoutDto } from 'src/models/payout/dto/create-payout.dto';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import { TransferErrorService } from 'src/models/transfer-error/transfer-error.service';
import { AlertsService } from 'src/services/alerts/alerts.service';
import { EntitiesValidationService } from 'src/services/entities-validation/entities-validation.service';
import { MerchantLimitEvaluatorService } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.service';
import { SlackService } from 'src/services/slack/slack.service';
import { app, connection } from 'test/app.setup';
import { randNumberString } from 'test/utils/testUtils';
import { LockMode } from 'src/common/enums/locks-mode.enum';

let trackingCode = randNumberString();

const createMerchantDto: Partial<MerchantEntity> = {
  name: 'Base Merchant',
  identifier: randNumberString(),
};

const createPayoutDto: CreatePayoutDto = {
  amount: 1000,
  destinationName: 'Test Transfer Service',
  destinationEmail: 'email@email.com',
  destinationAccount: '112301212',
  destinationHolderId: '123121212121',
  destinationBankCode: 'cl_banco_santander',
  destinationPhone: '56999695511',
  currency: Currency.CHILE,
  concept: 'Testing',
  trackingCode,
  version: EntityVersion.v2,
  merchantId: null,
};

const createTransferDto: CreateTransferDto = {
  amount: 1000,
  destinationName: 'Test Transfer Service',
  destinationEmail: 'email@email.com',
  destinationAccount: '112301212',
  destinationHolderId: '123121212121',
  destinationBankCode: 'cl_banco_santander',
  destinationPhone: '56999695511',
  currency: Currency.CHILE,
  concept: 'Testing',
  version: EntityVersion.v2,
  trackingCode,
  merchantId: null,
  payoutId: null,
  providerId: null,
};

const createAccountDto: CreateAccountDto = {
  bankCode: 'cl_banco_santander',
  countryCode: CountryCode.CHILE,
  currency: Currency.CHILE,
  name: 'Base Account',
  identifier: '123912391',
  state: State.ACTIVE,
  merchantId: null,
};

const createProviderDto: CreateProviderDto = {
  name: 'Test Provider',
  credentials: null,
  rules: null,
  providerType: ProviderType.ScraperPW,
  capabilities: [ProviderCapability.CREATE_TRANSFER],
  priority: 1,
  state: State.ACTIVE,
  accountId: null,
};

const createMerchantLimitDto = {
  state: State.ACTIVE,
  limitType: MerchantLimitType.RATE,
  limitDefinition: {
    value: 999,
    criteria: LimitCriteria.AMOUNT,
    currency: Currency.CHILE,
    scope: LimitScope.PERSON,
    aggregation: LimitAggregation.HOUR,
  },
};

describe('given payoutNewServiceNew', () => {
  let accountRepository: Repository<AccountEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let transferRepository: Repository<TransferEntity>;
  let merchantRepository: Repository<MerchantEntity>;
  let merchantLimitRepository: Repository<MerchantLimitEntity>;

  let payoutNewService: PayoutNewService;

  let account: AccountEntity;
  let merchant: MerchantEntity;

  let eventEmitMock;

  beforeAll(async () => {
    try {
      accountRepository = connection.getRepository(AccountEntity);
      payoutRepository = connection.getRepository(PayoutEntity);
      providerRepository = connection.getRepository(ProviderEntity);
      transferRepository = connection.getRepository(TransferEntity);
      merchantRepository = connection.getRepository(MerchantEntity);
      merchantLimitRepository = connection.getRepository(MerchantLimitEntity);

      payoutNewService = app.get<PayoutNewService>(PayoutNewService);

      merchant = await merchantRepository.save({ ...createMerchantDto });
      createTransferDto.merchantId = merchant.id;
      createAccountDto.merchantId = merchant.id;
      createPayoutDto.merchantId = merchant.id;
    } catch (error) {
      console.log(error);
    }
  });

  beforeEach(async () => {
    account = await accountRepository.save({
      ...createAccountDto,
    });
    createProviderDto.accountId = account.id;

    eventEmitMock = jest
      .spyOn(EventEmitter2.prototype, 'emit')
      .mockImplementation();

    jest
      .spyOn(SlackService.prototype, 'postMessage')
      .mockImplementation((_message) =>
        Promise.resolve({ success: true, response: undefined }),
      );
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ id: account.id });
  });

  afterAll(async () => {
    await merchantRepository.delete({ id: merchant.id });
  });

  // NEW HELPERS METHODS
  describe('when some code executes findOneOrFail', () => {
    let payout: PayoutEntity;
    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
      });
    });
    afterEach(async () => {
      await payoutRepository.delete({ id: payout.id });
    });
    it('should fail if payout does not exist', async () => {
      await payoutRepository.delete({ id: payout.id });

      await expect(payoutNewService.findOneOrFail(payout.id)).rejects.toThrow(
        new NotFoundException(`Payout ${payout.id} not found`),
      );
    });
  });

  describe('when some code executes findOneByConditions', () => {
    let payout: PayoutEntity;
    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
      });
    });
    afterEach(async () => {
      await payoutRepository.delete({ id: payout.id });
    });
    it('should return a payout base on conditions', async () => {
      const options = {
        where: {
          id: payout.id,
          version: EntityVersion.v2,
        },
        relations: ['merchant', 'transfers'],
      };
      const result = await payoutNewService.findOneByConditions(options);
      expect(result).toBeInstanceOf(PayoutEntity);
    });
  });

  describe('when some code executes findLastTransfer', () => {
    let payout: PayoutEntity;
    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
    });
    it('should find the last transfer for a given payoutId', async () => {
      const transferDto = {
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        version: EntityVersion.v2,
        payoutId: payout.id,
      };

      await transferRepository.save({ ...transferDto }); // other transfer
      const lastTransfer = await transferRepository.save({ ...transferDto }); // last transfer

      const foundLastTransfer = await payoutNewService.findLastTransfer(
        payout.id,
      );
      expect(foundLastTransfer).toBeDefined();
      expect(foundLastTransfer.id).toEqual(lastTransfer.id);
      expect(foundLastTransfer.payoutId).toEqual(lastTransfer.payoutId);
    });
  });

  describe('when some code executes updateTransferMetadata', () => {
    let payout: PayoutEntity;

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });
    });
    it('should update only metadata of a given transfer', async () => {
      const createdTransfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        payoutId: payout.id,
        metadata: {
          externalId: '1234',
        },
      });
      const updatedTransfer = await payoutNewService.updateTransferMetadata(
        createdTransfer.id,
        { message: 'Actualizar metadata de la transfer desde test' },
      );
      expect(updatedTransfer).toBeDefined();
      expect(updatedTransfer.metadata).toBeDefined();
      expect(updatedTransfer.metadata).toEqual(
        expect.objectContaining({
          externalId: '1234',
          message: 'Actualizar metadata de la transfer desde test',
        }),
      );
    });
  });

  describe('when some code executes updatePayoutMetadata', () => {
    let payout: PayoutEntity;

    afterEach(async () => {
      await payoutRepository.delete({ id: payout.id });
    });
    it('should update only metadata of a given payout', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        metadata: {
          message: 'Metadata con message',
        },
      });
      const updatedPayout = await payoutNewService.updatePayoutMetadata(
        payout.id,
        { action: PayoutActionSuggestion.AUTO_RETRY },
      );
      expect(updatedPayout).toBeDefined();
      expect(updatedPayout.metadata).toBeDefined();
      expect(updatedPayout.metadata).toEqual(
        expect.objectContaining({
          action: PayoutActionSuggestion.AUTO_RETRY,
          message: 'Metadata con message',
        }),
      );
    });
  });

  describe('when some code executes getExportableTransfers', () => {
    afterEach(async () => {
      await transferRepository.delete({ merchantId: merchant.id });
      await payoutRepository.delete({ merchantId: merchant.id });
    });
    it('should return an array of transfers', async () => {
      const transfers = await payoutNewService.getExportableTransfers(
        undefined,
      );
      expect(transfers).toBeInstanceOf(Array<TransferEntity>);
    });

    it('should return an empty array of transfers', async () => {
      const transfers = await payoutNewService.getExportableTransfers({
        to: '1999-01-01T00:00:00.000Z',
      });

      expect(transfers.length).toEqual(0);
    });

    it('should filter by date and return an array of transfers', async () => {
      const dateFrom = new Date('2020-01-01T00:00:00Z');
      const dateTo = new Date('2020-02-01T00:00:00Z');
      const payouts = Array(5)
        .fill(createPayoutDto)
        .map((createPayoutDto: CreatePayoutDto, index) => {
          const trackingCode = randUserName() + index;
          return payoutRepository.create({
            ...createPayoutDto,
            trackingCode,
            createdAt: randBetweenDate({ from: dateFrom, to: dateTo }),
            transfers: [{ ...createTransferDto, trackingCode }],
          });
        });

      await payoutRepository.save(payouts);
      const transfers = await payoutNewService.getExportableTransfers({
        from: dateFrom.toISOString(),
        to: dateTo.toISOString(),
      });

      expect(transfers.length).toEqual(5);
    });

    it('should filter by currency and return an array of transfers', async () => {
      const transfers = await payoutNewService.getExportableTransfers({
        currency: Currency.CHILE,
      });

      expect(
        transfers.every((t) => t.currency === Currency.CHILE),
      ).toBeTruthy();
    });

    it('should filter by a single state and return an array of transfers', async () => {
      const transfers = await payoutNewService.getExportableTransfers({
        states: [PayoutState.PENDING],
      });

      expect(transfers.every((t) => t.state === 'pending')).toBeTruthy();
    });

    it('should filter by multiple states and return an array of transfers', async () => {
      const trackingCode = 'completedPayout';

      const payout = payoutRepository.create({
        ...createPayoutDto,
        trackingCode,
        transfers: [{ ...createTransferDto, trackingCode }],
      });

      await payoutRepository.save(payout);

      const transfers = await payoutNewService.getExportableTransfers({
        states: [PayoutState.PENDING, PayoutState.COMPLETED],
      });

      expect(
        transfers.every(
          (t) => t.state === 'pending' || t.state === 'completed',
        ),
      ).toBeTruthy();
    });

    it('should filter by destinationBankCode and return an array of transfers', async () => {
      const destinationBankCode = 'cl_banco_falabella';
      const transfers = await payoutNewService.getExportableTransfers({
        destinationBankCode,
      });

      expect(
        transfers.every((t) => t.destinationBankCode === destinationBankCode),
      ).toBeTruthy();
    });

    it('should filter by originBankCode and return an array of transfers', async () => {
      const originBankCode = 'cl_banco_falabella';
      const transfers = await payoutNewService.getExportableTransfers({
        transfer: { originBankCode },
      });

      expect(
        transfers.every((t) => t.originBankCode === originBankCode),
      ).toBeTruthy();
    });
  });

  describe('when some code executes updateAutoRetried', () => {
    let transfer: TransferEntity;

    afterEach(async () => {
      await transferRepository.delete({ id: transfer.id });
    });

    it('then should update the autoRetried property of the transfer', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        autoRetried: false,
      });

      expect(transfer.autoRetried).toBeFalsy();

      const updatedTransfer = await payoutNewService.updateAutoRetried(
        transfer.id,
        true,
      );

      expect(updatedTransfer.autoRetried).toBeTruthy();
    });
    it('then should not update other properties but autoRetried', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        metadata: {
          existingKey: 'existingValue',
        },
        autoRetried: true,
      });

      const autoRetried = false;

      const updatedTransfer = await payoutNewService.updateAutoRetried(
        transfer.id,
        autoRetried,
      );

      expect(updatedTransfer).toEqual(
        expect.objectContaining({
          id: transfer.id,
          amount: transfer.amount,
          destinationName: transfer.destinationName,
          destinationEmail: transfer.destinationEmail,
          destinationAccount: transfer.destinationAccount,
          destinationHolderId: transfer.destinationHolderId,
          autoRetried,
          destinationBankCode: transfer.destinationBankCode,
          destinationPhone: transfer.destinationPhone,
          merchantId: transfer.merchantId,
          currency: transfer.currency,
          concept: transfer.concept,
          state: transfer.state,
          trackingCode: transfer.trackingCode,
          payoutId: transfer.payoutId,
          providerId: transfer.providerId,
        }),
      );
    });
  });

  describe('when some code executes cancelAllTransfers', () => {
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
    });

    it('then should cancel all transfers if they are cancelable', async () => {
      await providerRepository.save({
        id: provider.id,
        providerType: ProviderType.ScraperPW,
      });
      const cancelableStates = [
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
      ];

      const transfers = Array(2)
        .fill(createTransferDto)
        .map((createTransferDto: TransferEntity, index: number) =>
          transferRepository.create({
            ...createTransferDto,
            payoutId: payout.id,
            state: cancelableStates[index],
            providerId: provider.id,
          }),
        );

      const cancelableTransfers = await transferRepository.save(transfers);

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      await payoutNewService.cancelAllTransfers(payout, manager);
      await queryRunner.commitTransaction();
      await queryRunner.release();

      for (const transfer of cancelableTransfers) {
        const canceledTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        expect(canceledTransfer.state).toBe(TransferState.CANCELED);
      }
    });

    const cases = [
      ProviderType.Shinkansen,
      ProviderType.Liquido,
      ProviderType.Minka,
    ];
    it.each(cases)(
      'then should fail if the transfer is being processed by the %s provider',
      async (providerType: ProviderType) => {
        await providerRepository.save({
          id: provider.id,
          providerType,
        });
        const transfers = Array(2)
          .fill(createTransferDto)
          .map((createTransferDto: TransferEntity) =>
            transferRepository.create({
              ...createTransferDto,
              payoutId: payout.id,
              state: TransferState.PROCESSING,
              providerId: provider.id,
            }),
          );

        await transferRepository.save(transfers);

        const queryRunner = connection.createQueryRunner();
        try {
          const manager = queryRunner.manager;
          await queryRunner.startTransaction();
          const payoutToCancel = await manager.findOne(PayoutEntity, {
            where: {
              id: payout.id,
            },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });

          await payoutNewService.cancelAllTransfers(payoutToCancel, manager);
        } catch (error) {
          await queryRunner.release();
          expect(error).toBeInstanceOf(Error);
        }
      },
    );
  });

  // END HELPERS METHODS
  describe('when calling evaluateTransferAssignation', () => {
    let transfer: TransferEntity;
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });
      const createdTransfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        payoutId: payout.id,
      });
      transfer = await transferRepository.findOne({
        where: { id: createdTransfer.id },
        relations: ['payout', 'provider'],
      });
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      // await providerRepository.delete({ id: provider.id });
    });

    it('should return true if transfer it`s assignable for specified provider and return the transfer state ASSIGNED', async () => {
      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();

      const evaluateResult = await payoutNewService.evaluateTransferAssignation(
        transfer,
        manager,
        provider.id,
      );

      await queryRunner.commitTransaction();
      await queryRunner.release();

      const { result, detail } = evaluateResult;

      expect(result).toBeTruthy();
      expect(detail.message).toBeUndefined();
      expect(detail.provider.id).toBe(provider.id);
    });
    it('should return false if transfers it`s not assignable for specified provider and return the transfer state CANCELED', async () => {
      await providerRepository.update(provider.id, { state: State.INACTIVE });

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();

      const evaluateResult = await payoutNewService.evaluateTransferAssignation(
        transfer,
        manager,
        provider.id,
      );

      await queryRunner.commitTransaction();
      await queryRunner.release();

      const { result, detail } = evaluateResult;

      expect(result).toBeFalsy();
      expect(detail.message).toBeDefined();
      expect(detail.state).toBe(TransferState.CANCELED);
    });
    it('should return true if transfers it`s assignable and return the transfer state ASSIGNED', async () => {
      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      // HERE
      const evaluateResult = await payoutNewService.evaluateTransferAssignation(
        transfer,
        manager,
      );

      await queryRunner.commitTransaction();
      await queryRunner.release();

      const { result, detail } = evaluateResult;

      expect(result).toBeTruthy();
      expect(detail.message).toBeUndefined();
      expect(detail.provider).toBeDefined();
    });

    it('should return false if payout exceeds merchant limit and return the transfer state failed ', async () => {
      jest
        .spyOn(MerchantLimitEvaluatorService.prototype, 'evaluate')
        .mockReturnValue(
          Promise.resolve({
            exceeds: true,
            errorMessage: 'La transferencia excede el límite ...',
          }),
        );

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();

      const evaluateResult = await payoutNewService.evaluateTransferAssignation(
        transfer,
        manager,
      );

      await queryRunner.commitTransaction();
      await queryRunner.release();

      const { result, detail } = evaluateResult;

      expect(result).toBeFalsy();
      expect(detail.message).toBeDefined();
      expect(detail.state).toBe(TransferState.FAILED);
    });

    const cases = [
      TransferState.ASSIGNED,
      TransferState.CANCELED,
      TransferState.FAILED,
      TransferState.PROCESSING,
      TransferState.COMPLETED,
    ];
    it.each(cases)(
      'should return false if transfers it`s not assignable if it has state %s and return the transfer state CANCELED',
      async (state) => {
        await transferRepository.update(transfer.id, { state });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();

        const transferAssigned =
          await payoutNewService.evaluateTransferAssignation(transfer, manager);

        await queryRunner.commitTransaction();
        await queryRunner.release();

        const { result, detail } = transferAssigned;

        expect(result).toBeFalsy();
        expect(detail.message).toBeDefined();
        expect(detail.state).toBe(TransferState.CANCELED);
        expect(detail.provider).toBeUndefined();
      },
    );
  });

  describe('when calling createPayoutAndTransfer', () => {
    let transfer: TransferEntity;
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });

    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should create a pending payout and assign the new pending transfer if it`s assignable and emit TransferEvent.assigned', async () => {
      const createdPayout = await payoutNewService.createPayoutAndTransfer({
        ...createPayoutDto,
        trackingCode,
      });
      payout = await payoutRepository.findOne({
        where: { id: createdPayout.id },
        relations: ['transfers'],
      });

      expect(payout.transfers).toBeDefined();
      const payoutTransfers = payout.transfers;
      expect(payoutTransfers).toHaveLength(1);
      transfer = payoutTransfers[0];

      expect(createdPayout.state).toBe(PayoutState.PENDING);
      expect(transfer.state).toBe(TransferState.ASSIGNED);
      expect(eventEmitMock).toHaveBeenCalledWith(
        TransferEvent.ASSIGNED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.ASSIGNED,
          providerId: provider.id,
        }),
      );
    });
    it('should create a pending payout and cancel the new pending transfer if it`s not assignable base on evaluations', async () => {
      jest
        .spyOn(EntitiesValidationService.prototype, 'transferIsAssignable')
        .mockReturnValue({
          result: false,
          detail: {
            message: 'Transferencia no asignable',
            state: TransferState.CANCELED,
          },
        });

      const createdPayout = await payoutNewService.createPayoutAndTransfer({
        ...createPayoutDto,
        trackingCode,
      });
      payout = await payoutRepository.findOne({
        where: { id: createdPayout.id },
        relations: ['transfers'],
      });

      expect(payout.transfers).toBeDefined();
      const payoutTransfers = payout.transfers;
      expect(payoutTransfers).toHaveLength(1);
      transfer = payoutTransfers[0];

      expect(createdPayout.state).toBe(PayoutState.PENDING);
      expect(transfer).toEqual(
        expect.objectContaining({
          state: TransferState.CANCELED,
          message: 'Transferencia no asignable',
        }),
      );
    });
    it('should create a pending payout and cancel the new pending transfer if provider does not exist', async () => {
      jest
        .spyOn(EntitiesValidationService.prototype, 'providerIsValid')
        .mockReturnValue({
          result: false,
          detail: {
            message: 'No hay proveedores disponibles para la transferencia',
            state: TransferState.CANCELED,
          },
        });

      const createdPayout = await payoutNewService.createPayoutAndTransfer({
        ...createPayoutDto,
        trackingCode,
      });
      payout = await payoutRepository.findOne({
        where: { id: createdPayout.id },
        relations: ['transfers'],
      });

      const payoutTransfers = payout.transfers;
      transfer = payoutTransfers[0];

      expect(createdPayout.state).toBe(PayoutState.PENDING);
      expect(payoutTransfers).toHaveLength(1);
      expect(transfer).toEqual(
        expect.objectContaining({
          state: TransferState.CANCELED,
          message: 'No hay proveedores disponibles para la transferencia',
        }),
      );
    });
    it('should create a pending payout and cancel the new pending transfer if payout has a finished state', async () => {
      jest
        .spyOn(EntitiesValidationService.prototype, 'payoutIsUnfinished')
        .mockReturnValue({
          result: false,
          detail: {
            message: 'Transferencia cancelada por estado inválido del pago',
            state: TransferState.CANCELED,
          },
        });

      const createdPayout = await payoutNewService.createPayoutAndTransfer({
        ...createPayoutDto,
        trackingCode,
      });
      payout = await payoutRepository.findOne({
        where: { id: createdPayout.id },
        relations: ['transfers'],
      });

      const payoutTransfers = payout.transfers;
      transfer = payoutTransfers[0];

      expect(createdPayout.state).toBe(PayoutState.PENDING);
      expect(payoutTransfers).toHaveLength(1);
      expect(transfer).toEqual(
        expect.objectContaining({
          state: TransferState.CANCELED,
          message: 'Transferencia cancelada por estado inválido del pago',
        }),
      );
    });
  });

  describe.skip('when calling cancelPayoutAndTransfer', () => {
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should cancel a payout if it`s cancelable and emit payout canceled event', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.CANCELED,
        payoutId: payout.id,
        providerId: provider.id,
      });
      const canceledPayout = await payoutNewService.cancelPayoutAndTransfer(
        payout.id,
        transfer.id,
      );

      const canceledTransfers = await transferRepository.find({
        where: { payoutId: payout.id },
      });

      const everyCanceled = canceledTransfers.every(
        (transfer) => transfer.state === TransferState.CANCELED,
      );
      expect(canceledPayout.state).toBe(TransferState.CANCELED);
      expect(everyCanceled).toBeTruthy();
      expect(eventEmitMock).toHaveBeenCalledTimes(1);
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.CANCELED,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.CANCELED,
        }),
      );
    });

    it('should fail if payout if it`s not cancelable due its finished state', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.COMPLETED,
        trackingCode,
      });
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.CANCELED,
        payoutId: payout.id,
        providerId: provider.id,
      });
      await expect(
        payoutNewService.cancelPayoutAndTransfer(payout.id, transfer.id),
      ).rejects.toThrow(
        new UnprocessableEntityException(
          'Pago no encontrado con dichos parámetro de búsqueda',
        ),
      );
    });

    it('should handle concurrent call on cancelPayoutAndTransfer', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.CANCELED,
        payoutId: payout.id,
        providerId: provider.id,
      });
      const canceledPayout = payoutNewService.cancelPayoutAndTransfer(
        payout.id,
        transfer.id,
      );
      const canceledSecondPayout = payoutNewService.cancelPayoutAndTransfer(
        payout.id,
        transfer.id,
      );
      const concurrentCalls = await Promise.allSettled([
        canceledPayout,
        canceledSecondPayout,
      ]);
      const fulfilledResults = concurrentCalls.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = concurrentCalls.filter(
        (result) => result.status === 'rejected',
      );

      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);

      const canceledTransfers = await transferRepository.find({
        where: { payoutId: payout.id },
      });

      const everyCanceled = canceledTransfers.every(
        (transfer) => transfer.state === TransferState.CANCELED,
      );

      expect(everyCanceled).toBeTruthy();
      expect(eventEmitMock).toHaveBeenCalledTimes(1);
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.CANCELED,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.CANCELED,
        }),
      );
    });
  });

  describe('when calling completePayoutAndTransfer', () => {
    let payout: PayoutEntity;
    let transfer: TransferEntity;
    let provider: ProviderEntity;

    beforeEach(async () => {
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should complete the payout if its completable and complete the given transfer and emit corresponding events', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
        trackingCode,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const completedPayout = await payoutNewService.completePayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Completing payout from test',
        },
      );
      const completedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(completedPayout.state).toBe(PayoutState.COMPLETED);
      expect(completedTransfer.state).toBe(TransferState.COMPLETED);
      expect(eventEmitMock).toHaveBeenCalledTimes(2);
      expect(eventEmitMock).toHaveBeenCalledWith(
        TransferEvent.COMPLETED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.COMPLETED,
          providerId: provider.id,
        }),
      );
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.COMPLETED,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.COMPLETED,
        }),
      );
    });
    it(`should fail if payout it's not completable as it has finished state`, async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.CANCELED,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        payoutId: payout.id,
        providerId: provider.id,
      });

      await expect(
        payoutNewService.completePayoutAndTransfer(payout.id, transfer.id, {
          message: 'Cancelling payout from test',
        }),
      ).rejects.toThrow(
        new UnprocessableEntityException(
          `Pago no encontrado con dichos parámetro de búsqueda`,
        ),
      );

      const completedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      const unchangedPayout = await payoutRepository.findOne({
        where: { id: payout.id },
      });

      expect(completedTransfer.state).toBe(TransferState.PROCESSING);
      expect(unchangedPayout.state).toBe(PayoutState.CANCELED);
    });
    it(`should fail if transfer it's not completable as it has finished state`, async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.COMPLETED,
        providerId: provider.id,
      });

      await expect(
        payoutNewService.completePayoutAndTransfer(payout.id, transfer.id, {
          message: 'Cancelling payout from test',
        }),
      ).rejects.toThrow(
        new UnprocessableEntityException(
          `Invalid transition from ${transfer.state} to ${TransferState.COMPLETED}`,
        ),
      );

      const unchangedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      const unchangedPayout = await payoutRepository.findOne({
        where: { id: payout.id },
      });

      expect(unchangedTransfer.state).toBe(TransferState.COMPLETED);
      expect(unchangedPayout.state).toBe(PayoutState.PROCESSING);
    });
    it('should update payout even if it not has unique completed transfer and send alert ', async () => {
      const notifyPayoutInconsistentSpy = jest.spyOn(
        AlertsService.prototype,
        'notifyPayoutInconsistent',
      );

      jest
        .spyOn(
          EntitiesValidationService.prototype,
          'payoutUniqueTransferCompleted',
        )
        .mockReturnValue({
          result: false,
          detail: {
            message: 'No se encontró la transferencia completada',
          },
        });

      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.PROCESSING,
        providerId: provider.id,
      });

      const serviceResult = await payoutNewService.completePayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Cancelling payout from test',
        },
      );

      expect(serviceResult.state).toBe(PayoutState.COMPLETED);
      expect(notifyPayoutInconsistentSpy).toHaveBeenCalledWith(
        expect.objectContaining({ id: payout.id }),
        expect.stringContaining('No se encontró la transferencia completada'),
      );
    });
    it('should handle concurrent call on completePayoutAndTransfer', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
        trackingCode,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const completedPayout = payoutNewService.completePayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Completing payout from test',
        },
      );
      const completedSecondPayout = payoutNewService.completePayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Completing payout from test',
        },
      );
      const concurrentCalls = await Promise.allSettled([
        completedPayout,
        completedSecondPayout,
      ]);
      const fulfilledResults = concurrentCalls.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = concurrentCalls.filter(
        (result) => result.status === 'rejected',
      );

      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);

      expect(eventEmitMock).toHaveBeenCalledTimes(2);
      expect(eventEmitMock).toHaveBeenCalledWith(
        TransferEvent.COMPLETED,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.COMPLETED,
          providerId: provider.id,
        }),
      );
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.COMPLETED,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.COMPLETED,
        }),
      );
    });
  });

  describe('when calling processPayoutAndTransfer', () => {
    let payout: PayoutEntity;
    let transfer: TransferEntity;
    let provider: ProviderEntity;

    beforeEach(async () => {
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should update the payout and transfer to processing state if payout is in pending state and the transfer in assigned state and emit corresponding event', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const processedTransfer = await payoutNewService.processPayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Processing payout from test',
        },
      );
      const processedPayout = await payoutRepository.findOne({
        where: { id: payout.id },
      });

      expect(processedPayout.state).toBe(PayoutState.PROCESSING);
      expect(processedTransfer.state).toBe(TransferState.PROCESSING);
      expect(eventEmitMock).toHaveBeenCalledTimes(2);
      expect(eventEmitMock).toHaveBeenCalledWith(
        TransferEvent.PROCESSING,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.PROCESSING,
          providerId: provider.id,
        }),
      );
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.PROCESSING,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.PROCESSING,
        }),
      );
    });

    it('should fail if the transfer is not in assigned state', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.COMPLETED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      await expect(
        payoutNewService.processPayoutAndTransfer(payout.id, transfer.id, {
          message: 'Processing payout from test',
        }),
      ).rejects.toThrow(
        new UnprocessableEntityException(
          `Invalid transition from ${transfer.state} to ${TransferState.PROCESSING}`,
        ),
      );
    });

    it('should fail if the payoutId does not match the one from the transfer', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const differentPayoutId = -1;

      await expect(
        payoutNewService.processPayoutAndTransfer(
          differentPayoutId,
          transfer.id,
          {
            message: 'Processing payout from test',
          },
        ),
      ).rejects.toThrow(
        new UnprocessableEntityException('Transferencia no encontrada'),
      );
    });

    it('should notify if a payout has more than two transfers in processing', async () => {
      const notifyPayoutInconsistentSpy = jest.spyOn(
        AlertsService.prototype,
        'notifyPayoutInconsistent',
      );

      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
      });

      await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
        payoutId: payout.id,
        providerId: provider.id,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      await payoutNewService.processPayoutAndTransfer(payout.id, transfer.id);

      expect(notifyPayoutInconsistentSpy).toHaveBeenCalled();
    });

    it('should not update the payout to processing state if it is already in processing state', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const processedTransfer = await payoutNewService.processPayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Processing payout from test',
        },
      );

      const processedPayout = await payoutRepository.findOne({
        where: { id: payout.id },
      });

      expect(processedPayout.state).toBe(PayoutState.PROCESSING);
      expect(processedTransfer.state).toBe(TransferState.PROCESSING);
    });

    it('should handle concurrent calls on processTransferAndPayout', async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
        trackingCode,
      });

      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.ASSIGNED,
        payoutId: payout.id,
        providerId: provider.id,
      });

      const processedTransfer = payoutNewService.processPayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Processing payout from test',
        },
      );
      const processedSecondTransfer = payoutNewService.processPayoutAndTransfer(
        payout.id,
        transfer.id,
        {
          message: 'Processing payout from test',
        },
      );
      const concurrentCalls = await Promise.allSettled([
        processedTransfer,
        processedSecondTransfer,
      ]);
      const fulfilledResults = concurrentCalls.filter(
        (result) => result.status === 'fulfilled',
      );
      const rejectedResults = concurrentCalls.filter(
        (result) => result.status === 'rejected',
      );
      expect(fulfilledResults.length).toBe(1);
      expect(rejectedResults.length).toBe(1);

      const processedPayout = await payoutRepository.findOne({
        where: { id: payout.id },
      });

      expect(processedPayout.state).toBe(PayoutState.PROCESSING);
      expect(eventEmitMock).toHaveBeenCalledTimes(2);
      expect(eventEmitMock).toHaveBeenCalledWith(
        TransferEvent.PROCESSING,
        expect.objectContaining({
          payoutId: payout.id,
          id: transfer.id,
          state: TransferState.PROCESSING,
          providerId: provider.id,
        }),
      );
      expect(eventEmitMock).toHaveBeenCalledWith(
        PayoutEvent.PROCESSING,
        expect.objectContaining({
          id: payout.id,
          state: PayoutState.PROCESSING,
        }),
      );
    });

    describe('and payout is in a final state', () => {
      const states = [
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];

      it.each(states)(
        'should fail if payout is in %state state and transfer is a processable state',
        async (state) => {
          payout = await payoutRepository.save({
            ...createPayoutDto,
            state,
          });

          transfer = await transferRepository.save({
            ...createTransferDto,
            state: TransferState.ASSIGNED,
            payoutId: payout.id,
            providerId: provider.id,
          });

          await expect(
            payoutNewService.processPayoutAndTransfer(payout.id, transfer.id),
          ).rejects.toThrow(
            new UnprocessableEntityException(
              `El pago ${payout.id} se encuentra en estado inválido`,
            ),
          );
        },
      );
    });
  });

  describe('when calling createTransferAndAssign', () => {
    let transfer: TransferEntity;
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PENDING,
      });
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });

    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should create a transfer and assign it to a provider if it`s assignable', async () => {
      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      const lockedPayout = await manager.findOne(PayoutEntity, {
        where: {
          id: payout.id,
        },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      transfer = await payoutNewService.createTransferAndAssign(
        lockedPayout,
        manager,
      );
      await queryRunner.commitTransaction();
      await queryRunner.release();

      expect(transfer.state).toBe(TransferState.ASSIGNED);
      expect(transfer.providerId).toBeDefined();
    });
    it('should create a transfer and assign it to specified provider if it`s assignable', async () => {
      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      const lockedPayout = await manager.findOne(PayoutEntity, {
        where: {
          id: payout.id,
        },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      transfer = await payoutNewService.createTransferAndAssign(
        lockedPayout,
        manager,
        provider.id,
      );
      await queryRunner.commitTransaction();
      await queryRunner.release();

      expect(transfer.state).toBe(TransferState.ASSIGNED);
      expect(transfer.providerId).toBe(provider.id);
    });
    it('should create a transfer and cancel it if it`s not assignable', async () => {
      jest
        .spyOn(EntitiesValidationService.prototype, 'transferIsAssignable')
        .mockReturnValue({
          result: false,
          detail: {
            message: 'Transferencia no asignable',
            state: TransferState.CANCELED,
          },
        });

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      const lockedPayout = await manager.findOne(PayoutEntity, {
        where: {
          id: payout.id,
        },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      transfer = await payoutNewService.createTransferAndAssign(
        lockedPayout,
        manager,
        provider.id,
      );
      await queryRunner.commitTransaction();
      await queryRunner.release();

      expect(transfer.state).toBe(TransferState.CANCELED);
      expect(transfer.providerId).toBeNull();
    });
    describe('when there are merchant limits to evaluate', () => {
      let limit: MerchantLimitEntity;

      beforeEach(async () => {
        limit = await merchantLimitRepository.save({
          ...createMerchantLimitDto,
          merchantId: merchant.id,
        });
      });

      afterEach(async () => {
        merchantLimitRepository.delete(limit.id);
      });

      it('should create a transfer and failed it if payout exceeds merchant limit', async () => {
        // limite CLP $999
        // por persona por hora
        const evaluatorSpy = jest.spyOn(
          MerchantLimitEvaluatorService.prototype,
          'evaluate',
        );

        jest
          .spyOn(TransferErrorService.prototype, 'findOrCreateError')
          .mockImplementation(async () => new TransferErrorEntity());

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const lockedPayout = await manager.findOne(PayoutEntity, {
          where: {
            id: payout.id,
          },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });

        transfer = await payoutNewService.createTransferAndAssign(
          lockedPayout,
          manager,
          provider.id,
        );
        await queryRunner.commitTransaction();
        await queryRunner.release();

        expect(transfer.state).toBe(TransferState.FAILED);
        expect(transfer.providerId).toBeNull();
        expect(evaluatorSpy).toHaveBeenCalledWith(
          expect.objectContaining({ id: payout.id }),
        );
      });
      it('should create a transfer and assigned it if payout does not exceeds merchant limit', async () => {
        // limite CLP $999
        // por persona por hora
        const evaluatorSpy = jest.spyOn(
          MerchantLimitEvaluatorService.prototype,
          'evaluate',
        );

        jest
          .spyOn(TransferErrorService.prototype, 'findOrCreateError')
          .mockImplementation(async () => new TransferErrorEntity());

        await payoutRepository.update(payout.id, {
          amount: createMerchantLimitDto.limitDefinition.value - 1,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const lockedPayout = await manager.findOne(PayoutEntity, {
          where: {
            id: payout.id,
          },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        transfer = await payoutNewService.createTransferAndAssign(
          lockedPayout,
          manager,
          provider.id,
        );
        await queryRunner.commitTransaction();
        await queryRunner.release();

        expect(transfer.state).toBe(TransferState.ASSIGNED);
        expect(transfer.providerId).toBe(provider.id);
        expect(evaluatorSpy).toHaveBeenCalledWith(
          expect.objectContaining({ id: payout.id }),
        );
      });
    });
    describe('when payout has multiple transfers', () => {
      it('should create a transfer and assign it only if the other payout transfers are canceled', async () => {
        await transferRepository.save({
          ...createTransferDto,
          state: TransferState.CANCELED,
          payoutId: payout.id,
          trackingCode,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const lockedPayout = await manager.findOne(PayoutEntity, {
          where: {
            id: payout.id,
          },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });

        transfer = await payoutNewService.createTransferAndAssign(
          lockedPayout,
          manager,
        );
        await queryRunner.commitTransaction();
        await queryRunner.release();

        expect(transfer.state).toBe(TransferState.ASSIGNED);
        expect(transfer.providerId).toBeDefined();
      });
      it('should fail if payout transfers are not canceled', async () => {
        await transferRepository.save({
          ...createTransferDto,
          state: TransferState.PENDING,
          payoutId: payout.id,
          trackingCode,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        try {
          await queryRunner.startTransaction();
          const lockedPayout = await manager.findOne(PayoutEntity, {
            where: {
              id: payout.id,
            },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });
          await payoutNewService.createTransferAndAssign(lockedPayout, manager);
        } catch (error) {
          expect(error).toBeInstanceOf(Error);
          await queryRunner.rollbackTransaction();
        } finally {
          await queryRunner.release();
        }
      });
    });
  });

  describe.skip('when calling processTransfer', () => {
    let transfer: TransferEntity;
    let payout: PayoutEntity;
    let provider: ProviderEntity;
    trackingCode = randNumberString();

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });

    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    const processableCases = [TransferState.ASSIGNED];
    it.each(processableCases)(
      'should process the transfer as state %s its completable',
      async (state) => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state,
        });
        const options = {
          message: `Procesando transferencia desde test por proveedor ${provider.id}`,
          externalId: '123-456',
        };
        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();

        const processedTransfer = (await (
          payoutNewService as any
        ).processTransfer(transfer, manager, options)) as TransferEntity;

        await queryRunner.commitTransaction();
        await queryRunner.release();

        expect(processedTransfer).toEqual(
          expect.objectContaining({
            state: TransferState.PROCESSING,
            message: options.message,
            externalId: options.externalId,
          }),
        );
      },
    );
    const nonProcessableCases = [
      TransferState.CANCELED,
      TransferState.COMPLETED,
      TransferState.FAILED,
      TransferState.PENDING,
      TransferState.PROCESSING,
    ];
    it.each(nonProcessableCases)(
      'should fail if transfer does not have processable state',
      async (state) => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;

        try {
          await queryRunner.startTransaction();

          await (payoutNewService as any).processTransfer(transfer, manager);
        } catch (error) {
          expect(error).toBeInstanceOf(Error);
          // new UnprocessableEntityException('Transfer process failed');
        } finally {
          await queryRunner.release();
        }

        const unchangedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        expect(unchangedTransfer.state).toBe(state);
      },
    );
    it('should fail if transfer does not belong to payout', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        providerId: provider.id,
        trackingCode,
        payoutId: payout.id,
        state: TransferState.PENDING,
      });

      const anotherPayout = await payoutRepository.save({
        ...createPayoutDto,
        trackingCode: randNumberString(),
        state: PayoutState.PROCESSING,
      });

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;

      try {
        await queryRunner.startTransaction();
        const lockedTransfer = await manager.findOne(TransferEntity, {
          where: { id: transfer.id },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        await (payoutNewService as any).processTransfer(
          lockedTransfer,
          manager,
        );
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        // expect(error.message).toBe('Transferencia no encontrada');
      } finally {
        await queryRunner.release();
      }
      await payoutRepository.delete({ id: anotherPayout.id });
    });

    it('should fail if transfer does not exist', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        payoutId: payout.id,
      });

      await transferRepository.delete({ id: transfer.id });

      const queryRunner = connection.createQueryRunner();
      try {
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const lockedTransfer = await manager.findOne(TransferEntity, {
          where: { id: transfer.id },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });

        await (payoutNewService as any).processTransfer(
          lockedTransfer,
          manager,
        );
      } catch (error) {
        await queryRunner.release();
        expect(error).toBeInstanceOf(UnprocessableEntityException);
        expect(error.message).toBe('Transferencia no encontrada');
      }

      const removedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(removedTransfer).toBeNull();
    });
  });

  describe('when calling cancelTransfer', () => {
    let payout: PayoutEntity;
    let transfer: TransferEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });

      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });
    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    it('should cancel the transfer even if transfer does not have provider', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        payoutId: payout.id,
        providerId: null,
        provider: null,
      });

      const queryRunner = connection.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();
      const lockedTransfer = await manager.findOne(TransferEntity, {
        where: { id: transfer.id },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      const lockedPayout = await manager.findOne(PayoutEntity, {
        where: {
          id: payout.id,
        },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });

      const canceledTransfer = await payoutNewService.cancelTransfer(
        lockedTransfer,
        lockedPayout,
        manager,
      );
      await queryRunner.commitTransaction();
      await queryRunner.release();

      const transferPayout = await payoutRepository.findOne({
        where: { id: transfer.payoutId },
      });

      expect(canceledTransfer.state).toBe(TransferState.CANCELED);
      expect(canceledTransfer.providerId).toBeNull();
      expect(transferPayout.state).toBe(payout.state);
    });

    it('should fail if transfer does not exist', async () => {
      transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PENDING,
        payoutId: payout.id,
      });

      await transferRepository.delete({ id: transfer.id });

      const queryRunner = connection.createQueryRunner();
      try {
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const lockedTransfer = await manager.findOne(TransferEntity, {
          where: { id: transfer.id },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        const lockedPayout = await manager.findOne(PayoutEntity, {
          where: {
            id: payout.id,
          },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        await payoutNewService.cancelTransfer(
          lockedTransfer,
          lockedPayout,
          manager,
        );
      } catch (error) {
        await queryRunner.release();
        expect(error).toBeInstanceOf(UnprocessableEntityException);
        expect(error.message).toBe('Transferencia no encontrada');
      }

      const removedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(removedTransfer).toBeNull();
    });

    describe('when provider allow cancel', () => {
      it('should cancel the transfer if its cancelable, keep payout state and update message and metadata as are given', async () => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state: TransferState.PROCESSING,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();
        const processingTransfer = await manager.findOne(TransferEntity, {
          where: { id: transfer.id },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        const lockedPayout = await manager.findOne(PayoutEntity, {
          where: {
            id: payout.id,
          },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });
        const canceledTransfer = await payoutNewService.cancelTransfer(
          processingTransfer,
          lockedPayout,
          manager,
          {
            message: 'Transferencia cancelada desde test',
            metadata: {
              message: 'Not real transfer',
            },
          },
        );
        await queryRunner.commitTransaction();
        await queryRunner.release();

        const transferPayout = await payoutRepository.findOne({
          where: { id: transfer.payoutId },
        });

        expect(canceledTransfer.state).toBe(TransferState.CANCELED);
        expect(canceledTransfer.message).toBe(
          'Transferencia cancelada desde test',
        );
        expect(canceledTransfer.metadata.message).toBe('Not real transfer');
        expect(transferPayout.state).toBe(payout.state);
      });
      it('should fail if the transfer its not cancelable base on actual state and keep payout state', async () => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          provider: provider,
          trackingCode,
          payoutId: payout.id,
          state: TransferState.COMPLETED,
        });

        const queryRunner = connection.createQueryRunner();
        try {
          const manager = queryRunner.manager;
          await queryRunner.startTransaction();
          const completedTransfer = await manager.findOne(TransferEntity, {
            where: { id: transfer.id },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });
          const lockedPayout = await manager.findOne(PayoutEntity, {
            where: {
              id: payout.id,
            },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });

          await payoutNewService.cancelTransfer(
            completedTransfer,
            lockedPayout,
            manager,
          );
        } catch (error) {
          await queryRunner.release();
          expect(error).toBeInstanceOf(Error);
          // expect(error.message).toBe(
          //   `Invalid transition from ${transfer.state} to ${TransferState.CANCELED}`,
          // );
        }

        const unchangedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        const unchangedPayout = await payoutRepository.findOne({
          where: { id: transfer.payoutId },
        });

        expect(unchangedTransfer.state).toBe(transfer.state);
        expect(unchangedPayout.state).toBe(payout.state);
      });
    });

    describe('when provider does not allow to cancel', () => {
      it("then should fail if the provider can't cancel the transaction", async () => {
        provider = await providerRepository.save({
          ...createProviderDto,
          providerType: ProviderType.Shinkansen,
        });
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state: TransferState.PROCESSING,
        });

        const queryRunner = connection.createQueryRunner();
        try {
          const manager = queryRunner.manager;
          await queryRunner.startTransaction();
          const processingTransfer = await manager.findOne(TransferEntity, {
            where: { id: transfer.id },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });
          const lockedPayout = await manager.findOne(PayoutEntity, {
            where: {
              id: payout.id,
            },
            lock: { mode: LockMode.PESSIMISTIC_READ },
          });
          await payoutNewService.cancelTransfer(
            processingTransfer,
            lockedPayout,
            manager,
          );
        } catch (error) {
          await queryRunner.release();
          expect(error).toBeInstanceOf(Error);
          // new UnprocessableEntityException('Transfer cancellation failed'),
        }

        const unchangedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });
        const transferPayout = await payoutRepository.findOne({
          where: { id: transfer.payoutId },
        });

        expect(unchangedTransfer.state).toBe(transfer.state);
        expect(transferPayout.state).toBe(payout.state);
      });
    });
  });

  describe('when calling completeTransfer', () => {
    let transfer: TransferEntity;
    let payout: PayoutEntity;
    let provider: ProviderEntity;

    trackingCode = randNumberString();

    beforeEach(async () => {
      payout = await payoutRepository.save({
        ...createPayoutDto,
        state: PayoutState.PROCESSING,
      });
      provider = await providerRepository.save({
        ...createProviderDto,
      });
    });

    afterEach(async () => {
      await transferRepository.delete({ payoutId: payout.id });
      await payoutRepository.delete({ id: payout.id });
      await providerRepository.delete({ id: provider.id });
    });

    const completableCases = [TransferState.PROCESSING, TransferState.FAILED];
    it.each(completableCases)(
      'should complete the transfer as state %s its completable',
      async (state) => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state,
        });

        const options = {
          message: `Transferencia completada por proveedor ${provider.id}`,
        };

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        await queryRunner.startTransaction();

        const lockedTransfer = await manager.findOne(TransferEntity, {
          where: { id: transfer.id },
          lock: { mode: LockMode.PESSIMISTIC_READ },
        });

        const completedTransfer = (await (
          payoutNewService as any
        ).completeTransfer(lockedTransfer, manager, options)) as TransferEntity;
        await queryRunner.commitTransaction();
        await queryRunner.release();

        expect(completedTransfer).toEqual(
          expect.objectContaining({
            state: TransferState.COMPLETED,
            message: options.message,
          }),
        );
      },
    );

    const nonCompletableCases = [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.COMPLETED,
      TransferState.CANCELED,
    ];
    it.each(nonCompletableCases)(
      'should fail update as transfer state %s its not completable',
      async (state) => {
        transfer = await transferRepository.save({
          ...createTransferDto,
          providerId: provider.id,
          trackingCode,
          payoutId: payout.id,
          state,
        });

        const queryRunner = connection.createQueryRunner();
        const manager = queryRunner.manager;
        try {
          await queryRunner.startTransaction();
          await (payoutNewService as any).completeTransfer(transfer, manager);
        } catch (error) {
          await queryRunner.release();
          expect(error).toBeInstanceOf(Error);
          // new UnprocessableEntityException('Transfer completeness failed'),
        }

        const unchangedTransfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        expect(unchangedTransfer.state).toBe(state);
      },
    );
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/auditLogService.e2e-spec.ts
import { CreateAuditLogDto } from 'src/api/v2/audit-log/dto/create-audit-log.dto';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { app } from 'test/app.setup';

describe('Given an AuditLogService', () => {
  let service: AuditLogService;

  beforeAll(async () => {
    service = app.get(AuditLogService);
  });

  describe('When some code executes the create method', () => {
    it('Then should fail if invalid object is provided', async () => {
      const invalidObject: any = { invalidProp: 'Hello world' };

      await expect(service.create(invalidObject)).rejects.toThrow();
    });

    it('Then should create an audit log', async () => {
      const entityAfter = {
        id: 1,
        amount: 100,
      };

      const createAuditLogDto: CreateAuditLogDto = {
        authorId: 1,
        authorType: UserEntity.name,
        entityId: '1',
        entityType: PayoutEntity.name,
        event: AuditLogEvent.INSERT,
        entityAfter: JSON.stringify(entityAfter),
      };
      const auditLog = await service.create(createAuditLogDto);

      expect(auditLog).toBeDefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/metricsService.e2e-spec.ts
import moment = require('moment');
import { Repository } from 'typeorm';
import { randUuid } from '@ngneat/falso';
import { app, connection } from 'test/app.setup';

import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';

import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

import { MetricsService } from 'src/services/metrics/metrics.service';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given an MetricsService', () => {
  let metricsService: MetricsService;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let providerOne: ProviderEntity;
  let providerTwo: ProviderEntity;

  const createAccountDto: Partial<AccountEntity> = {
    bankCode: BankCode.BANCO_SANTANDER,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '45912391',
    merchantId: undefined,
  };

  const createProviderDto: Partial<ProviderEntity> = {
    name: 'Test Provider',
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.ScraperCG,
    accountId: undefined,
  };

  const createPayoutDto: Partial<PayoutEntity> = {
    amount: 1000,
    concept: 'Pago Buk Adelantos',
    destinationName: 'Vicente Fuenzalida',
    destinationPhone: '999999999',
    destinationEmail: 'vfuenzalida@buk.cl',
    destinationAccount: '00000111111222223333',
    destinationHolderId: '189340223',
    destinationBankCode: BankCode.BANCO_SANTANDER,
    currency: Currency.CHILE,
    version: EntityVersion.v2,
    merchantId: undefined,
  };

  const createTransferDto: Partial<TransferEntity> = {
    amount: 1000,
    concept: 'Pago Buk Adelantos',
    destinationName: 'Vicente Fuenzalida',
    destinationPhone: '999999999',
    destinationEmail: 'vfuenzalida@buk.cl',
    destinationAccount: '00000111111222223333',
    destinationHolderId: '189340223',
    destinationBankCode: BankCode.BANCO_SANTANDER,
    currency: Currency.CHILE,
    version: EntityVersion.v2,
    merchantId: undefined,
  };

  async function createPayout(
    payoutDto: Partial<PayoutEntity>,
  ): Promise<PayoutEntity> {
    const trackingCode = payoutDto.trackingCode ?? randUuid();

    return await payoutRepository.save({
      ...createPayoutDto,
      trackingCode,
      ...payoutDto,
    });
  }

  async function createTransfer(
    transferDto: Partial<TransferEntity>,
  ): Promise<TransferEntity> {
    const trackingCode = transferDto.trackingCode ?? randUuid();

    if (!transferDto.payoutId) {
      const payout = await createPayout({
        ...createPayoutDto,
        trackingCode,
      });

      transferDto.payoutId = payout.id;
    }

    return await transferRepository.save({
      ...createTransferDto,
      trackingCode,
      providerId: providerOne.id,
      state: TransferState.PENDING,
      ...transferDto,
    });
  }

  async function createTransfers(
    quantity: number,
    transferDto: Partial<TransferEntity>,
  ): Promise<TransferEntity[]> {
    const transfers: TransferEntity[] = [];

    for (let i = 0; i < quantity; i++) {
      const transfer = await createTransfer(transferDto);
      transfers.push(transfer);
    }

    return transfers;
  }

  beforeAll(async () => {
    metricsService = app.get(MetricsService);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();

    const merchantId = testMerchant.merchantId;

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId,
    });

    providerOne = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    providerTwo = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    createPayoutDto.merchantId = merchantId;
    createTransferDto.merchantId = merchantId;
  });

  afterEach(async () => {
    const merchantId = testMerchant.merchantId;

    await transferRepository.delete({ merchantId });
    await payoutRepository.delete({ merchantId });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('getStateMetrics method', () => {
    it('should return an object with transfer states as keys and numbers as values', async () => {
      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result).toEqual({
        [TransferState.PENDING]: 0,
        [TransferState.ASSIGNED]: 0,
        [TransferState.PROCESSING]: 0,
        [TransferState.COMPLETED]: 0,
        [TransferState.CANCELED]: 0,
        [TransferState.FAILED]: 0,
      });
    });

    it('should count all pending transfers if present', async () => {
      const count = 2;
      await createTransfers(count, { state: TransferState.PENDING });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.PENDING]).toEqual(count);
    });

    it('should count all assigned transfers if present', async () => {
      const count = 3;
      await createTransfers(count, { state: TransferState.ASSIGNED });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.ASSIGNED]).toEqual(count);
    });

    it('should count all processing transfers if present', async () => {
      const count = 5;
      await createTransfers(count, { state: TransferState.PROCESSING });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.PROCESSING]).toEqual(count);
    });

    it('should count all completed transfers if present', async () => {
      const count = 4;
      await createTransfers(count, { state: TransferState.COMPLETED });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.COMPLETED]).toEqual(count);
    });

    it('should count all canceled transfers if present', async () => {
      const count = 5;
      await createTransfers(count, { state: TransferState.CANCELED });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.CANCELED]).toEqual(count);
    });

    it('should count all failed transfers if present', async () => {
      const count = 2;
      await createTransfers(count, { state: TransferState.FAILED });

      const result = await metricsService.getStateMetrics(providerOne.id);

      expect(result[TransferState.FAILED]).toEqual(count);
    });

    describe('when date filters are provided', () => {
      it('should count all transfers within the date range', async () => {
        const referenceDate = '2021-01-01T00:00:00.000Z';

        const countIn = 5;
        const countOut = 3;

        await createTransfers(countIn, {
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).toDate(),
        });

        await createTransfers(countOut, {
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).add(2, 'day').toDate(),
        });

        const filters = {
          startDate: moment(referenceDate).toDate(),
          endDate: moment(referenceDate).add(1, 'day').toDate(),
        };

        const result = await metricsService.getStateMetrics(
          providerOne.id,
          filters,
        );

        expect(result[TransferState.COMPLETED]).toEqual(countIn);
      });

      it('should not count transfers outside the date range', async () => {
        const referenceDate = '2021-01-01T00:00:00.000Z';

        const countOut = 7;

        await createTransfers(countOut, {
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).add(2, 'day').toDate(),
        });

        const filters = {
          startDate: moment(referenceDate).toDate(),
          endDate: moment(referenceDate).add(1, 'day').toDate(),
        };

        const result = await metricsService.getStateMetrics(
          providerOne.id,
          filters,
        );

        expect(result[TransferState.COMPLETED]).toEqual(0);
      });
    });
  });

  describe('getTimeMetrics method', () => {
    it('should return an object with time stats interface', async () => {
      const result = await metricsService.getTimeMetrics(providerOne.id);

      expect(result).toEqual({
        avg: 0,
        max: 0,
        min: 0,
      });
    });

    it('should return the average duration in seconds for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const durationOne = 3 * 60;
      const durationTwo = 9 * 60;

      const averageDuration = (durationOne + durationTwo) / 2;

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationOne, 'seconds').toDate(),
      });

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationTwo, 'seconds').toDate(),
      });

      const result = await metricsService.getTimeMetrics(providerOne.id);

      expect(result['avg']).toEqual(averageDuration);
    });

    it('should return the maximum duration in seconds for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const durationOne = 2 * 60;
      const durationTwo = 20 * 60;

      const maximumDuration = Math.max(durationOne, durationTwo);

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationOne, 'seconds').toDate(),
      });

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationTwo, 'seconds').toDate(),
      });

      const result = await metricsService.getTimeMetrics(providerOne.id);

      expect(result['max']).toEqual(maximumDuration);
    });

    it('should return the minimum duration in seconds for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const durationOne = 7 * 60;
      const durationTwo = 40 * 60;

      const minimumDuration = Math.min(durationOne, durationTwo);

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationOne, 'seconds').toDate(),
      });

      await createTransfer({
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(durationTwo, 'seconds').toDate(),
      });

      const result = await metricsService.getTimeMetrics(providerOne.id);

      expect(result['min']).toEqual(minimumDuration);
    });

    describe('when date filters are provided', () => {
      it('should count all transfers within the date range', async () => {
        const referenceDate = '2021-01-01T00:00:00.000Z';

        await createTransfer({
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).toDate(),
          startedAt: moment(referenceDate).toDate(),
          finishedAt: moment(referenceDate).add(10, 'seconds').toDate(),
        });

        await createTransfer({
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).toDate(),
          startedAt: moment(referenceDate).toDate(),
          finishedAt: moment(referenceDate).add(20, 'seconds').toDate(),
        });

        await createTransfer({
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).add(2, 'day').toDate(),
          startedAt: moment(referenceDate).add(2, 'day').toDate(),
          finishedAt: moment(referenceDate)
            .add(2, 'day')
            .add(30, 'seconds')
            .toDate(),
        });

        const filters = {
          startDate: moment(referenceDate).toDate(),
          endDate: moment(referenceDate).add(1, 'day').toDate(),
        };

        const result = await metricsService.getTimeMetrics(
          providerOne.id,
          filters,
        );

        expect(result['avg']).toEqual(15);
        expect(result['max']).toEqual(20);
        expect(result['min']).toEqual(10);
      });

      it('should not count transfers outside the date range', async () => {
        const referenceDate = '2021-01-01T00:00:00.000Z';

        await createTransfer({
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).add(2, 'day').toDate(),
          startedAt: moment(referenceDate).add(2, 'day').toDate(),
          finishedAt: moment(referenceDate)
            .add(2, 'day')
            .add(10, 'seconds')
            .toDate(),
        });

        await createTransfer({
          state: TransferState.COMPLETED,
          createdAt: moment(referenceDate).add(3, 'day').toDate(),
          startedAt: moment(referenceDate).add(3, 'day').toDate(),
          finishedAt: moment(referenceDate)
            .add(3, 'day')
            .add(20, 'seconds')
            .toDate(),
        });

        const filters = {
          startDate: moment(referenceDate).toDate(),
          endDate: moment(referenceDate).add(1, 'day').toDate(),
        };

        const result = await metricsService.getTimeMetrics(
          providerOne.id,
          filters,
        );

        expect(result['avg']).toEqual(0);
        expect(result['max']).toEqual(0);
        expect(result['min']).toEqual(0);
      });
    });
  });

  describe('getAmountMetrics method', () => {
    it('should return an object with amount stats interface', async () => {
      const result = await metricsService.getAmountMetrics(providerOne.id);

      expect(result).toEqual({
        avg: 0,
        max: 0,
        min: 0,
        sum: 0,
      });
    });

    it('should return the average amount for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const amountOne = 10000;
      const amountTwo = 50000;

      const averageAmount = (amountOne + amountTwo) / 2;

      await createTransfer({
        amount: amountOne,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(5, 'seconds').toDate(),
      });

      await createTransfer({
        amount: amountTwo,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(10, 'seconds').toDate(),
      });

      const result = await metricsService.getAmountMetrics(providerOne.id);

      expect(result['avg']).toEqual(averageAmount);
    });

    it('should return the maximum amount for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const amountOne = 120000;
      const amountTwo = 130000;

      const maximumAmount = Math.max(amountOne, amountTwo);

      await createTransfer({
        amount: amountOne,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(5, 'seconds').toDate(),
      });

      await createTransfer({
        amount: amountTwo,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(10, 'seconds').toDate(),
      });

      const result = await metricsService.getAmountMetrics(providerOne.id);

      expect(result['max']).toEqual(maximumAmount);
    });

    it('should return the minimum amount for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const amountOne = 30000;
      const amountTwo = 170000;

      const minimumAmount = Math.min(amountOne, amountTwo);

      await createTransfer({
        amount: amountOne,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(5, 'seconds').toDate(),
      });

      await createTransfer({
        amount: amountTwo,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(10, 'seconds').toDate(),
      });

      const result = await metricsService.getAmountMetrics(providerOne.id);

      expect(result['min']).toEqual(minimumAmount);
    });

    it('should return the total amount for the completed transfers', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const amountOne = 410000;
      const amountTwo = 170000;
      const amountThree = 62000;

      const totalAmount = amountOne + amountTwo + amountThree;

      await createTransfer({
        amount: amountOne,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(5, 'seconds').toDate(),
      });

      await createTransfer({
        amount: amountTwo,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(10, 'seconds').toDate(),
      });

      await createTransfer({
        amount: amountThree,
        state: TransferState.COMPLETED,
        startedAt: moment(referenceDate).toDate(),
        finishedAt: moment(referenceDate).add(15, 'seconds').toDate(),
      });

      const result = await metricsService.getAmountMetrics(providerOne.id);

      expect(result['sum']).toEqual(totalAmount);
    });
  });

  describe('getManagementMetrics method', () => {
    it('should return an object with management stats interface', async () => {
      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result).toEqual({
        retry: 0,
        reassign: 0,
        cancel: 0,
        complete: 0,
      });
    });

    it('should return the retry count for the provider', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).add(10, 'minutes').toDate(),
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        createdAt: moment(referenceDate).add(20, 'minutes').toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.retry).toEqual(2);
    });

    it('should return the reassign count for the provider', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerTwo.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).add(10, 'minutes').toDate(),
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).add(20, 'minutes').toDate(),
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerTwo.id,
        state: TransferState.COMPLETED,
        createdAt: moment(referenceDate).add(30, 'minutes').toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.reassign).toEqual(2);
    });

    it('should return the cancel count for the provider when the transfer state is failed', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutTwo = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutThree = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutThree.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.cancel).toEqual(3);
    });

    it('should return the cancel count for the provider when the transfer state is canceled', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.CANCELED,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutTwo = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.CANCELED,
        createdAt: moment(referenceDate).toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.cancel).toEqual(2);
    });

    it('should return the complete count for the provider for transfers completed with an error code', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        errorCode: TransferErrorCode.UNKNOWN_ERROR,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutTwo = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.CANCELED,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutThree = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payoutThree.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        errorCode: TransferErrorCode.MERCHANT_LIMIT_EXCEED,
        createdAt: moment(referenceDate).toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.complete).toEqual(2);
    });

    it('should ignore completed transfers without error code for the complete count', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        errorCode: TransferErrorCode.UNKNOWN_ERROR,
        createdAt: moment(referenceDate).toDate(),
      });

      const payoutTwo = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        errorCode: null,
        createdAt: moment(referenceDate).toDate(),
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result.complete).toEqual(1);
    });

    it('should return all the management counts for a compound scenario with reassigns, retries and cancelations', async () => {
      const referenceDate = '2021-01-01T00:00:00.000Z';

      const payout = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
        concept: 'Reassign to provider 2 after fail',
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerTwo.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).add(10, 'minutes').toDate(),
        concept: 'Reassign to provider 1 after fail',
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).add(20, 'minutes').toDate(),
        concept: 'Retry with provider 1 after fail',
      });

      await createTransfer({
        payoutId: payout.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        createdAt: moment(referenceDate).add(30, 'minutes').toDate(),
        concept: 'Successful transfer',
      });

      const payoutTwo = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
        concept: 'Retry with provider 1 after fail',
      });

      await createTransfer({
        payoutId: payoutTwo.id,
        providerId: providerOne.id,
        state: TransferState.CANCELED,
        createdAt: moment(referenceDate).add(10, 'minutes').toDate(),
        concept: 'Cancel after fail',
      });

      const payoutThree = await createPayout({
        state: PayoutState.COMPLETED,
      });

      await createTransfer({
        payoutId: payoutThree.id,
        providerId: providerTwo.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
        concept: 'Reassign to provider 1 after fail',
      });

      await createTransfer({
        payoutId: payoutThree.id,
        providerId: providerOne.id,
        state: TransferState.COMPLETED,
        errorCode: TransferErrorCode.UNKNOWN_ERROR,
        createdAt: moment(referenceDate).add(10, 'minutes').toDate(),
        concept: 'Manually completed transfer',
      });

      const payoutFour = await createPayout({
        state: PayoutState.CANCELED,
      });

      await createTransfer({
        payoutId: payoutFour.id,
        providerId: providerOne.id,
        state: TransferState.FAILED,
        createdAt: moment(referenceDate).toDate(),
        concept: 'Cancel after fail',
      });

      const result = await metricsService.getManagementMetrics(providerOne.id);

      expect(result).toEqual({
        retry: 2,
        reassign: 1,
        cancel: 2,
        complete: 1,
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/bankService.e2e-spec.ts
import { BankService } from '../../src/models/bank/bank.service';
import { app } from '../app.setup';

describe('given BankService', () => {
  let bankService: BankService;

  beforeAll(async () => {
    try {
      bankService = app.get<BankService>(BankService);
    } catch (error) {
      console.log(error);
    }
  });
  describe('when some code execute findAll', () => {
    it('then BankService response with an array of BankEntity', async () => {
      const result = await bankService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });

  describe('when some code execute findOneByConditions', () => {
    it('should return a Chilean bank that his code starts with cl_', async () => {
      const bankCode = 'cl_tapp_caja_los_andes';
      const result = await bankService.findOneByConditions({
        where: { code: bankCode },
      });

      expect(result).toBeDefined();
      expect(result.code).toEqual(bankCode);
    });

    it('should return a Colombian bank that his code starts with co_', async () => {
      const bankCode = 'co_banco_popular';
      const result = await bankService.findOneByConditions({
        where: { code: bankCode },
      });

      expect(result).toBeDefined();
      expect(result.code).toEqual(bankCode);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/authorizationCodeService.e2e-spec.ts
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import moment = require('moment');
import { Repository } from 'typeorm';
import { AuthorizationCodeService } from '../../src/models/authorization-code/authorization-code.service';
import { app, connection } from '../app.setup';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import {
  ForbiddenException,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { EncryptTransformer } from 'src/common/transformers/encrypt.transformer';
import generalConfig from 'src/config/general.config';
import { DeviceCodeMessageDto } from 'src/models/authorization-code/dto/device-code-message.dto';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { TwilioMessageDto } from 'src/services/twilio/dto/twilio-message.dto';
import { State } from 'src/common/enums/state.enum';
import { AccessType } from 'src/common/enums/access-type.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';

describe('given AuthorizationCodeService', () => {
  let authorizationCodeService: AuthorizationCodeService;
  let authorizationCodeRepository: Repository<AuthorizationCodeEntity>;
  let transferMethodRepository: Repository<TransferMethodEntity>;
  let bankAccessRepository: Repository<BankAccessEntity>;

  let testMerchant: TestMerchantUtil;
  let bankAccess: BankAccessEntity;
  let transferMethod: TransferMethodEntity;

  const createBankAccessDto = {
    name: 'Created from test',
    state: State.INACTIVE,
    credentials: { a: '1' },
    capabilities: [],
    bankAccountIds: [3],
    merchantId: null,
    bankCode: 'cl_banco_falabella',
    accessType: AccessType.BUSINESS,
  };

  const createTransferMethodDto = {
    identifier: '123456789',
    methodType: TransferMethodType.CARD,
    merchantId: undefined,
    bankAccessId: 1,
  };

  beforeAll(async () => {
    authorizationCodeService = app.get<AuthorizationCodeService>(
      AuthorizationCodeService,
    );

    bankAccessRepository = connection.getRepository(BankAccessEntity);

    authorizationCodeRepository = connection.getRepository(
      AuthorizationCodeEntity,
    );

    transferMethodRepository = connection.getRepository(TransferMethodEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    createBankAccessDto.merchantId = testMerchant.merchant.id;
    createTransferMethodDto.merchantId = testMerchant.merchant.id;

    bankAccess = await bankAccessRepository.save({
      ...createBankAccessDto,
    });
    createTransferMethodDto.bankAccessId = bankAccess.id;

    transferMethod = await transferMethodRepository.save({
      ...createTransferMethodDto,
    });
  });

  afterEach(async () => {
    const merchantId = testMerchant.merchant.id;

    await authorizationCodeRepository.delete({
      transferMethodId: transferMethod.id,
    });
    await transferMethodRepository.delete({ merchantId });
    await bankAccessRepository.delete({ merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('when some code execute create', () => {
    it('then a new authorization code entity must be stored', async () => {
      const result = await authorizationCodeService.create({
        code: '1234',
        expiresAt: new Date(),
        transferMethodId: transferMethod.id,
      });

      const savedAuthCode = await authorizationCodeRepository.findOne({
        where: { id: result.id },
      });

      expect(result.id).toEqual(savedAuthCode.id);
    });

    // TODO: Needs to be debugged WHATS???? 16 months from now and counting
    it.skip('then a new authorization code entity must be stored with the code encrypted', async () => {
      const result = await authorizationCodeService.create({
        code: '1234',
        expiresAt: new Date(),
        transferMethodId: transferMethod.id,
      });

      const config = generalConfig();

      const encryptTransformer = new EncryptTransformer(
        config.security.securityKey,
      );
      const encryptedCode = encryptTransformer.to('1234');

      const savedAuthCode = await authorizationCodeRepository.findOne({
        where: { id: result.id },
      });

      expect(savedAuthCode.code).toEqual(encryptedCode);
    });

    it('then should not store the entity if expiresAt is invalid', async () => {
      try {
        await authorizationCodeService.create({
          code: '1234',
          expiresAt: null,
          transferMethodId: transferMethod.id,
        });
      } catch (error) {
        expect(error).toBeInstanceOf(UnprocessableEntityException);
      }
    });

    it('then should not store the entity if transferMethod does not exists', async () => {
      try {
        await authorizationCodeService.create({
          code: '1234',
          expiresAt: new Date(),
          transferMethodId: -1,
        });
      } catch (error) {
        expect(error).toBeInstanceOf(UnprocessableEntityException);
      }
    });
  });

  describe('when some code execute findAll', () => {
    it('then AuthorizationCodeService response with an array of AuthorizationCodeEntity', async () => {
      const result = await authorizationCodeService.findAll();
      expect(result).toEqual(expect.any(Array));
    });
  });

  describe('when some code execute findActiveForTransferMethod', () => {
    it('then should return an authorization code entity', async () => {
      const authCode = await authorizationCodeRepository.save({
        code: '1234',
        expiresAt: moment().add(1, 'd').toDate(),
        transferMethodId: transferMethod.id,
      });

      const result = await authorizationCodeService.findActiveForTransferMethod(
        transferMethod,
      );

      expect(result.id).toEqual(authCode.id);
    });
  });

  describe('when some code execute findOneAndClaim', () => {
    it('then should return an authorization code with status active and then updated it to claimed status', async () => {
      const authCode = await authorizationCodeRepository.save({
        code: '1234',
        expiresAt: moment().add(1, 'd').toDate(),
        transferMethodId: transferMethod.id,
        state: AuthorizationCodeState.ACTIVE,
      });

      const claimedAuthCode = await authorizationCodeService.findOneAndClaim(
        authCode.id,
      );

      expect(claimedAuthCode.state).toEqual(AuthorizationCodeState.CLAIMED);
    });

    it('then should fail if the request auth code is not active', async () => {
      const authCode = await authorizationCodeRepository.save({
        code: '1234',
        expiresAt: moment().add(1, 'd').toDate(),
        transferMethodId: transferMethod.id,
        state: AuthorizationCodeState.EXPIRED,
      });

      try {
        await authorizationCodeService.findOneAndClaim(authCode.id);
      } catch (error) {
        expect(error).toBeInstanceOf(ForbiddenException);
      }
    });

    it('then should fail if the request auth code does not exits', async () => {
      try {
        await authorizationCodeService.findOneAndClaim(-1);
      } catch (error) {
        expect(error).toBeInstanceOf(NotFoundException);
      }
    });
  });

  describe('when some code execute saveTwilioMessage', () => {
    const phoneNumber = '+56999695512';

    beforeEach(async () => {
      await transferMethodRepository.update(transferMethod.id, {
        methodType: TransferMethodType.SMS,
        identifier: phoneNumber,
      });
    });

    it('then should save a new autorization code entity if the "To" field matches a transferMethod', async () => {
      const twilioMessageDto: TwilioMessageDto = {
        Body: '1234',
        MessageSid: '110212',
        AccountSid: '222231',
        To: phoneNumber,
        From: '228819212012',
        ToCountry: 'CHL',
        ToCity: 'Santiago',
      };

      const result = await authorizationCodeService.saveTwilioMessage(
        twilioMessageDto,
      );

      expect(result).toBeDefined();
      expect(result.id).toBeDefined();
    });

    it('then should fail if no transfer method matches the "To" phone number', async () => {
      const twilioMessageDto: TwilioMessageDto = {
        Body: '1234',
        MessageSid: '110212',
        AccountSid: '222231',
        To: `Invalid Phone Number`,
        From: '228819212012',
        ToCountry: 'CHL',
        ToCity: 'Santiago',
      };

      const result = await authorizationCodeService.saveTwilioMessage(
        twilioMessageDto,
      );

      expect(result).toBeNull();
    });
  });

  describe('when some code execute saveDigipassMessage', () => {
    const identifier = '123457652';

    beforeEach(async () => {
      await transferMethodRepository.update(transferMethod.id, {
        methodType: TransferMethodType.DIGIPASS,
        identifier: identifier,
      });
    });

    describe('and there are no pending authorization codes', () => {
      it('then should throw an exception', async () => {
        const deviceCodeMessageDto: DeviceCodeMessageDto = {
          code: '1234',
          expiration: new Date('2022-11-12').getDate(),
          identifier,
        };

        const promise =
          authorizationCodeService.saveDigipassMessage(deviceCodeMessageDto);

        await expect(promise).rejects.toThrow(
          new UnprocessableEntityException(
            "Can't save Digipass code. No Authorization Codes in pending state",
          ),
        );
      });
    });
    describe('and a pending authorization code exists', () => {
      beforeEach(async () => {
        await authorizationCodeRepository.save({
          transferMethodId: transferMethod.id,
          state: AuthorizationCodeState.PENDING,
        });
      });

      it('then should save the code to the existing authorization code entity', async () => {
        const deviceCodeMessageDto: DeviceCodeMessageDto = {
          code: '1234',
          expiration: new Date('2022-11-12').getDate(),
          identifier,
        };

        const result = await authorizationCodeService.saveDigipassMessage(
          deviceCodeMessageDto,
        );

        expect(result.id).not.toBeUndefined();
      });
    });
  });

  describe('when some code execute saveMobileMessage', () => {
    const identifier = '32542652362';

    beforeEach(async () => {
      await transferMethodRepository.update(transferMethod.id, {
        methodType: TransferMethodType.MOBILE,
        identifier,
      });
    });

    describe('and there are no pending authorization codes', () => {
      it('then should throw an exception', async () => {
        const deviceCodeMessageDto: DeviceCodeMessageDto = {
          code: '1234',
          expiration: new Date('2022-11-12').getDate(),
          identifier: identifier,
        };

        const promise =
          authorizationCodeService.saveMobileMessage(deviceCodeMessageDto);

        await expect(promise).rejects.toThrow(
          new UnprocessableEntityException(
            "Can't save Mobile App code. No Authorization Codes in pending state",
          ),
        );
      });
    });
    describe('and a pending authorization code exists', () => {
      beforeEach(async () => {
        await authorizationCodeRepository.save({
          transferMethodId: transferMethod.id,
          state: AuthorizationCodeState.PENDING,
        });
      });

      it('then should save the code to the existing authorization code entity', async () => {
        const deviceCodeMessageDto: DeviceCodeMessageDto = {
          code: '1234',
          expiration: new Date('2022-11-12').getDate(),
          identifier: identifier,
        };

        const result = await authorizationCodeService.saveMobileMessage(
          deviceCodeMessageDto,
        );

        expect(result.id).not.toBeUndefined();
      });
    });
  });

  describe('when some code execute extractCode', () => {
    it('then should return a code without invalid characters', async () => {
      const code = '1111-2222-3333';

      const cleanedCode = authorizationCodeService.extractCode(code);

      expect(cleanedCode).toEqual('111122223333');
    });
  });

  describe('when some code execute updateExpiredCodes', () => {
    it('then should update an authorization code with state "expired"', async () => {
      const authCode = await authorizationCodeService.create({
        code: 'Az221XzS20',
        expiresAt: moment().subtract(60, 's').toDate(),
        transferMethodId: transferMethod.id,
      });

      await authorizationCodeService.updateExpiredCodes();

      const updatedAuthCode = await authorizationCodeRepository.findOne({
        where: { id: authCode.id },
      });

      expect(updatedAuthCode.state).toBe(AuthorizationCodeState.EXPIRED);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferProviderService.e2e-spec.ts
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CreateTransferDto } from 'src/api/v2/transfer/dto/create-transfer.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { MockProviderService } from 'src/providers/mock/mock-provider.service';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { app, connection } from 'test/app.setup';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { Repository } from 'typeorm';

describe('Given a TransferProviderService', () => {
  let transferProviderService: TransferProviderService;
  let eventEmitter: EventEmitter2;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;

  let testMerchant: TestMerchantUtil;

  const mockProviderService = new MockProviderService();
  let updatePayoutSpy: jest.SpyInstance;
  let eventEmitterSpy: jest.SpyInstance;

  const trackingCode = 'testTransferProviderService';

  const createPayoutDto: CreatePayoutDto = {
    amount: 1001,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    merchantId: undefined,
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto: CreateTransferDto = {
    amount: 100,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode,
    destinationHolderId: '120123123',
    destinationName: 'oblandon',
    destinationAccount: '1201231',
    destinationBankCode: 'cl_banco_falabella',
    destinationPhone: '001239912312',
    merchantId: undefined,
    payoutId: undefined,
    providerId: undefined,
    version: EntityVersion.v2,
    state: TransferState.ASSIGNED,
  };

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };
  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.Minka,
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  beforeAll(async () => {
    eventEmitter = app.get<EventEmitter2>(EventEmitter2);
    transferProviderService = app.get<TransferProviderService>(
      TransferProviderService,
    );

    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    jest
      .spyOn(ProviderService.prototype, 'getProviderAdapter')
      .mockReturnValue(mockProviderService);

    eventEmitterSpy = jest
      .spyOn(eventEmitter, 'emit')
      .mockImplementation(() => {
        return true;
      });

    testMerchant = await createTestMerchant();
    const merchantId = testMerchant.merchantId;

    createPayoutDto.merchantId = merchantId;
    createTransferDto.merchantId = merchantId;
    createAccountDto.merchantId = merchantId;

    payout = await payoutRepository.save({ ...createPayoutDto });
    createTransferDto.payoutId = payout.id;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;

    provider = await providerRepository.save({
      ...createProviderDto,
    });

    createTransferDto.providerId = provider.id;
  });

  afterEach(async () => {
    await transferRepository.delete({ merchantId: testMerchant.merchantId });
    await payoutRepository.delete({ merchantId: testMerchant.merchantId });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  describe("when some code emit the event 'transfer.state_updated'", () => {
    beforeEach(() => {
      updatePayoutSpy = jest
        .spyOn(transferProviderService, 'updatePayoutState')
        .mockImplementation((_transferUpdatedDto) =>
          Promise.resolve({} as PayoutEntity),
        );
    });

    it('then should call the method createTransaction with the specified arguments', async () => {
      const spy = jest.spyOn(transferProviderService, 'createTransaction');
      const transfer = await transferRepository.save({ ...createTransferDto });

      eventEmitterSpy.mockRestore();

      await eventEmitter.emitAsync(TransferEvent.UPDATED_STATE, transfer);

      expect(spy).toHaveBeenCalledWith(transfer);
    });

    it("then shouldn't change of state if the transfer version isn't v2", async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        version: EntityVersion.v1,
      });

      await transferProviderService.createTransaction(transfer);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.ASSIGNED);
    });

    it('then should create the transaction and update the transfer with the externalId', async () => {
      const spy = jest
        .spyOn(transferProviderService, 'updatePayoutState')
        .mockImplementation((_transferUpdatedDto) =>
          Promise.resolve({} as PayoutEntity),
        );
      const transfer = await transferRepository.save({ ...createTransferDto });

      await transferProviderService.createTransaction(transfer);

      const updatedTransfer = await transferRepository.findOne({
        where: { id: transfer.id },
      });

      expect(updatedTransfer.state).toEqual(TransferState.PROCESSING);
      expect(updatedTransfer.externalId).toBeDefined();
    });
  });

  describe("when some code emit the event 'transfer.state.updated'", () => {
    it('then should update the payout and reflect the provided transfer state', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        payoutId: payout.id,
        state: TransferState.PROCESSING,
      });

      const result = await transferProviderService.updatePayoutState(transfer);

      expect(result.state).toEqual(TransferState.PROCESSING);
      expect(result.id).toEqual(payout.id);
    });
  });

  describe('when some code execute createTransaction', () => {
    // TODO: Should what? create a transaction?
    it('then should ', async () => {
      const transfer = await transferRepository.save({ ...createTransferDto });
      const result = await transferProviderService.createTransaction(transfer);
      expect(result).toBeUndefined();
    });

    it('then should return undefined if the transfer version is not v2', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        version: EntityVersion.v1,
      });
      const result = await transferProviderService.createTransaction(transfer);
      expect(result).toBeUndefined();
    });

    it('then should return undefined if the transfer providerId is null', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        providerId: null,
      });
      const result = await transferProviderService.createTransaction(transfer);
      expect(result).toBeUndefined();
    });

    it('then should return undefined if the transfer provider does not exists', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
      });

      transfer.providerId = 999;
      const result = await transferProviderService.createTransaction(transfer);
      expect(result).toBeUndefined();
    });

    it('then should return undefined if the transfer state is not "assigned"', async () => {
      const transfer = await transferRepository.save({
        ...createTransferDto,
        state: TransferState.PROCESSING,
      });
      const result = await transferProviderService.createTransaction(transfer);
      expect(result).toBeUndefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/transferAssignmentService.e2e-spec.ts
import * as moment from 'moment';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { MerchantLimitEntity } from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { TransferAssignmentService } from 'src/services/transfer-assignment/transfer-assignment.service';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { State } from 'src/common/enums/state.enum';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { MerchantLimitEvaluatorService } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.service';
import { MockFeatureFlagService } from 'src/services/mocks/MockFeatureFlagService';
import { TransferAssignmentNewService } from 'src/services/transfer-assignment/transfer-assignment.new.service';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { randNumberString } from 'test/utils/testUtils';

describe('Given a TransferAssignmentService', () => {
  let transferAssignmentService: TransferAssignmentService;
  let transferProviderService: TransferProviderService;

  let providerService: ProviderService;
  let accountService: AccountService;
  let merchantLimitEvaluatorService: MerchantLimitEvaluatorService;

  let merchantLimitRepository: Repository<MerchantLimitEntity>;
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let payoutRepository: Repository<PayoutEntity>;
  let transferRepository: Repository<TransferEntity>;
  let merchantRepository: Repository<MerchantEntity>;

  let account: AccountEntity;
  let provider: ProviderEntity;
  let payout: PayoutEntity;
  let transfer: TransferEntity;
  let merchant: MerchantEntity;

  const trackingCode = 'testPayoutCreatedEventHandler';

  const createMerchantDto: Partial<MerchantEntity> = {
    name: 'Base Merchant',
    identifier: randNumberString(),
  };

  const createPayoutDto = {
    amount: 1001,
    state: PayoutState.PENDING,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
  };

  const createTransferDto = {
    amount: 1001,
    concept: 'Pago Buk Adelantos',
    destinationEmail: 'oblandon@buk.cl',
    destinationName: 'Cathia Castillo Quicaña',
    destinationHolderId: '72028164',
    destinationAccount: '00326101327274094052',
    destinationBankCode: 'cl_banco_bci',
    currency: Currency.CHILE,
    trackingCode,
    destinationPhone: '3212312312',
    version: EntityVersion.v2,
    state: TransferState.PENDING,
    payoutId: undefined,
    providerId: undefined,
  };

  const createAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    state: State.ACTIVE,
  };

  const createProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    providerType: ProviderType.ScraperCG,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const createMerchantLimitDto = {
    state: State.ACTIVE,
    limitType: MerchantLimitType.RATE,
    limitDefinition: {
      value: 1000,
      criteria: LimitCriteria.AMOUNT,
      currency: Currency.CHILE,
      scope: LimitScope.PERSON,
      aggregation: LimitAggregation.HOUR,
    },
  };

  beforeAll(async () => {
    transferAssignmentService = app.get(TransferAssignmentService);
    transferProviderService = app.get(TransferProviderService);
    accountService = app.get(AccountService);
    providerService = app.get(ProviderService);
    merchantLimitEvaluatorService = app.get<MerchantLimitEvaluatorService>(
      MerchantLimitEvaluatorService,
    );
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
    merchantLimitRepository = connection.getRepository(MerchantLimitEntity);
    merchantRepository = connection.getRepository(MerchantEntity);

    await merchantLimitRepository.clear();
    merchant = await merchantRepository.save({ ...createMerchantDto });
    await accountRepository.delete({ merchantId: merchant.id });
  });

  beforeEach(async () => {
    jest
      .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
      .mockReturnValue(Promise.resolve(false));
    jest
      .spyOn(transferProviderService, 'createTransaction')
      .mockImplementation((_transfer_id) => Promise.resolve());

    const eventEmitter = app.get(EventEmitter2);

    jest.spyOn(eventEmitter, 'emit').mockImplementation(() => {
      return true;
    });

    account = await accountRepository.save({
      ...createAccountDto,
      merchantId: merchant.id,
    });

    provider = await providerRepository.save({
      ...createProviderDto,
      accountId: account.id,
    });

    payout = await payoutRepository.save({
      ...createPayoutDto,
      merchantId: merchant.id,
    });

    transfer = await transferRepository.save({
      ...createTransferDto,
      merchantId: merchant.id,
      payoutId: payout.id,
    });
  });

  afterEach(async () => {
    await transferRepository.delete({ payoutId: payout.id });
    await payoutRepository.delete({ id: payout.id });
    await providerRepository.delete({ id: provider.id });
    await accountRepository.delete({ id: account.id });
  });

  afterAll(async () => {
    await merchantRepository.delete({ id: merchant.id });
  });

  describe('assignProviderToTransfer', () => {
    describe('transfer validations', () => {
      it('should return null when transfer is not present', async () => {
        const updatedTransfer =
          await transferAssignmentService.assignProviderToTransfer(undefined);
        expect(updatedTransfer).toBeNull();
      });

      it('should return the unchanged transfer when transfer is not v2', async () => {
        await transferRepository.update(transfer.id, {
          version: EntityVersion.v1,
          state: TransferState.ASSIGNED,
        });

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const updatedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);
        expect(updatedTransfer.id).toEqual(transfer.id);
        expect(updatedTransfer.state).toEqual(TransferState.ASSIGNED);
        expect(updatedTransfer.version).toEqual(EntityVersion.v1);
        expect(updatedTransfer.providerId).toEqual(null);
      });

      it('should return the unchanged transfer when transfer is in NOT in assigned state', async () => {
        await transferRepository.update(transfer.id, {
          state: TransferState.PROCESSING,
        });

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const updatedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);
        expect(updatedTransfer.id).toEqual(transfer.id);
        expect(updatedTransfer.state).toEqual(TransferState.PROCESSING);
        expect(updatedTransfer.providerId).toEqual(null);
      });

      it('should return the unchanged transfer when transfer does not have a providerId', async () => {
        await transferRepository.update(transfer.id, {
          state: TransferState.ASSIGNED,
          providerId: undefined,
        });

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const updatedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);
        expect(updatedTransfer.id).toEqual(transfer.id);
        expect(updatedTransfer.state).toEqual(TransferState.ASSIGNED);
        expect(updatedTransfer.providerId).toEqual(null);
      });
      it('should return assigned transfer if there is an available provider', async () => {
        jest
          .spyOn(accountService, 'evaluateRules')
          .mockImplementation((_account, _transfer) => Promise.resolve(true));
        jest
          .spyOn(providerService, 'evaluateRules')
          .mockImplementation((_provider, _transfer) => Promise.resolve(true));

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const updatedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);
        expect(updatedTransfer.id).toEqual(transfer.id);
        expect(updatedTransfer.state).toEqual(TransferState.ASSIGNED);
        expect(updatedTransfer.providerId).toEqual(provider.id);
      });
    });

    describe('when there are merchant limits to evaluate', () => {
      let limit: MerchantLimitEntity;

      const now = moment('10-13-2023 10:10:58', 'MM-DD-YYYY h:mm:ss').utc();

      beforeEach(async () => {
        limit = await merchantLimitRepository.save({
          ...createMerchantLimitDto,
          merchantId: merchant.id,
        });

        jest
          .spyOn(
            merchantLimitEvaluatorService as unknown as {
              getUtcDate: MerchantLimitEvaluatorService['getUtcDate'];
            },
            'getUtcDate',
          )
          .mockReturnValue(now);

        jest
          .spyOn(accountService, 'evaluateRules')
          .mockImplementation((_account, _transfer) => Promise.resolve(true));
        jest
          .spyOn(providerService, 'evaluateRules')
          .mockImplementation((_provider, _transfer) => Promise.resolve(true));
      });

      afterEach(async () => {
        merchantLimitRepository.delete(limit.id);
      });

      it('should return assigned transfer if the payout does not exceed merchant limit', async () => {
        // limite $1.000
        // por persona por hora
        const evaluatorSpy = jest.spyOn(
          MerchantLimitEvaluatorService.prototype,
          'evaluate',
        );

        await payoutRepository.update(payout.id, {
          createdAt: now.toISOString(),
          amount: createMerchantLimitDto.limitDefinition.value - 1,
        });

        await transferRepository.update(transfer.id, {
          createdAt: now.toISOString(),
          amount: createMerchantLimitDto.limitDefinition.value - 1,
        });

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const assignedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);

        expect(assignedTransfer.state).toBe(TransferState.ASSIGNED);
        expect(evaluatorSpy).toHaveBeenCalledWith(
          expect.objectContaining({ id: payout.id }),
        );
      });

      it('should return failed transfer if the payout exceed merchant limit', async () => {
        // limite $1.000
        // por persona por hora
        const evaluatorSpy = jest.spyOn(
          MerchantLimitEvaluatorService.prototype,
          'evaluate',
        );
        const findCapableProviderSpy = jest.spyOn(
          TransferAssignmentNewService.prototype,
          'findCapableProvider',
        );

        await payoutRepository.update(payout.id, {
          amount: createMerchantLimitDto.limitDefinition.value + 1,
          createdAt: now.toISOString(),
        });

        await transferRepository.update(transfer.id, {
          amount: createMerchantLimitDto.limitDefinition.value + 1,
          createdAt: now.toISOString(),
        });

        transfer = await transferRepository.findOne({
          where: { id: transfer.id },
        });

        const failedTransfer =
          await transferAssignmentService.assignProviderToTransfer(transfer);

        expect(evaluatorSpy).toHaveBeenCalledWith(
          expect.objectContaining({ id: payout.id }),
        );
        expect(findCapableProviderSpy).not.toHaveBeenCalled();
        expect(failedTransfer.state).toBe(TransferState.FAILED);
        expect(
          failedTransfer.message.startsWith(
            'La transferencia excede el límite',
          ),
        ).toBeTruthy();
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/services/accountService.e2e-spec.ts
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { UpdateAccountDto } from 'src/api/v2/account/dto/update-account.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { app, connection } from 'test/app.setup';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import { In, Repository } from 'typeorm';

describe('given an AccountService', () => {
  let accountService: AccountService;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;

  let testMerchant: TestMerchantUtil;

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  beforeAll(async () => {
    accountService = app.get(AccountService);
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchant.id;
  });

  afterEach(async () => {
    const accounts = await accountRepository.findBy({
      merchantId: testMerchant.merchant.id,
    });
    const accountIds = accounts.map((account) => account.id);

    await providerRepository.delete({ accountId: In(accountIds) });
    await accountRepository.delete({ merchantId: testMerchant.merchant.id });

    await testMerchant.deleteMerchant();
  });

  describe('when some code executes findAll', () => {
    it('then it should return an empty array if there are no accounts', async () => {
      const accounts = await accountService.findAll({
        where: { merchantId: testMerchant.merchant.id },
      });
      expect(accounts).toHaveLength(0);
    });

    it('then it should return an array with the existing accounts', async () => {
      const newAccounts = Array(4).fill({ ...baseAccount });
      await accountRepository.save(newAccounts);

      const accounts = await accountService.findAll();
      const allAccounts = await accountRepository
        .createQueryBuilder('account')
        .getMany();

      expect(accounts).toEqual(expect.arrayContaining(allAccounts));
    });

    it('then it should return an array with the existing accounts for a merchant', async () => {
      const newAccounts = Array(3).fill({ ...baseAccount });
      await accountRepository.save(newAccounts);

      const accounts = await accountService.findAll({
        where: { merchantId: baseAccount.merchantId },
      });

      expect(accounts).toHaveLength(3);
    });
  });

  describe('when some code executes findOne', () => {
    it('then it should return undefined if the account was not found', async () => {
      const accountId = -1;

      const account = await accountService.findOne(accountId);

      expect(account).toBeNull();
    });
    it('then it should return the account that matches with the specified id', async () => {
      const newAccount = await accountRepository.save({ ...baseAccount });

      const account = await accountService.findOne(newAccount.id);
      expect(account).toBeDefined();
    });
  });

  describe('when some code executes findOneWithConditions', () => {
    it('then it should return an error if the account was not found', async () => {
      const accountId = -1;

      const account = await accountService.findOneByConditions({
        where: { id: accountId, name: 'WithConditions' },
      });

      expect(account).toBeNull();
    });
    it('then it should return the account that matches with the specified id and conditions', async () => {
      const name = 'WithConditions';
      const newAccount = await accountRepository.save({ ...baseAccount, name });

      const account = await accountService.findOneByConditions({
        where: { id: newAccount.id, name },
      });

      expect(account).toBeDefined();
    });
  });

  describe('when some code executes create', () => {
    it('then it should thrown an error if invalid dto is provided', async () => {
      const createAccountDto = {} as CreateAccountDto;

      await expect(accountService.create(createAccountDto)).rejects.toThrow();
    });

    it('then it should create a new account', async () => {
      const createAccountDto: CreateAccountDto = { ...baseAccount };

      const account = await accountService.create(createAccountDto);

      expect(account).toBeDefined();
    });
  });

  describe('when some code executes update', () => {
    it('then it should return undefined if the account was not found', async () => {
      const updateAccountDto = { name: 'UpdatedAccount' } as UpdateAccountDto;
      const accountId = -1;

      const account = await accountService.update(accountId, updateAccountDto);
      expect(account).toBeUndefined();
    });
    it('then it should update an existing account', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        name: 'CreateAccount',
      });

      const updateAccountDto = { name: 'UpdatedAccount' } as UpdateAccountDto;
      const updatedAccount = await accountService.update(
        newAccount.id,
        updateAccountDto,
      );
      expect(newAccount.name).toEqual('CreateAccount');
      expect(updatedAccount.name).toEqual('UpdatedAccount');
    });
  });

  describe('when some code executes remove', () => {
    it('then it should return undefined if the account was not found', async () => {
      const updateAccountDto = { name: 'UpdatedAccount' } as UpdateAccountDto;
      const accountId = -1;

      const account = await accountService.update(accountId, updateAccountDto);
      expect(account).toBeUndefined();
    });
    it('then it should remove an existing account', async () => {
      const newAccount = await accountRepository.save({
        ...baseAccount,
        name: 'CreateAccount',
      });

      await accountService.remove(newAccount.id);
      const afterRemoveAccount = await accountRepository.findOne({
        where: { id: newAccount.id },
      });

      expect(afterRemoveAccount).toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/subscribers/__scenarios__/obfuscatedAuditLog.e2e-spec.ts
import { Repository } from 'typeorm';
import { ClsService } from 'nestjs-cls';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { app, connection } from 'test/app.setup';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';
import { ChangeAuditSubscriber } from 'src/database/subscribers/change-audit.subscriber';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { SentryService } from 'src/services/sentry/sentry.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { mapStringToClass } from 'src/utils/json.util';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given a storeAuditLog scenario', () => {
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;
  let auditLogRepository: Repository<AuditLogEntity>;
  let transferRepository: Repository<TransferEntity>;
  let payoutRepository: Repository<PayoutEntity>;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.Minka,
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  const createPayoutDto = {
    amount: 1000,
    destinationName: 'Test Transfer Service',
    destinationEmail: 'email@email.com',
    destinationAccount: '112301212',
    destinationHolderId: '123121212121',
    destinationBankCode: 'cl_banco_bice',
    merchantId: undefined,
    currency: Currency.CHILE,
    concept: 'Testing',
    trackingCode: 'store-all-Date-properties-1',
  };

  const createTransferDto = {
    amount: 1000,
    concept: 'Authorizing transfer',
    currency: Currency.CHILE,
    destinationAccount: '268784803',
    destinationBankCode: 'cl_banco_bice',
    destinationPhone: '1234456434',
    destinationHolderId: '268784803',
    destinationName: 'Antonia Flores',
    merchantId: undefined,
    payoutId: undefined,
    providerId: null,
    state: TransferState.PROCESSING,
    trackingCode: 'store-all-Date-properties-2',
  };

  beforeAll(async () => {
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
    auditLogRepository = connection.getRepository(AuditLogEntity);
    payoutRepository = connection.getRepository(PayoutEntity);
    transferRepository = connection.getRepository(TransferEntity);
  });

  beforeEach(async () => {
    const clsService = app.get(ClsService);
    const auditLogService = app.get(AuditLogService);
    const sentryService = app.get(SentryService);

    new ChangeAuditSubscriber(
      connection,
      auditLogService,
      clsService,
      sentryService,
    );

    testMerchant = await createTestMerchant();
    createAccountDto.merchantId = testMerchant.merchant.id;
    createPayoutDto.merchantId = testMerchant.merchant.id;
    createTransferDto.merchantId = testMerchant.merchant.id;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;
  });

  afterEach(async () => {
    connection.subscribers.pop();

    await auditLogRepository.delete({});
    await transferRepository.delete({ merchantId: testMerchant.merchant.id });
    await payoutRepository.delete({ merchantId: testMerchant.merchant.id });
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchant.id });
    await testMerchant.deleteMerchant();
  });

  describe('when some user perform operations of an entity with sensitive data', () => {
    const credentials = {
      username: 'secretUsername',
      password: 'secretPassword',
    };

    describe('and the user create a new entity', () => {
      it('then should create a new audit log for the created entity and obfuscate the sensitive data', async () => {
        createProviderDto.accountId = account.id;

        // Create new provider
        const provider = providerRepository.create({
          ...createProviderDto,
          credentials,
        });

        const createdProvider = await providerRepository.save(provider);

        const auditLogs = await auditLogRepository.find({
          where: { entityId: String(createdProvider.id) },
        });

        expect(auditLogs).toHaveLength(1);

        const { entityBefore, entityAfter } = auditLogs[0];

        const parsedEntityAfter = JSON.parse(entityAfter);

        expect(auditLogs[0].event).toEqual(AuditLogEvent.INSERT);
        expect(entityBefore).toBeNull();
        expect(parsedEntityAfter.credentials).toEqual('[OBFUSCATED]');
        expect(createdProvider.credentials).toEqual(credentials);
      });
    });

    describe('and the user update an exisiting entity', () => {
      it('then should create a new audit log for the updated entity and obfuscate the sensitive data', async () => {
        createProviderDto.accountId = account.id;

        // Create new provider
        const provider = providerRepository.create({
          ...createProviderDto,
          credentials: { ...credentials },
        });
        const createdProvider = await providerRepository.save(provider);

        const updatedCredentials = {
          username: 'newUsername',
          password: 'newPassword',
        };

        createdProvider.credentials = updatedCredentials;

        const updatedProvider = await providerRepository.save(createdProvider);

        const entityId = createdProvider.id.toString();
        const auditLogs = await auditLogRepository.find({
          where: { entityId, event: AuditLogEvent.UPDATE },
        });

        expect(auditLogs).toHaveLength(1);

        const { entityBefore, entityAfter } = auditLogs[0];

        const parsedEntityAfter = JSON.parse(entityAfter);
        const parsedEntityBefore = JSON.parse(entityBefore);

        expect(auditLogs[0].event).toEqual(AuditLogEvent.UPDATE);

        expect(parsedEntityAfter.credentials).toEqual('[OBFUSCATED]');
        expect(parsedEntityBefore.credentials).toEqual('[OBFUSCATED]');
        expect(updatedProvider.credentials).toEqual(updatedCredentials);
      });
    });

    describe('and the user remove an exisiting entity', () => {
      it('then should create a new audit log for the removed entity and obfuscate the sensitive data', async () => {
        createProviderDto.accountId = account.id;

        // Create new provider
        const provider = providerRepository.create({
          ...createProviderDto,
          credentials: { ...credentials },
        });

        const createdProvider = await providerRepository.save(provider);
        const providerId = createdProvider.id;
        await providerRepository.remove(createdProvider);

        const entityId = providerId.toString();
        const auditLogs = await auditLogRepository.find({
          where: { entityId, event: AuditLogEvent.REMOVE },
        });

        expect(auditLogs).toHaveLength(1);

        const { entityBefore } = auditLogs[0];

        const parsedEntityBefore = JSON.parse(entityBefore);

        expect(auditLogs[0].event).toEqual(AuditLogEvent.REMOVE);

        expect(parsedEntityBefore.credentials).toEqual('[OBFUSCATED]');
      });
    });

    describe('and the entity has Date properties', () => {
      it('should store all Date properties correctly of an audit log passed by obfuscateObject', async () => {
        const finishedAt = new Date();

        const payout = await payoutRepository.save({ ...createPayoutDto });

        const transfer = await transferRepository.save({
          ...createTransferDto,
          payoutId: payout.id,
          finishedAt,
        });

        const auditLog = await auditLogRepository.findOne({
          where: { entityId: transfer.id.toString() },
          order: { createdAt: 'DESC' },
        });
        const { entityAfter } = auditLog;
        const parsedEntityAfter = mapStringToClass<TransferEntity>(entityAfter);

        expect(auditLog).toBeDefined();
        expect(parsedEntityAfter.finishedAt).toEqual(finishedAt.toISOString());
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/subscribers/__scenarios__/storeAuditLog.e2e-spec.ts
import * as request from 'supertest';
import { ClsService } from 'nestjs-cls';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { ChangeAuditSubscriber } from 'src/database/subscribers/change-audit.subscriber';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { SentryService } from 'src/services/sentry/sentry.service';
import { SortOrder } from 'src/utils/array-methods.util';
import {
  createTestMerchant,
  TestMerchantUtil,
} from 'test/utils/merchantTestUtils';
import { createTestApiKey, TestApiKeyUtil } from 'test/utils/apiKeyTestUtils';
import { TestUserWithTokenUtil, useTestUser } from 'test/utils/userTestUtils';
import { UserRole } from 'src/common/enums/user-role.enum';

describe('given a storeAuditLog scenario', () => {
  let accountRepository: Repository<AccountEntity>;
  let auditLogRepository: Repository<AuditLogEntity>;

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: null,
    state: State.ACTIVE,
  };

  let testMerchant: TestMerchantUtil;
  let createdApiKey: TestApiKeyUtil;
  let testUser: TestUserWithTokenUtil;
  let account: AccountEntity;

  beforeAll(async () => {
    accountRepository = connection.getRepository(AccountEntity);
    auditLogRepository = connection.getRepository(AuditLogEntity);
  });

  beforeEach(async () => {
    const clsService = app.get(ClsService);
    const auditLogService = app.get(AuditLogService);
    const sentryService = app.get(SentryService);

    new ChangeAuditSubscriber(
      connection,
      auditLogService,
      clsService,
      sentryService,
    );

    testMerchant = await createTestMerchant();
    createdApiKey = await createTestApiKey(testMerchant.merchant.id);
    testUser = await useTestUser(UserRole.SUPER, false, {
      merchantId: testMerchant.merchant.id,
    });

    createAccountDto.merchantId = testMerchant.merchant.id;
  });

  afterEach(async () => {
    connection.subscribers.pop();

    await auditLogRepository.delete({});
    await createdApiKey.deleteApiKey();
    await testUser.deleteUser();
    await accountRepository.delete({ merchantId: testMerchant.merchant.id });
    await testMerchant.deleteMerchant();
  });

  describe('when concurrent user makes a http request resulting in an update', () => {
    it('then should call afterUpdate method and save the audit-log', async () => {
      account = await accountRepository.save({
        ...createAccountDto,
        merchantId: testMerchant.merchant.id,
      });

      const apiKeyId = createdApiKey.apiKey.id;
      const userId = testUser.user.id;

      const jwtSuperToken = testUser.token;

      const updateWithApiKey = 'Updated with apikey';
      const updateWithToken = 'Updated with token';

      // Use Promise.all to test the concurrency, the asserts could fail if the promise2 resolves first
      const promise1 = request(app.getHttpServer())
        .patch(`/v2/accounts/${account.id}`)
        .send({ name: updateWithApiKey })
        .set('X-API-KEY', createdApiKey.mockData.key);

      const promise2 = request(app.getHttpServer())
        .patch(`/v2/accounts/${account.id}`)
        .send({ name: updateWithToken })
        .set('Authorization', `Bearer ${jwtSuperToken}`);

      await Promise.all([promise1, promise2]);

      const auditLogs = await auditLogRepository.find({
        where: {
          event: AuditLogEvent.UPDATE,
        },
        order: { authorType: SortOrder.ASCENDING },
      });

      expect(auditLogs).toHaveLength(2);

      // TODO: use parseJson util, lines: 127, 135
      expect(auditLogs[0].authorId).toEqual(apiKeyId);
      expect(auditLogs[0].authorType).toEqual(ApiKeyEntity.name);
      expect(auditLogs[0].event).toEqual(AuditLogEvent.UPDATE);
      expect(auditLogs[0].entityId).toEqual(account.id.toString());
      expect(JSON.parse(auditLogs[0].entityAfter).name).toEqual(
        updateWithApiKey,
      );

      expect(auditLogs[1].authorId).toEqual(userId);
      expect(auditLogs[1].authorType).toEqual(UserEntity.name);
      expect(auditLogs[1].event).toEqual(AuditLogEvent.UPDATE);
      expect(auditLogs[1].entityId).toEqual(account.id.toString());
      expect(JSON.parse(auditLogs[1].entityAfter).name).toEqual(
        updateWithToken,
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/subscribers/changeAuditSubscriber.e2e-spec.ts
import { Repository } from 'typeorm';
import { connection } from 'test/app.setup';
import { Currency } from 'src/common/enums/currency.enum';
import { ChangeAuditSubscriberMock } from 'src/database/subscribers/__mocks__/change-audit.subscriber.mock';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given a ChangeAuditSubscriber', () => {
  let accountRepository: Repository<AccountEntity>;
  let providerRepository: Repository<ProviderEntity>;

  let afterInsertMock: jest.SpyInstance;
  let afterUpdateMock: jest.SpyInstance;
  let afterRemoveMock: jest.SpyInstance;
  let afterSoftRemoveMock: jest.SpyInstance;

  let testMerchant: TestMerchantUtil;

  const createAccountDto: CreateAccountDto = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto: CreateProviderDto = {
    name: 'Test Provider',
    credentials: null,
    rules: null,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    providerType: ProviderType.Minka,
    accountId: undefined,
    priority: 1,
    state: State.ACTIVE,
  };

  beforeAll(async () => {
    accountRepository = connection.getRepository(AccountEntity);
    providerRepository = connection.getRepository(ProviderEntity);
  });

  beforeEach(async () => {
    afterInsertMock = jest.spyOn(
      ChangeAuditSubscriberMock.prototype,
      'afterInsert',
    );
    afterUpdateMock = jest.spyOn(
      ChangeAuditSubscriberMock.prototype,
      'afterUpdate',
    );
    afterRemoveMock = jest.spyOn(
      ChangeAuditSubscriberMock.prototype,
      'afterRemove',
    );

    afterSoftRemoveMock = jest.spyOn(
      ChangeAuditSubscriberMock.prototype,
      'afterSoftRemove',
    );

    testMerchant = await createTestMerchant();
    createAccountDto.merchantId = testMerchant.merchantId;
  });

  afterEach(async () => {
    await accountRepository.delete({ merchantId: testMerchant.merchantId });
    await testMerchant.deleteMerchant();
  });

  describe('when an entity is created', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('then should call afterInsert method', async () => {
      const account = await accountRepository.save({
        ...createAccountDto,
      });
      expect(afterInsertMock).toHaveBeenCalledTimes(1);
      await accountRepository.remove(account);
    });

    it('then should call afterUpdate method', async () => {
      const account = await accountRepository.save({
        ...createAccountDto,
      });
      account.name = 'update';
      await accountRepository.save(account);
      expect(afterUpdateMock).toHaveBeenCalledTimes(1);
      await accountRepository.remove(account);
    });

    it('then should call afterRemove method', async () => {
      const account = await accountRepository.save({
        ...createAccountDto,
      });
      await accountRepository.remove(account);
      expect(afterRemoveMock).toHaveBeenCalledTimes(1);
    });

    it('then should call afterSoftRemove method', async () => {
      const account = await accountRepository.save({
        ...createAccountDto,
      });

      const provider = await providerRepository.save({
        ...createProviderDto,
        account,
      });

      await providerRepository.softRemove(provider);
      expect(afterSoftRemoveMock).toHaveBeenCalledTimes(1);

      await providerRepository.remove(provider);
      await accountRepository.remove(account);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/global.setup.ts
import setupDatabase from './utils/setupDatabase';
// import * as shell from 'shelljs';

async function setup() {
  console.log('\nTest setup starting');
  // This allows us to control the logging for each setup function (drop, create, migrate, seed)
  setupDatabase();
  // This alternative does the same thing, but logs everything
  // shell.exec('pnpm db:setup:test', { silent: true });
  console.log('\nTest setup completed');
}

export default setup;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/providers/liquidoProvider.e2e-spec.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { HttpService } from '@nestjs/axios';
import { LiquidoProviderService } from 'src/providers/liquido/liquido.provider.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { LiquidoResponseDto } from 'src/providers/liquido/dto/liquido.response.dto';
import { LiquidoTransactionState } from 'src/common/enums/liquido-transaction-state.enum';
import { LiquidoBalanceDto } from 'src/providers/liquido/dto/liquido.balance.dto';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given an LiquidoProvider', () => {
  let liquidoProvider: LiquidoProviderAdapter;
  let liquidoProviderService: LiquidoProviderService;
  let transactionDto: TransactionDto;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let httpService: HttpService;
  let accountId: number;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const baseProvider = {
    name: 'Liquido Provider',
    credentials: {
      authUrl: process.env.AUTH_URL ?? 'auth_url',
      baseUrl: process.env.GATEWAY_URL ?? 'gateway_url',
      clientId: process.env.CLIENTID ?? 'clientId',
      clientSecret: process.env.CLIENT_SECRET ?? 'clientSecret',
      apiKey: process.env.API_KEY ?? 'api_key',
    },
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    rules: {},
    providerType: ProviderType.Liquido,
    accountId,
  };

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  beforeAll(async () => {
    httpService = app.get<HttpService>(HttpService);
    liquidoProvider = app.get<LiquidoProviderAdapter>(LiquidoProviderAdapter);
    liquidoProviderService = app.get<LiquidoProviderService>(
      LiquidoProviderService,
    );
    providerRepository = connection.getRepository(ProviderEntity);
    accountRepository = connection.getRepository(AccountEntity);
  });

  beforeEach(async () => {
    jest
      .spyOn(liquidoProviderService, 'ensureToken')
      .mockImplementation(() => Promise.resolve());

    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...baseAccount });
    accountId = account.id;
    baseProvider.accountId = account.id;

    provider = await providerRepository.save({ ...baseProvider });
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  it('then liquidoProvider is defined', async () => {
    expect(liquidoProvider).toBeDefined();
  });

  describe('when execute createTransaction', () => {
    it('then return createdTransactionDto if payload is OK', async () => {
      transactionDto = {
        amount: 1200,
        providerId: provider.id,
        destinationHolderId: '120123123',
        destinationName: 'Liquido Service',
        destinationEmail: 'buk_liquido@gmail.com',
        destinationAccount: '706180005047305123',
        destinationBankCode: 'mx_banco_santander',
        currency: Currency.MEXICO,
        state: TransferState.ASSIGNED,
      };
      const response: LiquidoResponseDto = {
        statusCode: 200,
        transferStatus: LiquidoTransactionState.IN_PROGRESS,
      };
      jest
        .spyOn(httpService.axiosRef, 'post')
        .mockReturnValue(Promise.resolve({ data: response }));
      const createdTransaction = await liquidoProvider.createTransaction(
        provider,
        transactionDto,
      );
      expect(createdTransaction.externalId).toBeDefined();
      expect(createdTransaction.state).toBeDefined();
    });
    it('then return error if payload is WRONG', async () => {
      transactionDto = {
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.MEXICO,
        state: TransferState.ASSIGNED,
      };
      const response: LiquidoResponseDto = {
        statusCode: 422,
        errorMsg: 'Wrong payout message body',
      };
      jest
        .spyOn(httpService.axiosRef, 'post')
        .mockReturnValue(Promise.resolve({ data: response }));

      await expect(
        liquidoProvider.createTransaction(provider, transactionDto),
      ).rejects.toThrow(response.errorMsg);
    });
  });
  describe('when execute getTransactionState', () => {
    it('then should thrown an error if the external provided was not found', async () => {
      const response: LiquidoResponseDto = {
        statusCode: 422,
        errorMsg: undefined,
      };

      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));

      await expect(
        liquidoProvider.getTransactionState(provider, 'externalId'),
      ).rejects.toThrow(response.errorMsg);
    });
    it('then should thrown an error if cannot tanslate the liquido transaction status', async () => {
      const response: LiquidoResponseDto = {
        statusCode: 200,
        transferStatus: 'INVALID_STATE' as LiquidoTransactionState,
      };
      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));

      await expect(
        liquidoProvider.getTransactionState(provider, 'externalId'),
      ).rejects.toThrow("Can't translate transaction state");
    });
    it('then return Transfer state if is a LiquidoTransactionState', async () => {
      const response: LiquidoResponseDto = {
        statusCode: 200,
        transferStatus: LiquidoTransactionState.IN_PROGRESS,
      };
      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));

      const transactionStateDto = await liquidoProvider.getTransactionState(
        provider,
        'externalId',
      );
      expect(transactionStateDto.state).toBeDefined();
      expect(transactionStateDto.state).toBe(TransferState.PROCESSING);
    });
  });
  describe('when execute getBalance', () => {
    it('then return a AccountBalanceDto', async () => {
      const response: LiquidoBalanceDto = {
        code: 200,
        msg: 'success',
        data: {
          accountBalance: 123,
          currency: 'MXN',
        },
      };

      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));

      const balance = await liquidoProvider.getBalance(provider);
      expect(balance).toBeDefined();
    });
    it('then throw error if response !== HttpStatus.OK', async () => {
      const response: LiquidoBalanceDto = {
        code: 400,
        msg: 'Bad Request',
      };

      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));
      await expect(liquidoProvider.getBalance(provider)).rejects.toThrow();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/providers/scraperPWProvider.e2e-spec.ts
import { v4 as uuid } from 'uuid';
import { Repository } from 'typeorm';
import { app, connection } from 'test/app.setup';

import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import { TransferJobService } from 'src/models/transfer-job/transfer-job.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { ScraperPWProviderAdapter } from 'src/providers/scraperPW/scraperPW.provider';
import { AwsBatchService } from 'src/services/aws/batch.service';
import CredentialTransformer from 'src/common/transformers/credential.transformer';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('Given a ScraperPWProvider', () => {
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let transferJobRepository: Repository<TransferJobEntity>;
  let accountStatementJobRepository: Repository<AccountStatementJobEntity>;
  let scraperPWProvider: ScraperPWProviderAdapter;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const bankAccountId = 1;
  const bankAccessId = 1;
  const jobId = 'jobId';
  const bankCode = 'cl_banco_falabella';

  const createAccountDto: CreateAccountDto = {
    bankCode,
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
    state: State.ACTIVE,
  };

  const createProviderDto = {
    name: 'Scraper v2 Provider',
    credentials: undefined,
    rules: null,
    providerType: ProviderType.ScraperPW,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    priority: 1,
    state: State.ACTIVE,
    accountId: undefined,
  };

  const providerCredentials = {
    bankCode,
    bankAccessId: bankAccessId.toString(),
    bankAccountId: bankAccountId.toString(),
    username: 'username',
    password: 'password',
  };

  beforeAll(async () => {
    scraperPWProvider = app.get(ScraperPWProviderAdapter);

    providerRepository = connection.getRepository(ProviderEntity);
    accountRepository = connection.getRepository(AccountEntity);
    transferJobRepository = connection.getRepository(TransferJobEntity);
    accountStatementJobRepository = connection.getRepository(
      AccountStatementJobEntity,
    );
  });

  beforeEach(async () => {
    jest
      .spyOn(AwsBatchService.prototype, 'submitBatchJob')
      .mockImplementation((_params) =>
        Promise.resolve({
          jobId,
          jobName: '112399120-transfer-job-1-1-test',
          $metadata: undefined,
        }),
      );

    testMerchant = await createTestMerchant();
    createAccountDto.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...createAccountDto });
    createProviderDto.accountId = account.id;

    createProviderDto.credentials =
      CredentialTransformer.encrypt(providerCredentials);

    provider = await providerRepository.save(
      providerRepository.create({ ...createProviderDto }),
    );
  });

  afterEach(async () => {
    await transferJobRepository.delete({ bankAccessId: bankAccessId });
    await transferJobRepository.delete({ providerId: provider.id });

    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  describe('When some code call createTransaction', () => {
    it("then shouldn't start the batch job if there is already once running", async () => {
      jest
        .spyOn(TransferJobService.prototype, 'validateAnyRunningJob')
        .mockImplementation((_jobParams) => Promise.resolve(true));

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        amount: 100,
        currency: Currency.CHILE,
        providerId: provider.id,
        state: TransferState.ASSIGNED,
        destinationAccount: '123123123',
        destinationBankCode: BankCode.BANCO_FALABELLA,
        destinationEmail: 'oblandon@buk.cl',
        destinationHolderId: '123001231',
        destinationName: 'Minka Provider Test',
        destinationPhone: '123012312',
      };

      const result = await scraperPWProvider.createTransaction(
        provider,
        transactionDto,
      );

      expect(result.jobId).toBeUndefined();
    });

    it("then shouldn't start the batch job if the recipient information is invaild", async () => {
      jest
        .spyOn(TransferJobService.prototype, 'validateAnyRunningJob')
        .mockImplementation((_jobParams) => Promise.resolve(false));

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        amount: 100,
        currency: Currency.CHILE,
        providerId: provider.id,
        state: TransferState.ASSIGNED,
      };

      const transaction = await scraperPWProvider.createTransaction(
        provider,
        transactionDto,
      );

      expect(transaction).toBeDefined();
      expect(transaction.state).toEqual(TransferState.FAILED);
      expect(transaction.message).toEqual('Missing recipient information');
    });

    it("then shouldn't start the batch job if the provider credentials doesn't include the bankAccessId and bankAccountId", async () => {
      jest
        .spyOn(TransferJobService.prototype, 'validateAnyRunningJob')
        .mockImplementation((_jobParams) => Promise.resolve(false));

      const newProvider = providerRepository.create({
        name: 'Scraper v2 Provider',
        credentials: CredentialTransformer.encrypt({ key: 'value' }),
        rules: null,
        providerType: ProviderType.ScraperPW,
        priority: 1,
        state: State.ACTIVE,
        accountId: account.id,
      });

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        amount: 100,
        currency: Currency.CHILE,
        providerId: provider.id,
        state: TransferState.ASSIGNED,
        countryCode: CountryCode.CHILE,
        destinationBankCode: BankCode.BANCO_FALABELLA,
        destinationEmail: 'oblandon@buk.cl',
        destinationName: 'Minka Provider Test',
        destinationAccount: '123123123',
        destinationHolderId: '123001231',
        destinationPhone: '123012312',
      };

      const transaction = await scraperPWProvider.createTransaction(
        newProvider,
        transactionDto,
      );

      expect(transaction).toBeDefined();
      expect(transaction.state).toEqual(TransferState.FAILED);
      expect(transaction.message).toEqual('Invalid Scraper credentials.');
    });

    it('then should start the batch job', async () => {
      jest
        .spyOn(TransferJobService.prototype, 'validateAnyRunningJob')
        .mockImplementation((_jobParams) => Promise.resolve(false));

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        amount: 100,
        currency: Currency.CHILE,
        providerId: provider.id,
        state: TransferState.ASSIGNED,
        countryCode: CountryCode.CHILE,
        destinationBankCode: BankCode.BANCO_FALABELLA,
        destinationEmail: 'oblandon@buk.cl',
        destinationAccount: '123123123',
        destinationHolderId: '123001231',
        destinationName: 'Minka Provider Test',
        destinationPhone: '123012312',
      };

      const transaction = await scraperPWProvider.createTransaction(
        provider,
        transactionDto,
      );

      expect(transaction).toBeDefined();
      expect(transaction.state).toEqual(TransferState.ASSIGNED);
      expect(transaction.jobId).toEqual('jobId');
      expect(transaction.message).toEqual('Scraper job started successfully.');
    });
  });

  describe('When some code call getBalance', () => {
    let providerWithAccount: ProviderEntity;

    beforeEach(async () => {
      const newProvider = await providerRepository.save({
        name: 'Balance Shinkansen Provider',
        capabilities: [ProviderCapability.READ_TRANSFER],
        providerType: ProviderType.ScraperPW,
        accountId: account.id,
      });
      providerWithAccount = await providerRepository.findOne({
        where: { id: newProvider.id },
        relations: ['account'],
      });
    });

    it('then should return the latest balance within finished account statement job', async () => {
      // Create an account statement job
      const balance = 9999;
      const retrievedAt = new Date('2022-12-12T10:55:59.000Z');

      const accountStatementJob = await accountStatementJobRepository.save({
        endDate: new Date('2022-11-12T16:54:05.000Z'),
        startDate: new Date('2022-11-12T16:54:05.000Z'),
        state: AccountStatementJobState.FINISHED,
        startedAt: new Date('2022-12-12T10:50:05.000Z'),
        endedAt: new Date('2022-12-12T10:55:05.000Z'),
        retrievedAt,
        totalRetrieved: 3,
        jobId: 'ABC123JobId',
        balance,
        accountId: account.id,
      });

      const currentBalance = await scraperPWProvider.getBalance(
        providerWithAccount,
      );

      expect(currentBalance).toEqual({
        balance: balance.toFixed(2),
        currency: account.currency,
        retrievedAt,
      });

      await accountStatementJobRepository.update(
        { id: accountStatementJob.id },
        { accountId: null },
      );
      await accountStatementJobRepository.remove(accountStatementJob);
    });
    // Job no finished
    it('then should throw an error if the balance is not avaliable', async () => {
      await expect(
        scraperPWProvider.getBalance(providerWithAccount),
      ).rejects.toThrow("Can't get balance for the account.");
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/providers/minkaProvider.e2e-spec.ts
import { v4 as uuid } from 'uuid';
import { Repository } from 'typeorm';
import { HttpService } from '@nestjs/axios';
import { app, connection } from 'test/app.setup';

import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { MinkaProviderAdapter } from 'src/providers/minka/minka.provider';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { MinkaProviderService } from 'src/providers/minka/minka.provider.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';
import CredentialTransformer from 'src/common/transformers/credential.transformer';

describe('given an MinkaProvider', () => {
  let minkaProvider: MinkaProviderAdapter;
  let minkaProviderService: MinkaProviderService;
  let transactionDto: TransactionDto;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let httpService: HttpService;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  const baseProvider = {
    name: 'Minka Provider',
    credentials: undefined,
    providerType: ProviderType.Minka,
    accountId: undefined,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    rules: {},
  };

  const providerCredentials = {
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    apiKey: 'apiKey',
    apiUrl: 'apiUrl',
    source: 'source',
  };

  beforeAll(async () => {
    httpService = app.get<HttpService>(HttpService);
    minkaProvider = app.get<MinkaProviderAdapter>(MinkaProviderAdapter);
    minkaProviderService = app.get<MinkaProviderService>(MinkaProviderService);
    providerRepository = connection.getRepository(ProviderEntity);
    accountRepository = connection.getRepository(AccountEntity);
  });

  beforeEach(async () => {
    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...baseAccount });
    baseProvider.accountId = account.id;
    baseProvider.credentials =
      CredentialTransformer.encrypt(providerCredentials);

    provider = await providerRepository.save({ ...baseProvider });
    provider = await providerRepository.findOneBy({ id: provider.id });
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  it('then minkaProvider is defined', async () => {
    expect(minkaProvider).toBeDefined();
  });

  describe('when execute canCreateTransaction', () => {
    it('then return false if Currency != COLOMBIA', async () => {
      const currencyArray = [
        Currency.ARGENTINA,
        Currency.BOLIVIA,
        Currency.BRAZIL,
        Currency.CHILE,
        Currency.MEXICO,
        Currency.ECUADOR,
        Currency.PERU,
        Currency.URUGUAY,
      ];
      for (const currency of currencyArray) {
        transactionDto = {
          uuid: uuid(),
          amount: 1200,
          providerId: provider.id,
          destinationPhone: '123456789',
          currency: currency,
          state: TransferState.ASSIGNED,
        };
        const canCreateTransaction =
          minkaProvider.canCreateTransaction(transactionDto);
        expect(canCreateTransaction.capable).toBe(false);
      }
    });

    it('then return false if destinationPhone = undefined, null, empty', async () => {
      const falsyArray = [undefined, null, ''];
      for (const falsy of falsyArray) {
        transactionDto = {
          uuid: uuid(),
          amount: 1200,
          providerId: provider.id,
          destinationPhone: falsy,
          currency: Currency.COLOMBIA,
          state: TransferState.ASSIGNED,
        };
        const canCreateTransaction =
          minkaProvider.canCreateTransaction(transactionDto);
        expect(canCreateTransaction.capable).toBe(false);
      }
    });

    it('then return true if destinationPhone is valid and Currency Colombia', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.COLOMBIA,
        state: TransferState.ASSIGNED,
      };
      const canCreateTransaction =
        minkaProvider.canCreateTransaction(transactionDto);
      expect(canCreateTransaction.capable).toBe(true);
    });
  });

  describe('when execute createTransaction', () => {
    it('then return createdTransactionDto if payload is OK', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.COLOMBIA,
        state: TransferState.ASSIGNED,
      };
      const response = {
        amount: transactionDto.amount,
        transferId: 'dfsgdgsdfgsdfg',
        labels: { status: 'CREATED' },
      };
      jest
        .spyOn(httpService.axiosRef, 'post')
        .mockReturnValue(Promise.resolve({ data: response }));
      jest
        .spyOn(minkaProviderService, 'ensureToken')
        .mockReturnValue(Promise.resolve());
      const createdTransaction = await minkaProvider.createTransaction(
        provider,
        transactionDto,
      );
      expect(createdTransaction.externalId).toBeDefined();
      expect(createdTransaction.state).toBeDefined();
    });

    it('then return error if payload is WRONG', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.CHILE,
        state: TransferState.ASSIGNED,
      };
      const response = {
        amount: transactionDto.amount,
        transferId: 'dfsgdgsdfgsdfg',
        labels: { status: 'CREATED' },
      };
      jest
        .spyOn(httpService.axiosRef, 'post')
        .mockReturnValue(Promise.resolve({ data: response }));
      jest
        .spyOn(minkaProviderService, 'ensureToken')
        .mockReturnValue(Promise.resolve());
      try {
        await minkaProvider.createTransaction(provider, transactionDto);
      } catch (e) {
        expect(e.message).toBeDefined();
        expect(
          e.message.includes(
            'This transaction cant`t be created with this provider',
          ),
        ).toBe(true);
      }
    });
  });

  describe('when execute getTransactionState', () => {
    it('then return null state if is not a MinkaTransactionState', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.COLOMBIA,
        state: TransferState.ASSIGNED,
      };
      const response = {
        amount: transactionDto.amount,
        transferId: 'dfsgdgsdfgsdfg',
        entities: [{ status: 'desconocido' }],
      };
      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));
      jest
        .spyOn(minkaProviderService, 'ensureToken')
        .mockReturnValue(Promise.resolve());
      const createdTransaction = await minkaProvider.getTransactionState(
        provider,
        '3ocv8bcxv87dkfngqwolek5803914ydfiuns',
      );
      expect(createdTransaction.state).toBeNull();
      expect(createdTransaction.message).toBeUndefined();
    });

    it('then return TransactionStateDto if is a common MinkaTransactionState', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.COLOMBIA,
        state: TransferState.ASSIGNED,
      };
      const response = {
        amount: transactionDto.amount,
        transferId: 'dfsgdgsdfgsdfg',
        entities: [{ status: 'INITIATED' }],
      };
      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));
      jest
        .spyOn(minkaProviderService, 'ensureToken')
        .mockReturnValue(Promise.resolve());
      const createdTransaction = await minkaProvider.getTransactionState(
        provider,
        '3ocv8bcxv87dkfngqwolek5803914ydfiuns',
      );
      expect(createdTransaction.state).toBeDefined();
    });

    it('then return TransactionStateDto with a message if it is present', async () => {
      transactionDto = {
        uuid: uuid(),
        amount: 1200,
        providerId: provider.id,
        destinationPhone: '123456789',
        currency: Currency.COLOMBIA,
        state: TransferState.ASSIGNED,
      };
      const response = {
        amount: transactionDto.amount,
        transferId: 'dfsgdgsdfgsdfg',
        entities: [
          {
            status: 'INITIATED',
            error: {
              code: 315,
              message: 'Fondos insuficientes',
            },
          },
        ],
      };
      jest
        .spyOn(httpService.axiosRef, 'get')
        .mockReturnValue(Promise.resolve({ data: response }));
      jest
        .spyOn(minkaProviderService, 'ensureToken')
        .mockReturnValue(Promise.resolve());
      const createdTransaction = await minkaProvider.getTransactionState(
        provider,
        '3ocv8bcxv87dkfngqwolek5803914ydfiuns',
      );
      expect(createdTransaction.state).toBeDefined();
      expect(createdTransaction.message).toBeDefined();
      expect(createdTransaction.message).toEqual(
        response.entities[0].error.message,
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/providers/shinkansenProvider.e2e-spec.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { app, connection } from 'test/app.setup';
import { Repository } from 'typeorm';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { HttpService } from '@nestjs/axios';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';
import { ShinkansenProviderService } from 'src/providers/shinkansen/shinkansen.provider.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { Errors } from 'src/common/enums/errors.enum';
import {
  TestMerchantUtil,
  createTestMerchant,
} from 'test/utils/merchantTestUtils';

describe('given an ShinkansenProvider', () => {
  let shinkansenProvider: ShinkansenProvider;
  let providerRepository: Repository<ProviderEntity>;
  let accountRepository: Repository<AccountEntity>;
  let httpService: HttpService;

  let testMerchant: TestMerchantUtil;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const transferUuid = '90930230-e363-11ed-b5ea-0242ac120002';

  const baseAccount = {
    bankCode: 'cl_banco_falabella',
    countryCode: CountryCode.CHILE,
    currency: Currency.CHILE,
    name: 'Base Account',
    identifier: '123912391',
    merchantId: undefined,
  };

  const baseProvider = {
    name: 'Shinkansen Provider',
    rules: {},
    providerType: ProviderType.Shinkansen,
    capabilities: [ProviderCapability.CREATE_TRANSFER],
    accountId: undefined,
    credentials: {
      webhookCertificate: 'certificate',
      apiUrl: 'https://dev.shinkansen.finance/v1',
      apiKey: 'bukApiKey',
      certificate: 'bukCertificate',
      privateKey: 'bukPrivateKey',
      name: 'Buk Spa',
      email: 'buk@buk.cl',
      holderId: '76691442k',
      senderId: 'BUK',
      bankCode: 'cl_banco_bice',
      account: '60000007',
    },
  };

  beforeAll(async () => {
    httpService = app.get<HttpService>(HttpService);
    shinkansenProvider = app.get<ShinkansenProvider>(ShinkansenProvider);

    providerRepository = connection.getRepository(ProviderEntity);
    accountRepository = connection.getRepository(AccountEntity);
  });

  beforeEach(async () => {
    jest
      .spyOn(ShinkansenProviderService.prototype as any, 'buildPayload')
      .mockReturnValue(Promise.resolve({}));

    jest
      .spyOn(ShinkansenProviderService.prototype as any, 'signPayload')
      .mockReturnValue(Promise.resolve('signature'));

    jest.spyOn(httpService.axiosRef as any, 'post').mockReturnValue(
      Promise.resolve({
        data: {
          transactions: [
            {
              shinkansen_transaction_id: 'x9vsdfjipol8dfgdfklc0v94',
              transaction_id: transferUuid,
            },
          ],
        },
        status: 200,
        statusText: 'OK',
      }),
    );

    testMerchant = await createTestMerchant();
    baseAccount.merchantId = testMerchant.merchantId;

    account = await accountRepository.save({ ...baseAccount });
    baseProvider.accountId = account.id;

    provider = await providerRepository.save({ ...baseProvider });
    provider = await providerRepository.findOneBy({ id: provider.id });
  });

  afterEach(async () => {
    await providerRepository.delete({ accountId: account.id });
    await accountRepository.delete({ merchantId: testMerchant.merchantId });

    await testMerchant.deleteMerchant();
  });

  it('then shinkansenProvider is defined', async () => {
    expect(shinkansenProvider).toBeDefined();
  });

  describe('when execute createTransaction', () => {
    it('then return CreatedTransactionDto with defined externalId if all goes OK', async () => {
      const shinkansenTransaction = await shinkansenProvider.createTransaction(
        provider,
        {
          uuid: transferUuid,
          currency: Currency.CHILE,
        } as TransactionDto,
      );

      expect(shinkansenTransaction.externalId).toBeDefined();
    });

    it('then return error if payload is wrong and provider cant process it', async () => {
      try {
        await shinkansenProvider.createTransaction(provider, {
          currency: Currency.ARGENTINA,
        } as TransactionDto);
      } catch (e) {
        // TODO: Must refactor this
        expect(e.message).toBe(
          `This transaction cant\`t be created with this provider \n
        ProviderId                  : ${provider.id}
        Transaction currency        : ${Currency.ARGENTINA}`,
        );
      }
    });
  });
  describe('when execute getTransactionState', () => {
    it('then return TransactionStateDto with message defined if response is error', async () => {
      jest
        .spyOn(httpService.axiosRef as any, 'get')
        .mockReturnValueOnce(
          Promise.resolve({
            data: {
              shinkansen_transaction_status: 'error',
            },
          }),
        )
        .mockReturnValueOnce(
          Promise.resolve({
            data: {
              response_id: '684d4386-bd7a-4173-bf2e-1d70ef18553e',
              response_message:
                'Error CCA 38. Banco sin servicio por mantención programada',
              response_status: 'error_creditor_fi_offline',
              settlement_date: '2023-08-01T05:43:19Z',
              shinkansen_transaction_id: 'a8eedec7-1026-465f-8f8b-f166f3480529',
              shinkansen_transaction_message: '',
              shinkansen_transaction_status: 'error',
              transaction_id: '8a139cec-f934-436f-af1e-2d24c83b2662',
              transaction_type: 'payout',
            },
          }),
        );

      const result = await shinkansenProvider.getTransactionState(
        provider,
        '12344',
      );
      expect(result.state).toBeDefined();
      expect(result.message).toBeDefined();
      expect(result.state).toEqual(TransferState.FAILED);
    });

    it('then return TransactionStateDto with state defined if response is ok', async () => {
      jest.spyOn(httpService.axiosRef as any, 'get').mockReturnValue(
        Promise.resolve({
          data: {
            shinkansen_transaction_status: 'ok',
          },
        }),
      );
      const result = await shinkansenProvider.getTransactionState(
        provider,
        '12344',
      );
      expect(result.state).toBeDefined();
      expect(result.state).toBe(TransferState.COMPLETED);
    });

    it('then return TransactionStateDto with state defined if response is pending', async () => {
      jest.spyOn(httpService.axiosRef as any, 'get').mockReturnValue(
        Promise.resolve({
          data: {
            shinkansen_transaction_status: 'pending',
          },
        }),
      );
      const result = await shinkansenProvider.getTransactionState(
        provider,
        '12344',
      );
      expect(result.state).toBeDefined();
      expect(result.state).toBe(TransferState.PROCESSING);
    });
  });
  describe('when execute getBalance', () => {
    let providerWithAccount: ProviderEntity;

    beforeEach(async () => {
      const readProvider = await providerRepository.save({
        ...baseProvider,
        capabilities: [ProviderCapability.READ_TRANSFER],
      });

      providerWithAccount = await providerRepository.findOne({
        relations: ['account'],
        where: { id: readProvider.id },
      });
    });
    it('then should return the latest balance', async () => {
      const currentBalanace = '9999';
      const balances = [
        currentBalanace,
        String(+currentBalanace + 600),
        String(+currentBalanace + 1000),
      ];
      const retrievedAt = new Date();
      jest.spyOn(httpService.axiosRef as any, 'get').mockResolvedValueOnce(
        Promise.resolve({
          data: {
            account: account.identifier,
            balances: [
              {
                available_balance: balances[1],
                balance_type: 'snapshot',
                book_balance: balances[1],
                timestamp: new Date(retrievedAt.getTime() - 1).toISOString(),
              },
              {
                available_balance: currentBalanace,
                balance_type: 'snapshot',
                book_balance: currentBalanace,
                timestamp: retrievedAt.toISOString(),
              },
              {
                available_balance: balances[2],
                balance_type: 'snapshot',
                book_balance: balances[2],
                timestamp: new Date(retrievedAt.getTime() - 6000).toISOString(),
              },
            ],
            currency: 'CLP',
            financial_institution: {
              fin_id: 'BANCO_BICE_CL',
              fin_id_schema: 'SHINKANSEN',
            },
          },
        }),
      );

      const latestBalance = await shinkansenProvider.getBalance(
        providerWithAccount,
      );

      expect(latestBalance).toEqual({
        balance: Number(currentBalanace),
        retrievedAt,
        currency: account.currency,
      });
    });
    it('then should throw an error if the provider does not has the "read_balance" capability', async () => {
      providerWithAccount.capabilities = [ProviderCapability.CREATE_TRANSFER];

      await providerRepository.save(providerWithAccount);

      await expect(
        shinkansenProvider.getBalance(providerWithAccount),
      ).rejects.toThrow(Errors.MISSING_READ_TRANSFER_CAPABILITY);

      providerWithAccount.capabilities = [ProviderCapability.READ_TRANSFER];
      await providerRepository.save(providerWithAccount);
    });
    it('then should throw an error if the balance is not available', async () => {
      jest
        .spyOn(httpService.axiosRef as any, 'post')
        .mockRejectedValueOnce(Promise.resolve());
      await expect(shinkansenProvider.getBalance(provider)).rejects.toThrow();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/config/jest.config.ts
import type { Config } from 'jest';

const config: Config = {
  verbose: true,
  maxWorkers: '50%',
  testTimeout: 60000,
  fakeTimers: {
    enableGlobally: true,
  },
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true,
  preset: 'ts-jest',
  testEnvironment: 'node',
  testEnvironmentOptions: {
    NODE_ENV: 'test',
  },
  rootDir: '../../',
  roots: ['<rootDir>/test', '<rootDir>/src'],
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  modulePaths: ['<rootDir>'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  moduleDirectories: ['node_modules', 'src', 'test'],
  moduleNameMapper: {
    '^src/(.*)$': '<rootDir>/src/$1',
  },
  // collectCoverage: true,
  // coverageDirectory: 'coverage',
  testRegex: 'spec.ts$',
  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
  setupFilesAfterEnv: ['<rootDir>/test/app.setup.ts'],
  globalSetup: '<rootDir>/test/global.setup.ts',
  globalTeardown: '<rootDir>/test/global.teardown.ts',
};

export default config;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/config/e2e.jest.config.ts
import type { Config } from 'jest';

const config: Config = {
  verbose: true,
  maxWorkers: '50%',
  workerIdleMemoryLimit: '1GB',
  logHeapUsage: true,
  detectOpenHandles: true,
  forceExit: true,
  testTimeout: 60000,
  fakeTimers: {
    enableGlobally: true,
    doNotFake: ['nextTick', 'setImmediate'],
  },
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true,
  preset: 'ts-jest',
  testEnvironment: 'node',
  testEnvironmentOptions: {
    NODE_ENV: 'test',
  },
  rootDir: '../../',
  roots: ['<rootDir>/test'],
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  modulePaths: ['<rootDir>'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  moduleDirectories: ['node_modules', 'src', 'test'],
  moduleNameMapper: {
    '^src/(.*)$': '<rootDir>/src/$1',
  },
  // collectCoverage: true,
  // coverageDirectory: 'coverage/e2e',
  testRegex: 'e2e-spec.ts$',
  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
  setupFilesAfterEnv: ['<rootDir>/test/app.setup.ts'],
  globalSetup: '<rootDir>/test/global.setup.ts',
  globalTeardown: '<rootDir>/test/global.teardown.ts',
};

export default config;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/test/config/unit.jest.config.ts
import type { Config } from 'jest';

const config: Config = {
  verbose: true,
  maxWorkers: '50%',
  workerIdleMemoryLimit: '1GB',
  logHeapUsage: true,
  detectOpenHandles: true,
  forceExit: true,
  testTimeout: 60000,
  fakeTimers: {
    enableGlobally: true,
  },
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true,
  preset: 'ts-jest',
  testEnvironment: 'node',
  testEnvironmentOptions: {
    NODE_ENV: 'test',
  },
  rootDir: '../../',
  roots: ['<rootDir>/src'],
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  modulePaths: ['<rootDir>'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  moduleDirectories: ['node_modules', 'src', 'test'],
  moduleNameMapper: {
    '^src/(.*)$': '<rootDir>/src/$1',
  },
  testRegex: '.spec.ts$',
  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
  // collectCoverage: true,
  // coverageDirectory: 'coverage/unit',
};

export default config;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/.commitlintrc.json
{
  "extends": ["@commitlint/config-conventional"],
  "rules": {
    "type-enum": [
      2,
      "always",
      [
        "test",
        "chore",
        "docs",
        "feat",
        "fix",
        "perf",
        "refactor",
        "revert",
        "style"
      ]
    ]
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/tsconfig.build.json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"],
  "compilerOptions": {
    "sourceMap": true,
    "inlineSources": true,
    "sourceRoot": "/"
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/nodemon.json
{
 "watch": ["src"],
 "ext": "ts",
 "ignore": ["src/**/*.spec.ts"],
 "exec": "node --inspect=127.0.0.1:9223 -r ts-node/register -- src/main.ts",
 "env": {}
}

/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/tsconfig.json
{
  "extends": "@repo/typescript-config/api.json",
  "compilerOptions": {
    "baseUrl": ".",
    "sourceMap": true, // TODO: Remove this line
    "outDir": "./dist",
    "paths": {
      "src/*": ["./src/*"],
      "test/*": ["./test/*"],
    }
  },
  "include": ["src/**/*", "test/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "require": ["tsconfig-paths/register"]
  },
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/jobs/start-auto-founding-job.worker.ts
import { Injectable, Logger, Inject } from '@nestjs/common';
import { BaseWorker } from '../base.worker';
import { AccountFundingService } from 'src/workers/services/account-funding/account-funding.service';

@Injectable()
export class StartAutoFundingJobWorker extends BaseWorker {
  @Inject(AccountFundingService)
  private accountFundingService: AccountFundingService;

  private logger = new Logger('StartAccountFundingJobWorker');

  public async run(): Promise<void> {
    this.logger.log('Initializing StartAccountFundingJobWorker');
    try {
      const { payoutId, transferId, jobId, externalId } =
        await this.accountFundingService.fundAccount();

      this.logger.log(`Funding Payout created with id: ${payoutId}`);
      this.logger.log(`Transfer created with id: ${transferId}`);
      this.logger.log(`Started auto funding job with id: ${jobId}`);
      this.logger.log(`External Id: ${externalId}`);
    } catch (error) {
      this.logger.error(
        `Error when trying to start auto funding job: ${error.message}`,
      );
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/jobs/start-account-statement-job.worker.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { BaseWorker } from '../base.worker';
import workerConfig from '../config/worker.config';
import { ConfigType } from '@nestjs/config';
import * as moment from 'moment';

const DATE_FORMAT = 'YYYY-MM-DD';

Injectable();
export class StartAccountStatementJobWorker extends BaseWorker {
  @Inject(AccountStatementJobService)
  private accountStatementJobService: AccountStatementJobService;
  @Inject(workerConfig.KEY) private config: ConfigType<typeof workerConfig>;

  private logger = new Logger('StartAccountStatementJobWorker');

  public async run(): Promise<void> {
    this.logger.log('Initializing StartAccountStatementJobWorker');

    const accountId = this.config.accountStatement.accountId;

    if (!accountId) {
      this.logger.warn(
        `Can't start account statement job, invalid accountId: '${accountId}' received`,
      );
      return;
    }

    try {
      this.logger.log('Trying to start account statement job');

      const endDate = moment();
      const startDate = endDate.subtract(1, 'day');

      const result = await this.accountStatementJobService.startScraper(
        accountId,
        {
          startDate: startDate.format(DATE_FORMAT),
          endDate: endDate.format(DATE_FORMAT),
        },
      );

      this.logger.log(`Started account statement job. jobId: ${result.jobId}`);
    } catch (error) {
      this.logger.error(
        `Error when trying to start account statement job: ${error.message}`,
      );
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/base.worker.ts
export abstract class BaseWorker {
  public abstract run(): Promise<void>;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/main.ts
import { NestFactory } from '@nestjs/core';
import { WorkersModule } from './workers.module';
import { StartAccountStatementJobWorker } from './jobs/start-account-statement-job.worker';
import { StartAutoFundingJobWorker } from './jobs/start-auto-founding-job.worker';

enum Workers {
  START_ACCOUNT_STATEMENT_JOB = 'start_account_statement_job',
  START_ACCOUNT_FUNDING_JOB = 'start_account_funding_job',
}

async function bootstrap() {
  try {
    const app = await NestFactory.createApplicationContext(WorkersModule);

    app.enableShutdownHooks();

    const workerName = process.env.WORKER_NAME ?? '';

    if (workerName === Workers.START_ACCOUNT_STATEMENT_JOB) {
      const worker = app.get(StartAccountStatementJobWorker);

      await worker.run();
    }

    if (workerName === Workers.START_ACCOUNT_FUNDING_JOB) {
      const worker = app.get(StartAutoFundingJobWorker);
      await worker.run();
    }

    console.log('Worker ended without errors');
    process.exit(0);
  } catch (error) {
    console.log('Worker failed with error', error);
    process.exit(1);
  }
}

bootstrap();


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/workers.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule } from '@nestjs/config';
import databaseConfig from 'src/config/database.config';
import { AccountStatementJobModule } from 'src/models/account-statement-job/account-statement-job.module';
import workerConfig from './config/worker.config';
import { StartAccountStatementJobWorker } from './jobs/start-account-statement-job.worker';
import { AccountModule } from 'src/models/account/account.module';
import { ProviderModule } from 'src/models/provider/provider.module';
import { AccountFundingModule } from 'src/workers/services/account-funding/account-founding.module';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { StartAutoFundingJobWorker } from './jobs/start-auto-founding-job.worker';
import { SecretManagerModule } from './services/secret-manager/secret-manager/secret-manager.module';
import { dataSourceOptions } from 'src/database/dataSource';

@Module({
  imports: [
    ConfigModule.forRoot({
      load: [databaseConfig, workerConfig],
      isGlobal: true,
    }),
    TypeOrmModule.forRoot(dataSourceOptions),
    AccountStatementJobModule,
    AccountModule,
    ProviderModule,
    AccountFundingModule,
    EventEmitterModule.forRoot(),
    SecretManagerModule,
  ],
  providers: [StartAccountStatementJobWorker, StartAutoFundingJobWorker],
})
export class WorkersModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/account-funding/account-funding.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/models/account/account.service';
import { Repository } from 'typeorm';
import { plainToClass } from 'class-transformer';
import { InjectRepository } from '@nestjs/typeorm';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { AccountFundingDto } from './dto/account-funding.dto';
import { validate } from 'class-validator';
import { randUuid } from '@ngneat/falso';
import { SecretManagerService } from '../secret-manager/secret-manager/secret-manager.service';
import workerConfig from 'src/workers/config/worker.config';
import { ConfigType } from '@nestjs/config';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderService } from 'src/models/provider/provider.service';
import moment = require('moment');
import { CreatePayoutDto } from 'src/api/v2/payout/dto/create-payout.dto';
import { InSimpleArray } from 'src/common/queries/inSimpleArray.query';

export interface FundingResult {
  payoutId: number;
  transferId: number;
  jobId: string;
  externalId: string;
}

@Injectable()
export class AccountFundingService {
  private readonly logger = new Logger(AccountFundingService.name);

  @InjectRepository(PayoutEntity)
  private payoutRepository: Repository<PayoutEntity>;
  @InjectRepository(TransferEntity)
  private transferRepository: Repository<TransferEntity>;
  @Inject(AccountService)
  private accountService: AccountService;
  @Inject(ProviderService)
  private providerService: ProviderService;
  @Inject(TransferProviderService)
  private transferProviderService: TransferProviderService;
  @Inject(SecretManagerService)
  private secretManagerService: SecretManagerService;

  constructor(
    @Inject(workerConfig.KEY)
    private readonly config: ConfigType<typeof workerConfig>,
  ) {
    const { secretId } = this.config.accountFunding;

    if (!secretId) throw new Error('Missing secret id');
  }

  private async getAccountBalance({
    destinationAccountId,
    destinationMerchantId,
  }: {
    destinationAccountId: number;
    destinationMerchantId: number;
  }): Promise<number> {
    const [provider] = await this.providerService.findAll({
      relations: ['account'],
      where: {
        account: {
          id: destinationAccountId,
          merchantId: destinationMerchantId,
        },
        capabilities: InSimpleArray(ProviderCapability.READ_TRANSFER),
      },
    });

    if (!provider) {
      throw new Error(
        `Couldn't find a provider with "read_transfer" capability`,
      );
    }

    const providerAdapter = this.providerService.getProviderAdapter(
      provider.providerType,
    );

    const { balance, retrievedAt } = await providerAdapter.getBalance(provider);

    this.logger.log(
      `Current balance: $${balance}, retrieved at: ${retrievedAt}`,
    );

    const diffHours = moment().diff(moment(retrievedAt), 'hours');

    if (diffHours > 1) {
      throw new Error('Balance must be less than one hour ago');
    }

    return balance;
  }

  private buildFundingResponse(payout: PayoutEntity): FundingResult {
    if (payout?.transfers?.length !== 1) {
      throw new Error('Invalid funding response');
    }
    const payoutId = payout.id;
    const transferId = payout.transfers[0].id;
    const jobId = payout.transfers[0]?.metadata?.jobId;
    const externalId = payout.transfers[0]?.externalId;

    if (!payoutId || !transferId || !jobId || !externalId) {
      throw new Error('Invalid funding response data');
    }
    return {
      payoutId,
      transferId,
      jobId,
      externalId,
    };
  }

  private async buildPayoutDto(
    accountFundingDto: AccountFundingDto,
  ): Promise<CreatePayoutDto> {
    return this.payoutRepository.create({
      amount: Number(accountFundingDto.amount),
      currency: accountFundingDto.currency,
      state: PayoutState.PENDING,
      version: EntityVersion.v2,
      destinationAccount: accountFundingDto.destinationAccountIdentifier,
      destinationBankCode: accountFundingDto.destinationAccountBankCode,
      destinationEmail: accountFundingDto.destinationAccountEmail,
      destinationHolderId: accountFundingDto.destinationAccountHolderId,
      destinationName: accountFundingDto.destinationHolderName,
      concept:
        accountFundingDto.concept ?? `Payout Funding ${new Date().getDate()}`,
      trackingCode: randUuid(),
      merchantId: accountFundingDto.originMerchantId,
      metadata: {
        message: 'Account Funding Payout',
      },
    });
  }

  private async createTransfer(
    payout: PayoutEntity,
    providerId: number,
  ): Promise<TransferEntity> {
    const createTransferDto = this.transferRepository.create({
      amount: payout.amount,
      currency: payout.currency,
      destinationAccount: payout.destinationAccount,
      destinationBankCode: payout.destinationBankCode,
      destinationEmail: payout.destinationEmail,
      destinationHolderId: payout.destinationHolderId,
      destinationName: payout.destinationName,
      concept: payout.concept,
      trackingCode: payout.trackingCode,
      merchantId: payout.merchantId,
      payoutId: payout.id,
      providerId,
      state: TransferState.ASSIGNED,
      version: EntityVersion.v2,
      metadata: {
        message: 'Account Funding Payout',
      },
    });

    this.logger.log(`Transfer DTO: ${JSON.stringify(createTransferDto)}`);

    return this.transferRepository.save(createTransferDto);
  }

  private async createPayout(
    accountFundingDto: AccountFundingDto,
  ): Promise<PayoutEntity> {
    const createPayoutDto = await this.buildPayoutDto(accountFundingDto);
    this.logger.log(`Payout DTO: ${JSON.stringify(createPayoutDto)}`);

    const payout = await this.payoutRepository.save(createPayoutDto);
    this.logger.log(`Payout created with id: ${payout.id}`);

    const transfer = await this.createTransfer(
      payout,
      accountFundingDto.originProviderId,
    );
    this.logger.log(`Transfer created with id: ${transfer.id}`);

    await this.transferProviderService.createTransaction(transfer);
    this.logger.log(`Provider transaction created`);

    const updatedPayout = await this.payoutRepository.findOne({
      where: { id: payout.id },
      relations: ['transfers'],
    });

    if (!updatedPayout) {
      this.logger.log('Something went wrong creating payout');
      throw new Error('Payout not found');
    }
    return updatedPayout;
  }

  private async canFundAccount(
    accountFundingDto: AccountFundingDto,
  ): Promise<void> {
    const originAccount = await this.accountService.findOneByConditions({
      where: {
        id: accountFundingDto.originAccountId,
        merchantId: accountFundingDto.originMerchantId,
      },
    });

    if (!originAccount) {
      throw new Error(
        `Origin account with id ${accountFundingDto.originAccountId} was not found`,
      );
    }

    this.logger.log(
      `Validating destination account Id '${accountFundingDto.destinationAccountId}'`,
    );
    const destinationAccount = await this.accountService.findOneByConditions({
      where: {
        id: accountFundingDto.destinationAccountId,
        merchantId: accountFundingDto.destinationMerchantId,
      },
    });

    if (!destinationAccount) {
      throw new Error(
        `Destination account with id ${accountFundingDto.destinationAccountId} was not found`,
      );
    }

    const originProvider = await this.providerService.findOne(
      accountFundingDto.originProviderId,
    );

    if (!originProvider) {
      throw new Error(
        `Provider with id ${accountFundingDto.originProviderId} was not found`,
      );
    }

    this.logger.log(`
      Account fund validations success
      - Origin Account: ${originAccount.name} - ${originAccount.identifier}
      - Origin Provider: ${originProvider.name} - ${originProvider.providerType}
      - Destination Account: ${destinationAccount.name} - ${destinationAccount.identifier}
    `);
  }

  private async getFundingDto(): Promise<AccountFundingDto> {
    const { secretId } = this.config.accountFunding;

    const rawObject =
      await this.secretManagerService.getSecret<AccountFundingDto>(secretId);

    const accountFundingDto = plainToClass(AccountFundingDto, rawObject);

    const errors = await validate(accountFundingDto);

    if (errors.length > 0) {
      this.logger.log(errors);
      throw new Error('Invalid DTO');
    }

    return accountFundingDto;
  }

  async fundAccount(): Promise<FundingResult> {
    const accountFundingDto = await this.getFundingDto();

    this.logger.log('Validating if can fund account');
    await this.canFundAccount(accountFundingDto);

    const currentBalance = await this.getAccountBalance({
      destinationAccountId: accountFundingDto.destinationAccountId,
      destinationMerchantId: accountFundingDto.destinationMerchantId,
    });

    if (currentBalance >= accountFundingDto.minBalance) {
      this.logger.log('No need to fund account');
      return;
    }

    // TODO: Replace this with the payoutService method
    this.logger.log('Creating payout');
    const payout = await this.createPayout(accountFundingDto);

    this.logger.log('Building and validating funding response');
    const fundingResponse = this.buildFundingResponse(payout);

    return fundingResponse;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/account-funding/account-founding.module.ts
import { Module } from '@nestjs/common';
import { AccountFundingService } from './account-funding.service';
import { AccountModule } from 'src/models/account/account.module';
import { TransferProviderModule } from 'src/services/transfer-provider/transfer-provider.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { SecretManagerModule } from '../secret-manager/secret-manager/secret-manager.module';
import { ProviderModule } from 'src/models/provider/provider.module';

@Module({
  imports: [
    AccountModule,
    ProviderModule,
    TransferProviderModule,
    TypeOrmModule.forFeature([PayoutEntity, TransferEntity]),
    SecretManagerModule,
  ],
  providers: [AccountFundingService],
  exports: [AccountFundingService],
})
export class AccountFundingModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/account-funding/account-funding.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountFundingService } from './account-funding.service';
import { AccountService } from 'src/models/account/account.service';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { SecretManagerService } from '../secret-manager/secret-manager/secret-manager.service';
import workerConfig from 'src/workers/config/worker.config';
import { ProviderService } from 'src/models/provider/provider.service';

describe('AutoFundingService', () => {
  let service;
  let mockAccountStatementJobService;
  let mockAccountService;
  let mockTransferProviderService;
  let mockProviderService;

  beforeEach(async () => {
    mockAccountStatementJobService = {
      // mock methods or properties here
    };
    mockAccountService = {};
    mockTransferProviderService = {
      // mock methods or properties here
    };
    mockProviderService = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AccountFundingService,
        {
          provide: AccountService,
          useValue: mockAccountService,
        },
        {
          provide: TransferProviderService,
          useValue: mockTransferProviderService,
        },
        {
          provide: 'PayoutEntityRepository',
          useValue: {},
        },
        {
          provide: 'TransferEntityRepository',
          useValue: {},
        },
        {
          provide: SecretManagerService,
          useValue: {},
        },
        {
          provide: workerConfig.KEY,
          useValue: {
            accountFunding: { secretId: 'dummyKey' },
          },
        },
        {
          provide: ProviderService,
          useValue: mockProviderService,
        },
      ],
    }).compile();

    service = module.get<AccountFundingService>(AccountFundingService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/account-funding/dto/account-funding.dto.ts
import { Type } from 'class-transformer';
import {
  IsEnum,
  IsNotEmpty,
  IsNumberString,
  IsString,
  IsOptional,
  IsNumber,
} from 'class-validator';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { Currency } from 'src/common/enums/currency.enum';

export class AccountFundingDto {
  @IsNumber()
  @Type(() => Number)
  minBalance: number;

  @IsString()
  @IsNumberString()
  amount: string;

  @IsString()
  @IsNumberString()
  maxAmountAllowed?: string;

  @IsString()
  @IsOptional()
  concept?: string;

  @IsString()
  @IsOptional()
  trackingCode?: string;

  @IsEnum(Currency)
  currency: Currency;

  @IsNumber()
  @Type(() => Number)
  originMerchantId: number;

  @IsNumber()
  @Type(() => Number)
  originAccountId: number;

  @IsNumber()
  @Type(() => Number)
  originProviderId: number;

  @IsNumber()
  @Type(() => Number)
  destinationMerchantId: number;

  @IsNumber()
  @Type(() => Number)
  destinationAccountId: number;

  @IsString()
  @IsNotEmpty()
  destinationAccountIdentifier: string;

  @IsString()
  @IsNotEmpty()
  destinationHolderName: string;

  @IsString()
  @IsNotEmpty()
  destinationAccountEmail: string;

  @IsString()
  @IsNotEmpty()
  destinationAccountHolderId: string;

  @IsEnum(BankCode)
  @IsNotEmpty()
  destinationAccountBankCode: BankCode;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/secret-manager/secret-manager/secret-manager.service.ts
import { Injectable } from '@nestjs/common';
import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';

@Injectable()
export class SecretManagerService {
  private client: SecretsManagerClient;

  constructor() {
    this.client = this.getSecretManager();
  }

  private getSecretManager() {
    const region = process.env.AWS_REGION;
    if (!region) {
      throw new Error('AWS_REGION is not set');
    }
    const accessKeyId = process.env.AWS_ACCESS_KEY_ID;
    if (!accessKeyId) {
      throw new Error('AWS_ACCESS_KEY_ID is not set');
    }
    const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY;
    if (!secretAccessKey) {
      throw new Error('AWS_SECRET_ACCESS_KEY is not set');
    }
    const clientCred = {
      region,
    };
    const credentials = {
      accessKeyId,
      secretAccessKey,
    };
    clientCred['credentials'] = credentials;

    return new SecretsManagerClient(clientCred);
  }

  public async getSecret<Type>(secretId: string): Promise<Type> {
    try {
      const command = new GetSecretValueCommand({ SecretId: secretId });
      const response = await this.client.send(command);
      const secretString = response.SecretString;
      const secret: Type = JSON.parse(secretString);
      return secret;
    } catch (error) {
      throw new Error(`Error retrieving secret: ${error}`);
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/secret-manager/secret-manager/secret-manager.module.ts
import { Module } from '@nestjs/common';
import { SecretManagerService } from './secret-manager.service';

@Module({
  providers: [SecretManagerService],
  exports: [SecretManagerService],
})
export class SecretManagerModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/services/secret-manager/secret-manager/secret-manager.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { SecretManagerService } from './secret-manager.service';

describe('SecretManagerService', () => {
  let service: SecretManagerService;
  process.env.AWS_REGION = 'us-east-1';
  process.env.AWS_ACCESS_KEY_ID = 'test';
  process.env.AWS_SECRET_ACCESS_KEY = 'test';
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SecretManagerService],
    }).compile();

    service = module.get<SecretManagerService>(SecretManagerService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/workers/config/worker.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('worker', () => ({
  accountStatement: {
    accountId: parseInt(process.env.ACCOUNT_ID) ?? 0,
  },
  accountFunding: {
    secretId: process.env.ACCOUNT_FUNDING_SECRET_ID ?? 'secret',
  },
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/queue.constants.ts
import { BullModuleOptions } from '@nestjs/bull';

export const TransferQueue: BullModuleOptions = {
  name: 'transfer',
};

export const WebhookQueue: BullModuleOptions = {
  name: 'webhook',
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/webhook-event-job/webhook-event-job.module.ts
import { BullModule } from '@nestjs/bull';
import { Module } from '@nestjs/common';
import { WebhookEndpointModule } from 'src/models/webhook-endpoint/webhook-endpoint.module';
import { WebhookQueue } from '../queue.constants';
import { WebhookEventJobConsumer } from './webhook-event-job.consumer';
import { WebhookEventJobProducer } from './webhook-event-job.producer';

@Module({
  imports: [BullModule.registerQueue(WebhookQueue), WebhookEndpointModule],
  providers: [WebhookEventJobProducer, WebhookEventJobConsumer],
  exports: [WebhookEventJobProducer],
})
export class WebhookEventJobModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/webhook-event-job/webhook-event-job.producer.ts
import { InjectQueue } from '@nestjs/bull';
import { Injectable, Logger } from '@nestjs/common';
import { Queue } from 'bull';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';
import { CALL_WEBHOOK_JOB } from './webhook-event-job.consumer';
import { WebhookQueue } from '../queue.constants';
import { BaseEntity } from 'src/common/base.entity';

export type CallWebhookJobPayload = {
  webhookEndpointId: number;
  eventName: WebhookEvent;
  data: EventPayload;
};

export type EventPayload = {
  object?: BaseEntity;
  error?: string;
};

@Injectable()
export class WebhookEventJobProducer {
  private readonly logger = new Logger('WebhookEventJobProducer');
  constructor(
    @InjectQueue(WebhookQueue.name) private webhookQueue: Queue,
    private webhookEndpointService: WebhookEndpointService,
  ) {}

  async handleEvent(
    merchantId: number,
    eventName: WebhookEvent,
    data: EventPayload,
  ) {
    const webhookEndpoints = await this.findEndpoints(eventName, merchantId);
    for (const webhookEndpoint of webhookEndpoints) {
      const payload: CallWebhookJobPayload = {
        webhookEndpointId: webhookEndpoint.id,
        eventName,
        data,
      };
      await this.webhookQueue.add(CALL_WEBHOOK_JOB, payload, { attempts: 1 });
    }
  }

  async findEndpoints(eventName: WebhookEvent, merchantId: number) {
    const webhookEndpoints = await this.webhookEndpointService.findByEventName(
      eventName,
      merchantId,
    );
    return webhookEndpoints;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/webhook-event-job/webhook-event-job.consumer.ts
import { Processor, Process } from '@nestjs/bull';
import { Injectable, Logger } from '@nestjs/common';
import axios, { AxiosRequestConfig } from 'axios';
import { Job } from 'bull';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';
import { generatePayloadSignature } from 'src/utils/secrets.util';
import {
  CallWebhookJobPayload,
  EventPayload,
} from './webhook-event-job.producer';

export const CALL_WEBHOOK_JOB = 'callWebhookJob';

export type WebhookPayload = {
  timestamp: number;
  type: WebhookEvent;
  data: EventPayload;
};

export type WebhookHeaders = {
  'Payouts-Signature': string;
  'Content-Type': string;
};

@Injectable()
@Processor('webhook')
export class WebhookEventJobConsumer {
  private readonly logger = new Logger('WebhookEventJobConsumer');

  constructor(private webhookEndpointService: WebhookEndpointService) {}

  @Process(CALL_WEBHOOK_JOB)
  async consume(job: Job<CallWebhookJobPayload>) {
    const { webhookEndpointId } = job.data;

    const webhookEndpoint = await this.webhookEndpointService.findOne(
      webhookEndpointId,
    );

    const payload = this.preparePayload(job.data);
    const { secret, url } = webhookEndpoint;
    const config: AxiosRequestConfig = {
      headers: this.prepareHeaders(payload, secret),
    };
    try {
      const response = await axios.post(url, payload, config);
      return {
        payload: payload,
        data: response?.data,
        status: response?.status,
      };
    } catch (err) {
      return {
        error: err.message,
        status: err?.response?.status,
      };
    }
  }

  prepareHeaders(payload: WebhookPayload, secret: string): WebhookHeaders {
    const hmacSignature = generatePayloadSignature(payload, secret);
    return {
      'Payouts-Signature': hmacSignature,
      'Content-Type': 'application/json',
    };
  }

  preparePayload(jobPayload: CallWebhookJobPayload): WebhookPayload {
    const { data, eventName } = jobPayload;
    const timestamp = Date.now();
    const type = eventName;
    return { timestamp, type, data };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/queue.module.ts
import { BullModule } from '@nestjs/bull';
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';

import { TransferQueue, WebhookQueue } from './queue.constants';

import { WebhookEventJobModule } from './webhook-event-job/webhook-event-job.module';

import { TransferStateAlertJobModule } from './transfer-state-alert-job/transfer-state-alert-job.module';

@Module({
  imports: [
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        redis: {
          host: configService.get<string>('redis.host'),
          port: configService.get<number>('redis.port'),
          enableReadyCheck: false,
          maxRetriesPerRequest: null,
        },
      }),
      inject: [ConfigService],
    }),
    BullModule.registerQueue(TransferQueue, WebhookQueue),
    TransferStateAlertJobModule,
    WebhookEventJobModule,
  ],
})
export class QueueModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/transfer-state-alert-job/transfer-state-alert-job.producer.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { SchedulerRegistry } from '@nestjs/schedule';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import alertsConfig from 'src/config/alerts.config';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { CronJob } from 'cron';
import { SlackService } from 'src/services/slack/slack.service';
import { Repository } from 'typeorm';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { SlackTransferStateAlert } from 'src/services/alerts/templates/slack-transfer-state-alert';

const CLEAN_REGEX = /[^0-9:\-,\w]/g;
const ALERT_STATE_REGEX = /([a-z]+):([0-9]+)-([0-9]+)/g;
export const DEFAULT_MIN_LOOKUP_TIME = 10;
export const DEFAULT_MAX_LOOKUP_TIME = 35;

interface AlertThreshold {
  minLookupTime: number;
  maxLookupTime: number;
}

type AlertsThreshold = {
  [key in TransferState]: AlertThreshold;
};

type TransferAlert = {
  currency: string;
  state: string;
  transferId: string;
  payoutIds: string;
  transferCount: number;
};

type CurrencyFilter = {
  [key in Currency]: Array<string>;
};

type TransferAlertsFilters = {
  currency: Partial<CurrencyFilter>;
};

@Injectable()
export class TransferStateAlertJobProducer {
  private readonly logger = new Logger('TransferStateAlertJobProducer');

  @InjectRepository(TransferEntity)
  private readonly transferRepository: Repository<TransferEntity>;
  @Inject(SlackService) private readonly slackService: SlackService;

  constructor(
    @Inject(alertsConfig.KEY) private config: ConfigType<typeof alertsConfig>,
    private scheduleRegistry: SchedulerRegistry,
  ) {
    if (!this.config?.alerts.enabled) return;

    const job = new CronJob(
      this.config.alerts.cronExpression,
      this.runTransferStateAlerts.bind(this),
    );

    this.scheduleRegistry.addCronJob('transferStateAlerts', job);

    job.start();
  }

  private async runTransferStateAlerts() {
    if (!this.config.alerts.enabled) return;

    const alertsThreshold: AlertsThreshold = this.parseAlertsThresholds(
      this.config.alerts.transfers,
    );

    if (!alertsThreshold) return;

    for (const stateKey in alertsThreshold) {
      const minLookupTime = alertsThreshold[stateKey].minLookupTime;
      const maxLookupTime = alertsThreshold[stateKey].maxLookupTime;

      try {
        const transfers: Array<TransferAlert> =
          await this.transferRepository.query(
            `
          SELECT  t.currency, 
                  t.state, 
                  GROUP_CONCAT(t.id SEPARATOR ',') AS transferId,
                  GROUP_CONCAT(DISTINCT t.payoutId  SEPARATOR ',') AS payoutIds,
                  COUNT(t.id) AS transferCount 
          FROM transfer t 
          INNER JOIN payout p ON p.id = t.payoutId
          INNER JOIN (SELECT MAX(id) id, payoutId FROM transfer GROUP BY payoutId) lt
          ON t.id = lt.id AND p.id = lt.payoutId
          WHERE TIMESTAMPDIFF(MINUTE, t.updatedAt, NOW()) >= ?
          AND TIMESTAMPDIFF(MINUTE, t.updatedAt, NOW()) <= ?
          AND t.state = ?
          AND p.state IN(?)
          GROUP BY t.currency
          ORDER BY t.currency ASC;
          `,
            [
              minLookupTime,
              maxLookupTime,
              stateKey,
              [PayoutState.PENDING, PayoutState.PROCESSING],
            ],
          );

        if (transfers.length === 0) continue;

        this.logger.debug(
          `Found ${transfers.length} transfers with state ${stateKey}`,
        );

        for (const countryTransfersGroup of transfers) {
          const totalTransfers = countryTransfersGroup.transferCount;
          const payoutIds = countryTransfersGroup.payoutIds;
          const currency = countryTransfersGroup.currency;

          if (!this.shouldSendAlert(countryTransfersGroup)) continue;

          const alert = new SlackTransferStateAlert(currency).stuckTransfers(
            stateKey as TransferState,
            payoutIds,
            totalTransfers,
          );

          this.logger.debug(`Sending message to slack channel`);

          const { success } = await this.slackService.postMessage(alert);

          if (success)
            this.logger.debug(`Message to slack channel sent successfully`);
        }
      } catch (error) {
        this.logger.error(`Error on job execution, message: ${error}`);
      }
    }
  }

  shouldSendAlert(trasferAlert: Partial<TransferAlert>): boolean {
    let filters: TransferAlertsFilters;
    try {
      filters = JSON.parse(this.config.alerts.filters);
    } catch {
      this.logger.log("Can't parse transfer alerts filters");
      return true;
    }

    const { currency, state } = trasferAlert;
    const currencyFilter: Array<string> = filters?.currency[currency] ?? [];

    if (!currencyFilter.length) return true;

    if (!currencyFilter.includes(state)) return false;

    return true;
  }

  parseAlertsThresholds(rawAlerts: string): AlertsThreshold {
    try {
      if (!rawAlerts || rawAlerts.length === 0)
        throw new Error('Value for alertsThreshold was empty.');

      const cleanedAlerts = rawAlerts.replace(CLEAN_REGEX, '');
      const alerts = cleanedAlerts.split(',');

      const parsedAlerts: any = {};

      for (const alert of alerts) {
        // Should match something like: pending:10-25
        const match = ALERT_STATE_REGEX.exec(alert);

        if (!match || !TransferState[match[1].toLocaleUpperCase()]) {
          ALERT_STATE_REGEX.lastIndex = 0;
          continue;
        }

        if (!+match[2])
          this.logger.error(
            `Invalid minLookupTime: ${match[2]} for state ${match[1]}. Setting default value: ${DEFAULT_MIN_LOOKUP_TIME}`,
          );

        if (!+match[3])
          this.logger.error(
            `Invalid maxLookupTime: ${match[2]} for state ${match[1]}. Setting default value: ${DEFAULT_MAX_LOOKUP_TIME}`,
          );

        let minLookupTime: number = +match[2]
          ? +match[2]
          : DEFAULT_MIN_LOOKUP_TIME;
        let maxLookupTime: number = +match[3]
          ? +match[3]
          : DEFAULT_MAX_LOOKUP_TIME;

        if (minLookupTime > maxLookupTime) {
          [minLookupTime, maxLookupTime] = [maxLookupTime, minLookupTime];
        }

        try {
          parsedAlerts[TransferState[match[1].toLocaleUpperCase()]] = {
            minLookupTime,
            maxLookupTime,
          };
        } catch (error) {
          this.logger.error(
            `Ignorig invalid state. The state '${match[1]}' doesn't match with the transfers states defined`,
          );
        }

        ALERT_STATE_REGEX.lastIndex = 0;
      }

      return parsedAlerts as AlertsThreshold;
    } catch (error) {
      this.logger.error(
        `An error ocurred when parsing the alerts thresholds, message: ${error.mensaje}`,
      );
      return undefined;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/transfer-state-alert-job/transfer-state-alert-job.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import alertsConfig from 'src/config/alerts.config';
import { SlackModule } from 'src/services/slack/slack.module';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferStateAlertJobProducer } from './transfer-state-alert-job.producer';

@Module({
  imports: [
    ConfigModule.forFeature(alertsConfig),
    SlackModule,
    TypeOrmModule.forFeature([TransferEntity]),
  ],
  providers: [TransferStateAlertJobProducer],
  exports: [TransferStateAlertJobProducer],
})
export class TransferStateAlertJobModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/jobs/transfer-state-alert-job/tranfer-state-alert-job.spec.ts
import { SchedulerRegistry } from '@nestjs/schedule';
import { Test, TestingModule } from '@nestjs/testing';
import { SlackService } from 'src/services/slack/slack.service';
import alertsConfig from 'src/config/alerts.config';
import {
  DEFAULT_MAX_LOOKUP_TIME,
  DEFAULT_MIN_LOOKUP_TIME,
  TransferStateAlertJobProducer,
} from './transfer-state-alert-job.producer';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ConfigType } from '@nestjs/config';
import { Currency } from 'src/common/enums/currency.enum';

describe('given a TransferStateAlertJobProducer', () => {
  let jobProducer: TransferStateAlertJobProducer;
  let mockAlertsConfig: Partial<ConfigType<typeof alertsConfig>>;

  beforeEach(async () => {
    mockAlertsConfig = {
      alerts: {
        filters: '',
        cronExpression: '',
        enabled: false,
        transfers: '',
      },
    };

    const mockSlackService = {};

    const mockTransferRepository = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferStateAlertJobProducer,
        {
          provide: alertsConfig.KEY,
          useValue: mockAlertsConfig,
        },
        {
          provide: SlackService,
          useValue: mockSlackService,
        },
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferRepository,
        },
        SchedulerRegistry,
      ],
    }).compile();

    jobProducer = module.get<TransferStateAlertJobProducer>(
      TransferStateAlertJobProducer,
    );
  });

  it('should be defined', () => {
    expect(jobProducer).toBeDefined();
  });

  describe('when the method parseAlertsThresholds is called', () => {
    it('should return undefined if an empty string is passed', () => {
      const result = jobProducer.parseAlertsThresholds('');

      expect(result).toEqual(undefined);
    });

    it('should return undefined if null value is passed', () => {
      const result = jobProducer.parseAlertsThresholds(null);

      expect(result).toEqual(undefined);
    });

    it('should return an object that contain the status list provided as keys', () => {
      const result = jobProducer.parseAlertsThresholds(
        'pending:1-2, processing:2-3',
      );

      expect(result.pending).not.toBe(undefined);
      expect(result.processing).not.toBe(undefined);
    });

    it('should return an object that contain the pending state as key and the thresolds values provided', () => {
      const result = jobProducer.parseAlertsThresholds('pending:1-2');

      expect(result.pending).not.toBe(undefined);
      expect(result.pending.minLookupTime).toEqual(1);
      expect(result.pending.maxLookupTime).toEqual(2);
    });

    it('should ignore a state if the format provided is invalid', () => {
      const result = jobProducer.parseAlertsThresholds('pending');

      expect(result.pending).toBe(undefined);
    });

    it('should swap the minLookupTime value if his value is higher than maxLookupTime', () => {
      const result = jobProducer.parseAlertsThresholds('pending:20-10');

      expect(result.pending.minLookupTime).toEqual(10);
      expect(result.pending.maxLookupTime).toEqual(20);
    });

    it('should set the default value for minLookupTime is the value is <= 0', () => {
      const result = jobProducer.parseAlertsThresholds('pending:0-10');

      expect(result.pending.minLookupTime).toEqual(DEFAULT_MIN_LOOKUP_TIME);
    });

    it('should set the default value for maxLookupTime is the value is <= 0', () => {
      const result = jobProducer.parseAlertsThresholds('pending:10-0');

      expect(result.pending.maxLookupTime).toEqual(DEFAULT_MAX_LOOKUP_TIME);
    });

    it('should return an object only with the valid state provided', () => {
      const result = jobProducer.parseAlertsThresholds('pending, failed:10-25');

      expect(result.pending).toBe(undefined);
      expect(result.failed).not.toBe(undefined);
    });

    it('should return an object only with the valid state provided', () => {
      const result = jobProducer.parseAlertsThresholds(
        'invlalid_state:10-25, failed:10-25',
      );

      expect(result).toStrictEqual({
        failed: {
          minLookupTime: 10,
          maxLookupTime: 25,
        },
      });
    });
  });

  describe('when the method shouldSendAlert is called', () => {
    it('should return true if there is no filters', () => {
      mockAlertsConfig.alerts.filters = '';
      const result = jobProducer.shouldSendAlert({
        currency: 'clp',
        state: TransferState.ASSIGNED,
      });

      expect(result).toBe(true);
    });

    it('should return true if there is an alert configured for an specific state and a filter for the same state with the specified currency', () => {
      const includedState = TransferState.FAILED;
      for (const currency of Object.values(Currency)) {
        mockAlertsConfig.alerts.filters = `{"currency": {"${currency}": ["${includedState}"]}}`;
        const result = jobProducer.shouldSendAlert({
          currency: currency,
          state: includedState,
        });

        expect(result).toBe(true);
      }
    });

    it('should return false only for transfers with state and currency that is not in a filter', () => {
      const transferAlerts = [
        { currency: 'clp', state: 'failed', result: true },
        { currency: 'clp', state: 'processing', result: true },
        { currency: 'clp', state: 'assigned', result: true },
        { currency: 'cop', state: 'processing', result: true },
        { currency: 'cop', state: 'assigned', result: true },
        { currency: 'cop', state: 'failed', result: false },
      ];

      mockAlertsConfig.alerts.filters =
        '{"currency": {"cop":["pending", "assigned", "processing"], "clp": ["failed", "processing", "assigned"]}}';

      for (const alert of transferAlerts) {
        const result = jobProducer.shouldSendAlert(alert);

        expect(result).toBe(alert.result);
      }
    });

    it('should return false if there is no filter that match with a configured alert state and currency', () => {
      const filteredState = TransferState.FAILED;
      mockAlertsConfig.alerts.filters = `{"currency": {"clp": ["${filteredState}"]}}`;

      const result = jobProducer.shouldSendAlert({
        state: TransferState.PROCESSING,
        currency: Currency.CHILE,
      });

      expect(result).toBe(false);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/dataSource.ts
import { join } from 'path';
import { DataSource, DataSourceOptions } from 'typeorm';

import databaseConfigFactory from 'src/config/database.config';

import { DatabaseType } from './database.constants';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { DepositEntity } from 'src/models/deposit/entities/deposit.entity';
import { MasterAccountEntity } from 'src/models/master-account/entities/master-account.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';
import { MerchantLimitEntity } from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutActionEntity } from 'src/models/payout-actions/entities/payout-action.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { WebhookEndpointEntity } from 'src/models/webhook-endpoint/entities/webhook-endpoint.entity';
import { TransferSubscriber } from 'src/models/transfer/entities/transfer.subscriber';
import { ChangeAuditSubscriber } from './subscribers/change-audit.subscriber';
import { WebhookEndpointSubscriber } from 'src/models/webhook-endpoint/entities/webhook-endpoint.subscriber';

function buildDataSourceOptions(): DataSourceOptions {
  const databaseConfig = databaseConfigFactory();

  return {
    type: DatabaseType.MYSQL,
    host: databaseConfig.host,
    port: databaseConfig.port,
    username: databaseConfig.username,
    password: databaseConfig.password,
    logging: databaseConfig.logging,
    database: databaseConfig.database,
    synchronize: false,
    migrationsRun: true,
    entities: [
      AccountEntity,
      AccountStatementEntity,
      AccountStatementJobEntity,
      ApiKeyEntity,
      AuditLogEntity,
      AuthorizationCodeEntity,
      BankEntity,
      BankAccessEntity,
      BankAccountEntity,
      DepositEntity,
      MasterAccountEntity,
      MerchantEntity,
      MerchantLimitEntity,
      PayoutEntity,
      PayoutActionEntity,
      ProviderEntity,
      TransferEntity,
      TransferErrorEntity,
      TransferJobEntity,
      TransferMethodEntity,
      UserEntity,
      WebhookEndpointEntity,
    ],
    migrations: [join(__dirname, '..', 'database', 'migrations', '*.{ts,js}')],
    subscribers: [
      TransferSubscriber,
      ChangeAuditSubscriber,
      WebhookEndpointSubscriber,
    ],
    supportBigNumbers: true,
    extra: {
      decimalNumbers: true,
    },
    timezone: '+00:00',
  };
}

export const dataSourceOptions = buildDataSourceOptions();

const dataSource = new DataSource(dataSourceOptions);

export default dataSource;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/utils/createDatabase.ts
import DatabaseManager from './database.manager';

DatabaseManager.createDatabase()
  .catch((error) => console.error('Error creating database', error));

/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/utils/database.manager.ts
import { DataSource } from 'typeorm';
import { dataSourceOptions } from '../dataSource';
import { Environment } from 'src/common/enums/environment.enum';
import { DatabaseType } from '../database.constants';
import { MysqlConnectionOptions } from 'typeorm/driver/mysql/MysqlConnectionOptions';

export default class DatabaseManager {
  private static _dataSource: DataSource;

  public static get databaseName() {
    return String(this.options.database);
  }

  public static get options(): MysqlConnectionOptions {
    return dataSourceOptions as MysqlConnectionOptions;
  }

  private static get dataSource(): DataSource {
    if (process.env.NODE_ENV === Environment.PRODUCTION) {
      throw new Error('Forbidden action for production environment');
    }

    if (this._dataSource) return this._dataSource;

    this._dataSource = new DataSource({
      type: DatabaseType.MYSQL,
      host: this.options.host,
      port: this.options.port,
      username: this.options.username,
      password: this.options.password,
      logging: false,
    });

    return this._dataSource;
  }

  private static async initialize() {
    if (this.dataSource.isInitialized) return;

    await this.dataSource.initialize();
  }

  private static async destroy() {
    if (!this.dataSource.isInitialized) return;

    await this.dataSource.destroy();
  }

  private static async findDatabase(): Promise<boolean> {
    const query = `SHOW DATABASES LIKE '${this.databaseName}'`;
    const dataPackages = await this.dataSource.query(query);

    if (!Array.isArray(dataPackages)) return false;

    const results = dataPackages.map((dataPackage) =>
      JSON.parse(JSON.stringify(dataPackage)),
    );
    const databases = Object.values(results);

    const databaseFound = databases.length > 0;
    return databaseFound;
  }

  public static async createDatabase(): Promise<void> {
    try {
      await this.initialize();
      const databaseFound = await this.findDatabase();
      if (databaseFound) {
        console.log(`Database '${this.databaseName}' already exists`);
        return;
      }

      const createDatabaseQuery = `CREATE DATABASE ${this.databaseName}`;
      await this.dataSource.query(createDatabaseQuery);
      console.log('Database created successfully');
    } catch (error) {
      console.error('Error creating database', error);
    } finally {
      await this.destroy();
    }
  }

  public static async dropDatabase() {
    try {
      await this.initialize();
      const databaseFound = await this.findDatabase();
      if (!databaseFound) {
        console.log(`Database '${this.databaseName}' does not exist`);
        return;
      }

      const dropDatabaseQuery = `DROP DATABASE ${this.databaseName}`;
      await this.dataSource.query(dropDatabaseQuery);
      console.log('Database dropped successfully');
    } catch (error) {
      console.error('Error dropping database', error);
    } finally {
      await this.destroy();
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/utils/dropDatabase.ts
import DatabaseManager from './database.manager';

DatabaseManager.dropDatabase()
  .catch((error) => console.error('Error dropping database', error));

/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/data.service.ts
import { Type } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindManyOptions, FindOptionsWhere, Repository } from 'typeorm';

const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
};

export interface IPageResult<T> {
  data: Array<T>;
  page: number;
  limit: number;
  itemCount: number;
  pageCount: number;
}

export interface IPaginationQuery<T> {
  page?: number;
  limit?: number;
  options?: FindManyOptions<T>;
}

export interface IDataService<T> {
  readonly repository: Repository<T>;
  findAllPaginated: (query: IPaginationQuery<T>) => Promise<IPageResult<T>>;
}

type Constructor<I> = new (...args: any[]) => I;

export function DataService<T>(entity: Constructor<T>): Type<IDataService<T>> {
  class DataServiceHost implements IDataService<T> {
    @InjectRepository(entity) public readonly repository: Repository<T>;

    public async findAllPaginated(
      query: IPaginationQuery<T>,
    ): Promise<IPageResult<T>> {
      let options: FindManyOptions<T> = {};

      if (typeof query.options === 'object') {
        options = { ...query.options };
      }

      let { page, limit } = query;

      if (isNaN(limit) || limit <= 0) limit = DEFAULT_PAGINATION.limit;
      if (isNaN(page) || page <= 0) page = DEFAULT_PAGINATION.page;

      options.take = limit;
      options.skip = this.skip(page, limit);

      const filters = options.where ?? [];

      const filterArray: FindOptionsWhere<T>[] = Array.isArray(filters)
        ? filters
        : [filters];
      const filterOptions = filterArray.map((f) =>
        buildFindOptionsFromFilters<T>(f),
      );

      options.where = filterOptions.map((f) => f.where);
      options.relations =
        mergeArrays(filterOptions.map((f) => f.relations)) ?? [];

      const [data, count] = await this.repository.findAndCount(options);

      const pageCount = Math.ceil(count / limit);

      return {
        page,
        pageCount,
        itemCount: count,
        data,
        limit,
      };
    }

    private skip(page: number, limit: number): number {
      return (page - 1) * limit;
    }
  }

  return DataServiceHost;
}

function buildFindOptionsFromFilters<T>(filters: FindOptionsWhere<T>): {
  where: FindOptionsWhere<T>;
  relations: string[];
} {
  const options = {
    where: {},
    relations: [],
  };

  const fields = Object.keys(filters);

  const entityFields = fields.filter((c) => !c.includes('.'));
  const nestedFields = fields.filter((c) => c.includes('.'));

  const relations = nestedFields.map((c) => c.split('.')[0]);
  const uniqueRelations = Array.from(new Set(relations));

  const nestedQuery = nestedFields.reduce((acc, nestedField) => {
    const [relation, field] = nestedField.split('.');
    const value = filters[nestedField];
    return {
      ...acc,
      [relation]: {
        ...acc[relation],
        [field]: value,
      },
    };
  }, {});

  const entityQuery = entityFields.reduce((acc, field) => {
    return {
      ...acc,
      [field]: filters[field],
    };
  }, {});

  options.where = {
    ...entityQuery,
    ...nestedQuery,
  };

  options.relations = uniqueRelations;

  return options;
}

function mergeArrays<T>(arrays: T[][]): T[] {
  return Array.from(new Set([].concat(...arrays)));
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/database.utils.ts
import { Environment } from "src/common/enums/environment.enum";

export function getDatabaseName(environment: Environment): string {
  switch (environment) {
    case Environment.DEVELOPMENT:
      return 'payments_engine_dev';
    case Environment.TEST:
      return 'payments_engine_test';
    default:
      return 'payments_engine_dev';
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/bankAccess.factory.ts
import { randFullName } from '@ngneat/falso';
import { BankAccessCapability } from 'src/common/enums/bank-access-capability.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';

export const BankAccessFactory = () => {
  const bankAccess = new BankAccessEntity();
  bankAccess.name = randFullName();
  bankAccess.merchantId = 1;
  bankAccess.bankCode = 'cl_banco_falabella';
  bankAccess.capabilities = [
    BankAccessCapability.CREATE_TRANSFER,
    BankAccessCapability.AUTHORIZE_TRANSFER,
  ];
  return bankAccess;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/apikey.factory.ts
import { randUserName } from '@ngneat/falso';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';

export const ApiKeyFactory = () => {
  const apiKey = new ApiKeyEntity();
  apiKey.name = `${randUserName()} API key`;
  return apiKey;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/transfer.factory.ts
import {
  randAmount,
  randEmail,
  randFullName,
  randRecentDate,
  randSoonDate,
} from '@ngneat/falso';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferEntity } from '../../models/transfer/entities/transfer.entity';

export const TransferFactory = () => {
  const transfer = new TransferEntity();
  transfer.amount = randAmount({ min: 1000, max: 2000000 });
  transfer.concept = 'adelanto';
  transfer.trackingCode = 'adelanto';
  transfer.destinationEmail = randEmail();
  transfer.destinationName = randFullName();
  transfer.destinationHolderId = '268784803';
  transfer.destinationAccount = '268784803';
  transfer.destinationBankCode = 'cl_banco_falabella';
  transfer.merchantId = 1;
  transfer.payoutId = 1;
  transfer.originBankCode = 'cl_banco_de_chile';
  transfer.originBankAccessId = 1;
  transfer.originBankAccountId = 1;
  transfer.currency = Currency.COLOMBIA;
  transfer.message = '';
  transfer.startedAt = randRecentDate();
  transfer.finishedAt = randSoonDate();
  transfer.state = TransferState.PENDING;
  transfer.destinationPhone = '$573770000075';
  return transfer;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/rule.json


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/accountStatement.factory.ts
import {
  randAmount,
  randEmail,
  randFullName,
  randSuperhero,
  randUuid,
} from '@ngneat/falso';
import moment = require('moment');

import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';

export const AccountStatementFactory = () => {
  const now = moment();
  const accountStatementEntity = new AccountStatementEntity();
  accountStatementEntity.uuid = randUuid();
  accountStatementEntity.createdAt = now.toDate();
  accountStatementEntity.date = now.subtract(45, 'minutes').toDate();
  accountStatementEntity.originBankCode = 'cl_banco_de_chile';
  accountStatementEntity.originBankAccountIdentifier = randSuperhero().alterEgo;
  accountStatementEntity.currency = Currency.CHILE;
  accountStatementEntity.concept = 'adelanto';
  accountStatementEntity.countryCode = CountryCode.CHILE;
  accountStatementEntity.amount = randAmount({ min: 1000, max: 2000000 });
  accountStatementEntity.state = TransferState.COMPLETED;
  accountStatementEntity.transactionCode = 'adelanto';
  accountStatementEntity.destinationHolderId = '268784803';
  accountStatementEntity.destinationName = randFullName();
  accountStatementEntity.destinationAccount = '268784803';
  accountStatementEntity.destinationEmail = randEmail();
  accountStatementEntity.destinationBankCode = 'cl_banco_falabella';
  accountStatementEntity.metadata = {
    status: 'Ok',
    destinationBank: 'Banco falabella',
  };
  accountStatementEntity.accountStatementJobId = 1;

  return accountStatementEntity;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/merchant.factory.ts
import { randEmail, randFullName } from '@ngneat/falso';
import { MerchantEntity } from '../../models/merchant/entities/merchant.entity';

export const MerchantFactory = () => {
  const merchant = new MerchantEntity();
  merchant.name = randFullName();
  merchant.identifier = randEmail();
  return merchant;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/authorizationCode.factory.ts
import { randPassword, randSoonDate, randUuid } from '@ngneat/falso';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';

export const AuthorizationCodeFactory = () => {
  const currentDate = new Date();
  const authorizationCode = new AuthorizationCodeEntity();
  authorizationCode.uuid = randUuid();
  authorizationCode.createdAt = currentDate;
  authorizationCode.expiresAt = randSoonDate();
  authorizationCode.code = randPassword();
  authorizationCode.transferMethodId = 1;
  authorizationCode.state = AuthorizationCodeState.ACTIVE;

  return authorizationCode;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/payout.factory.ts
import { randAmount, randEmail, randNumber, randUserName } from '@ngneat/falso';
import { Currency } from 'src/common/enums/currency.enum';
import { PayoutEntity } from '../../models/payout/entities/payout.entity';

export const PayoutFactory = () => {
  const payout = new PayoutEntity();
  payout.amount = randAmount({ min: 1000, max: 20000000 });
  payout.destinationName = randUserName();
  payout.destinationEmail = randEmail();
  payout.destinationHolderId = randEmail();
  payout.destinationAccount = randEmail();
  payout.destinationBankCode = 'cl_banco_falabella';
  payout.merchantId = 1;
  payout.currency = Currency.COLOMBIA;
  payout.concept = 'adelanto de sueldo';
  payout.trackingCode =
    randNumber({ min: 10, max: 1000 }).toString() + randEmail();
  payout.destinationPhone = '$573770000075';
  return payout;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/transferJob.factory.ts
import { randUuid } from '@ngneat/falso';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';

export const TransferJobFactory = () => {
  const transferJobEntity = new TransferJobEntity();
  transferJobEntity.bankAccessId = 1;
  transferJobEntity.jobId = randUuid();
  transferJobEntity.startedAt = new Date();

  return transferJobEntity;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/accountStatementJob.factory.ts
import { randAmount, randUuid } from '@ngneat/falso';
import moment = require('moment');

import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';

export const AccountStatementJobFactory = () => {
  const now = moment();
  const accountStatementJobEntity = new AccountStatementJobEntity();
  accountStatementJobEntity.uuid = randUuid();
  accountStatementJobEntity.createdAt = now.toDate();
  accountStatementJobEntity.endDate = now.subtract(2, 'days').toDate();
  accountStatementJobEntity.startDate = now.subtract(1, 'days').toDate();
  accountStatementJobEntity.state = AccountStatementJobState.CREATED;
  accountStatementJobEntity.endedAt = now.subtract(1, 'minutes').toDate();
  accountStatementJobEntity.startedAt = now.subtract(4, 'minutes').toDate();
  accountStatementJobEntity.retrievedAt = now.subtract(3, 'minutes').toDate();
  accountStatementJobEntity.totalRetrieved = randAmount({
    min: 10,
    max: 200,
  });
  accountStatementJobEntity.jobId = TransferState.COMPLETED;
  accountStatementJobEntity.bankAccountId = 1;

  return accountStatementJobEntity;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/bank.factory.ts
import { randAirportCode, randPassword } from '@ngneat/falso';
import { State } from '../../common/enums/state.enum';
import { BankEntity } from '../../models/bank/entities/bank.entity';

export const BankFactory = () => {
  const bank = new BankEntity();
  bank.name = randPassword();
  bank.state = State.ACTIVE;
  bank.code = randAirportCode();
  return bank;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/user.factory.ts
import { randFullName, randPassword, randEmail } from '@ngneat/falso';
import { UserEntity } from '../../models/user/entities/user.entity';

export const UserFactory = () => {
  const user = new UserEntity();
  user.email = randEmail();
  user.name = randFullName();
  user.merchantId = 1;
  user.password = randPassword();
  return user;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/webHook.factory.ts
import { randUrl } from '@ngneat/falso';
import { WebhookEvent } from '../../common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointEntity } from '../../models/webhook-endpoint/entities/webhook-endpoint.entity';

export const WebhookEndpointFactory = () => {
  const webHook = new WebhookEndpointEntity();
  webHook.url = randUrl();
  webHook.description = 'we hook description';
  webHook.enabledEvents = [WebhookEvent.PAYOUT_COMPLETED];
  webHook.secret = 'secret';
  webHook.merchantId = 1;

  return webHook;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/factories/transferMethod.factory.ts
import { randAnimalType, randFullName } from '@ngneat/falso';
import { TransferMethodType } from '../../common/enums/transfer-method-type.enum';
import { TransferMethodEntity } from '../../models/transfer-method/entities/transfer-method.entity';

export const TransferMethodFactory = () => {
  const transferMethod = new TransferMethodEntity();
  transferMethod.identifier = randFullName() + randAnimalType();
  transferMethod.methodType = TransferMethodType.SMS;
  transferMethod.merchantId = 1;
  transferMethod.bankAccessId = 1;
  return transferMethod;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1699376701961-AddPasswordUpdatedAtToUsers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddPasswordUpdatedAtToUsers1699376701961
  implements MigrationInterface
{
  name = 'AddPasswordUpdatedAtToUsers1699376701961';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD \`passwordUpdatedAt\` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`user\` DROP COLUMN \`passwordUpdatedAt\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1699376701963-MigrateEncryptTransformer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { AuthorizationCodeEntity } from '../../models/authorization-code/entities/authorization-code.entity';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { EncryptTransformer } from 'src/common/transformers/encrypt.transformer';

export class MigrateEncryptTransformer1699376701963
  implements MigrationInterface
{
  name = 'MigrateEncryptTransformer1699376701963';

  private async getAllAuthCode(
    queryRunner: QueryRunner,
  ): Promise<Partial<AuthorizationCodeEntity>[]> {
    const allAuthCodeWithCode = (await queryRunner.connection.manager.query(
      `
        SELECT auth_code.id, auth_code.code FROM authorization_code auth_code
        WHERE  auth_code.code IS NOT NULL
      `,
    )) as Partial<AuthorizationCodeEntity>[];
    return allAuthCodeWithCode;
  }

  private async getAllTransferMethod(
    queryRunner: QueryRunner,
  ): Promise<Partial<TransferMethodEntity>[]> {
    const allTransferMethodWithSigningKeys =
      (await queryRunner.connection.manager.query(
        `
        SELECT tm.id, tm.signingKeys FROM transfer_method tm
        WHERE  tm.signingKeys IS NOT NULL
      `,
      )) as Partial<TransferMethodEntity>[];
    return allTransferMethodWithSigningKeys;
  }

  private async updateAuthorizationCode(
    queryRunner: QueryRunner,
  ): Promise<void> {
    const authCodes = await this.getAllAuthCode(queryRunner);
    if (authCodes.length === 0) {
      console.warn('No authorization code with code encrypted to migrate');
      return;
    }
    for (const authCode of authCodes) {
      const oldTransformer = EncryptTransformer.default();
      const rawCode = oldTransformer.from(authCode.code);
      const newTransformer = EncryptTransformer.default();
      const newEncryptedCode = newTransformer.to(rawCode);
      if (!newEncryptedCode) {
        console.error(
          `Could not encrypt code for auth code ${authCode.id}. Skip update record.`,
        );
        continue;
      }
      await queryRunner.query(
        `UPDATE authorization_code
                  SET authorization_code.code = ? 
                  WHERE authorization_code.id = ?`,
        [newEncryptedCode, authCode.id],
      );
      console.log(`code for auth code ${authCode.id} encrypted`);
    }
    console.log('Update all authorization code keys');
  }

  private async updateTransferMethodSigningKeys(
    queryRunner: QueryRunner,
  ): Promise<void> {
    const transferMethods = await this.getAllTransferMethod(queryRunner);
    if (transferMethods.length === 0) {
      console.warn('No transfer method with singing keys encrypted to migrate');
      return;
    }
    for (const transferMethod of transferMethods) {
      const oldTransformer = EncryptTransformer.default();
      const rawSigningKey = oldTransformer.from(transferMethod.signingKeys);
      const newTransformer = EncryptTransformer.default();
      const newEncryptedSigningKey = newTransformer.to(rawSigningKey);

      if (!newEncryptedSigningKey) {
        console.error(
          `Could not encrypt signing key for transfer method ${transferMethod.id}. Skip update record.`,
        );
        continue;
      }
      await queryRunner.query(
        `UPDATE transfer_method
                  SET transfer_method.signingKeys = ? 
                  WHERE transfer_method.id = ?`,
        [newEncryptedSigningKey, transferMethod.id],
      );
      console.log(
        `signing key for transfer method ${transferMethod.id} encrypted`,
      );
    }
    console.log('Update all transfer method signing keys');
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.updateAuthorizationCode(queryRunner);
    await this.updateTransferMethodSigningKeys(queryRunner);
  }

  public async down(_queryRunner: QueryRunner): Promise<void> {
    // If update fails, theres nothing to rollback
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1646373866093-AddPriorityToMasterAccounts.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddPriorityToMasterAccounts1646373866093
  implements MigrationInterface
{
  name = 'AddPriorityToMasterAccounts1646373866093';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`master_account\` ADD \`priority\` int NOT NULL DEFAULT '1'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`master_account\` DROP COLUMN \`priority\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1690375622085-AddDataSuggestionToPayoutActionTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { Logger } from '@nestjs/common';
import { randUuid } from '@ngneat/falso';
import { suggestedPayoutErrorCode } from 'src/models/transfer-error/error.definition.type';
const logger = new Logger('AddDataSuggestionToPayoutActionTable');

export class AddDataSuggestionToPayoutActionTable1690375622085
  implements MigrationInterface
{
  name = 'AddDataSuggestionToPayoutActionTable1690375622085';

  private async buildPayoutActionData(queryRunner: QueryRunner): Promise<void> {
    for (const errorCode of suggestedPayoutErrorCode) {
      const uuid = randUuid();
      try {
        await queryRunner.query(
          `INSERT INTO payout_action(uuid,errorCode,suggestion) VALUES(?,?,?);`,
          [uuid, errorCode, 'AUTO_RETRY'],
        );
      } catch (e) {
        logger.log(e);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.buildPayoutActionData(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      'DELETE FROM payout_action WHERE `suggestion` is NOT NULL;',
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1655481295364-AddCanceledStateToTransfer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddCanceledStateToTransfer1655481295364
  implements MigrationInterface
{
  name = 'AddCanceledStateToTransfer1655481295364';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed') NOT NULL DEFAULT 'pending'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1688414730320-AddPayoutActionsTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddPayoutActionsTable1688414730320 implements MigrationInterface {
  name = 'AddPayoutActionsTable1688414730320';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`payout_action\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009') NULL, \`action\` varchar(128) NULL, \`suggestion\` varchar(128) NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE \`payout_action\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1670254121311-AddPeruvianBanksSeed.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { randUuid } from '@ngneat/falso';

export class AddPeruvianBanks1670254121311 implements MigrationInterface {
  name = 'AddPeruvianBanksSeed1670254121311';

  private async makePeruvianBanks(queryRunner: QueryRunner): Promise<void> {
    const peruvianBanksCodes = {
      bancoComercio: 'pe_banco_de_comercio',
      bancoBcp: 'pe_banco_bcp',
      banbif: 'pe_banco_banbif',
      bancoPichinchaPeru: 'pe_banco_pichincha',
      bancoBbvaPeru: 'pe_banco_bbva',
      bancoCitibankPeru: 'pe_banco_citibank',
      bancoInterbank: 'pe_banco_interbank',
      bancoMibancoPeru: 'pe_banco_mibanco',
      bancoScotiabank: 'pe_banco_scotiabank',
      bancoGnb: 'pe_banco_gnb',
      bancoFalabellaPeru: 'pe_banco_falabella',
      bancoRipleyPeru: 'pe_banco_ripley',
      bancoSantanderPeru: 'pe_banco_santander',
      bancoAlfin: 'pe_banco_alfin', // OLD Azteca Del Perú
      bancoBoc: 'pe_bank_of_china',
      bancoIcbc: 'pe_banco_icbc',
      agrobanco: 'pe_agrobanco',
      bancoLaNacion: 'pe_banco_de_la_nacion',
      cofide: 'pe_cofide',
      fondoMiVivienda: 'pe_fondo_mivivienda',
      amerik: 'pe_amerika',
      crediscotia: 'pe_crediscotia',
      confianza: 'pe_confianza',
      compartamos: 'pe_compartamos',
      credinka: 'pe_credinka',
      efectiva: 'pe_efectiva',
      proempresa: 'pe_proempresa',
      mitsuiAutoFinance: 'pe_mitsui_auto_finance',
      oh: 'pe_oh',
      qapaq: 'pe_qapaq',
      arequipa: 'pe_arequipa',
      cusco: 'pe_cusco',
      delSanta: 'pe_del_santa',
      trujillo: 'pe_trujillo',
      huancayo: 'pe_huancayo',
      ica: 'pe_ica',
      maynas: 'pe_maynas',
      paita: 'pe_paita',
      piura: 'pe_piura',
      sullana: 'pe_sullana',
      tacna: 'pe_tacna',
      cajaMetropolitanaDeLima: 'pe_caja_metropolitana_de_lima',
      incasur: 'pe_incasur',
      losAndes: 'pe_los_andes',
      prymera: 'pe_prymera',
      delCentro: 'pe_del_centro',
      raiz: 'pe_raiz',
      cencosudScotia: 'pe_cencosud_scotia',
      accesoCrediticio: 'pe_acceso_crediticio',
      alternativa: 'pe_alternativa',
      bbvaConsumerFinance: 'pe_bbva_consumer_finance',
      credivision: 'pe_credivision',
      inversionesLaCruz: 'pe_inversiones_la_cruz',
      miCasita: 'pe_mi_casita',
      santanderConsumerPeru: 'pe_santander_consumer_peru',
      totalServiciosFinancieros: 'pe_total_servicios_financieros',
      jpMorganBancoInversion: 'pe_jp_morgan_banco_de_inversion',
    };

    const peruvianBanksNames = {
      bancoComercio: 'Banco de Comercio',
      bancoBcp: 'Banco de Crédito del Perú',
      banbif: 'Banco Interamericano de Finanzas (BanBif)',
      bancoPichinchaPeru: 'Banco Pichincha',
      bancoBbvaPeru: 'BBVA',
      bancoCitibankPeru: 'Citibank Perú',
      bancoInterbank: 'Interbank',
      bancoMibancoPeru: 'MiBanco',
      bancoScotiabank: 'Scotiabank Perú',
      bancoGnb: 'Banco GNB Perú',
      bancoFalabellaPeru: 'Banco Falabella',
      bancoRipleyPeru: 'Banco Ripley',
      bancoSantanderPeru: 'Banco Santander Perú',
      bancoAlfin: 'Alfin Banco',
      bancoBoc: 'Bank of China',
      bancoIcbc: 'ICBC PERU BANK',
      agrobanco: 'Agrobanco',
      bancoLaNacion: 'Banco de la Nación',
      cofide: 'COFIDE',
      fondoMiVivienda: 'Fondo MiVivienda',
      amerik: 'Amérika',
      crediscotia: 'Crediscotia',
      confianza: 'Confianza',
      compartamos: 'Compartamos',
      credinka: 'Credinka',
      efectiva: 'Efectiva',
      proempresa: 'Proempresa',
      mitsuiAutoFinance: 'Mitsui Auto Finance',
      oh: 'Oh!',
      qapaq: 'Qapaq',
      arequipa: 'Caja Municipal Arequipa',
      cusco: 'Caja Municipal Cusco',
      delSanta: 'Caja Municipal del Santa',
      trujillo: 'Caja Municipal Trujillo',
      huancayo: 'Caja Municipal Huancayo',
      ica: 'Caja Municipal Ica',
      maynas: 'Caja Municipal Maynas',
      paita: 'Caja Municipal Paita',
      piura: 'Caja Municipal Piura',
      sullana: 'Caja Municipal Sullana',
      tacna: 'Caja Municipal Tacna',
      cajaMetropolitanaDeLima: 'Caja Metropolitana de Lima',
      incasur: 'Caja Rural Incasur',
      losAndes: 'Caja Rural los Andes',
      prymera: 'Caja Rural Prymera',
      delCentro: 'Caja Rural del Centro',
      raiz: 'Caja Rural Raíz',
      cencosudScotia: 'Caja Rural Cencosud Scotia',
      accesoCrediticio: 'Acceso Crediticio',
      alternativa: 'Alternativa',
      bbvaConsumerFinance: 'BBVA Consumer Finance',
      credivision: 'Credivisión',
      inversionesLaCruz: 'Inversiones la Cruz',
      miCasita: 'Mi Casita',
      santanderConsumerPeru: 'Santander Consumer Perú',
      totalServiciosFinancieros: 'Total, Servicios Financieros',
      jpMorganBancoInversion: 'J.P. Morgan Banco de Inversión',
    };

    const peruvianBanks = Object.keys(peruvianBanksCodes);

    for (const bank of peruvianBanks) {
      const uuid = randUuid();
      const bankCode = peruvianBanksCodes[bank];
      const bankName = peruvianBanksNames[bank];
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.makePeruvianBanks(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const peruvianBanks = await queryRunner.query(
      `SELECT * FROM bank where code LIKE 'pe_%';`,
    );
    for (const bank of peruvianBanks) {
      try {
        await queryRunner.query(`DELETE FROM bank WHERE id = ?`, bank.id);
      } catch (error) {
        console.log(error);
      }
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1671048858605-SetAuthCodeExpirationAsOptional.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class SetAuthCodeExpirationAsOptional1671048858605
  implements MigrationInterface
{
  name = 'SetAuthCodeExpirationAsOptional1671048858605';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`expiresAt\` \`expiresAt\` datetime(6) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`state\` \`state\` enum ('pending', 'active', 'claimed', 'expired', 'deleted') NOT NULL DEFAULT 'active'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008') NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`state\` \`state\` enum ('active', 'claimed', 'expired', 'deleted') NOT NULL DEFAULT 'active'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`expiresAt\` \`expiresAt\` datetime(6) NOT NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1668011663025-AddErrorCodeToTransfer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddErrorCodeToTransfer1668011663025 implements MigrationInterface {
  name = 'AddErrorCodeToTransfer1668011663025';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006') NULL DEFAULT NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`errorCode\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1663094864229-IncreaseBankCodeColumnLength.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class IncreaseBankCodeColumnLength1663094864229
  implements MigrationInterface
{
  name = 'IncreaseBankCodeColumnLength1663094864229';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` DROP FOREIGN KEY \`FK_f5e70828e96027413bcc199a6ea\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_1baf589ec5263f8ca58b4b939b6\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP FOREIGN KEY \`FK_ef032e23c88ec38598f43573129\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_0dea23d5a30db31a05415facb2e\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_328b779f7669629bb40ff7ce60b\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank\` MODIFY COLUMN \`code\` varchar(64) NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` ADD CONSTRAINT \`FK_f5e70828e96027413bcc199a6ea\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_1baf589ec5263f8ca58b4b939b6\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD CONSTRAINT \`FK_ef032e23c88ec38598f43573129\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_0dea23d5a30db31a05415facb2e\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_328b779f7669629bb40ff7ce60b\` FOREIGN KEY (\`originBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_328b779f7669629bb40ff7ce60b\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_0dea23d5a30db31a05415facb2e\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP FOREIGN KEY \`FK_ef032e23c88ec38598f43573129\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_1baf589ec5263f8ca58b4b939b6\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` DROP FOREIGN KEY \`FK_f5e70828e96027413bcc199a6ea\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank\` MODIFY COLUMN \`code\` varchar(32) NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_328b779f7669629bb40ff7ce60b\` FOREIGN KEY (\`originBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_0dea23d5a30db31a05415facb2e\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD CONSTRAINT \`FK_ef032e23c88ec38598f43573129\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_1baf589ec5263f8ca58b4b939b6\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` ADD CONSTRAINT \`FK_f5e70828e96027413bcc199a6ea\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1663094864211-AddMetadataToTransfers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddMetadataToTransfers1663094864211 implements MigrationInterface {
  name = 'AddMetadataToTransfers1663094864211';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`metadata\` json NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`metadata\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1685764830323-AddSupportRole.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddSupportRole1685764830323 implements MigrationInterface {
  name = 'AddSupportRole1685764830323';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`apikey\` CHANGE \`role\` \`role\` enum ('user', 'admin', 'super', 'support') NOT NULL DEFAULT 'super'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` CHANGE \`role\` \`role\` enum ('user', 'admin', 'super', 'support') NOT NULL DEFAULT 'user'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`user\` CHANGE \`role\` \`role\` enum ('user', 'admin', 'super') NOT NULL DEFAULT 'user'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`apikey\` CHANGE \`role\` \`role\` enum ('user', 'admin', 'super') NOT NULL DEFAULT 'super'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1646669505161-CreateWebhooksEntity.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateWebhooksEntity1646669505161 implements MigrationInterface {
  name = 'CreateWebhooksEntity1646669505161';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`webhook_endpoint\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`url\` text NOT NULL, \`description\` text NULL, \`enabledEvents\` text NOT NULL, \`secret\` varchar(128) NOT NULL, \`state\` enum ('enabled', 'disabled') NOT NULL DEFAULT 'enabled', \`merchantId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`webhook_endpoint\` ADD CONSTRAINT \`FK_c07d8bc53bfba220721a9f60fa7\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`webhook_endpoint\` DROP FOREIGN KEY \`FK_c07d8bc53bfba220721a9f60fa7\``,
    );
    await queryRunner.query(`DROP TABLE \`webhook_endpoint\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1693346069517-AddProviderCapabilityAndRelationWithAccountStatementJobs.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderCapabilityAndRelationWithAccountStatementJobs1693346069517
  implements MigrationInterface
{
  name =
    'AddProviderCapabilityAndRelationWithAccountStatementJobs1693346069517';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`capability\` varchar(255) NOT NULL DEFAULT 'create_transfer'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD \`accountId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP FOREIGN KEY \`FK_70308a42b6c507cf79d68a7542f\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` CHANGE \`bankAccountId\` \`bankAccountId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD CONSTRAINT \`FK_70308a42b6c507cf79d68a7542f\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD CONSTRAINT \`FK_35ab21ff16989a50faf4efd4e1e\` FOREIGN KEY (\`accountId\`) REFERENCES \`account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP FOREIGN KEY \`FK_35ab21ff16989a50faf4efd4e1e\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP FOREIGN KEY \`FK_70308a42b6c507cf79d68a7542f\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` CHANGE \`bankAccountId\` \`bankAccountId\` int NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD CONSTRAINT \`FK_70308a42b6c507cf79d68a7542f\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP COLUMN \`accountId\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`capability\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1672876989213-AddAccountStatementRelatedTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAccountStatementRelatedTable1672876989213
  implements MigrationInterface
{
  name = 'AddAccountStatementRelatedTable1672876989213';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`account_statement\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`date\` datetime(6) NULL, \`originBankCode\` varchar(64) NULL, \`originBankAccountIdentifier\` varchar(64) NULL, \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`concept\` text NULL, \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER') NOT NULL DEFAULT 'CHL', \`amount\` decimal(18,2) NOT NULL DEFAULT '0.00', \`state\` enum ('pending', 'assigned', 'created', 'authorizing', 'processing', 'completed', 'failed', 'canceled') NULL, \`transactionCode\` varchar(128) NOT NULL, \`destinationHolderId\` varchar(64) NOT NULL, \`destinationName\` varchar(128) NOT NULL, \`destinationAccount\` varchar(128) NOT NULL, \`destinationEmail\` varchar(255) NULL, \`destinationBankCode\` varchar(64) NULL, \`metadata\` json NULL, \`accountStatementJobId\` int NOT NULL, UNIQUE INDEX \`IDX_e9b3ab8e8928d75457b20e1521\` (\`transactionCode\`, \`originBankAccountIdentifier\`, \`originBankCode\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`account_statement_job\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`endDate\` datetime(6) NULL, \`startDate\` datetime(6) NULL, \`state\` enum ('started', 'created', 'finished', 'error') NOT NULL, \`endedAt\` datetime(6) NULL, \`startedAt\` datetime(6) NOT NULL, \`retrievedAt\` datetime(6) NULL, \`totalRetrieved\` int NULL, \`jobId\` text NULL, \`bankAccountId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` ADD CONSTRAINT \`FK_8b28e32405a24bd577bb17eb628\` FOREIGN KEY (\`accountStatementJobId\`) REFERENCES \`account_statement_job\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD CONSTRAINT \`FK_70308a42b6c507cf79d68a7542f\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP FOREIGN KEY \`FK_70308a42b6c507cf79d68a7542f\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` DROP FOREIGN KEY \`FK_8b28e32405a24bd577bb17eb628\``,
    );
    await queryRunner.query(`DROP TABLE \`account_statement_job\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_e9b3ab8e8928d75457b20e1521\` ON \`account_statement\``,
    );
    await queryRunner.query(`DROP TABLE \`account_statement\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1706795242703-HashApiKeyKeys.ts
import { createHash } from 'crypto';
import generalConfig from 'src/config/general.config';
import { MigrationInterface, QueryRunner } from 'typeorm';

export class HashApiKeyKeys1706795242703 implements MigrationInterface {
  name = 'HashApiKeyKeys1706795242703';
  hashKey(apiKey: string) {
    const secret = generalConfig().security.securityKey;
    return createHash('sha256')
      .update(apiKey + secret)
      .digest('hex');
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    const apiKeys = await queryRunner.query(`SELECT * FROM \`apikey\``);

    for (const apiKey of apiKeys) {
      const hashedKey = this.hashKey(apiKey.key);
      await queryRunner.query(
        `UPDATE \`apikey\` SET \`key\` = '${hashedKey}' WHERE \`id\` = ${apiKey.id}`,
      );
    }
  }

  public async down(_queryRunner: QueryRunner): Promise<void> {
    console.log('down not implemented');
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1663094864220-AddDestinationPhoneNumerToPayout.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddDestinationPhoneNumerToPayout1663094864220
  implements MigrationInterface
{
  name = 'AddDestinatinPhoneNumerToPayout1663094864220';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD \`destinationPhone\` varchar(25) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP COLUMN \`destinationPhone\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1664387654137-AddMFAColumnsToUser.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddMFAColumnsToUser1664387654137 implements MigrationInterface {
  name = 'AddMFAColumnsToUser1664387654137';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`user\` ADD \`seed\` text NULL`);
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD \`mfaState\` enum ('disabled', 'enrolled', 'verified') NOT NULL DEFAULT 'disabled'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD \`mfa\` tinyint NOT NULL DEFAULT 0`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`user\` DROP COLUMN \`mfa\``);
    await queryRunner.query(`ALTER TABLE \`user\` DROP COLUMN \`mfaState\``);
    await queryRunner.query(`ALTER TABLE \`user\` DROP COLUMN \`seed\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1661272450267-AddAuthorizationCodeStatusColumn.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAuthorizationCodeStatusColumn1661272450267
  implements MigrationInterface
{
  name = 'AddAuthorizationCodeStatusColumn1661272450267';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` ADD \`state\` enum ('active', 'claimed', 'expired', 'deleted') NOT NULL DEFAULT 'active'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` DROP COLUMN \`state\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1663094864240-AddNewBanksAndFormatExisting.ts
import { randUuid } from '@ngneat/falso';
import { MigrationInterface, QueryRunner } from 'typeorm';

const COLOMBIAN_BANKS = {
  co_banco_nequi: 'Banco Nequi',
  co_movii: 'Movii',
  co_banco_itau: 'Banco Itau Co',
  co_daviplata: 'Daviplata',
  co_dale: 'Dale',
  co_confiar_coop: 'Confiar Coop',
  co_bancolombia: 'Bancolombia',
  co_banco_finandina: 'Banco Finandina',
  co_banco_caja_social: 'Banco Caja Social',
  co_aportes_en_linea: 'Aportes en Línea',
  co_banco_serfinanza: 'Banco Serfinanza',
  co_asopagos: 'Asopagos',
  co_bancoldex: 'Bancoldex',
  co_banco_agrario_de_colombia: 'Banco Agrario de Colombia',
  co_banco_av_villas: 'Banco Av Villas',
  co_bancoomeva: 'Bancoomeva',
  co_banco_bbva: 'Banco Bbva',
  co_bnp_paribas: 'Bnp Paribas',
  co_banco_bcsc: 'Banco Bcsc',
  co_coltefinanciera: 'Coltefinanciera',
  co_banco_citibank: 'Banco Citibank',
  co_compensar: 'Compensar',
  co_banco_coop_central: 'Banco Coop Central',
  co_confiar_cooperativa_financiera: 'Confiar Cooperativa Financiera',
  co_banco_davivienda: 'Banco Davivienda',
  co_coofinep_cooperativa_financiera: 'Coofinep Cooperativa Financiera',
  co_banco_de_bogota: 'Banco de Bogotá',
  co_cooperativa_financiera_cotrafa: 'Cooperativa Financiera Cotrafa',
  co_banco_de_la_republica: 'Banco de la República',
  co_cooperativa_financiera_de_antioquia: 'Cooperativa Financiera de Antioquia',
  co_banco_de_occidente: 'Banco de Occidente',
  co_deceval: 'Deceval',
  co_direccion_del_tesoro_nacional_regalias:
    'Dirección del Tesoro Nacional Regalías',
  co_direccion_del_tesoro_nacional: 'Dirección del Tesoro Nacional',
  co_banco_gnb_sudameris: 'Banco Gnb Sudameris',
  co_enlace_operativo: 'Enlace Operativo',
  co_banco_itau_corpbanca_colombia: 'Banco Itau Corpbanca Colombia',
  co_financiera_juriscoop: 'Financiera Juriscoop',
  co_banco_mundo_mujer: 'Banco Mundo Mujer',
  co_banco_jp_morgan_colombia: 'Banco Jp Morgan Colombia',
  co_banco_pichincha: 'Banco Pichincha',
  co_mibanco: 'Mibanco',
  co_banco_popular: 'Banco Popular',
  co_red_multibanca_colpatria: 'Red Multibanca Colpatria',
  co_banco_credifinanciera: 'Banco Credifinanciera',
  co_simple: 'Simple',
  co_bancon_santander_de_negocios_colombia:
    'Banco Santander de Negocios Colombia',
  co_fogafin: 'Fogarín',
  co_bancamia: 'Bancamia',
  co_jfk_cooperativa_financiera: 'Jfk Cooperativa Financiera',
};

const CHILEAN_BANKS = {
  cl_tapp_caja_los_andes: 'tapp caja los andes',
  cl_mercado_pago: 'mercado pago s.a',
};

export class AddNewBanksAndFormatExisting1663094864240
  implements MigrationInterface
{
  name = 'AddNewBanksAndFormatExisting1663094864240';

  private async deleteUnformattedColombianBanks(queryRunner: QueryRunner) {
    await queryRunner.query(`DELETE FROM bank WHERE code LIKE 'co_%'`);
  }

  private async addNewChileanBanks(queryRunner: QueryRunner) {
    for (const [bankCode, bankName] of Object.entries(CHILEAN_BANKS)) {
      const uuid = randUuid();
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  private async addFormattedColombianBanks(queryRunner: QueryRunner) {
    for (const [bankCode, bankName] of Object.entries(COLOMBIAN_BANKS)) {
      const uuid = randUuid();
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  public async addUnformattedColombianBanks(queryRunner: QueryRunner) {
    const colimbianBanks = {
      nequi: 'banco_nequi',
      movii: 'movii',
      itauproduccion: 'banco_itau',
      daviviendaprd: 'davivienda',
      daviplataprd: 'daviplata',
      dale: 'dale',
      confiarcoopprd: 'confiar_coop',
      bancoserfinanza: 'banco_serfinanza',
      bancolombia: 'bancolombia',
      bancofinandina: 'banco_finandina',
      bancodebogotasa: 'banco_de_bogota',
      bancocoopcentral: 'banco_coopcentral',
      bancocajasocial: 'banco_caja_social',
      bancoavvillas: 'banco_av_villas',
    };

    for (const [bankCode, bankName] of Object.entries(colimbianBanks)) {
      const uuid = randUuid();
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }

  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.deleteUnformattedColombianBanks(queryRunner);

    await this.addNewChileanBanks(queryRunner);

    await this.addFormattedColombianBanks(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const createdBanks = [
      ...Object.keys(CHILEAN_BANKS),
      ...Object.keys(COLOMBIAN_BANKS),
    ];

    await queryRunner.query(`DELETE FROM bank where code IN (?)`, [
      createdBanks,
    ]);

    await this.addUnformattedColombianBanks(queryRunner);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1660254865457-AddRolesApiKeyEntity.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddRolesApiKeyEntity1660254865457 implements MigrationInterface {
  name = 'AddRolesApiKeyEntity1660254865457';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`apikey\` ADD \`role\` enum ('user', 'admin', 'super') NOT NULL DEFAULT 'super'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`apikey\` DROP COLUMN \`role\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1676488041844-AddVersionColumnToTransferAndPayout.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddVersionColumnToTransferAndPayout1676488041844
  implements MigrationInterface
{
  name = 'AddVersionColumnToTransferAndPayout1676488041844';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD \`version\` enum ('v1', 'v2') NULL DEFAULT 'v1'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`version\` enum ('v1', 'v2') NULL DEFAULT 'v1'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`transfer\` DROP COLUMN \`version\``);
    await queryRunner.query(`ALTER TABLE \`payout\` DROP COLUMN \`version\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1676489159307-AddErroCodeAndMessageToPayout.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddErroCodeAndMessageToPayout1676489159307
  implements MigrationInterface
{
  name = 'AddErroCodeAndMessageToPayout1676489159307';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD \`errorCode\` varchar(255) NULL`,
    );
    await queryRunner.query(`ALTER TABLE \`payout\` ADD \`message\` text NULL`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`payout\` DROP COLUMN \`message\``);
    await queryRunner.query(`ALTER TABLE \`payout\` DROP COLUMN \`errorCode\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1702403432542-AddPatternColumnToTransferError.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddPatternColumnToTransferError1702403432542
  implements MigrationInterface
{
  name = 'AddPatternColumnToTransferError1702403432542';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD \`pattern\` text NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP COLUMN \`pattern\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1685391106869-AddTransferErrorTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddTransferErrorTable1685391106869 implements MigrationInterface {
  name = 'AddTransferErrorTable1685391106869';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`transfer_error\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`errorRaw\` text NOT NULL, \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009') NULL, \`errorType\` enum ('UNKNOWN_ERROR', 'PROVIDER_INTERNAL_FAILURE', 'PROVIDER_INSUFFICIENT_FUNDS', 'RECIPIENT_FIRST_TRANSFER', 'RECIPIENT_INVALID_ACCOUNT', 'RECIPIENT_DISABLED_ACCOUNT', 'DESTINATION_BANK_IN_MAINTENANCE', 'DESTINATION_BANK_NOT_AVAILABLE', 'DESTINATION_BANK_TIMEOUT', 'RECIPIENT_ACCOUNT_OVER_LIMIT') NULL, \`description\` varchar(128) NULL, \`issuer\` varchar(128) NULL, FULLTEXT INDEX \`IDX_ERROR_RAW\` (\`errorRaw\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_ERROR_RAW\` ON \`transfer_error\``,
    );
    await queryRunner.query(`DROP TABLE \`transfer_error\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1663094864219-AddDestinatinPhoneNumerToTransfer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddDestinatinPhoneNumerToTransfer1663094864219
  implements MigrationInterface
{
  name = 'AddDestinatinPhoneNumerToTransfer1663094864219';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`destinationPhone\` text NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`destinationPhone\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1675373408050-AddProviderToTransfer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderToTransfer1675373408050 implements MigrationInterface {
  name = 'AddProviderToTransfer1675373408050';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`providerId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_9c14d10032dd17bd9c0934b3374\` FOREIGN KEY (\`providerId\`) REFERENCES \`provider\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_9c14d10032dd17bd9c0934b3374\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`providerId\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1690896992225-ChangeUsernameToEmail.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class ChangeUsernameToEmail1690896992225 implements MigrationInterface {
  name = 'ChangeUsernameToEmail1690896992225';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`user\` DROP FOREIGN KEY \`FK_48a28cfd87e34f3df960bb374ba\``,
    );

    await queryRunner.query(
      `ALTER TABLE \`user\` DROP INDEX \`IDX_0425106f4a9ec75293c3d01b36\``,
    );

    await queryRunner.query(
      `ALTER TABLE \`user\` CHANGE \`username\` \`email\` varchar(128) NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD \`name\` varchar(128) NOT NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_43e32cc306a0e09415fee4688a\` ON \`user\` (\`merchantId\`, \`email\`)`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_43e32cc306a0e09415fee4688a\` ON \`user\``,
    );
    await queryRunner.query(`ALTER TABLE \`user\` DROP COLUMN \`name\``);
    await queryRunner.query(
      `ALTER TABLE \`user\` CHANGE \`email\` \`username\` varchar(128) NOT NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_0425106f4a9ec75293c3d01b36\` ON \`user\` (\`merchantId\`, \`username\`)`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD CONSTRAINT \`FK_48a28cfd87e34f3df960bb374ba\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1680544115817-RemoveProviderCapabilitiesColumn.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RemoveProviderCapabilitiesColumn1680544115817
  implements MigrationInterface
{
  name = 'RemoveProviderCapabilitiesColumn1680544115817';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`capabilities\``,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`capabilities\` text NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1697208312658-AlterStateMerchantLimit.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AlterStateMerchantLimit1697208312658
  implements MigrationInterface
{
  name = 'AlterStateMerchantLimit1697208312658';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` CHANGE \`state\` \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'inactive'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` CHANGE \`state\` \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1657057864344-RenamePinpassToDigipass.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RenamePinpassToDigipass1657057864344
  implements MigrationInterface
{
  name = 'RenamePinpassToDigipass1657057864344';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` CHANGE \`methodType\` \`methodType\` enum ('security_card', 'sms', 'digipass') NOT NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\` (\`identifier\`, \`methodType\`)`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` CHANGE \`methodType\` \`methodType\` enum ('security_card', 'sms', 'pinpass') NOT NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\` (\`identifier\`, \`methodType\`)`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656535160835-DropSmsCodeTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class DropSmsCodeTable1656535160835 implements MigrationInterface {
  name = 'DropSmsCodeTable1656535160835';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE \`sms_code\``);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`sms_code\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`phoneNumber\` varchar(32) NOT NULL, \`messageId\` varchar(128) NULL, \`message\` text NULL, \`code\` text NULL, \`receivedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1678400069041-AddHolderIdToAccountTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddHolderIdToAccountTable1678400069041
  implements MigrationInterface
{
  name = 'AddHolderIdToAccountTable1678400069041';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account\` ADD \`holderId\` varchar(64) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`account\` DROP COLUMN \`holderId\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1646372844951-AddTransferRulesToMasterAccounts.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddTransferRulesToMasterAccounts1646372844951
  implements MigrationInterface
{
  name = 'AddTransferRulesToMasterAccounts1646372844951';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`master_account\` ADD \`transferRules\` json NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` DROP FOREIGN KEY \`FK_fdebdfd23aff93692acf34d0edb\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` CHANGE \`bankAccountId\` \`bankAccountId\` int NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`state\` \`state\` enum ('pending', 'processing', 'completed', 'cancelled', 'failed') NOT NULL DEFAULT 'pending'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` ADD CONSTRAINT \`FK_fdebdfd23aff93692acf34d0edb\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`master_account\` DROP FOREIGN KEY \`FK_fdebdfd23aff93692acf34d0edb\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`state\` \`state\` enum ('created', 'processing', 'completed', 'cancelled', 'failed') NOT NULL DEFAULT 'created'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` CHANGE \`bankAccountId\` \`bankAccountId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` ADD CONSTRAINT \`FK_fdebdfd23aff93692acf34d0edb\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` DROP COLUMN \`transferRules\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656779745473-MakeTransferDestinationEmailOptional.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class MakeTransferDestinationEmailOptional1656779745473
  implements MigrationInterface
{
  name = 'MakeTransferDestinationEmailOptional1656779745473';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`destinationEmail\` \`destinationEmail\` varchar(255) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`destinationEmail\` \`destinationEmail\` varchar(255) NOT NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1659463289495-AddFullTextIndexToPayouts.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddFullTextIndexToPayouts1659463289495
  implements MigrationInterface
{
  name = 'AddFullTextIndexToPayouts1659463289495';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE FULLTEXT INDEX \`IDX_6211d2b676e2476845c341ab24\` ON \`payout\` (\`destinationEmail\`)`,
    );
    await queryRunner.query(
      `CREATE FULLTEXT INDEX \`IDX_5409e7f68bba4792565b957394\` ON \`payout\` (\`destinationName\`)`,
    );
    await queryRunner.query(
      `CREATE FULLTEXT INDEX \`IDX_1008c15ba23ffe3ec239920a98\` ON \`payout\` (\`destinationAccount\`)`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_1008c15ba23ffe3ec239920a98\` ON \`payout\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_5409e7f68bba4792565b957394\` ON \`payout\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_6211d2b676e2476845c341ab24\` ON \`payout\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1684168880507-EnableSoftDeleteOnProviders.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class EnableSoftDeleteOnProviders1684168880507
  implements MigrationInterface
{
  name = 'EnableSoftDeleteOnProviders1684168880507';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`deletedAt\` datetime(6) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`deletedAt\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1643299228963-InitialMigration.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class InitialMigration1643299228963 implements MigrationInterface {
  name = 'InitialMigration1643299228963';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`transfer\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed') NOT NULL DEFAULT 'pending', \`amount\` decimal(18,2) NOT NULL DEFAULT '0.00', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`mode\` enum ('single', 'bulk') NOT NULL DEFAULT 'single', \`concept\` text NOT NULL, \`trackingCode\` varchar(128) NOT NULL, \`destinationEmail\` varchar(255) NOT NULL, \`destinationName\` varchar(128) NOT NULL, \`destinationHolderId\` varchar(64) NOT NULL, \`destinationAccount\` varchar(128) NOT NULL, \`destinationBankCode\` varchar(64) NOT NULL, \`merchantId\` int NOT NULL, \`payoutId\` int NULL, \`originBankCode\` varchar(64) NULL, \`originBankAccessId\` int NULL, \`originBankAccountId\` int NULL, \`message\` text NULL, \`startedAt\` datetime(6) NULL, \`finishedAt\` datetime(6) NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`master_account\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'inactive', \`bankAccountId\` int NULL, UNIQUE INDEX \`REL_fdebdfd23aff93692acf34d0ed\` (\`bankAccountId\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`bank_account\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`identifier\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`accountType\` enum ('current', 'savings') NOT NULL DEFAULT 'current', \`bankCode\` varchar(64) NOT NULL, \`merchantId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`user\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`username\` varchar(128) NOT NULL, \`password\` varchar(256) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`role\` enum ('user', 'admin', 'super') NOT NULL DEFAULT 'user', \`merchantId\` int NOT NULL, UNIQUE INDEX \`IDX_0425106f4a9ec75293c3d01b36\` (\`merchantId\`, \`username\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`deposit\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('created', 'processing', 'accepted', 'rejected', 'cancelled') NOT NULL DEFAULT 'created', \`amount\` decimal(18,2) NOT NULL DEFAULT '0.00', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`concept\` text NOT NULL, \`trackingCode\` varchar(128) NOT NULL, \`walletId\` int NOT NULL, \`merchantId\` int NOT NULL, UNIQUE INDEX \`IDX_d729bbeebc1f6c38c84daaec35\` (\`merchantId\`, \`trackingCode\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`wallet\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`balance\` decimal(18,2) NOT NULL DEFAULT '0.00', \`reservedBalance\` decimal(18,2) NOT NULL DEFAULT '0.00', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`merchantId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`merchant\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`identifier\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', UNIQUE INDEX \`IDX_508dc3971f301076f7ee0b6c37\` (\`identifier\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`payout\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('created', 'processing', 'completed', 'cancelled', 'failed') NOT NULL DEFAULT 'created', \`amount\` decimal(18,2) NOT NULL DEFAULT '0.00', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`concept\` text NOT NULL, \`trackingCode\` varchar(128) NOT NULL, \`destinationEmail\` varchar(255) NOT NULL, \`destinationName\` varchar(128) NOT NULL, \`destinationHolderId\` varchar(64) NOT NULL, \`destinationAccount\` varchar(128) NOT NULL, \`destinationBankCode\` varchar(64) NOT NULL, \`walletId\` int NOT NULL, \`merchantId\` int NOT NULL, UNIQUE INDEX \`IDX_1d47d75ed2e6232c2c2181cfe0\` (\`merchantId\`, \`trackingCode\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`bank\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`name\` varchar(128) NOT NULL, \`code\` varchar(32) NOT NULL, UNIQUE INDEX \`IDX_efdd3f589f04cd21d79136de1a\` (\`code\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`transfer_method\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`signingKeys\` text NULL, \`methodType\` enum ('security_card', 'sms', 'pinpass') NOT NULL, \`merchantId\` int NOT NULL, \`bankAccessId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`bank_access\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`accessType\` enum ('personal', 'business') NOT NULL DEFAULT 'business', \`credentials\` text NULL, \`merchantId\` int NOT NULL, \`bankCode\` varchar(64) NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`sms_code\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`phoneNumber\` varchar(32) NOT NULL, \`messageId\` varchar(128) NULL, \`message\` text NULL, \`code\` text NULL, \`receivedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `CREATE TABLE \`bank_access_accounts\` (\`bankAccessId\` int NOT NULL, \`bankAccountId\` int NOT NULL, INDEX \`IDX_80d5197eaed21b09d2f35a4f23\` (\`bankAccessId\`), INDEX \`IDX_251a2a8820ed2f1bdb4dc30d12\` (\`bankAccountId\`), PRIMARY KEY (\`bankAccessId\`, \`bankAccountId\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_0dea23d5a30db31a05415facb2e\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_328b779f7669629bb40ff7ce60b\` FOREIGN KEY (\`originBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_57f43e896a2018beff9bea61f02\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_93e997f4ed29ef8cb239a155566\` FOREIGN KEY (\`payoutId\`) REFERENCES \`payout\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_6f3d65c1f51b2b68c067deeb3cd\` FOREIGN KEY (\`originBankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD CONSTRAINT \`FK_7119b581c01e9f3b86e53aa1ae0\` FOREIGN KEY (\`originBankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` ADD CONSTRAINT \`FK_fdebdfd23aff93692acf34d0edb\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` ADD CONSTRAINT \`FK_f5e70828e96027413bcc199a6ea\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` ADD CONSTRAINT \`FK_18126630bb390c2eecd2e08add3\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD CONSTRAINT \`FK_48a28cfd87e34f3df960bb374ba\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` ADD CONSTRAINT \`FK_414a92c88a75322a479d3c0a5f1\` FOREIGN KEY (\`walletId\`) REFERENCES \`wallet\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` ADD CONSTRAINT \`FK_bfc1ea3ae2a242d398220a0b000\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`wallet\` ADD CONSTRAINT \`FK_3fb601595d9285ac47135c134df\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_1baf589ec5263f8ca58b4b939b6\` FOREIGN KEY (\`destinationBankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_4f3efd7909d1d397f98d6d93be8\` FOREIGN KEY (\`walletId\`) REFERENCES \`wallet\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_7748b57872c21f0b3fc7d7ebba1\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` ADD CONSTRAINT \`FK_2609acbcda5200029ab8423adc8\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` ADD CONSTRAINT \`FK_eaf04eed3013451e2eef6ed8044\` FOREIGN KEY (\`bankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD CONSTRAINT \`FK_aa5f58f0691c95ba5594bca01df\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD CONSTRAINT \`FK_ef032e23c88ec38598f43573129\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access_accounts\` ADD CONSTRAINT \`FK_80d5197eaed21b09d2f35a4f234\` FOREIGN KEY (\`bankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE CASCADE ON UPDATE CASCADE`,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access_accounts\` ADD CONSTRAINT \`FK_251a2a8820ed2f1bdb4dc30d126\` FOREIGN KEY (\`bankAccountId\`) REFERENCES \`bank_account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_access_accounts\` DROP FOREIGN KEY \`FK_251a2a8820ed2f1bdb4dc30d126\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access_accounts\` DROP FOREIGN KEY \`FK_80d5197eaed21b09d2f35a4f234\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP FOREIGN KEY \`FK_ef032e23c88ec38598f43573129\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP FOREIGN KEY \`FK_aa5f58f0691c95ba5594bca01df\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` DROP FOREIGN KEY \`FK_eaf04eed3013451e2eef6ed8044\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` DROP FOREIGN KEY \`FK_2609acbcda5200029ab8423adc8\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_7748b57872c21f0b3fc7d7ebba1\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_4f3efd7909d1d397f98d6d93be8\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_1baf589ec5263f8ca58b4b939b6\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`wallet\` DROP FOREIGN KEY \`FK_3fb601595d9285ac47135c134df\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` DROP FOREIGN KEY \`FK_bfc1ea3ae2a242d398220a0b000\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` DROP FOREIGN KEY \`FK_414a92c88a75322a479d3c0a5f1\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` DROP FOREIGN KEY \`FK_48a28cfd87e34f3df960bb374ba\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` DROP FOREIGN KEY \`FK_18126630bb390c2eecd2e08add3\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` DROP FOREIGN KEY \`FK_f5e70828e96027413bcc199a6ea\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`master_account\` DROP FOREIGN KEY \`FK_fdebdfd23aff93692acf34d0edb\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_7119b581c01e9f3b86e53aa1ae0\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_6f3d65c1f51b2b68c067deeb3cd\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_93e997f4ed29ef8cb239a155566\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_57f43e896a2018beff9bea61f02\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_328b779f7669629bb40ff7ce60b\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP FOREIGN KEY \`FK_0dea23d5a30db31a05415facb2e\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_251a2a8820ed2f1bdb4dc30d12\` ON \`bank_access_accounts\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_80d5197eaed21b09d2f35a4f23\` ON \`bank_access_accounts\``,
    );
    await queryRunner.query(`DROP TABLE \`bank_access_accounts\``);
    await queryRunner.query(`DROP TABLE \`sms_code\``);
    await queryRunner.query(`DROP TABLE \`bank_access\``);
    await queryRunner.query(`DROP TABLE \`transfer_method\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_efdd3f589f04cd21d79136de1a\` ON \`bank\``,
    );
    await queryRunner.query(`DROP TABLE \`bank\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_1d47d75ed2e6232c2c2181cfe0\` ON \`payout\``,
    );
    await queryRunner.query(`DROP TABLE \`payout\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_508dc3971f301076f7ee0b6c37\` ON \`merchant\``,
    );
    await queryRunner.query(`DROP TABLE \`merchant\``);
    await queryRunner.query(`DROP TABLE \`wallet\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_d729bbeebc1f6c38c84daaec35\` ON \`deposit\``,
    );
    await queryRunner.query(`DROP TABLE \`deposit\``);
    await queryRunner.query(
      `DROP INDEX \`IDX_0425106f4a9ec75293c3d01b36\` ON \`user\``,
    );
    await queryRunner.query(`DROP TABLE \`user\``);
    await queryRunner.query(`DROP TABLE \`bank_account\``);
    await queryRunner.query(
      `DROP INDEX \`REL_fdebdfd23aff93692acf34d0ed\` ON \`master_account\``,
    );
    await queryRunner.query(`DROP TABLE \`master_account\``);
    await queryRunner.query(`DROP TABLE \`transfer\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656513118436-AddCreatedStatusToTransfers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddCreatedStatusToTransfers1656513118436
  implements MigrationInterface
{
  name = 'AddCreatedStatusToTransfers1656513118436';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'created', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1701891454566-ChangeDefaultEntityVersion.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class ChangeDefaultEntityVersion1701891454566
  implements MigrationInterface
{
  name = 'ChangeDefaultEntityVersion1701891454566';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`version\` \`version\` enum ('v1', 'v2') NOT NULL DEFAULT 'v2'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`version\` \`version\` enum ('v1', 'v2') NOT NULL DEFAULT 'v2'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`version\` \`version\` enum ('v1', 'v2') NULL DEFAULT 'v1'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`version\` \`version\` enum ('v1', 'v2') NULL DEFAULT 'v1'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1708613571499-AddProviderTypeToTransferErrors.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderTypeToTransferErrors1708613571499
  implements MigrationInterface
{
  name = 'AddProviderTypeToTransferErrors1708613571499';

  public async up(queryRunner: QueryRunner): Promise<void> {
    const errorsWithProvider = await queryRunner.query(
      `SELECT transfer_error.id, providerType FROM \`transfer_error\` JOIN \`provider\` ON transfer_error.providerId = provider.id WHERE transfer_error.providerId IS NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP FOREIGN KEY \`FK_c59051c637e96fe366a8793380e\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`providerId\` \`providerType\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP COLUMN \`providerType\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD \`providerType\` enum ('scraperCG', 'scraperPW', 'minka', 'liquido', 'shinkansen', 'thomas') NULL`,
    );

    for (const error of errorsWithProvider) {
      await queryRunner.query(
        `UPDATE \`transfer_error\` SET providerType = '${error.providerType}' WHERE id = ${error.id}`,
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP COLUMN \`providerType\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD \`providerType\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`providerType\` \`providerId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD CONSTRAINT \`FK_c59051c637e96fe366a8793380e\` FOREIGN KEY (\`providerId\`) REFERENCES \`provider\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1679497269021-AddExternalIdColumnToTransfers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddExternalIdColumnToTransfers1679497269021
  implements MigrationInterface
{
  name = 'AddExternalIdColumnToTransfers1679497269021';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`externalId\` varchar(128) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`externalId\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1697488577577-AddMoreDataToPayoutAction.ts
import { Logger } from '@nestjs/common';
import { randUuid } from '@ngneat/falso';
import { MigrationInterface, QueryRunner } from 'typeorm';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';

const logger = new Logger('AddMoreDataToPayoutActionLogger');

export class AddNewTransferErrorCode1697488577576
  implements MigrationInterface
{
  name = 'AddMoreDataToPayoutAction1697488577577';
  errorCode = TransferErrorCode.MERCHANT_LIMIT_EXCEED;
  uuid = randUuid();

  private async buildPayoutActionData(queryRunner: QueryRunner): Promise<void> {
    try {
      await queryRunner.query(
        `INSERT INTO payout_action(uuid,errorCode,action) VALUES(?,?,?);`,
        [this.uuid, this.errorCode, 'AUTO_CANCEL'],
      );
    } catch (e) {
      logger.log(e);
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.buildPayoutActionData(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`TRUNCATE TABLE payout_action;`);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1680180602159-AddMexicanBanks.ts
import { randUuid } from '@ngneat/falso';
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddMexicanBanks1680180602159 implements MigrationInterface {
  name = 'AddMexicanBanks1680180602159';
  private async makeMexicanBanks(queryRunner: QueryRunner): Promise<void> {
    const mexicanBanks = [
      { code: 'mx_banco_bbva', name: 'Banco BBVA Mexico' },
      { code: 'mx_banco_banorte', name: 'Banco Banorte' },
      { code: 'mx_banco_banamex', name: 'Banco Banamex' },
      { code: 'mx_banco_santander', name: 'Banco Santander Mexico' },
      { code: 'mx_banco_scotiabank', name: 'Banco Scotiabank Mexico' },
      { code: 'mx_banco_hsbc', name: 'HSBC Mexico' },
      { code: 'mx_banco_inbursa', name: 'Banco Inbursa' },
      { code: 'mx_banco_bajio', name: 'Banco del Bajio' },
      { code: 'mx_banco_afirme', name: 'Banco Afirme' },
      { code: 'mx_banco_azteca', name: 'Banco Azteca' },
      { code: 'mx_banco_abc_capital', name: 'Banco ABC Capital' },
      { code: 'mx_banca_mifel', name: 'Banca Mifel' },
      { code: 'mx_banco_actinver', name: 'Banco Actinver' },
      { code: 'mx_banco_autofin', name: 'Banco Autofin' },
      { code: 'mx_banco_bancrea', name: 'Banco Bancrea' },
      { code: 'mx_banco_base', name: 'Banco Base' },
      { code: 'mx_banco_credit_suisse', name: 'Banco Credit Suisse Mexico' },
      { code: 'mx_banco_finterra', name: 'Banco Finterra' },
      { code: 'mx_banco_forjadores', name: 'Banco Forjadores' },
      { code: 'mx_banco_invex', name: 'Banco Invex' },
      { code: 'mx_banco_monex', name: 'Banco Monex' },
      { code: 'mx_banco_multiva', name: 'Banco Multiva' },
      { code: 'mx_banco_pagatodo', name: 'Banco PagaTodo' },
      { code: 'mx_banco_banregio', name: 'Banco Banregio' },
      { code: 'mx_banco_sabadell', name: 'Banco Sabadell' },
      { code: 'mx_banco_vepormas', name: 'Banco Ve Por Mas' },
      { code: 'mx_banco_bancoppel', name: 'Banca Bancoppel' },
      { code: 'mx_banco_bankaool', name: 'Banco Bankaool' },
      { code: 'mx_banco_bansi', name: 'Banco Bansi' },
      { code: 'mx_banco_cibanco', name: 'CI Banco' },
      { code: 'mx_banco_consubanco', name: 'Banca Consubanco' },
      { code: 'mx_banco_intercam', name: 'Intercam Banco' },
    ];

    for (const bank of mexicanBanks) {
      const uuid = randUuid();
      const { name, code } = bank;
      try {
        await queryRunner.query(
          'INSERT INTO bank(uuid,name,code) VALUES(?,?,?);',
          [uuid, name, code],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.makeMexicanBanks(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const mexicanBanks = await queryRunner.query(
      `SELECT * FROM bank where code LIKE 'mx_%';`,
    );
    for (const bank of mexicanBanks) {
      try {
        await queryRunner.query('DELETE FROM bank WHERE id = ?', bank.id);
      } catch (error) {
        console.log(error);
      }
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1669641539298-AddMobileAppTransferMethodType.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddMobileAppTransferMethodType1669641539298
  implements MigrationInterface
{
  name = 'AddMobileAppTransferMethodType1669641539298';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` MODIFY \`destinationPhone\` text NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` DROP FOREIGN KEY \`FK_8dc683366ef821c8ee3ea28dfa0\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`transferMethodId\` \`transferMethodId\` int NOT NULL`,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` CHANGE \`methodType\` \`methodType\` enum ('security_card', 'sms', 'digipass', 'mobile_app') NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` MODIFY \`metadata\` text NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\` (\`identifier\`, \`methodType\`)`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` ADD CONSTRAINT \`FK_8dc683366ef821c8ee3ea28dfa0\` FOREIGN KEY (\`transferMethodId\`) REFERENCES \`transfer_method\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` DROP FOREIGN KEY \`FK_8dc683366ef821c8ee3ea28dfa0\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` MODIFY \`metadata\` json NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` CHANGE \`methodType\` \`methodType\` enum ('security_card', 'sms', 'digipass') NOT NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\` (\`identifier\`, \`methodType\`)`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` CHANGE \`transferMethodId\` \`transferMethodId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` ADD CONSTRAINT \`FK_8dc683366ef821c8ee3ea28dfa0\` FOREIGN KEY (\`transferMethodId\`) REFERENCES \`transfer_method\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` MODIFY \`destinationPhone\` varchar(25) NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656535160832-CreateAuthorizationCodeTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateAuthorizationCodeTable1656535160832
  implements MigrationInterface
{
  name = 'CreateAuthorizationCodeTable1656535160832';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`authorization_code\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`code\` text NULL, \`expiresAt\` datetime(6) NOT NULL, \`transferMethodId\` int NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` ADD \`identifier\` varchar(128) NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` CHANGE \`state\` \`state\` enum ('created', 'processing', 'accepted', 'rejected', 'canceled') NOT NULL DEFAULT 'created'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` ADD CONSTRAINT \`FK_8dc683366ef821c8ee3ea28dfa0\` FOREIGN KEY (\`transferMethodId\`) REFERENCES \`transfer_method\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`authorization_code\` DROP FOREIGN KEY \`FK_8dc683366ef821c8ee3ea28dfa0\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` CHANGE \`state\` \`state\` enum ('created', 'processing', 'accepted', 'rejected', 'cancelled') NOT NULL DEFAULT 'created'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_method\` DROP COLUMN \`identifier\``,
    );
    await queryRunner.query(`DROP TABLE \`authorization_code\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656513284791-AddCapabilitiesToBankAccesses.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddCapabilitiesToBankAccesses1656513284791
  implements MigrationInterface
{
  name = 'AddCapabilitiesToBankAccesses1656513284791';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD \`capabilities\` text NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP COLUMN \`capabilities\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1659461315275-AddApikey.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddApikey1659461315275 implements MigrationInterface {
  name = 'AddApikey1659461315275';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`apikey\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`key\` varchar(64) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`merchantId\` int NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`apikey\` ADD CONSTRAINT \`FK_e5b23100ef1045725f5fb97e3b1\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`apikey\` DROP FOREIGN KEY \`FK_e5b23100ef1045725f5fb97e3b1\``,
    );
    await queryRunner.query(`DROP TABLE \`apikey\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1678210002958-AddProviderColumnsTransferJobEntity.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderColumnsTransferJobEntity1678210002958
  implements MigrationInterface
{
  name = 'AddProviderColumnsTransferJobEntity1678210002958';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` ADD \`providerId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` DROP FOREIGN KEY \`FK_bf14426e62d77186f61702851b5\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` CHANGE \`bankAccessId\` \`bankAccessId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` ADD CONSTRAINT \`FK_bf14426e62d77186f61702851b5\` FOREIGN KEY (\`bankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` ADD CONSTRAINT \`FK_d646ec5164e6c8c7176a132c676\` FOREIGN KEY (\`providerId\`) REFERENCES \`provider\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` DROP FOREIGN KEY \`FK_d646ec5164e6c8c7176a132c676\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` DROP FOREIGN KEY \`FK_bf14426e62d77186f61702851b5\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` CHANGE \`bankAccessId\` \`bankAccessId\` int NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` ADD CONSTRAINT \`FK_bf14426e62d77186f61702851b5\` FOREIGN KEY (\`bankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` DROP COLUMN \`providerId\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1655481299496-AddCanceledStateToPayout.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddCanceledStateToPayout1655481299496
  implements MigrationInterface
{
  name = 'AddCanceledStateToPayout1655481299496';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`state\` \`state\` enum ('pending', 'processing', 'completed', 'canceled', 'failed') NOT NULL DEFAULT 'pending'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`state\` \`state\` enum ('pending', 'processing', 'completed', 'cancelled', 'failed') NOT NULL DEFAULT 'pending'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1685391106879-AddDataToTransferErrorTable.ts
import { Logger } from '@nestjs/common';
import { MigrationInterface, QueryRunner } from 'typeorm';
const logger = new Logger('TransferErrorCodeDataMigrationLogger');
export class AddDataToTransferErrorTable1685391106879
  implements MigrationInterface
{
  name = 'AddDataToTransferErrorTable1685391106879';
  private async buildErrorData(queryRunner: QueryRunner): Promise<void> {
    const errorData = [
      {
        uuid: 'd06a786a-0372-46aa-babb-34e0332b2395',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que no estar disponible',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'bf490c92-8eab-4263-9b0e-cc542d8ea25e',
        errorRaw:
          'estimado cliente, el banco del destinatario se encuentra temporalmente inhabilitado para recibir transferencias. (cod. cca7037).',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: '91bd8a6a-4e7d-4795-9490-66b73dc98758',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que servicio no disponible por ifr',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'b012e00f-1bd1-46f9-a3bc-d5e11d0ac808',
        errorRaw:
          'no es posible realizar esta transaccion, aun no han pasado 24 hrs desde tu primera transferencia hacia una cuenta corriente de scotiabank azul-ex bbva.',
        errorType: 'RECIPIENT_FIRST_TRANSFER',
        errorCode: 'ERROR_0003',
      },
      {
        uuid: '0e5702cb-8298-4641-aed4-4cc6eca9a742',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que tiempo de respuesta excedido',
        errorType: 'DESTINATION_BANK_TIMEOUT',
        errorCode: 'ERROR_0008',
      },
      {
        uuid: 'b5d89c9b-5e31-4551-8a47-dabe8c30da9a',
        errorRaw:
          'la clave dinamica ingresada no corresponde. por favor intentelo nuevamente. recuerde que por motivos de seguridad, al tercer ingreso erroneo su clave dinamica se bloqueara.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'a0ad7732-4968-453f-b51c-e9bfc2ced2b9',
        errorRaw:
          'se ha presentado una intermitencia en el envio de su transferencia. para confirmar que la operacion fue realizada, le agradeceremos consultar su cartola de cuenta corriente',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '8c8fdb44-6188-4036-9508-883fabd8dd6b',
        errorRaw:
          'estimado cliente, el banco destino informa que el rut y/o cuenta de tu destinatario no son validos. (cca7046).',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '648a56d4-c246-4b2f-b821-ee154865bc09',
        errorRaw:
          'debe seleccionar un banco. ha ocurrido un error, reingrese los campos. ha ocurrido un error',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'cd944559-5406-43a2-813d-59daaea5e4fa',
        errorRaw:
          'estimado cliente, se ha producido un error al realizar tu transferencia (firma_rechazada).',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '694c574c-e8e9-4238-8778-0d844d506233',
        errorRaw: 'servicio no disponible en este momento',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'fe01e34a-82d7-44b0-a384-db3ae13c4db2',
        errorRaw:
          'estimado cliente, el banco del destinatario esta temporalmente inhabilitado para recibir transferencias. (cca7091).',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'bb78bfd0-27b5-4ef5-9126-611bfc53d3ed',
        errorRaw: 'banco destino no disponible',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: '1ecef3ce-adf0-42b6-8d71-aa4e401ce68f',
        errorRaw: 'relacion rut/cuenta corriente invalida',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '24517ec3-7a86-4cca-be7a-f40e94ba653e',
        errorRaw:
          'no es posible realizar esta transaccion, aun no han pasado 24 hrs desde tu primera transferencia hacia una cuenta corriente de scotiabank chile.',
        errorType: 'RECIPIENT_FIRST_TRANSFER',
        errorCode: 'ERROR_0003',
      },
      {
        uuid: 'cbf72e6e-4b18-44b1-87d3-7e32a9e40cac',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que no disponible por detencion programada',
        errorType: 'DESTINATION_BANK_IN_MAINTENANCE',
        errorCode: 'ERROR_0006',
      },
      {
        uuid: 'e460f7a3-bc72-4375-8f40-745b2165b7b2',
        errorRaw:
          'estimado cliente, el banco del destinatario esta temporalmente inhabilitado para recibir transferencias. (cca7063).',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'b6ad2e2d-2360-494f-9e8a-b3d20a02214e',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que la cuenta no pertenece al rut ingresado',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'f8e2ad51-f51f-4d9c-898b-f48795c53bd1',
        errorRaw: 'servicio no disponible por ifr',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'c72a7265-c39d-4f96-a496-78ddd5322dc1',
        errorRaw: 'recuerda ingresar un monto',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '2f178d2a-852d-4b9d-a785-948f9458fdf5',
        errorRaw:
          'estimado cliente, se ha producido un error al realizar tu transferencia (transcca7053).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'e2620ef5-adf3-453e-8dfb-409bd2b603c1',
        errorRaw:
          'estimado cliente, la cuenta del destinatario ingresada es invalida. (cod. cca7041).',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '6b144ab7-e861-4318-83ea-23990be0351d',
        errorRaw: 'cuenta destino incorrecto',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'f2118e16-2590-452f-bf7d-937770c75f50',
        errorRaw:
          'estimado cliente, el banco del destinatario se encuentra temporalmente inhabilitado para recibir transferencias. (cod. cca7038).',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: 'c18bd395-781b-4cf0-8f13-332b94447f8e',
        errorRaw: 'banco sin servicio por mantencion programada',
        errorType: 'DESTINATION_BANK_IN_MAINTENANCE',
        errorCode: 'ERROR_0006',
      },
      {
        uuid: 'c193e248-11be-4540-b309-a026e9959cb1',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que que la cuenta no permite abonos',
        errorType: 'RECIPIENT_DISABLED_ACCOUNT',
        errorCode: 'ERROR_0005',
      },
      {
        uuid: '9fe99112-13cb-4ec2-90e0-cff4cc8773b8',
        errorRaw:
          'estimado cliente, hemos tenido un inconveniente al procesar la transaccion (cod. skt0999).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'd451c2d4-958d-4ca3-b5ba-8ac29eaf9012',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que la cuenta del beneficiario no existe',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '2816704b-d988-4cc3-bfa6-fc99089dfc74',
        errorRaw:
          'no se ha podido realizar la operacion, por favor ingrese nuevamente en unos minutos mas.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '1be7c2b0-5820-4a49-b923-1e57426034f5',
        errorRaw:
          'estimado cliente, el banco del destinatario informa que la cuenta ingresada no existe. (cca7051).',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '56652011-d734-4995-8cc2-565d98f7e582',
        errorRaw: 'cuenta beneficiario no existe',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '19023f6b-c467-4814-90b8-d7711efeaabb',
        errorRaw: 'ha ocurrido un error inesperado, intenta mas tarde.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '8f6aed48-95e0-4578-b6ad-bf42fcc21c4c',
        errorRaw: 'problemas al crear clave otp',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '433aaf5d-94bc-45e1-8486-b9e90afa1d6c',
        errorRaw:
          'ocurrio un error al realizar la transferencia : error en la transaccion.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '8e2ba203-64d9-46d6-9d47-eafa6413b15a',
        errorRaw: 'mensaje no definido',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'ac86d205-db91-4333-8399-3e58a8bbea95',
        errorRaw: 'manually canceled by vfm. transfer did not complete.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '63a8cbe4-692b-4a6d-b008-f06ee98de6e2',
        errorRaw:
          'manually canceled by vfm. employee returned the money (unwanted payment).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'a73c8ff5-5b2e-42dd-8aee-dec85290ab10',
        errorRaw: 'manually canceled by vfm.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'b281308f-6b0c-43b3-aeac-665983ecf060',
        errorRaw: 'manually canceled by vfm. transfer not completed.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '254bdd5e-67d2-4b87-b642-3e41f3266a57',
        errorRaw: 'error al esperar resultado de la transferencia',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '79e35503-9ed5-49c8-bcdb-133dbcb45128',
        errorRaw:
          'estimado cliente, hemos tenido un inconveniente al procesar la transaccion (cod. tef7017).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'b8b8282e-1f29-4b18-aef4-1ac7d04d2b29',
        errorRaw:
          'estimado cliente, hemos tenido un inconveniente al procesar la transaccion (cod. tef7033).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '044901cd-4666-4b35-8980-c136bac07e4d',
        errorRaw:
          'no es posible realizar esta transaccion, aun no han pasado 24 hrs desde tu primera transferencia hacia una cuenta corriente de banco falabella.',
        errorType: 'RECIPIENT_FIRST_TRANSFER',
        errorCode: 'ERROR_0003',
      },
      {
        uuid: 'a5093b79-2fc0-4e98-84ff-fd5ac268cd6e',
        errorRaw:
          'estimado cliente, se ha producido un error al realizar tu transferencia (transtef7098).',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '697d6073-2952-4f53-a991-1d8dfef6906b',
        errorRaw: 'manually canceled by vfm',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '12526bf2-5a1e-4822-bb45-292c2d30ba44',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que cuenta destino inhabilitada para recibir tef',
        errorType: 'RECIPIENT_DISABLED_ACCOUNT',
        errorCode: 'ERROR_0005',
      },
      {
        uuid: '0ac9a525-e576-4d8b-a512-5469bf3cb55a',
        errorRaw:
          'estimado cliente, el rut del destinatario es incorrecto. (cca7045).',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'f55e4a54-f18d-4f82-a9b8-d11b5a098cdd',
        errorRaw: 'destinatario invalido',
        errorType: 'RECIPIENT_INVALID_ACCOUNT\n',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'a9c74532-27fa-427a-9bf0-0dbbef58698e',
        errorRaw:
          'se produjo un error en la transaccion. por favor vuelva a intentarlo en unos minutos.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '24d6f674-e468-46fb-889c-4b02cb74bf48',
        errorRaw: 'error timeout.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '39ae77dc-cc8a-4e6f-8e38-b001fb545b57',
        errorRaw: 'transaction deadline exceeded',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '1b601e68-fc54-449b-9363-aabf74b4c479',
        errorRaw: 'transactional data is not consistent',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b971bafc-8a5a-4fb9-8bf4-3ab2633dc56a',
        errorRaw: 'minka service fail',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '96034db7-effb-440d-b91c-739360d6dda6',
        errorRaw: 'number of transactions exceeded.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'd18928f4-e11b-40b1-91a0-704b538b05c3',
        errorRaw: 'destination has rejected the transfer.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'f8f5b73f-4d1f-4eca-9b54-9530cc0a2bb7',
        errorRaw: 'lower-limit-reached',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: '34d3d716-7379-44ab-8444-d3315edf727b',
        errorRaw: 'bank api error: bad gateway',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '25b571cb-b637-4bc1-a93f-867eb13e02d8',
        errorRaw: 'bad request',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '535e46a5-5b15-47be-a8c4-01c2cb9047f6',
        errorRaw:
          'por el momento para realizar transferencias a cuentas de banco estado y falabella debera guardar previamente la cuenta de destino. para registrar una cuenta nueva, ingrese a la opcion cuentas guardadas en el menu transferencias. la nueva cuenta guardada quedara habilitada para transferir en un plazo de 2 horas.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '7a988dbf-955a-4c38-855c-3683a9158438',
        errorRaw:
          'operacion realizada ! la transferencia ha quedado en estado pendiente de pago.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '176f3442-4e39-4cc6-bf96-a0368603b224',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que error mac recibido desde ifr',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'e927b4be-16fa-4a72-9384-04a51da65f98',
        errorRaw:
          'estimado cliente, esta transaccion ha sido rechazada por una validacion de seguridad. (cod. cca7015).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '862ac30e-4fb2-4957-8c19-d12177f71226',
        errorRaw: 'rut beneficiario incorrecto',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '49fa70aa-31e2-48a7-8814-888a97da7016',
        errorRaw:
          'estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que el rut del beneficiario esta incorrecto',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '17644ccd-3970-4e30-806e-eb84116d48db',
        errorRaw:
          'estimado cliente, por el momento no podemos atender su operacion. intente nuevamente en unos instantes',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '28629fa4-0673-455d-b4d3-d268f5b84f43',
        errorRaw: 'rut destinatario invalido.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '3e5785cc-fe2c-4511-a7af-b4632fc26e6e',
        errorRaw: 'la cuenta ingresada no existe',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '4e2731e4-ff72-4d7d-9f0d-7b2776cf71e6',
        errorRaw:
          'ha ocurrido un error no controlado. por favor intentelo nuevamente. si el problema persiste contactese con servicio atencion clientes security al telefono 2258 44060.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'd08c0d2d-d69a-489b-9601-820b8cb6ad02',
        errorRaw: 'error al esperar resultado de la transferencia',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '132ad517-f47c-43bf-b5e2-1b02cb41b241',
        errorRaw:
          'las transferencias hacia una cuenta vista y rut de banco del estado de chile no podran superar $1.000.000 en 24 hrs.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'a6a20d81-2140-474c-b392-ebafd27cb8e9',
        errorRaw:
          'lo sentimos, tu operacion no ha podido ser realizada. estamos trabajando para solucionar el inconveniente.',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'a726d67e-0644-446a-939f-a584be9e2726',
        errorRaw: 'no se pudo obtener el codigo de autorizacion',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'bb5b0420-03e2-4e04-a4b0-2016f2b52c0c',
        errorRaw:
          "el estado de la transferencia no coincide con el estado esperado. esperado: 'assigned', recibido: 'processing'",
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '03b94bd5-5521-4c73-b82f-f2be78f6735d',
        errorRaw: 'los datos del destinatario no coinciden',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '95579462-a44c-4dac-a96b-f1a2d2b36c62',
        errorRaw:
          'la clave token ingresada es incorrecta. por favor, verifica y vuelve a intentar. recuerda que tienes un limite de intentos validos de lo contrario tus tokens seran bloqueadas.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '66d5f121-9513-4449-90b3-ee035bf7d085',
        errorRaw:
          'rechazada - la cuenta no tiene los fondos suficientes para realizar la operacion. por favor, verifica y vuelve a intentarlo. 8ba52e1290651e58',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: 'a17107d4-f855-437c-8780-e223620e2958',
        errorRaw:
          'en estos momentos no es posible atenderlo, intente mas tarde',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'ec6f81a5-7f38-450d-8029-92af45808849',
        errorRaw: 'el numero de cuenta debe tener 13 digitos',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '6ae401c5-4784-4821-bf65-fb5deddff1fe',
        errorRaw:
          'estimado cliente, la transferencia no se ha efectuado por validacion de datos de cliente. (cod. cca7033).',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '1f11b63b-1fb3-42c2-a55c-4802a6b92747',
        errorRaw:
          'error al esperar resultado de la transferencia. 2023-03-04 19:02:37.005',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'c5e94420-a475-46b6-bfe4-c80dfdb0f672',
        errorRaw:
          'estimado cliente, hemos tenido un inconveniente al procesar la transaccion (cod. skt0804).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'da33a8c7-e9da-4b2d-bdd2-fdb313f96439',
        errorRaw:
          'estimado cliente, hemos tenido un inconveniente al procesar la transaccion (cod. skt0810).',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '357da921-ad52-488f-b199-e254ff36998e',
        errorRaw: 'la clave token ingresada es incorrecta',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '5e2a3fa4-c5bf-4172-9150-11108c19b007',
        errorRaw: 'contacte a su ejecutivo de cuentas',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'a99f1f45-8bfe-4689-91a6-da9c15492016',
        errorRaw:
          'ocurrio un error al procesar la transferencia. consulte los logs para ver mas detalle',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '1d657d1c-27f7-4c73-8d24-7757de367a25',
        errorRaw: 'cuenta destino con restriccion de abono',
        errorType: 'RECIPIENT_ACCOUNT_OVER_LIMIT',
        errorCode: 'ERROR_0009',
      },
      {
        uuid: '04d70687-72ab-4cb0-aeb5-65eec4e19d1b',
        errorRaw: 'no se encontro la cuenta de origen',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '0b59698c-7b9c-491b-909b-ac8b4a58dcfa',
        errorRaw: 'tiempo maximo de espera excedido',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: '\nERROR_0001',
      },
      {
        uuid: '18c5f7f2-2bdd-460b-931f-0a6a8412afec',
        errorRaw:
          'estimado cliente, el saldo en la cuenta de origen es insuficiente para realizar la transferencia. (cod. bge9156).',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: '006f953f-ba56-4635-a559-0c0e1dcaf22f',
        errorRaw: 'la cuenta ingresada debe tener 18 digitos.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '6928f1b5-ad9b-45ad-9728-64a7bc8d3fc2',
        errorRaw: 'la cuenta de destino no existe.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '8b77897f-4386-4ff2-b98a-7933f4676d8f',
        errorRaw: 'no se pudo procesar la transferencia',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '8c472312-c61d-4ccf-988e-f9e530552efb',
        errorRaw: 'error cca 91. host ifr no disponible',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: 'e2598acd-0ad0-4d1d-9778-c966c7fe1303',
        errorRaw: 'ac-ovd01 insufficient_funds',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: '42174c33-8dd9-4072-8fac-6edce6a0201f',
        errorRaw: 'error cca 41. cuenta destino incorrecta',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '968cca47-29b4-47ba-b2ba-d454352b1030',
        errorRaw:
          'an internal error has occurred, please try again later or contact us.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '33cc9839-0859-42bb-b68d-96a7ed800b71',
        errorRaw: 'error',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '5ece0972-b03d-46b7-9851-8b49397f7e99',
        errorRaw:
          'an error has occurred, validate the format and consistency of the input data.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'c01e41dc-2e2f-4db2-a75e-a014b415aea0',
        errorRaw:
          'ha ocurrido un error interno en bice. an internal error has occurred, please try again later.. por favor envie una nueva transaccion',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '39f16b70-3b2f-4c04-b66a-87dac1d0ce7e',
        errorRaw: "cannot read property 'constructor' of undefined",
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '226c502b-bc50-4c36-8449-555985e0e6e5',
        errorRaw: 'the client account is locked.',
      },
      {
        uuid: '4c33b205-52de-406b-9536-d2baf370e517',
        errorRaw: 'the target bank name was not found.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '76e596ba-1cd7-482a-b3f7-1ba589b8e335',
        errorRaw: 'the target bank code was not found.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'aa9fc973-6977-4030-9352-d24bc88a0bfb',
        errorRaw: 'the target bank branch was not found.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '1642eec4-030e-47e3-9b30-eb7e21b03423',
        errorRaw:
          'the target beneficiary document is invalid, such as wrong cpf.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'e46badac-c90e-4460-83e9-da3ab160453c',
        errorRaw:
          "the target beneficiary name doesn't match the target account holder's name.",
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '0a39ea33-a188-4382-9ff9-800baec9c877',
        errorRaw: 'the target account was not found.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '17b39f42-32b3-40c1-8a8f-9d4281c27d5c',
        errorRaw: 'the target account is invalid, mostly due to wrong format.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '0794a0a7-d1f8-41bd-8697-bbd60891fe1b',
        errorRaw: "the target account is locked, couldn't be used now.",
        errorType: 'RECIPIENT_DISABLED_ACCOUNT',
        errorCode: 'ERROR_0005',
      },
      {
        uuid: 'b265cecb-b97b-4bab-9b9d-b79334070cfa',
        errorRaw: 'the pix key provided is invalid, brazil only.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '49c8255b-cb14-4b30-981c-b1f52b39949b',
        errorRaw: 'the payer document is invalid.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '0ff43359-0951-482a-ba31-1f1f8d7a43e1',
        errorRaw: 'the transaction id is invalid.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '516d7036-89f2-4ba6-b6b5-2a6ffd4ccaee',
        errorRaw: 'the idempodency key provided is used before.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '29272091-2b62-459b-a4df-fa91ec664bc1',
        errorRaw: 'the source account is out of balance.',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: 'c0828990-872a-4189-9094-388a988e2d7c',
        errorRaw: 'the payment amount is reached the payment limit.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'a0e084d0-dd68-4403-954b-f14d911a1248',
        errorRaw:
          'the total daily payment amount is reached the daily payment limit.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '845d5a97-e674-4134-9284-25f4f8a0b717',
        errorRaw:
          'the total monthly payment amount is reached the daily payment limit.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '0d578e2c-78d5-4448-a590-de5b6c1e691c',
        errorRaw:
          'the total yearly payment amount is reached the daily payment limit.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '559a77d0-981b-4eeb-9975-b01011cb663f',
        errorRaw: 'the payment amount is too small to be accepted.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '6b060c26-7d62-4a7f-b7b9-174bda45846d',
        errorRaw: 'the payment gateway connection time out.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b3f45d54-abc1-485c-872b-ab63ad29018d',
        errorRaw: 'the payment gateway had a problem.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '9778dcb5-c552-4dfe-862d-89ffac0143f4',
        errorRaw: 'the payment operation had a time out issue.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '42224dc4-1cd2-4a77-82cd-0e35f28979ce',
        errorRaw: 'the payment transaction was cancelled.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b807226f-38c4-4dbe-a23f-9b28f00b8360',
        errorRaw: 'the payment transaction was rejected by bank.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '2eafb20b-1c70-4c68-ad5b-d56512ec8581',
        errorRaw: 'the date is invalid.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '3a8b7f73-3965-4ab1-8bca-15e7b55958b9',
        errorRaw: 'the bill according to date has not come out.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'eeef6a03-cf70-4751-8111-7449ba1dde0d',
        errorRaw: 'balance unavailable.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'f1958054-de52-469d-8ac4-927037fcd4bf',
        errorRaw:
          'the sku provided is invalid and was not found in the system.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '550575c7-608e-4611-a9b7-622e7571ab3e',
        errorRaw: 'carrier does not support the phone number.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'c83be28e-db80-4ad4-9f36-5b6950597679',
        errorRaw: 'carrier does not support the reference number.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'c85750f1-8d0f-47ab-a3e7-bbebc6e1cd37',
        errorRaw:
          'the payment amount does not match the corresponding reference number.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'a8909c2d-f8d2-4ac2-9164-6df6b95b1ff0',
        errorRaw: 'an error happened but can failover.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '5805086c-8f8b-4d2b-a830-59459b48096d',
        errorRaw: 'the payment is rejected because account type not correct.',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '08203d3c-8c11-4710-aca8-50fe2e27cdbc',
        errorRaw: 'the vendor is in short outage.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '9871f461-81cf-471c-9fdb-f4782a7a709e',
        errorRaw: 'the target bank is in outage.',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: '93b2a9af-11d0-47af-90cd-ed1bcb3aa73a',
        errorRaw: 'the transaction failed risk analysis.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'f6e689b5-1e73-48a3-9f76-0b1a44a0460d',
        errorRaw: 'the giftcard is out of stock at this moment.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'cb8b04d9-6393-449a-a44c-29fcd7ed5307',
        errorRaw: 'error_creditor_account_not_found',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '858c5752-cf76-461d-86c7-ecac2fc08a75',
        errorRaw: 'error_creditor_account_detail_mismatch',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: '52dbca98-1690-4b7f-b936-cf25d9419efa',
        errorRaw: 'error_creditor_account_over_limits',
        errorType: 'RECIPIENT_ACCOUNT_OVER_LIMIT',
        errorCode: 'ERROR_0009',
      },
      {
        uuid: '4f57b8ac-ad6d-4750-aca6-080dcca1aa78',
        errorRaw: 'error_creditor_fi_offline',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b4d297cf-e50f-4742-8f55-f3b3710cfb90',
        errorRaw: 'error_payment_rail_offline',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '0a84f9b8-fcbc-467d-a477-3ca7e02d60c9',
        errorRaw: 'error_debtor_account_over_limits',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '82c69356-f3b4-442e-b0d6-3212f0206535',
        errorRaw: 'error_debtor_insufficient_funds',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: 'fca456c8-8ca9-434e-8160-9ecea0f9819f',
        errorRaw: 'error',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '4a9ad4a8-a911-46a6-a951-a92850c6e05b',
        errorRaw: 'labels object is invalid or missing',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'e16e977b-e04c-4fd0-b992-ddd575b4e698',
        errorRaw: 'unauthorized request, invalid or expired token',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '10fc9dee-6ea7-4d06-b697-3233e8be8064',
        errorRaw: 'transfer or action source is invalid',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '9f5ea323-1fb4-44e1-a92e-6f9d77643fe5',
        errorRaw: 'transfer or action target is invalid',
        errorType: 'RECIPIENT_INVALID_ACCOUNT',
        errorCode: 'ERROR_0004',
      },
      {
        uuid: 'a1b920ff-f94e-4037-a4f6-ef386e7b7cd0',
        errorRaw: 'invalid symbol handle or address',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '820a550e-e34a-419a-a5d2-7ee66fa30cd9',
        errorRaw: 'resource schema validation error',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'f4446b67-b960-45c7-b659-d1442ce2cb35',
        errorRaw: 'request timed out',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'c80fdec8-25e4-475f-b578-9d089d241010',
        errorRaw: 'default timeout is 30 seconds',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '7c5e5d8a-7f2d-453d-a772-b9a55e1a1cd7',
        errorRaw: "resource doesn't exist in the system",
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '8996efe9-fee0-49f2-8a44-5d6401c760a1',
        errorRaw: 'a transfer exceeds configured business rules',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '3ad3f9ba-0d09-46c2-9a7c-dfa7b2d466c9',
        errorRaw:
          'attempting to process a transfer that has already been processed',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '7286aafc-7c60-44a6-9198-0d1fc764c634',
        errorRaw: 'transfer timeout',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '2f50055b-e9b9-43c4-9c65-a78baf5b3df1',
        errorRaw: 'source has rejected the transfer',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'c9ab67d5-c20b-4fb3-8624-e33839c2d96b',
        errorRaw: 'target has rejected the transfer',
        errorType: 'UNKNOWN_ERROR',
        errorCode: 'ERROR_0000',
      },
      {
        uuid: '4a3de43f-b2b5-406c-baf4-103e2f781bc5',
        errorRaw: 'access data invalid in the bank',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '24093a79-5a2e-41ee-bb1b-b0028b5d49cc',
        errorRaw: 'transfer information is invalid',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '09098f82-6feb-47cf-b9bc-504fb1525708',
        errorRaw: 'user abandoned transaction in bank',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '78807bf8-d328-4b35-9804-1d9d4a5f1f8b',
        errorRaw: 'seizure account',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b5cb0987-3fd5-4230-ae92-f7ddc9e7df04',
        errorRaw: 'inactive account',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b8fc483e-6799-49a6-851f-a2f21ea9adf5',
        errorRaw: 'cancelled account',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'e8679e88-1153-41e5-bd3f-774f75d17494',
        errorRaw: 'account does not exist',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '59d52ef9-9dd0-4ad4-a77a-1192b8a03d3a',
        errorRaw: 'account not enabled',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'd3bb3a36-9c08-4c77-b30e-52697930a10c',
        errorRaw: 'account has not being assigned',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'a8d52246-fa75-47a7-80c7-e610d89d12e4',
        errorRaw: 'account paid off',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '4350c387-0c3a-4eed-858e-f108ab23dd54',
        errorRaw: 'user exceeds the transactional limit authorized by the bank',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '858528a5-8e76-495e-a3d5-654c3363e83a',
        errorRaw: 'bank is not available',
        errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
        errorCode: 'ERROR_0007',
      },
      {
        uuid: '53e3bfa7-8c5d-4151-966e-2a423455d8d0',
        errorRaw: 'insufficient funds',
        errorType: 'PROVIDER_INSUFFICIENT_FUNDS ',
        errorCode: 'ERROR_0002',
      },
      {
        uuid: '8bf54b68-23e1-4b09-a07e-d51b84be0cd1',
        errorRaw: 'transactional data is not consistent',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '3d3d1ae4-7d5b-48cd-9657-4539d06e9b74',
        errorRaw: 'financial entity does not confirm transaction status',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '3ac80b0d-e423-40e0-a08e-527ab46b99f9',
        errorRaw: 'transaction not included in the bank',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'eddff8e6-2ee4-47ed-998c-74f345236ef1',
        errorRaw: 'transfer was marked as fraud',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '7c4f0631-4bca-44e7-a879-71e4904b73fb',
        errorRaw: 'user does not have tin payments enabled',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '8436db3e-4e2e-4c89-9cde-4e4cabccb200',
        errorRaw: 'transaction status changed',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'd1317458-9900-4450-a87f-71b31feed977',
        errorRaw: 'transaction declined by fraud',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'dd73259c-ce58-47da-a639-887b8a3fa119',
        errorRaw: 'browser used by the user is not compatible with tin',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '4b140e9d-53b4-4965-9bb1-88cf8967b230',
        errorRaw: 'user does not show any activity in tin (timeout)',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '2bbc981e-5904-4675-94af-1e9bc3c4597a',
        errorRaw: 'bank does not accept transaction initialization',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '7372b3f4-5fb9-49bc-bf39-252487f17ce6',
        errorRaw: 'transaction limit exceeded by the user',
        errorType: 'RECIPIENT_ACCOUNT_OVER_LIMIT',
        errorCode: 'ERROR_0009',
      },
      {
        uuid: '8244a249-14fb-40db-8aa0-dce42d7a01c1',
        errorRaw: 'cannot connect to the financial entity',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'b98ebc05-b404-4202-a269-4fd82a5f391f',
        errorRaw: 'transaction deadline exceeded',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '46967c67-f7bd-4a83-a42a-b31fd601cff5',
        errorRaw: 'unexpected error happened when calling financial entity.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '2db771af-7f0d-4247-8897-c1c2e92ce0fa',
        errorRaw:
          'invalid api call from the bank, or bank returned an invalid response',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '4aefa0b9-0f83-4868-944f-387abf7bbcb3',
        errorRaw: 'unexpected server error',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '87f82ea8-38e1-4beb-8eeb-b51f1d46899b',
        errorRaw: 'unable to get a valid response from a target service',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '1ed77b41-61a0-4876-935e-c8a2806ac4ee',
        errorRaw:
          'the server is not ready to handle the request. common causes are',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '91d8e47c-01af-4841-97f3-b7fa38a8ea2e',
        errorRaw:
          'a server that is down for maintenance or that is overloaded.',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '270b6c90-949e-4431-bd41-6ddba30ac85b',
        errorRaw: 'invalid amount',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '99ac45fb-bd19-4ed9-ac0e-5e7ee328e084',
        errorRaw:
          "action type isn't supported for provided source and/or target",
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: 'f94caa8a-3a45-4e03-9aa7-afd6c95621fc',
        errorRaw: "resource doesn't exist in the system",
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
      {
        uuid: '26314741-e7f2-409b-9636-a7275b2219fd',
        errorRaw: 'a transfer exceeds configured business rules',
        errorType: 'PROVIDER_INTERNAL_FAILURE',
        errorCode: 'ERROR_0001',
      },
    ];
    for (const error of errorData) {
      try {
        await queryRunner.query(
          `INSERT INTO transfer_error (uuid , errorRaw , errorType , errorCode) VALUES (?,?,?,?);`,
          [error.uuid, error.errorRaw, error.errorType, error.errorCode],
        );
      } catch (e) {
        logger.log(e);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.buildErrorData(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`TRUNCATE TABLE transfer_error;`);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1675344142086-AddProviderTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderTable1675344142086 implements MigrationInterface {
  name = 'AddProviderTable1675344142086';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`provider\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`providerType\` enum ('scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'inactive', \`credentials\` text NULL, \`rules\` json NULL, \`priority\` int NULL, \`accountId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD CONSTRAINT \`FK_e8b5da60822bd44f396b3c91949\` FOREIGN KEY (\`accountId\`) REFERENCES \`account\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP FOREIGN KEY \`FK_e8b5da60822bd44f396b3c91949\``,
    );
    await queryRunner.query(`DROP TABLE \`provider\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1707945139243-RenameCapabilityProviderColumn.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RenameCapabilityProviderColumn1707945139243
  implements MigrationInterface
{
  name = 'RenameCapabilityProviderColumn1707945139243';

  public async up(queryRunner: QueryRunner): Promise<void> {
    const providers = await queryRunner.query(
      `SELECT id, capability FROM provider`,
    );

    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`capability\` \`capabilities\` varchar(255) NOT NULL DEFAULT 'create_transfer'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`capabilities\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`capabilities\` text NOT NULL`,
    );

    for (const provider of providers) {
      await queryRunner.query(
        `UPDATE \`provider\` SET capabilities = '${provider.capability}' WHERE id = ${provider.id}`,
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const providers = await queryRunner.query(
      `SELECT id, capabilities FROM provider`,
    );

    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`capabilities\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`capabilities\` varchar(255) NOT NULL DEFAULT 'create_transfer'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`capabilities\` \`capability\` varchar(255) NOT NULL DEFAULT 'create_transfer'`,
    );

    for (const provider of providers) {
      await queryRunner.query(
        `UPDATE \`provider\` SET capability = '${provider.capability}' WHERE id = ${provider.id}`,
      );
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1665634280097-AddAuthorizingTransferState.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAuthorizingTransferState1665634280097
  implements MigrationInterface
{
  name = 'AddAuthorizingTransferState1665634280097';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'created', 'authorizing', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'created', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1653396350589-AddHolderIdToBankAccounts.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddHolderIdToBankAccounts1653396350589
  implements MigrationInterface
{
  name = 'AddHolderIdToBankAccounts1653396350589';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` ADD \`holderId\` varchar(64) NOT NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_account\` DROP COLUMN \`holderId\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656778950984-MakePayoutDestinationEmailOptional.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class MakePayoutDestinationEmailOptional1656778950984
  implements MigrationInterface
{
  name = 'MakePayoutDestinationEmailOptional1656778950984';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`destinationEmail\` \`destinationEmail\` varchar(255) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` CHANGE \`destinationEmail\` \`destinationEmail\` varchar(255) NOT NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1656708997608-AddIndexToTransferMethods.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddIndexToTransferMethods1656708997608
  implements MigrationInterface
{
  name = 'AddIndexToTransferMethods1656708997608';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\` (\`identifier\`, \`methodType\`)`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_9fda148f13ed05eb66c57f3a7c\` ON \`transfer_method\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1688414454990-RemoveWalletModelRelations.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RemoveWalletModelRelations1688414454990
  implements MigrationInterface
{
  name = 'RemoveWalletModelRelations1688414454990';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`deposit\` DROP FOREIGN KEY \`FK_414a92c88a75322a479d3c0a5f1\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` DROP FOREIGN KEY \`FK_4f3efd7909d1d397f98d6d93be8\``,
    );
    await queryRunner.query(`ALTER TABLE \`deposit\` DROP COLUMN \`walletId\``);
    await queryRunner.query(`ALTER TABLE \`payout\` DROP COLUMN \`walletId\``);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD \`walletId\` int NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` ADD \`walletId\` int NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD CONSTRAINT \`FK_4f3efd7909d1d397f98d6d93be8\` FOREIGN KEY (\`walletId\`) REFERENCES \`wallet\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`deposit\` ADD CONSTRAINT \`FK_414a92c88a75322a479d3c0a5f1\` FOREIGN KEY (\`walletId\`) REFERENCES \`wallet\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1677004819811-AddProviderCapabilitiesColumn.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderCapabilitiesColumn1677004819811
  implements MigrationInterface
{
  name = 'AddProviderCapabilitiesColumn1677004819811';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`capabilities\` text NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` DROP COLUMN \`capabilities\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1699376701962-MigrateSecretTransformer.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { UserEntity } from '../../models/user/entities/user.entity';
import { SecretTransformer } from '../../common/transformers/secret.transformer';

export class MigrateSecretTransformer1699376701962
  implements MigrationInterface
{
  name = 'MigrateSecretTransformer1699376701962';

  private async getAllUsers(
    queryRunner: QueryRunner,
  ): Promise<Partial<UserEntity>[]> {
    const allUsersWithSeed = (await queryRunner.connection.manager.query(
      `
        SELECT usr.id, usr.seed FROM user usr
        WHERE  usr.seed IS NOT NULL
      `,
    )) as Partial<UserEntity>[];
    return allUsersWithSeed;
  }

  private async updateUserSeeds(queryRunner: QueryRunner): Promise<void> {
    const users = await this.getAllUsers(queryRunner);
    if (users.length === 0) {
      console.warn('No users with mfa seed encrypted to migrate.');
      return;
    }
    for (const user of users) {
      const oldTransformer = SecretTransformer.default();
      const rawSeed = oldTransformer.from(user.seed);
      const newTransformer = SecretTransformer.default();
      const newEncryptedSeed = newTransformer.to(rawSeed);
      if (!newEncryptedSeed || typeof newEncryptedSeed !== 'string') {
        console.error(
          `Could not encrypt seed for user ${user.id}. Skip update record.`,
        );
        continue;
      }
      await queryRunner.query(
        `UPDATE user
                  SET user.seed = ? 
                  WHERE user.id = ?`,
        [newEncryptedSeed, user.id],
      );
      console.log(`seed for user ${user.id} encrypted`);
    }
    console.log('Update all user seeds');
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.updateUserSeeds(queryRunner);
  }

  public async down(_queryRunner: QueryRunner): Promise<void> {
    // If update fails, theres nothing to rollback
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1661278450269-AddColombianBanksSeed.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { randUuid } from '@ngneat/falso';
export class AddColombianBanksSeed1661278450269 implements MigrationInterface {
  name = 'AddColombianBanksSeed1661278450269';
  private async makeColombianBanks(queryRunner: QueryRunner): Promise<void> {
    const colimbianBanksCodes = {
      nequi: 'banco_nequi',
      movii: 'movii',
      itauproduccion: 'banco_itau',
      daviviendaprd: 'davivienda',
      daviplataprd: 'daviplata',
      dale: 'dale',
      confiarcoopprd: 'confiar_coop',
      bancoserfinanza: 'banco_serfinanza',
      bancolombia: 'bancolombia',
      bancofinandina: 'banco_finandina',
      bancodebogotasa: 'banco_de_bogota',
      bancocoopcentral: 'banco_coopcentral',
      bancocajasocial: 'banco_caja_social',
      bancoavvillas: 'banco_av_villas',
    };
    const colombianBanks = [
      'nequi',
      'movii',
      'itauproduccion',
      'daviviendaprd',
      'daviplataprd',
      'dale',
      'confiarcoopprd',
      'bancoserfinanza',
      'bancolombia',
      'bancofinandina',
      'bancodebogotasa',
      'bancocoopcentral',
      'bancocajasocial',
      'bancoavvillas',
    ];
    for (const bankName of colombianBanks) {
      const uuid = randUuid();
      const bankCode = 'co_' + colimbianBanksCodes[bankName];
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.makeColombianBanks(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const colombianBanks = await queryRunner.query(
      `SELECT * FROM bank where code LIKE 'co_%';`,
    );
    for (const bank of colombianBanks) {
      try {
        await queryRunner.query(`DELETE FROM bank WHERE id = ?`, bank.id);
      } catch (error) {
        console.log(error);
      }
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1661278450268-AddChileanBanksSeed.ts
import { MigrationInterface, QueryRunner } from 'typeorm';
import { randUuid } from '@ngneat/falso';
export class AddChileanBanksSeed1661272450268 implements MigrationInterface {
  name = 'AddChileanBanksSeed1661272450268';
  private async makeChileanBanks(queryRunner: QueryRunner): Promise<void> {
    const chileanBanksCodes = [
      'cl_abn_amro_bank_chile',
      'cl_banco_bice',
      'cl_banco_de_chile',
      'cl_banco_consorcio',
      'cl_banco_bci',
      'cl_banco_del_desarrollo',
      'cl_banco_estado',
      'cl_banco_falabella',
      'cl_banco_internacional',
      'cl_banco_itau_chile',
      'cl_banco_paris',
      'cl_banco_ripley',
      'cl_banco_security',
      'cl_banco_coopeuch',
      'cl_banco_corpbanca',
      'cl_hsbc_bank_chile',
      'cl_prepago_los_heroes',
      'cl_rabobank_chile',
      'cl_scotiabank_azul',
      'cl_scotiabank_sud_americano',
      'cl_tenpo_prepago',
      'cl_banco_santander',
      'cl_jp_morgan_chase_bank',
    ];
    const chileanBanksNames = {
      cl_abn_amro_bank_chile: 'abn amro bank chile',
      cl_banco_bice: 'banco bice',
      cl_banco_de_chile: 'banco chile',
      cl_banco_consorcio: 'banco consorcio',
      cl_banco_bci: 'banco de creditos e inversiones',
      cl_banco_del_desarrollo: 'banco del desarrollo',
      cl_banco_estado: 'banco del estado de chile',
      cl_banco_falabella: 'banco falabella',
      cl_banco_internacional: 'banco internacional',
      cl_banco_itau_chile: 'banco itau chile',
      cl_banco_paris: 'banco paris',
      cl_banco_ripley: 'banco ripley',
      cl_banco_security: 'banco security',
      cl_banco_coopeuch: 'coopeuch',
      cl_banco_corpbanca: 'corpbanca',
      cl_hsbc_bank_chile: 'hsbc bank chile',
      cl_prepago_los_heroes: 'prepago los heroes',
      cl_rabobank_chile: 'rabobank chile',
      cl_scotiabank_azul: 'scotiabank azul',
      cl_scotiabank_sud_americano: 'scotiabank sud americano',
      cl_tenpo_prepago: 'tenpo prepago s.a.',
      cl_banco_santander: 'banco santander',
      cl_jp_morgan_chase_bank: 'jp morgan chase bank',
    };
    for (const bankCode of chileanBanksCodes) {
      const uuid = randUuid();
      const bankName = chileanBanksNames[bankCode];
      try {
        await queryRunner.query(
          `INSERT INTO bank(uuid,name,code) VALUES(?,?,?);`,
          [uuid, bankName, bankCode],
        );
      } catch (error) {
        console.log(error);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.makeChileanBanks(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const chileananks = await queryRunner.query(
      `SELECT * FROM bank where code LIKE '%cl_%';`,
    );
    for (const bank of chileananks) {
      try {
        await queryRunner.query(`DELETE FROM bank WHERE id = ?`, bank.id);
      } catch (error) {
        console.log(error);
      }
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1679521124136-AddBalanceAvailableToAccountStatements.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddBalanceAvailableToAccountStatements1679521124136
  implements MigrationInterface
{
  name = 'AddBalanceAvailableToAccountStatements1679521124136';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` ADD \`retrievedAt\` datetime(6) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` ADD \`balance\` decimal(18,2) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` CHANGE \`startedAt\` \`startedAt\` datetime(6) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` CHANGE \`startedAt\` \`startedAt\` datetime(6) NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement_job\` DROP COLUMN \`balance\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` DROP COLUMN \`retrievedAt\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1704384643243-AddProviderIdAndExtErrorCodeToTransferErrorTable.ts
import { randUuid } from '@ngneat/falso';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { MigrationInterface, QueryRunner } from 'typeorm';

const STANDARDIZED_ERRORS: Array<Partial<TransferErrorEntity>> = [
  {
    errorCode: TransferErrorCode.RECIPIENT_INVALID_ACCOUNT,
    errorType: 'RECIPIENT_INVALID_ACCOUNT',
    errorRaw: "The destination account doesn't exist",
    externalErrorCode: 'error_creditor_account_not_found',
  },
  {
    errorCode: TransferErrorCode.RECIPIENT_INVALID_ACCOUNT,
    errorType: 'RECIPIENT_INVALID_ACCOUNT',
    errorRaw: 'Something is wrong with the destination account details',
    externalErrorCode: 'error_creditor_account_detail_mismatch',
  },
  {
    errorCode: TransferErrorCode.RECIPIENT_ACCOUNT_OVER_LIMIT,
    errorType: 'RECIPIENT_ACCOUNT_OVER_LIMIT',
    errorRaw:
      'The destination account is over the limits set by the creditor bank/institution',
    externalErrorCode: 'error_creditor_account_over_limits',
  },
  {
    errorCode: TransferErrorCode.DESTINATION_BANK_NOT_AVAILABLE,
    errorType: 'DESTINATION_BANK_NOT_AVAILABLE',
    errorRaw: 'The creditor bank/institution is temporarily offline',
    externalErrorCode: 'error_creditor_fi_offline',
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw: 'The payment rail used by Shinkansen/PO is temporarily offline',
    externalErrorCode: 'error_payment_rail_offline',
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw: 'Provider Internal Failure',
    externalErrorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
  },
];

export class AddProviderIdAndExtErrorCodeToTransferErrorTable1704384643243
  implements MigrationInterface
{
  name = 'AddProviderIdAndExtErrorCodeToTransferErrorTable1704384643243';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD \`externalErrorCode\` varchar(128) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD \`providerId\` int NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` ADD CONSTRAINT \`FK_c59051c637e96fe366a8793380e\` FOREIGN KEY (\`providerId\`) REFERENCES \`provider\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );

    for (const error of STANDARDIZED_ERRORS) {
      const uuid = randUuid();
      await queryRunner.query(
        `INSERT INTO transfer_error (uuid , errorRaw , errorType , errorCode, externalErrorCode) VALUES (?,?,?,?,?);`,
        [
          uuid,
          error.errorRaw,
          error.errorType,
          error.errorCode,
          error.externalErrorCode,
        ],
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP FOREIGN KEY \`FK_c59051c637e96fe366a8793380e\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP COLUMN \`providerId\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` DROP COLUMN \`externalErrorCode\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1674763686474-AddAccountTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAccountTable1674763686474 implements MigrationInterface {
  name = 'AddAccountTable1674763686474';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`account\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`bankCode\` varchar(64) NOT NULL, \`identifier\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'inactive', \`name\` varchar(128) NOT NULL, \`rules\` json NULL, \`merchantId\` int NOT NULL, \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER') NOT NULL DEFAULT 'CHL', PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account\` ADD CONSTRAINT \`FK_fcd2b6248c1aae7649bba9a2bbf\` FOREIGN KEY (\`bankCode\`) REFERENCES \`bank\`(\`code\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account\` ADD CONSTRAINT \`FK_b3f46f678ecd1d7e1d2901074bf\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account\` DROP FOREIGN KEY \`FK_b3f46f678ecd1d7e1d2901074bf\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`account\` DROP FOREIGN KEY \`FK_fcd2b6248c1aae7649bba9a2bbf\``,
    );
    await queryRunner.query(`DROP TABLE \`account\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1679947591872-AddNameColumnToProviders.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddNameColumnToProviders1679947591872
  implements MigrationInterface
{
  name = 'AddNameColumnToProviders1679947591872';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` ADD \`name\` varchar(128) NOT NULL AFTER updatedAt`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`provider\` DROP COLUMN \`name\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1688593062279-AddAuditLogTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAuditLogTable1688593062279 implements MigrationInterface {
  name = 'AddAuditLogTable1688593062279';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`audit_log\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`context\` text NULL, \`authorId\` int NULL, \`authorType\` varchar(64) NULL, \`event\` enum ('insert', 'update', 'remove', 'softremove') NOT NULL, \`entityType\` varchar(64) NOT NULL, \`entityId\` varchar(128) NOT NULL, \`entityAfter\` longtext NULL, \`entityBefore\` longtext NULL, INDEX \`IDX_7253c576c9bcaf94fe064341dd\` (\`entityType\`, \`entityId\`), INDEX \`IDX_4075c67942432d1e1d5c548098\` (\`authorId\`, \`authorType\`), PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_4075c67942432d1e1d5c548098\` ON \`audit_log\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_7253c576c9bcaf94fe064341dd\` ON \`audit_log\``,
    );
    await queryRunner.query(`DROP TABLE \`audit_log\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1688414454991-DropWalletTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class DropWalletTable1688414454990 implements MigrationInterface {
  name = 'DropWalletTable1688414454991';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE \`wallet\``);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`wallet\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`name\` varchar(128) NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`balance\` decimal(18,2) NOT NULL DEFAULT '0.00', \`reservedBalance\` decimal(18,2) NOT NULL DEFAULT '0.00', \`currency\` enum ('ars', 'bob', 'brl', 'clp', 'cop', 'mxn', 'usd', 'pen', 'uyu') NOT NULL DEFAULT 'clp', \`merchantId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1703121694992-AddAutoRetriedColumnToTransfers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAutoRetriedColumnToTransfers1703121694992
  implements MigrationInterface
{
  name = 'AddAutoRetriedColumnToTransfers1703121694992';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` ADD \`autoRetried\` tinyint NOT NULL DEFAULT 0`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` DROP COLUMN \`autoRetried\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1703622210846-TruncatePayoutActionAndTransferErrorTable.ts
import { randUuid } from '@ngneat/falso';
import { PayoutAction } from 'src/common/enums/payout-action.enum';
import { TransferErrorEntity } from 'src/models/transfer-error/entities/transfer-error.entity';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { MigrationInterface, QueryRunner } from 'typeorm';

const CANCELABLE_ERROR_CODE = [
  TransferErrorCode.RECIPIENT_INVALID_ACCOUNT,
  TransferErrorCode.RECIPIENT_DISABLED_ACCOUNT,
  TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
  TransferErrorCode.DESTINATION_BANK_NOT_AVAILABLE,
  TransferErrorCode.RECIPIENT_ACCOUNT_OVER_LIMIT,
  TransferErrorCode.MERCHANT_LIMIT_EXCEED,
];

const RETRYABLE_ERROR_CODE = [TransferErrorCode.PROVIDER_INTERNAL_FAILURE];

const STANDARDIZED_ERRORS: Array<Partial<TransferErrorEntity>> = [
  {
    errorCode: TransferErrorCode.MERCHANT_LIMIT_EXCEED,
    errorType: 'MERCHANT_LIMIT_EXCEED',
    errorRaw:
      'La transferencia excede el límite por criterio "cantidad". Límite 1 excedido',
    pattern: `La transferencia excede el límite por criterio \\"(monto|cantidad)\\"\\. Límite \\d+ excedido`,
  },
  {
    errorCode: TransferErrorCode.RECIPIENT_DISABLED_ACCOUNT,
    errorType: 'RECIPIENT_DISABLED_ACCOUNT',
    errorRaw: 'Error CCA 17. Cuenta Destino inhabilitada para recibir TEF',
  },
  {
    errorCode: TransferErrorCode.RECIPIENT_INVALID_ACCOUNT,
    errorType: 'RECIPIENT_INVALID_ACCOUNT',
    errorRaw: 'Error CCA 46. Relación RUT / Cuenta inválido',
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw:
      'Error al completar el formulario de creación de transferencia. No se realizó transacción de dinero.: Ha ocurrido un error inesperado',
    pattern: null,
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw:
      'Error al completar el proceso de autorización de transferencia.: No se pudo obtener el código de autorización',
    pattern: null,
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw: `Transaction NOT executed, verified by the bank support team. Bank report: 
        -------- Detalle ------.
       Cliente: BUK Pagos SpA.
       SHK ID: 05fda726-5027-4503-873c-81acfafd30eb.
       Estado: Rejected.
       Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
       .
       Mueve Dinero:No.
       Cliente puede reintentar: Si.
       Requiere Callback Manual: Si.
       Cliente recibirá Cargo Manual: No.
       `,
    pattern: `Transaction NOT executed, verified by the bank support team. Bank report: 
       -------- Detalle ------.
      Cliente: BUK Pagos SpA.
      SHK ID: (\\w+-+){4}\\w+.
      Estado: Rejected.
      Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
      .
      Mueve Dinero:No.
      Cliente puede reintentar: Si.
      Requiere Callback Manual: Si.
      Cliente recibirá Cargo Manual: No.
      `,
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw: `Transaction NOT executed, verified by the bank support team. Bank report: 
    -------- Detalle ------.
   Cliente: BUK Pagos SpA.
   SHK ID: 7d40e0ec-cfb8-4978-8c2c-b78ed29f1435.
   Estado: Rejected - SE REVERSARA CARGO EN CARTOLA.
   Detalle: Intermitencia CONEXION CCA.
   .
   Mueve Dinero:No.
   Cliente puede reintentar: Si.
   Requiere Callback Manual: No.
   Cliente recibirá Cargo Manual: No.`,
    pattern: `Transaction NOT executed, verified by the bank support team. Bank report: 
    -------- Detalle ------.
   Cliente: BUK Pagos SpA.
   SHK ID: (\\w+-+){4}\\w+.
   Estado: Rejected - SE REVERSARA CARGO EN CARTOLA.
   Detalle: Intermitencia CONEXION CCA.
   .
   Mueve Dinero:No.
   Cliente puede reintentar: Si.
   Requiere Callback Manual: No.
   Cliente recibirá Cargo Manual: No.`,
  },
  {
    errorCode: TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
    errorType: 'PROVIDER_INTERNAL_FAILURE',
    errorRaw:
      'Error: Shinkansen transaction 55b2a235-55e3-4393-91f0-5eff3ca7183e failed after 4 attempts',
    pattern:
      'Error: Shinkansen transaction (\\w+-+){4}\\w+ failed after 4 attempts',
  },
];

export class TruncatePayoutActionAndTransferErrorTable1703622210846
  implements MigrationInterface
{
  name = 'TruncatePayoutActionAndTransferErrorTable1703622210846';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`TRUNCATE TABLE \`payout_action\``);

    // Cancelable
    for (const errorCode of CANCELABLE_ERROR_CODE) {
      const uuid = randUuid();
      await queryRunner.query(
        `INSERT INTO payout_action(uuid,errorCode,action) VALUES(?,?,?);`,
        [uuid, errorCode, PayoutAction.AUTO_CANCEL],
      );
    }

    // Retryable
    for (const errorCode of RETRYABLE_ERROR_CODE) {
      const uuid = randUuid();
      await queryRunner.query(
        `INSERT INTO payout_action(uuid,errorCode,action) VALUES(?,?,?);`,
        [uuid, errorCode, PayoutAction.AUTO_RETRY],
      );
    }

    await queryRunner.query(`TRUNCATE TABLE \`transfer_error\``);

    for (const error of STANDARDIZED_ERRORS) {
      const uuid = randUuid();
      await queryRunner.query(
        `INSERT INTO transfer_error (uuid , errorRaw , errorType , errorCode, pattern) VALUES (?,?,?,?,?);`,
        [uuid, error.errorRaw, error.errorType, error.errorCode, error.pattern],
      );
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`UPDATE \`payout_action\` SET action = NULL`);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1701806507811-AddAutoRetryPayoutActionEnumValue.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddAutoRetryPayoutActionEnumValue1701806507811
  implements MigrationInterface
{
  name = 'AddAutoRetryPayoutActionEnumValue1701806507811';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` CHANGE \`action\` \`action\` enum ('AUTO_CANCEL', 'AUTO_RETRY') NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` CHANGE \`action\` \`action\` enum ('AUTO_CANCEL') NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1680544509721-UpdateProviderTypeEnum.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class UpdateProviderTypeEnum1680544509721 implements MigrationInterface {
  name = 'UpdateProviderTypeEnum1680544509721';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `ALTER TABLE \`bank_access\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `UPDATE provider SET providerType = 'scraperCG' WHERE providerType = 'scraperV1'`,
    );

    await queryRunner.query(
      `UPDATE provider SET providerType = 'scraperPW' WHERE providerType = 'scraperv2'`,
    );

    await queryRunner.query(
      `UPDATE bank_access SET providerType = 'scraperCG' WHERE providerType = 'scraperV1'`,
    );

    await queryRunner.query(
      `UPDATE bank_access SET providerType = 'scraperPW' WHERE providerType = 'scraperv2'`,
    );

    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `ALTER TABLE \`bank_access\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'minka', 'liquido', 'shinkansen') NOT NULL DEFAULT 'scraperCG'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `ALTER TABLE \`bank_access\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `UPDATE provider SET providerType = 'scraperV1' WHERE providerType = 'scraperCG'`,
    );

    await queryRunner.query(
      `UPDATE provider SET providerType = 'scraperv2' WHERE providerType = 'scraperPW'`,
    );

    await queryRunner.query(
      `UPDATE bank_access SET providerType = 'scraperV1' WHERE providerType = 'scraperCG'`,
    );

    await queryRunner.query(
      `UPDATE bank_access SET providerType = 'scraperv2' WHERE providerType = 'scraperPW'`,
    );

    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );

    await queryRunner.query(
      `ALTER TABLE \`bank_access\` CHANGE \`providerType\` \`providerType\` enum ('scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL DEFAULT 'scraperCG'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1689260598326-AddDataToPayoutActionTable.ts
import { Logger } from '@nestjs/common';
import { randUuid } from '@ngneat/falso';
import { actionablePayoutErrorCode } from 'src/models/transfer-error/error.definition.type';
import { MigrationInterface, QueryRunner } from 'typeorm';
const logger = new Logger('AddDataToPayoutActionTableLogger');

export class AddDataToPayoutActionTable1689260598326
  implements MigrationInterface
{
  name = 'AddDataToPayoutActionTable1689260598326';
  private async buildPayoutActionData(queryRunner: QueryRunner): Promise<void> {
    for (const errorCode of actionablePayoutErrorCode) {
      const uuid = randUuid();
      try {
        await queryRunner.query(
          `INSERT INTO payout_action(uuid,errorCode,action) VALUES(?,?,?);`,
          [uuid, errorCode, 'AUTO_CANCEL'],
        );
      } catch (e) {
        logger.log(e);
      }
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.buildPayoutActionData(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`TRUNCATE TABLE payout_action;`);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1697549622819-AddDeletedAtToMerchantLimit.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddDeletedAtToMerchantLimit1697549622819
  implements MigrationInterface
{
  name = 'AddDeletedAtToMerchantLimit1697549622819';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` ADD \`deletedAt\` datetime(6) NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` DROP COLUMN \`deletedAt\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1697488577576-AddNewTransferErrorCode.ts
import { randUuid } from '@ngneat/falso';
import { MigrationInterface, QueryRunner } from 'typeorm';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';

export class AddNewTransferErrorCode1697488577576
  implements MigrationInterface
{
  name = 'AddNewTransferErrorCode1697488577576';
  error = {
    uuid: randUuid(),
    errorRaw: 'la transferencia excede el límite',
    errorType: 'MERCHANT_LIMIT_EXCEED',
    errorCode: TransferErrorCode.MERCHANT_LIMIT_EXCEED,
  };

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009', 'ERROR_0010') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009', 'ERROR_0010') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`errorType\` \`errorType\` enum ('UNKNOWN_ERROR', 'PROVIDER_INTERNAL_FAILURE', 'PROVIDER_INSUFFICIENT_FUNDS', 'RECIPIENT_FIRST_TRANSFER', 'RECIPIENT_INVALID_ACCOUNT', 'RECIPIENT_DISABLED_ACCOUNT', 'DESTINATION_BANK_IN_MAINTENANCE', 'DESTINATION_BANK_NOT_AVAILABLE', 'DESTINATION_BANK_TIMEOUT', 'RECIPIENT_ACCOUNT_OVER_LIMIT', 'MERCHANT_LIMIT_EXCEED') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009', 'ERROR_0010') NOT NULL`,
    );
    await queryRunner.query(
      `INSERT INTO transfer_error (uuid , errorRaw , errorType , errorCode) VALUES (?,?,?,?);`,
      [
        this.error.uuid,
        this.error.errorRaw,
        this.error.errorType,
        this.error.errorCode,
      ],
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DELETE FROM \`transfer_error\` WHERE \`errorRaw\` = "${this.error.errorRaw}";`,
    );

    await queryRunner.query(
      `ALTER TABLE \`payout_action\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009') NOT NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`errorType\` \`errorType\` enum ('UNKNOWN_ERROR', 'PROVIDER_INTERNAL_FAILURE', 'PROVIDER_INSUFFICIENT_FUNDS', 'RECIPIENT_FIRST_TRANSFER', 'RECIPIENT_INVALID_ACCOUNT', 'RECIPIENT_DISABLED_ACCOUNT', 'DESTINATION_BANK_IN_MAINTENANCE', 'DESTINATION_BANK_NOT_AVAILABLE', 'DESTINATION_BANK_TIMEOUT', 'RECIPIENT_ACCOUNT_OVER_LIMIT') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_error\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`errorCode\` \`errorCode\` enum ('ERROR_0000', 'ERROR_0001', 'ERROR_0002', 'ERROR_0003', 'ERROR_0004', 'ERROR_0005', 'ERROR_0006', 'ERROR_0007', 'ERROR_0008', 'ERROR_0009') NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1698256901769-RemoveUnusedTransferStates.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RemoveUnusedTransferStates1698256901769
  implements MigrationInterface
{
  name = 'RemoveUnusedTransferStates1698256901769';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` CHANGE \`countryCode\` \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER', 'BRA', 'ARG', 'BOL', 'ECU', 'URY') NOT NULL DEFAULT 'CHL'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed', 'canceled') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account\` CHANGE \`countryCode\` \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER', 'BRA', 'ARG', 'BOL', 'ECU', 'URY') NOT NULL DEFAULT 'CHL'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` ADD UNIQUE INDEX \`IDX_fb21cc75cd518eb97724b1ca42\` (\`errorCode\`)`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` DROP COLUMN \`action\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` ADD \`action\` enum ('AUTO_CANCEL') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` DROP COLUMN \`suggestion\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` ADD \`suggestion\` enum ('AUTO_RETRY') NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` DROP COLUMN \`suggestion\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` ADD \`suggestion\` varchar(128) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` DROP COLUMN \`action\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` ADD \`action\` varchar(128) NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`payout_action\` DROP INDEX \`IDX_fb21cc75cd518eb97724b1ca42\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'created', 'authorizing', 'processing', 'completed', 'failed', 'canceled') NOT NULL DEFAULT 'pending'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account\` CHANGE \`countryCode\` \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER') NOT NULL DEFAULT 'CHL'`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` CHANGE \`state\` \`state\` enum ('pending', 'assigned', 'created', 'authorizing', 'processing', 'completed', 'failed', 'canceled') NULL`,
    );
    await queryRunner.query(
      `ALTER TABLE \`account_statement\` CHANGE \`countryCode\` \`countryCode\` enum ('CHL', 'COL', 'MEX', 'PER') NOT NULL DEFAULT 'CHL'`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1695929081337-CreateMerchantLimitTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateMerchantLimitTable1695929081337
  implements MigrationInterface
{
  name = 'CreateMerchantLimitTable1695929081337';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`merchant_limit\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`limitType\` enum ('rate') NOT NULL DEFAULT 'rate', \`limitDefinition\` json NOT NULL, \`state\` enum ('active', 'inactive', 'deleted') NOT NULL DEFAULT 'active', \`merchantId\` int NOT NULL, PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` ADD CONSTRAINT \`FK_38c5d1365eeba4147edc95fcb42\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`merchant_limit\` DROP FOREIGN KEY \`FK_38c5d1365eeba4147edc95fcb42\``,
    );
    await queryRunner.query(`DROP TABLE \`merchant_limit\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1694697666608-AddSoftDeleteColumnToUsers.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddSoftDeleteColumnToUsers1694697666608
  implements MigrationInterface
{
  name = 'AddSoftDeleteColumnToUsers1694697666608';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `DROP INDEX \`IDX_43e32cc306a0e09415fee4688a\` ON \`user\``,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD \`deletedAt\` datetime(6) NULL`,
    );
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_7c6802ff9d7c1ba5f61702d6ca\` ON \`user\` (\`merchantId\`, \`email\`, \`deletedAt\`)`,
    );
    await queryRunner.query(
      `ALTER TABLE \`user\` ADD CONSTRAINT \`FK_48a28cfd87e34f3df960bb374ba\` FOREIGN KEY (\`merchantId\`) REFERENCES \`merchant\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`user\` DROP FOREIGN KEY \`FK_48a28cfd87e34f3df960bb374ba\``,
    );
    await queryRunner.query(
      `DROP INDEX \`IDX_7c6802ff9d7c1ba5f61702d6ca\` ON \`user\``,
    );
    await queryRunner.query(`ALTER TABLE \`user\` DROP COLUMN \`deletedAt\``);
    await queryRunner.query(
      `CREATE UNIQUE INDEX \`IDX_43e32cc306a0e09415fee4688a\` ON \`user\` (\`merchantId\`, \`email\`)`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1672159475153-AddTransferJobTable.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddTransferJobTable1672159475153 implements MigrationInterface {
  name = 'AddTransferJobTable1672159475153';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `CREATE TABLE \`transfer_job\` (\`id\` int NOT NULL AUTO_INCREMENT, \`uuid\` varchar(36) NOT NULL, \`createdAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), \`updatedAt\` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), \`startedAt\` datetime(6) NULL, \`endedAt\` datetime(6) NULL, \`state\` enum ('started', 'created', 'finished', 'error') NOT NULL DEFAULT 'created', \`jobId\` varchar(255) NULL, \`bankAccessId\` int NOT NULL, \`totalCompleted\` int NOT NULL DEFAULT '0', \`totalFailed\` int NOT NULL DEFAULT '0', PRIMARY KEY (\`id\`)) ENGINE=InnoDB`,
    );
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` ADD CONSTRAINT \`FK_bf14426e62d77186f61702851b5\` FOREIGN KEY (\`bankAccessId\`) REFERENCES \`bank_access\`(\`id\`) ON DELETE NO ACTION ON UPDATE NO ACTION`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`transfer_job\` DROP FOREIGN KEY \`FK_bf14426e62d77186f61702851b5\``,
    );
    await queryRunner.query(`DROP TABLE \`transfer_job\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1654489386288-AddMetadataToPayouts.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddMetadataToPayouts1654489386288 implements MigrationInterface {
  name = 'AddMetadataToPayouts1654489386288';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`payout\` ADD \`metadata\` text NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE \`payout\` DROP COLUMN \`metadata\``);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1675372019393-AddProviderTypeToBankAccess.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddProviderTypeToBankAccess1675372019393
  implements MigrationInterface
{
  name = 'AddProviderTypeToBankAccess1675372019393';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` ADD \`providerType\` enum ('scraperV1', 'scraperv2', 'minka', 'liquido', 'shinkansen') NOT NULL DEFAULT 'scraperV1'`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`bank_access\` DROP COLUMN \`providerType\``,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/migrations/1703622210845-AddThomasProvider.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddThomasProvider1703622210845 implements MigrationInterface {
  name = 'AddThomasProvider1703622210845';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'minka', 'liquido', 'shinkansen', 'thomas') NOT NULL`,
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      `ALTER TABLE \`provider\` CHANGE \`providerType\` \`providerType\` enum ('scraperCG', 'scraperPW', 'minka', 'liquido', 'shinkansen') NOT NULL`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/subscribers/change-audit.subscriber.ts
import { Inject, Injectable } from '@nestjs/common';
import {
  DataSource,
  EntitySubscriberInterface,
  InsertEvent,
  RemoveEvent,
  UpdateEvent,
} from 'typeorm';
import { SoftRemoveEvent } from 'typeorm/subscriber/event/SoftRemoveEvent';
import { ClsService } from 'nestjs-cls';
import { UserLike } from 'src/services/auth/requestWithUser.interface';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { CreateAuditLogDto } from 'src/api/v2/audit-log/dto/create-audit-log.dto';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';
import { obfuscateObject } from 'src/utils/obfuscation.util';
import { SentryService } from 'src/services/sentry/sentry.service';

type AuditLogData =
  | InsertEvent<any>
  | UpdateEvent<any>
  | RemoveEvent<any>
  | SoftRemoveEvent<any>;
@Injectable()
export class ChangeAuditSubscriber implements EntitySubscriberInterface {
  constructor(
    @Inject(DataSource) private connection: DataSource,
    private auditLogService: AuditLogService,
    private cls: ClsService,
    private sentryService: SentryService,
  ) {
    this.connection.subscribers.push(this);
  }

  private get user(): UserLike {
    return this.cls.get('user');
  }

  private storeAuditLog(
    data: AuditLogData,
    event: AuditLogEvent,
  ): Promise<AuditLogEntity> {
    if (data.metadata.isJunction) return;

    const entityBefore = obfuscateObject(data['databaseEntity']);
    const entityAfter = obfuscateObject(data.entity);
    const entityType = data.metadata.targetName;

    try {
      // Avoid to create an audit log for itselft to prevent circular loop
      if (entityType === AuditLogEntity.name) return;

      // entityAfter could be undefined when deleting
      const entityId = entityAfter?.id ?? entityBefore?.id;

      const auditLog: CreateAuditLogDto = {
        authorId: this.user ? this.user.id : null,
        authorType: this.user ? this.user.constructor.name : 'PayoutsApi',
        event,
        entityId,
        entityType,
        entityAfter: JSON.stringify(entityAfter),
        entityBefore: JSON.stringify(entityBefore),
      };

      return this.auditLogService.create(auditLog);
    } catch (error) {
      this.sentryService.captureException(error, {
        extra: {
          entityBefore,
          entityAfter,
          entityType,
        },
      });
    }
  }

  afterInsert(event: InsertEvent<any>): Promise<AuditLogEntity> {
    return this.storeAuditLog(event, AuditLogEvent.INSERT);
  }

  afterUpdate(event: UpdateEvent<any>): Promise<AuditLogEntity> {
    return this.storeAuditLog(event, AuditLogEvent.UPDATE);
  }

  afterRemove(event: RemoveEvent<any>): Promise<AuditLogEntity> {
    return this.storeAuditLog(event, AuditLogEvent.REMOVE);
  }

  afterSoftRemove(event: SoftRemoveEvent<any>): Promise<AuditLogEntity> {
    return this.storeAuditLog(event, AuditLogEvent.SOFTREMOVE);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/subscribers/__mocks__/change-audit.subscriber.mock.ts
/* eslint-disable @typescript-eslint/no-empty-function */
import { Inject, Injectable } from '@nestjs/common';
import {
  DataSource,
  EntitySubscriberInterface,
  InsertEvent,
  RemoveEvent,
  UpdateEvent,
} from 'typeorm';
import { SoftRemoveEvent } from 'typeorm/subscriber/event/SoftRemoveEvent';

@Injectable()
export class ChangeAuditSubscriberMock implements EntitySubscriberInterface {
  constructor(@Inject(DataSource) private connection: DataSource) {
    this.connection.subscribers.push(this);
  }

  afterInsert(_event: InsertEvent<any>) {}

  afterUpdate(_event: UpdateEvent<any>) {}

  afterRemove(_event: RemoveEvent<any>) {}

  afterSoftRemove(_event: SoftRemoveEvent<any>) {}
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/database.constants.ts
export enum DatabaseType {
  MYSQL = 'mysql',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/query.constants.ts
export const ASCENDING_ORDER = 'ASC';
export const DESCENDING_ORDER = 'DESC';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/database/errors/database.errors.ts
export const PG_UNIQUE_CONSTRAINT_VIOLATION = '23505';
export const MYSQL_UNIQUE_CONSTRAINT_VIOLATION = 'ER_DUP_ENTRY';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/app.controller.ts
import { Controller, Get } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';

@Controller()
@ApiTags('App')
export class AppController {
  @Get()
  @RequireAuth('none')
  index(): string {
    return 'Payments Engine API';
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/main.ts
import { NestFactory } from '@nestjs/core';
import { NestApplicationOptions } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';
import { ConfigService } from '@nestjs/config';
import { CorsOptions } from '@nestjs/common/interfaces/external/cors-options.interface';
import { PaginationHeader } from './common/enums/pagination-header.enum';
import configureApp from './configure-app';
import { SentryConfig } from './config/sentry.config';
import { GeneralConfig } from './config/general.config';
import { SentryService } from './services/sentry/sentry.service';
import { ControllerVersion } from './api/common';
import { ApiV2Module } from './api/v2/api.module';

const baseDocPrefix = 'docs/api';

async function bootstrap() {
  const cors: CorsOptions = {
    origin: true,
    exposedHeaders: Object.values(PaginationHeader),
  };
  const appOptions: NestApplicationOptions = { bufferLogs: true, cors };
  const app = await NestFactory.create(AppModule, appOptions);

  const configService = app.get(ConfigService);
  const generalConfig = configService.get<GeneralConfig>('general');
  const sentryConfig = configService.get<SentryConfig>('sentry');

  SentryService.init({
    dsn: sentryConfig.dsn,
    environment: generalConfig.api.env,
    enabled: sentryConfig.enabled,
    release: generalConfig.version,
    tracesSampleRate: 1.0,
    profilesSampleRate: 1.0,
    debug: true,
  });

  configureApp(app);

  console.info('Running Payouts API with version: ', generalConfig.version);

  const optionsV2 = new DocumentBuilder()
    .setTitle('Payments Engine v2')
    .setDescription(
      'Payflow Payments Engine is an API v2 that provides bank transactions through digital wallets',
    )
    .setVersion(generalConfig.version)
    .addTag('PaymentsEngine v2')
    .addBearerAuth({
      type: 'http',
      scheme: 'bearer',
      bearerFormat: 'JWT',
      description: 'JWT Authorization',
    })
    .addSecurity('apiKey', {
      type: 'apiKey',
      in: 'header',
      name: 'X-API-KEY',
      description: 'API key',
    })
    .build();

  const documentV2 = SwaggerModule.createDocument(app, optionsV2, {
    include: [ApiV2Module],
  });

  SwaggerModule.setup(
    `${baseDocPrefix}/v${ControllerVersion.V2}`,
    app,
    documentV2,
  );

  await app.listen(generalConfig.api.port);
}

bootstrap();


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/configure-app.ts
import {
  INestApplication,
  RequestMethod,
  ValidationPipe,
  VersioningType,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { Logger, LoggerErrorInterceptor } from 'nestjs-pino';
import { env } from 'process';
import { ControllerVersion } from './api/common';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { Environment } from 'src/common/enums/environment.enum';
import { SentryService } from './services/sentry/sentry.service';

export default (app: INestApplication) => {
  const httpAdapterHost = app.get(HttpAdapterHost);
  const sentryService = app.get(SentryService);
  app.useGlobalFilters(new HttpExceptionFilter(httpAdapterHost, sentryService));

  app.useGlobalInterceptors(new LoggerErrorInterceptor());

  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
    }),
  );

  if (env.NODE_ENV !== Environment.TEST) {
    app.useLogger(app.get(Logger));
    app.setGlobalPrefix('api', {
      exclude: [{ path: '/health', method: RequestMethod.GET }],
    });
  }

  app.enableShutdownHooks();
  app.enableVersioning({
    type: VersioningType.URI,
    defaultVersion: ControllerVersion.V2,
  });

  return app;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/decorators/requireAuth.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { AuthStrategyName } from '../../../../services/auth/authStrategy.interface';

/**
 * Decorator to restrict access to a controller method to authenticated users.
 * @param ...strategies The authentication strategies that can be used
 *
 * strategies can be one of the following:
 * - A list of authentication strategies that can be used. [jwtMFA, jwt, apikey]
 * - 'none' - no authentication required
 * - undefined - use any strategy
 *
 * **Important**: if a request presents multiple authentication strategies, a `BadRequestException` is thrown.
 */
export const RequireAuth = (...strategies: AuthStrategyName[] | ['none']) =>
  SetMetadata('auth', strategies);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/auth.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';
import { AuthService } from 'src/services/auth/auth.service';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { MailService } from 'src/services/mail/mail.service';
import { JwtService } from '@nestjs/jwt';
import { UserService } from 'src/models/user/user.service';
import { LoginUserDto } from './dto/login-user.dto';
import { RegisterUserDto } from './dto/register-user.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { NotFoundException } from '@nestjs/common';

describe('AuthController', () => {
  let authController: AuthController;
  let authService: AuthService;
  const mockUserService = {};
  const mockJwtService = {
    sign: () => 'jwt',
  };
  const mockMailService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        AuthService,
        {
          provide: UserService,
          useValue: mockUserService,
        },
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
        {
          provide: MailService,
          useValue: mockMailService,
        },
      ],
    }).compile();

    authController = module.get<AuthController>(AuthController);
    authService = module.get<AuthService>(AuthService);
  });

  describe('login', () => {
    it('should return a JWT when given valid credentials', async () => {
      const loginDto: LoginUserDto = {
        email: 'test@example.com',
        password: 'password',
        mfaCode: 'some',
      };
      const user = new UserEntity();
      user.email = loginDto.email;
      user.password = loginDto.password;

      jest.spyOn(authService, 'login').mockReturnValue(Promise.resolve(user));

      expect((await authController.login(loginDto)).token).toBe('jwt');
    });
  });

  describe('register', () => {
    it('should return a user when given valid data', async () => {
      const registerDto: RegisterUserDto = {
        email: 'test@example.com',
        name: 'Test User',
        merchantId: 1,
        role: UserRole.ADMIN,
      };
      const user = new UserEntity();
      user.email = registerDto.email;
      user.name = registerDto.name;
      jest
        .spyOn(authService, 'register')
        .mockImplementation(() => Promise.resolve(user));

      expect(await authController.register(registerDto)).toBe(user);
    });
  });

  describe('resetPassword', () => {
    it('should return success message when user exists', async () => {
      const userId = '1';
      const result = {
        message: `Password for user ${userId} was reset successfully`,
      };

      jest
        .spyOn(authService, 'resetPassword')
        .mockImplementation(() => Promise.resolve());

      expect(await authController.resetPassword(userId)).toEqual(result);
    });

    it('should throw when user does not exist', async () => {
      const userId = '2';

      jest.spyOn(authService, 'resetPassword').mockImplementation(() => {
        throw new NotFoundException(`User with id ${userId} not found`);
      });

      try {
        await authController.resetPassword(userId);
      } catch (e) {
        expect(e).toBeInstanceOf(NotFoundException);
        expect(e.message).toEqual(`User with id ${userId} not found`);
      }
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/auth.controller.ts
import { LoginUserDto } from './dto/login-user.dto';
import { Body, Controller, HttpCode, Param, Patch, Post } from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { AuthService } from 'src/services/auth/auth.service';
import { RegisterUserDto } from './dto/register-user.dto';
import { UpdateMFAEnrollUserDto } from './dto/update-mfa-enroll-user.dto';
import { UpdateMFAVerifyUserDto } from './dto/update-mfa-verify-user.dto';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { User } from 'src/common/decorators/user.decorator';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { ChangeUserPasswordDto } from './dto/change-user-password.dto';
@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Auth')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Auth })
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  async register(@Body() registerUserDto: RegisterUserDto): Promise<any> {
    return this.authService.register(registerUserDto);
  }

  /**
   * **TODO:** specific strategy methods should be moved to a strategy service
   */
  @Post('login')
  @HttpCode(200)
  @RequireAuth('none')
  async login(@Body() loginUserDto: LoginUserDto) {
    const user = await this.authService.login(loginUserDto);
    const token = this.authService.generateToken(user);
    return { token };
  }

  @Post('mfa/init')
  @HttpCode(201)
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER, UserRole.ADMIN, UserRole.SUPPORT)
  async initMFA(@User() user: UserEntity) {
    const otpauthUrl = await this.authService.mfaInit(user.id);
    return { otpauthUrl };
  }

  @Patch('mfa/enroll')
  @HttpCode(201)
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER, UserRole.ADMIN, UserRole.SUPPORT)
  async verifyMFA(
    @User() user: UserEntity,
    @Body() updateMFAEnrollUserDto: UpdateMFAEnrollUserDto,
  ) {
    return await this.authService.mfaEnroll(
      user.id,
      user.seed,
      updateMFAEnrollUserDto,
    );
  }

  @Patch('mfa/verify')
  @HttpCode(201)
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER, UserRole.ADMIN, UserRole.SUPPORT)
  async activateMFA(
    @User() user: UserEntity,
    @Body() updateMFAVerifyUserDto: UpdateMFAVerifyUserDto,
  ) {
    return this.authService.mfaVerify(user, updateMFAVerifyUserDto);
  }

  @Patch('mfa/reset/:id')
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER)
  async resetMFA(@Param('id') userId: string) {
    await this.authService.resetMFA(+userId);
    return { message: `MFA for user ${userId} was reset successfully` };
  }

  @Patch('reset-password/:id')
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER)
  async resetPassword(@Param('id') userId: string) {
    await this.authService.resetPassword(+userId);
    return { message: `Password for user ${userId} was reset successfully` };
  }

  @Patch('change-password')
  @RequireAuth('jwt')
  @Roles(UserRole.SUPER, UserRole.ADMIN, UserRole.SUPPORT, UserRole.USER)
  async changePassword(
    @User('id') userId: number,
    @Body() changePasswordDto: ChangeUserPasswordDto,
  ) {
    await this.authService.changePassword(userId, changePasswordDto);
    return { message: `Password for user ${userId} was changed successfully` };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/dto/update-mfa-verify-user.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class UpdateMFAVerifyUserDto {
  @IsString()
  @IsNotEmpty()
  password: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/dto/change-user-password.dto.ts
import {
  IsNotEmpty,
  IsString,
  MinLength,
  MaxLength,
  Matches,
  IsOptional,
} from 'class-validator';

export class ChangeUserPasswordDto {
  @IsNotEmpty()
  @IsString()
  readonly oldPassword: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(8, {
    message: 'Password is too short, minimum length is 8 characters.',
  })
  @MaxLength(50, {
    message: 'Password is too long, maximum length is 50 characters.',
  })
  @Matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,50}$/, {
    message:
      'Password too weak. It must contain at least one uppercase letter, one lowercase letter, and one number.',
  })
  readonly newPassword: string;

  @IsNotEmpty()
  @IsString()
  readonly confirmNewPassword: string;

  @IsOptional()
  @IsString()
  readonly mfaCode?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/dto/update-mfa-enroll-user.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class UpdateMFAEnrollUserDto {
  @IsString()
  @IsNotEmpty()
  code: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/dto/login-user.dto.ts
import { IsEmail, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class LoginUserDto {
  @IsString()
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsString()
  @IsNotEmpty()
  password: string;

  @IsString()
  @IsOptional()
  mfaCode: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/auth/dto/register-user.dto.ts
import {
  IsEmail,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsString,
} from 'class-validator';
import { UserRole } from 'src/common/enums/user-role.enum';

export class RegisterUserDto {
  @IsString()
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsNumber()
  @IsNotEmpty()
  merchantId: number;

  @IsEnum(UserRole)
  @IsNotEmpty()
  role: UserRole;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-job/dtos/update-transfer-job.dto.ts
import {
  IsDateString,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';

export class UpdateTransferJobDto {
  @IsDateString()
  @IsOptional()
  startedAt?: string;

  @IsDateString()
  @IsOptional()
  endedAt?: string;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  jobId?: string;

  @IsEnum(TransferJobState)
  @IsOptional()
  state?: TransferJobState;

  @IsNumber()
  @IsOptional()
  totalCompleted?: number;

  @IsNumber()
  @IsOptional()
  totalFailed?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-job/dtos/create-transfer-job.dto.ts
import {
  IsDateString,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';

export class CreateTransferJobDto {
  @IsDateString()
  @IsOptional()
  startedAt?: string;

  @IsEnum(TransferJobState)
  @IsOptional()
  state?: TransferJobState;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  jobId?: string;

  @IsNumber()
  @IsPositive()
  providerId: number;

  @IsNumber()
  @IsOptional()
  totalCompleted?: number;

  @IsNumber()
  @IsOptional()
  totalFailed?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-job/transfer-job.controller.ts
import { Body, Controller, HttpCode, Param, Patch, Post } from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { CreateTransferJobDto } from './dtos/create-transfer-job.dto';
import { UpdateTransferJobDto } from './dtos/update-transfer-job.dto';
import { TransferJobService } from 'src/models/transfer-job/transfer-job.service';
import { ControllerRoute, ControllerVersion } from 'src/api/common';

@ApiBearerAuth()
@ApiSecurity('apikey')
@ApiTags('Transfer Job')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.TransferJob,
})
export class TransferJobController {
  constructor(private transferJobService: TransferJobService) {}

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  create(@Body() createTransferJobDto: CreateTransferJobDto) {
    return this.transferJobService.create(createTransferJobDto);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  patch(
    @Param('id') id: string,
    @Body() updateTransferJobDto: UpdateTransferJobDto,
  ) {
    return this.transferJobService.update(+id, updateTransferJobDto);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-job/transfer-job.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferJobController } from './transfer-job.controller';
import { TransferJobService } from 'src/models/transfer-job/transfer-job.service';

describe('TransferJobController', () => {
  let controller: TransferJobController;
  const fakeTransferJobService = {};
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TransferJobController],
      providers: [
        { provide: TransferJobService, useValue: fakeTransferJobService },
      ],
    }).compile();

    controller = module.get<TransferJobController>(TransferJobController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/provider.controller.ts
import {
  Body,
  Controller,
  Delete,
  ForbiddenException,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { ProviderService } from 'src/models/provider/provider.service';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { FindManyOptions, Like } from 'typeorm';
import { CreateProviderDto } from './dto/create-provider.dto';
import { GetProvidersQueryDto } from './dto/get-providers-query-dto';
import { UpdateProviderDto } from './dto/update-provider.dto';
import { AccountService } from 'src/models/account/account.service';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';

const ByAccountPath = `${ControllerRoute.Account}/:accountId/${ControllerRoute.Provider}`; // front
const ByMerchantPath = `${ControllerRoute.Merchant}/:merchantId/${ControllerRoute.Provider}`;
@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Provider')
@Controller({
  version: ControllerVersion.V2,
})
export class ProviderController {
  constructor(
    private readonly providerService: ProviderService,
    private accountService: AccountService,
  ) {}

  @Get(ByAccountPath)
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  findAllForAccount(
    @MerchantId({ required: true }) merchantId: number,
    @Query() query: GetProvidersQueryDto,
    @Param('accountId') accountId: string,
  ) {
    const { page, limit, search } = query;

    // TODO: Add merchantId to providers
    const options: FindManyOptions<ProviderEntity> = {
      relations: ['account'],
      where: {
        account: { id: +accountId, merchantId },
        ...(search && { name: Like(`%${search}%`) }),
      },
    };

    return this.providerService.findAllPaginated({ page, limit, options });
  }

  // TODO: unify find all controllers
  @Get(ByMerchantPath)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  findAllForMerchant(
    @User('merchantId') userMerchantId: number,
    @User('role') role: UserRole,
    @Param('merchantId') merchantId: string,
  ) {
    const isSuper = role === UserRole.SUPER;
    const hasDifferentMerchant = userMerchantId !== +merchantId;

    if (!isSuper && hasDifferentMerchant) {
      throw new ForbiddenException("Can't get providers for other merchant");
    }

    const options: FindManyOptions<ProviderEntity> = {
      where: {
        account: {
          merchantId: +merchantId,
        },
      },
      relations: ['account'],
    };

    return this.providerService.findAll(options);
  }

  @Get(`${ControllerRoute.Provider}`)
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  findAll(
    @User('merchantId') userMerchantId: number,
    @User('role') role: UserRole,
  ) {
    const isSuper = role === UserRole.SUPER;

    const options: FindManyOptions<ProviderEntity> = {
      where: {
        account: { ...(!isSuper && { merchantId: userMerchantId }) },
      },
      relations: ['account'],
    };

    return this.providerService.findAll(options);
  }

  @Get(`${ControllerRoute.Provider}/:id`)
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  async findOneForMerchant(
    @User('merchantId') userMerchantId: number,
    @Param('id') id: string,
  ) {
    const provider = await this.providerService.findOneByConditions({
      where: {
        id: +id,
        account: {
          merchantId: +userMerchantId,
        },
      },
      relations: ['account'],
    });
    if (!provider) throw new NotFoundException(`Provider ${id} not found`);
    return provider;
  }

  @Get(`${ByAccountPath}/:id`)
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  async findOne(
    @MerchantId({ required: true }) merchantId: number,
    @Param('id') id: string,
    @Param('accountId') accountId: string,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +accountId, merchantId },
    });

    if (!account) {
      throw new ForbiddenException(
        "The account doesn't belong to the merchant",
      );
    }

    const provider = await this.providerService.findOneByConditions({
      where: { id: +id, accountId: +accountId },
      relations: ['account'],
    });

    if (!provider) throw new NotFoundException(`Provider ${id} not found`);

    return provider;
  }

  @Post(ByAccountPath)
  @HttpCode(201)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  async create(
    @User('merchantId') merchantId: number,
    @Param('accountId') accountId: string,
    @Body() createProviderDto: CreateProviderDto,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +accountId, merchantId },
    });

    if (!account)
      throw new ForbiddenException(
        "The account doesn't belong to the merchant",
      );

    createProviderDto.accountId = account.id;
    return this.providerService.create(createProviderDto);
  }

  @Patch(`${ByAccountPath}/:id`)
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  async update(
    @User('merchantId') merchantId: number,
    @Param('id') id: string,
    @Param('accountId') accountId: string,
    @Body() updateProviderDto: UpdateProviderDto,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +accountId, merchantId },
    });

    if (!account) {
      throw new ForbiddenException(
        "The account doesn't belong to the merchant",
      );
    }

    const provider = await this.providerService.findOneByConditions({
      where: { id: +id, accountId: +accountId },
      relations: ['account'],
    });

    if (!provider) throw new NotFoundException(`Provider ${id} not found`);

    return this.providerService.update(+id, updateProviderDto);
  }

  @Delete(`${ByAccountPath}/:id`)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  async remove(
    @User('merchantId') merchantId: number,
    @Param('id') id: string,
    @Param('accountId') accountId: string,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +accountId, merchantId },
    });

    if (!account) {
      throw new ForbiddenException(
        "The account doesn't belong to the merchant",
      );
    }

    const provider = await this.providerService.findOneByConditions({
      where: { id: +id, accountId: +accountId },
      relations: ['account'],
    });

    if (!provider) throw new NotFoundException(`Provider ${id} not found`);

    return this.providerService.remove(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/dto/create-provider.dto.ts
import {
  IsArray,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
  MaxLength,
} from 'class-validator';
import { IsNotThomasProvider } from 'src/common/decorators/custom-validators/is-not-thomas-provider.validator';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';

export class CreateProviderDto {
  @IsString()
  @MaxLength(128)
  @IsNotEmpty()
  name: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;

  @IsObject()
  @IsOptional()
  rules?: RuleDefinition;

  @IsObject()
  @IsOptional()
  credentials?: any;

  @IsEnum(ProviderType)
  @IsNotThomasProvider()
  providerType: ProviderType;

  @IsOptional()
  @IsArray()
  @IsEnum(ProviderCapability, { each: true })
  capabilities?: ProviderCapability[];

  @IsNumber()
  @IsPositive()
  @IsOptional()
  priority?: number;

  @IsNumber()
  @IsOptional()
  accountId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/dto/update-provider.dto.ts
import {
  IsArray,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
  MaxLength,
} from 'class-validator';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { State } from 'src/common/enums/state.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';

export class UpdateProviderDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(128)
  @IsOptional()
  name?: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  priority?: number;

  @IsOptional()
  @IsArray()
  @IsEnum(ProviderCapability, { each: true })
  capabilities?: ProviderCapability[];

  @IsObject()
  @IsOptional()
  credentials?: any;

  @IsObject()
  @IsOptional()
  rules?: RuleDefinition;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/dto/get-providers-query-dto.ts
import { IsOptional, IsString } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetProvidersQueryDto extends QueryPaginatedDto {
  @IsOptional()
  @IsString()
  public search?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/decorators/shinkansen.webhook.decorator.ts
import {
  BadRequestException,
  createParamDecorator,
  ExecutionContext,
  Logger,
} from '@nestjs/common';
import { plainToClass } from 'class-transformer';
import { validate } from 'class-validator';
import { ShinkansenTransactionUpdateDto } from 'src/api/v2/provider/webhooks/dto/shinkansen-transaction-update.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { UpdateTransactionDto } from 'src/providers/common/dtos/update-transaction.dto';
import { ShinkansenTransactionResponseDto } from 'src/providers/shinkansen/dto/shinkansen.transaction.response.dto';
import { translateShinkansenStatus } from 'src/providers/shinkansen/utils/state';

const logger = new Logger('ShinkansenWebhookDecoratorLogger');

export const ShinkansenWebhookValidator = createParamDecorator(
  async (data: unknown, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    const updateTransactionDto: ShinkansenTransactionUpdateDto = request.body;
    const validatedPayload = plainToClass(
      ShinkansenTransactionUpdateDto,
      updateTransactionDto,
    );
    const errors = await validate(validatedPayload);
    if (errors.length > 0) {
      throw new BadRequestException('Invalid payload');
    }
    try {
      const { responses } = updateTransactionDto.document;
      const [response] = responses;

      const transaction = response as ShinkansenTransactionResponseDto;

      const {
        shinkansen_transaction_status: status,
        shinkansen_transaction_id: externalId,
        response_message,
        response_status,
      } = transaction;

      // response_message is empty for successful transactions
      const message = response_message || response_status;
      const state = translateShinkansenStatus(status);
      const metadata: UpdateTransactionDto['metadata'] = {};
      if (state === TransferState.FAILED) {
        metadata.providerErrorCode = response_status;
      }

      const updateTransaction: UpdateTransactionDto = {
        externalId,
        message,
        state,
        metadata,
      };
      return updateTransaction;
    } catch (e) {
      logger.log('Invalid shinkansenPayload');
      logger.error(e);
    }
  },
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/decorators/liquido.webhook.decorator.ts
import {
  BadRequestException,
  createParamDecorator,
  ExecutionContext,
  Logger,
} from '@nestjs/common';
import { plainToClass } from 'class-transformer';
import { validate } from 'class-validator';
import { LiquidoTransactionUpdateDto } from 'src/api/v2/provider/webhooks/dto/liquido-transaction-update.dto';
import { LiquidoTransactionState } from 'src/common/enums/liquido-transaction-state.enum';
import { UpdateTransactionDto } from 'src/providers/common/dtos/update-transaction.dto';
import { translateLiquidoStateToTransferState } from 'src/providers/common/state-translators/liquido-state.translator';

const logger = new Logger('LiquidoWebhookDecoratorLogger');

export const LiquidoWebhook = createParamDecorator(
  async (data: unknown, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    const updateTransactionDto: LiquidoTransactionUpdateDto = request.body;
    const validatedPayload = plainToClass(
      LiquidoTransactionUpdateDto,
      updateTransactionDto,
    );
    const errors = await validate(validatedPayload);
    if (errors.length > 0) {
      throw new BadRequestException('Invalid payload');
    }
    try {
      const { transferStatus, idempotencyKey } = updateTransactionDto;

      const updatedState = translateLiquidoStateToTransferState(
        transferStatus as LiquidoTransactionState,
      );

      const updateTransaction: UpdateTransactionDto = {
        externalId: idempotencyKey,
        state: updatedState,
      };
      return updateTransaction;
    } catch (e) {
      logger.log('Invalid LiquidoPayload');
    }
  },
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/provider-webhooks.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { ProviderWebHooksController } from './provider-webhooks.controller';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';
import { ShinkansenGuard } from 'src/common/guards/shinkansen.guard';
import { TransferService } from 'src/models/transfer/transfer.service';
import { ScraperGuard } from 'src/common/guards/scraper.guard';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';
import { ProviderService } from 'src/models/provider/provider.service';
import { ThomasProviderAdapter } from 'src/providers/thomas/thomas.provider';
import thomasConfig from 'src/config/thomas.config';

describe('ProviderWebhooksController', () => {
  let controller: ProviderWebHooksController;
  const fakeTransferService = {};
  const fakeShinkansenProvider = {};
  const fakeTransferProviderService = {};
  const fakeShinkansenGuard = {};
  const fakeScraperGuard = {};
  const fakeLiquidoProvider = {};
  const fakeProviderService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProviderWebHooksController],
      providers: [
        { provide: TransferService, useValue: fakeTransferService },
        { provide: ShinkansenProvider, useValue: fakeShinkansenProvider },
        {
          provide: TransferProviderService,
          useValue: fakeTransferProviderService,
        },
        { provide: LiquidoProviderAdapter, useValue: fakeLiquidoProvider },
        { provide: ProviderService, useValue: fakeProviderService },
        { provide: thomasConfig.KEY, useValue: {} },
        { provide: ThomasProviderAdapter, useValue: {} },
      ],
    })
      .overrideGuard(ShinkansenGuard)
      .useValue(fakeShinkansenGuard)
      .overrideGuard(ScraperGuard)
      .useValue(fakeScraperGuard)
      .compile();

    controller = module.get<ProviderWebHooksController>(
      ProviderWebHooksController,
    );
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/provider-webhooks.controller.ts
import {
  Body,
  Controller,
  HttpCode,
  HttpException,
  HttpStatus,
  Inject,
  Logger,
  Param,
  Post,
  UseGuards,
  ValidationPipe,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { plainToInstance } from 'class-transformer';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ScraperGuard } from 'src/common/guards/scraper.guard';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { UpdateTransactionDto } from 'src/providers/common/dtos/update-transaction.dto';
import { ShinkansenGuard } from 'src/common/guards/shinkansen.guard';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { ShinkansenWebhookValidator } from 'src/api/v2/provider/webhooks/decorators/shinkansen.webhook.decorator';
import { LiquidoWebhook } from './decorators/liquido.webhook.decorator';
import { LiquidoProviderValidateOrigin } from './guards/liquido.provider.validate.guard';
import { ThomasGuard } from './guards/thomas.guard';

@ApiTags('Provider Webhooks')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.Provider,
})
export class ProviderWebHooksController {
  @Inject()
  private transferProviderService: TransferProviderService;

  private readonly logger = new Logger('ProviderWebHooksControllerLogger');

  @RequireAuth('none')
  @HttpCode(200)
  @UseGuards(ScraperGuard)
  @Post(`/:providerId/${ControllerRoute.Scraper}/updates`)
  async updateTransaction(@Body() updateTransactionDto: UpdateTransactionDto) {
    const updatedTransfer = await this.transferProviderService.updateTransfer(
      updateTransactionDto,
    );

    const updatedTransaction = plainToInstance(
      TransactionDto,
      updatedTransfer,
      { excludeExtraneousValues: true },
    );

    return updatedTransaction;
  }

  @RequireAuth('none')
  @HttpCode(200)
  @UseGuards(ShinkansenGuard)
  @Post(`/webhooks/${ProviderType.Shinkansen}`)
  async shinkansenWebhook(
    @Body(new ValidationPipe()) payload: any,
    @ShinkansenWebhookValidator() updateTransactionDto: UpdateTransactionDto,
  ) {
    try {
      await this.transferProviderService.updateTransfer(updateTransactionDto);
      return HttpStatus.OK;
    } catch (e) {
      this.logger.error(
        `An error occurred on endpoint shinkansenWebhook. ${e}`,
      );
      this.logger.error(e);
      throw new HttpException(e?.message, HttpStatus.BAD_REQUEST);
    }
  }

  @RequireAuth('none')
  @HttpCode(200)
  @UseGuards(ShinkansenGuard)
  @Post(`/:providerId/${ProviderType.Shinkansen}/updates`)
  async updateShinkansenTransaction(
    @Body(new ValidationPipe()) payload: any,
    @ShinkansenWebhookValidator() updateTransactionDto: UpdateTransactionDto,
  ) {
    try {
      await this.transferProviderService.updateTransfer(updateTransactionDto);
      return HttpStatus.OK;
    } catch (e) {
      this.logger.error(
        `An error occurred on webhook updateShinkansenTransaction. ${e}`,
      );
      this.logger.error(e);
      throw new HttpException(e?.message, HttpStatus.BAD_REQUEST);
    }
  }

  @RequireAuth('none')
  @HttpCode(200)
  @UseGuards(LiquidoProviderValidateOrigin)
  @Post(`/:providerId/${ProviderType.Liquido}/updates`)
  async updateLiquidoTransaction(
    @Param('providerId') providerId: number,
    @Body(new ValidationPipe()) payload: any,
    @LiquidoWebhook() updateTransactionDto: UpdateTransactionDto,
  ) {
    try {
      await this.transferProviderService.updateTransfer(updateTransactionDto);
      return HttpStatus.OK;
    } catch (e) {
      this.logger.error(
        `An error occurred on webhook updateLiquidoTransaction. ${e}`,
      );
      this.logger.error(e);
      throw new HttpException(e?.message, HttpStatus.BAD_REQUEST);
    }
  }

  @RequireAuth('none')
  @HttpCode(200)
  @UseGuards(ThomasGuard)
  @Post(`:providerId/${ProviderType.Thomas}/updates`)
  async updateTransactionThomas(
    @Body() updateTransactionDto: UpdateTransactionDto,
  ) {
    const updatedTransfer = await this.transferProviderService.updateTransfer(
      updateTransactionDto,
    );
    const updatedTransaction = plainToInstance(
      TransactionDto,
      updatedTransfer,
      { excludeExtraneousValues: true },
    );

    return updatedTransaction;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/dto/shinkansen-transaction-update.dto.ts
import { IsArray, IsObject } from 'class-validator';

class Receiver {
  fin_id: string;
  fin_id_schema: string;
}

class Sender {
  fin_id: string;
  fin_id_schema: string;
}

class Header {
  creation_date: Date;
  message_id: string;
  receiver: Receiver;
  sender: Sender;
  shinkansen_message_id: string;
}

export class ShinkansenResponse {
  response_id: string;
  response_message: string;
  response_status: string;
  shinkansen_transaction_id: string;
  shinkansen_transaction_message: string;
  shinkansen_transaction_status: string;
  transaction_id: string;
  transaction_type: string;
}

class Document {
  header: Header;
  @IsArray()
  responses: ShinkansenResponse[];
}

export class ShinkansenTransactionUpdateDto {
  @IsObject()
  document: Document;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/dto/liquido-transaction-update.dto.ts
export class LiquidoTransactionUpdateDto {
  statusCode: number;
  errorMsg: string;
  transactionId: string;
  idempotencyKey: string;
  referenceNumber: string;
  targetName: string;
  targetDocument: string;
  targetBankName: string;
  targetBankCode: string;
  targetBankBranchId: string;
  targetBankAccountId: string;
  amount: string;
  amountInCents: number;
  currency: string;
  paidAmount: number;
  paidCurrency: string;
  exchangeRate: number;
  paidTax: number;
  createTime: string;
  finalStatusTime: string;
  transferStatus: string;
  transferStatusCode: number;
  transferErrorMsg: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/guards/liquido.provider.validate.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
  Logger,
} from '@nestjs/common';
import { ProviderService } from 'src/models/provider/provider.service';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';

const logger = new Logger('LiquidoProviderGuardLogger');

@Injectable()
export class LiquidoProviderValidateOrigin implements CanActivate {
  @Inject()
  private readonly liquidoProvider: LiquidoProviderAdapter;
  @Inject()
  private providerService: ProviderService;
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const signature: string = request.headers['liquido-signature'];
    const params = context.switchToHttp().getRequest().params;
    const providerId: number = params.providerId;
    const provider = await this.providerService.findOne(providerId);
    if (!provider) return false;
    const headerElements = signature.split(',');
    if (headerElements.length < 2) return false;
    const timestamp = headerElements
      .find((el) => el.startsWith('timestamp='))
      .split('=')[1];

    const headerSignature = headerElements
      .find((el) => el.startsWith('signature='))
      .split('=')[1];
    const body = request.body;
    const strBody = JSON.stringify(body);

    const message = `payload=${strBody},timestamp=${timestamp}`;
    const isValidSignature = await this.liquidoProvider.verifySignature(
      message,
      headerSignature,
      provider,
    );
    logger.log(
      `Validation of liquidoProvider webhook signature was ${isValidSignature}`,
    );
    return isValidSignature;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/guards/liquido.provider.validate.guard.spec.ts
import { ExecutionContext } from '@nestjs/common';
import { createHmac } from 'crypto';
import { LiquidoProviderValidateOrigin } from './liquido.provider.validate.guard';
import { createMock } from '@golevelup/ts-jest';

describe('LiquidoValidateOrigin', () => {
  let guard: LiquidoProviderValidateOrigin;
  let liquidoProvider;
  let providerService;
  let executionContext;

  beforeEach(() => {
    liquidoProvider = {
      verifySignature: jest.fn(),
    };
    providerService = {
      findOne: jest.fn(),
    };

    executionContext = createMock<ExecutionContext>();

    guard = new LiquidoProviderValidateOrigin();
    (guard as any).liquidoProvider = liquidoProvider;
    (guard as any).providerService = providerService;
  });

  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  it('should return true when the signature is valid', async () => {
    const secret = 'my-secret-key';
    const payload = { data: 'test' };
    const timestamp = Date.now().toString();
    const message = `payload=${JSON.stringify(payload)},timestamp=${timestamp}`;

    const hmac = createHmac('sha256', secret);
    hmac.update(message);
    const signature = hmac.digest('hex');

    executionContext.switchToHttp().getRequest.mockReturnValue({
      headers: {
        'liquido-signature': `algorithm=HmacSHA256,timestamp=${timestamp},signature=${signature}`,
      },
      body: payload,
      params: { providerId: 1 },
    });

    providerService.findOne.mockReturnValue({ id: 1 });
    liquidoProvider.verifySignature.mockReturnValue(true);
    expect(
      await guard.canActivate(executionContext as unknown as ExecutionContext),
    ).toBe(true);
  });

  it('should return false when the signature is invalid', async () => {
    executionContext.switchToHttp().getRequest.mockReturnValue({
      headers: {
        'liquido-signature':
          'algorithm=HmacSHA256,timestamp=123,signature=invalid',
      },
      body: { data: 'test' },
      params: { providerId: 1 },
    });

    providerService.findOne.mockReturnValue({ id: 1 });
    liquidoProvider.verifySignature.mockReturnValue(false);

    expect(
      await guard.canActivate(executionContext as unknown as ExecutionContext),
    ).toBe(false);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/webhooks/guards/thomas.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
} from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { PAYOUTS_HEADER } from 'src/common/guards/device.guard';
import thomasConfig from 'src/config/thomas.config';
import { validateSignature } from 'src/utils/secrets.util';

@Injectable()
export class ThomasGuard implements CanActivate {
  @Inject(thomasConfig.KEY)
  private config: ConfigType<typeof thomasConfig>;
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const { body, headers } = context.switchToHttp().getRequest();

    const { hmacKey } = this.config;
    const header = String(headers[PAYOUTS_HEADER]);
    const validSignature = validateSignature(hmacKey, header, body);

    return validSignature;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/provider/provider.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountService } from 'src/models/account/account.service';
import { ProviderService } from 'src/models/provider/provider.service';
import { ProviderController } from './provider.controller';

describe('ProviderController', () => {
  let controller: ProviderController;
  const fakeProviderService = {};
  const fakeAccountService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProviderController],
      providers: [
        { provide: ProviderService, useValue: fakeProviderService },
        { provide: AccountService, useValue: fakeAccountService },
      ],
    }).compile();

    controller = module.get<ProviderController>(ProviderController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/webhook-endpoint/webhook-endpoint.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';
import { CreateWebhookEndpointDto } from './dto/create-webhook-endpoint.dto';
import { UpdateWebhookEndpointDto } from './dto/update-webhook-endpoint.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { FindManyOptions, FindOneOptions } from 'typeorm';
import { WebhookEndpointEntity } from 'src/models/webhook-endpoint/entities/webhook-endpoint.entity';
import { ControllerRoute, ControllerVersion } from 'src/api/common';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Webhook Endpoint')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.WebhookEndpoint,
})
export class WebhookEndpointController {
  constructor(
    private readonly webhookEndpointService: WebhookEndpointService,
  ) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  findAll(@User('merchantId') merchantId: number) {
    const options: FindManyOptions<WebhookEndpointEntity> = {
      where: { merchantId },
    };
    return this.webhookEndpointService.findAll(options);
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  findOne(@User('merchantId') merchantId: number, @Param('id') id: string) {
    const options: FindOneOptions<WebhookEndpointEntity> = {
      where: { id: +id, merchantId },
    };
    return this.webhookEndpointService.findOneByConditions(options);
  }

  @Post()
  @HttpCode(201)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  create(
    @User('merchantId') merchantId: number,
    @Body() createWebhookEndpointDto: CreateWebhookEndpointDto,
  ) {
    createWebhookEndpointDto.merchantId = merchantId;
    return this.webhookEndpointService.create(createWebhookEndpointDto);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  update(
    @Param('id') id: string,
    @Body() updateWebhookEndpointDto: UpdateWebhookEndpointDto,
  ) {
    return this.webhookEndpointService.update(+id, updateWebhookEndpointDto);
  }

  @Delete(':id')
  @HttpCode(204)
  @Roles(UserRole.SUPER)
  remove(@Param('id') id: string) {
    return this.webhookEndpointService.remove(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/webhook-endpoint/dto/update-webhook-endpoint.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateWebhookEndpointDto } from './create-webhook-endpoint.dto';

export class UpdateWebhookEndpointDto extends PartialType(
  CreateWebhookEndpointDto,
) {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/webhook-endpoint/dto/create-webhook-endpoint.dto.ts
import {
  IsArray,
  IsEnum,
  IsNotEmpty,
  IsOptional,
  IsString,
} from 'class-validator';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointState } from 'src/common/enums/webhook-endpoint-state.enum';

export class CreateWebhookEndpointDto {
  @IsString()
  @IsNotEmpty()
  url: string;

  @IsString()
  @IsOptional()
  description: string;

  @IsArray()
  @IsNotEmpty()
  enabledEvents: WebhookEvent[];

  @IsEnum(WebhookEndpointState)
  @IsOptional()
  state: WebhookEndpointState;

  @IsOptional()
  merchantId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/webhook-endpoint/webhook-endpoint.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { WebhookEndpointController } from './webhook-endpoint.controller';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';

describe('WebhookEndpointController', () => {
  let controller: WebhookEndpointController;

  beforeEach(async () => {
    const mockWebhookEndpointService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [WebhookEndpointController],
      providers: [
        WebhookEndpointService,
        {
          provide: WebhookEndpointService,
          useValue: mockWebhookEndpointService,
        },
      ],
    }).compile();

    controller = module.get<WebhookEndpointController>(
      WebhookEndpointController,
    );
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant/merchant.controller.ts
import {
  Controller,
  Get,
  Body,
  Patch,
  HttpCode,
  Post,
  Param,
  Delete,
  UseInterceptors,
  Query,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { MerchantService } from 'src/models/merchant/merchant.service';
import { UpdateMerchantDto } from './dto/update-merchant.dto';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { CreateMerchantDto } from './dto/create-merchant.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { GetMerchantsQueryDto } from './dto/get-merchants-query.dto';
import { ControllerRoute, ControllerVersion } from 'src/api/common';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Merchant')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Merchant })
export class MerchantController {
  constructor(private readonly merchantService: MerchantService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  findAll(@Query() query: GetMerchantsQueryDto) {
    return this.merchantService.findAllPaginated(query);
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  findOne(@User() user: UserEntity): MerchantEntity {
    return user.merchant;
  }

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  @RequireAuth('none')
  create(@Body() createMerchantDto: CreateMerchantDto) {
    return this.merchantService.create(createMerchantDto);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  update(
    @User() user: UserEntity,
    @Body() updateMerchantDto: UpdateMerchantDto,
  ) {
    return this.merchantService.update(user.merchant.id, updateMerchantDto);
  }

  @Delete(':id')
  @HttpCode(204)
  @Roles(UserRole.SUPER)
  remove(@Param('id') id: string) {
    return this.merchantService.remove(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant/merchant.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { MerchantController } from './merchant.controller';
import { MerchantService } from 'src/models/merchant/merchant.service';

describe('MerchantController', () => {
  let controller: MerchantController;

  beforeEach(async () => {
    const mockMerchantService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MerchantController],
      providers: [
        MerchantService,
        {
          provide: MerchantService,
          useValue: mockMerchantService,
        },
      ],
    }).compile();

    controller = module.get<MerchantController>(MerchantController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant/dto/update-merchant.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateMerchantDto } from './create-merchant.dto';

export class UpdateMerchantDto extends PartialType(CreateMerchantDto) {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant/dto/create-merchant.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateMerchantDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  identifier: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant/dto/get-merchants-query.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetMerchantsQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-method/transfer-method.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { TransferMethodService } from 'src/models/transfer-method/transfer-method.service';
import { CreateTransferMethodDto } from './dto/create-transfer-method.dto';
import { UpdateTransferMethodDto } from './dto/update-transfer-method.dto';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { User } from 'src/common/decorators/user.decorator';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { FindManyOptions, FindOneOptions } from 'typeorm';
import { QueryTransferMethodDto } from './dto/query-transfer-method.dto';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Transfer Method')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.TransferMethod,
})
export class TransferMethodController {
  constructor(private readonly transferMethodService: TransferMethodService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  findAll(
    @MerchantId()
    merchantId: number,
    @Query()
    query: QueryTransferMethodDto,
  ) {
    const { state, methodType, bankAccessId, identifier, page, limit } = query;

    const options: FindManyOptions<TransferMethodEntity> = {
      where: {
        ...(state && { state }),
        ...(methodType && { methodType }),
        ...(bankAccessId && { bankAccessId: +bankAccessId }),
        ...(identifier && { identifier }),
        ...(merchantId && { merchantId }),
      },
    };
    return this.transferMethodService.findAllPaginated({
      page,
      limit,
      options,
    });
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  findOne(@User('merchantId') merchantId: number, @Param('id') id: string) {
    const options: FindOneOptions<TransferMethodEntity> = {
      where: { merchantId, id: +id },
    };
    return this.transferMethodService.findOneByConditions(options);
  }

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  create(
    @User('merchantId') merchantId: number,
    @Body() createTransferMethodDto: CreateTransferMethodDto,
  ) {
    createTransferMethodDto.merchantId = merchantId;
    return this.transferMethodService.create(createTransferMethodDto);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  update(
    @Param('id') id: string,
    @Body() updateTransferMethodDto: UpdateTransferMethodDto,
  ) {
    return this.transferMethodService.update(+id, updateTransferMethodDto);
  }

  @Delete(':id')
  @HttpCode(204)
  @Roles(UserRole.SUPER)
  remove(@Param('id') id: string) {
    return this.transferMethodService.remove(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-method/transfer-method.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferMethodController } from './transfer-method.controller';
import { TransferMethodService } from 'src/models/transfer-method/transfer-method.service';

describe('TransferMethodController', () => {
  let controller: TransferMethodController;

  beforeEach(async () => {
    const mockTransferMethodService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TransferMethodController],
      providers: [
        TransferMethodService,
        {
          provide: TransferMethodService,
          useValue: mockTransferMethodService,
        },
      ],
    }).compile();

    controller = module.get<TransferMethodController>(TransferMethodController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-method/dto/update-transfer-method.dto.ts
import { IsEnum, IsObject, IsOptional } from 'class-validator';
import { State } from 'src/common/enums/state.enum';

export class UpdateTransferMethodDto {
  @IsObject()
  @IsOptional()
  signingKeys?: any;

  @IsEnum(State)
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-method/dto/create-transfer-method.dto.ts
import { State } from '../../../../common/enums/state.enum';
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsString,
} from 'class-validator';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';

export class CreateTransferMethodDto {
  @IsObject()
  @IsOptional()
  signingKeys?: any;

  @IsEnum(TransferMethodType)
  @IsNotEmpty()
  methodType: TransferMethodType;

  @IsEnum(State)
  @IsOptional()
  state?: State;

  @IsString()
  identifier: string;

  @IsNumber()
  bankAccessId: number;

  @IsNumber()
  @IsOptional()
  merchantId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-method/dto/query-transfer-method.dto.ts
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';
import { State } from 'src/common/enums/state.enum';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';

export class QueryTransferMethodDto extends QueryPaginatedDto {
  @IsString()
  @IsOptional()
  public identifier?: string;

  @IsString()
  @IsOptional()
  public bankAccessId?: string;

  @IsEnum(State)
  @IsOptional()
  public state?: State;

  @IsString()
  @IsOptional()
  public methodType?: TransferMethodType;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/metrics/metrics.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { MetricsController } from './metrics.controller';
import { MetricsService } from 'src/services/metrics/metrics.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

describe('MetricsController', () => {
  let controller: MetricsController;

  beforeEach(async () => {
    const mockMetricsService = {};
    const mockFeatureFlagService = {};

    const module: TestingModule = await Test.createTestingModule({
      controllers: [MetricsController],
      providers: [
        {
          provide: MetricsService,
          useValue: mockMetricsService,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    controller = module.get<MetricsController>(MetricsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/metrics/metrics.controller.ts
import { Controller, HttpCode, Get, Query, Param } from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiResponse,
  ApiSecurity,
  ApiTags,
} from '@nestjs/swagger';

import { ControllerRoute, ControllerVersion } from 'src/api/common';

import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';

import { MetricsRequestDto } from 'src/api/v2/metrics/dto/metrics-request.dto';

import { MetricsService } from 'src/services/metrics/metrics.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { MetricsResponseDto } from './dto/metrics-response.dto';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Metrics')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Metrics })
export class MetricsController {
  constructor(
    private readonly metricsService: MetricsService,
    private readonly featureFlagService: FeatureFlagService,
  ) {}

  @Get('/:providerId/amount')
  @HttpCode(200)
  @ApiOperation({
    summary: 'Get Amount Metrics for a provider',
    operationId: 'amount',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully returned Amount Metrics.',
    type: MetricsResponseDto,
  })
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async getAmountMetrics(
    @Param('providerId') providerId: number,
    @Query() query: MetricsRequestDto,
  ) {
    const filters = { startDate: query.from, endDate: query.to };
    const amountMetrics = await this.metricsService.getAmountMetrics(
      providerId,
      filters,
    );

    return amountMetrics;
  }

  @Get('/:providerId/time')
  @HttpCode(200)
  @ApiOperation({
    summary: 'Get Time Metrics for a provider',
    operationId: 'time',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully returned Time Metrics.',
    type: MetricsResponseDto,
  })
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async getTimeMetrics(
    @Param('providerId') providerId: number,
    @Query() query: MetricsRequestDto,
  ) {
    const filters = { startDate: query.from, endDate: query.to };
    const timeMetrics = await this.metricsService.getTimeMetrics(
      providerId,
      filters,
    );

    return timeMetrics;
  }

  @Get('/:providerId/state')
  @HttpCode(200)
  @ApiOperation({
    summary: 'Get State Metrics for a provider',
    operationId: 'state',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully returned State Metrics.',
    type: MetricsResponseDto,
  })
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async getStateMetrics(
    @Param('providerId') providerId: number,
    @Query() query: MetricsRequestDto,
  ) {
    const filters = { startDate: query.from, endDate: query.to };
    const stateMetrics = await this.metricsService.getStateMetrics(
      providerId,
      filters,
    );

    return stateMetrics;
  }

  @Get('/:providerId/management')
  @HttpCode(200)
  @ApiOperation({
    summary: 'Get Management Metrics for a provider',
    operationId: 'management',
  })
  @ApiResponse({
    status: 200,
    description: 'Successfully returned Management Metrics.',
    type: MetricsResponseDto,
  })
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async getManagementMetrics(
    @Param('providerId') providerId: number,
    @Query() query: MetricsRequestDto,
  ) {
    const filters = { startDate: query.from, endDate: query.to };
    const managementMetrics = await this.metricsService.getManagementMetrics(
      providerId,
      filters,
    );

    return managementMetrics;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/metrics/dto/metrics-request.dto.ts
import { IsDateString, IsOptional } from 'class-validator';

export class MetricsRequestDto {
  @IsDateString()
  @IsOptional()
  from?: Date;

  @IsDateString()
  @IsOptional()
  to?: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/metrics/dto/metrics-response.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';

export class MetricsResponseDto {
  @IsNumber()
  @IsPositive()
  amount: number;

  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @IsString()
  concept: string;

  @IsString()
  @IsNotEmpty()
  trackingCode: string;

  @IsObject()
  @IsOptional()
  metadata?: any;

  @IsString()
  @IsNotEmpty()
  destinationEmail: string;

  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @IsString()
  @IsNotEmpty()
  destinationHolderId: string;

  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @IsString()
  @IsNotEmpty()
  destinationBankCode: string;

  @IsNumber()
  @IsOptional()
  merchantId: number;

  @IsString()
  @IsOptional()
  destinationPhone: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  providerId?: number;

  // TODO: Should only allow to set this to v2
  @IsEnum(EntityVersion)
  @IsOptional()
  version?: EntityVersion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api.module.ts
import { Module } from '@nestjs/common';

import { AccountModule } from 'src/models/account/account.module';
import { AccountStatementModule } from 'src/models/account-statement/account-statement.module';
import { ApiKeyModule } from 'src/models/apikey/apikey.module';
import { AuditLogModule } from 'src/models/audit-log/audit-log.module';
import { AuthModule } from 'src/services/auth/auth.module';
import { BankModule } from 'src/models/bank/bank.module';
import { ExcelModule } from 'src/services/excel/excel.module';
import { LiquidoProviderModule } from 'src/providers/liquido/liquido.provider.module';
import { MailModule } from 'src/services/mail/mail.module';
import { MerchantLimitEvaluatorModule } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.module';
import { MerchantLimitModule } from 'src/models/merchant-limit/merchant-limit.module';
import { MerchantModule } from 'src/models/merchant/merchant.module';
import { PayoutManagementModule } from 'src/services/payout-management/payout-management.module';
import { PayoutModule } from 'src/models/payout/payout.module';
import { ProviderModule } from 'src/models/provider/provider.module';
import { ShinkansenProviderModule } from 'src/providers/shinkansen/shinkansen.provider.module';
import { TransferMethodModule } from 'src/models/transfer-method/transfer-method.module';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { FeatureFlagModule } from 'src/services/feature-flag/feature-flag.module';
import { TransferProviderModule } from 'src/services/transfer-provider/transfer-provider.module';
import { TransferReconciliationModule } from 'src/services/transfer-reconciliation/transfer-reconciliation.module';
import { UserModule } from 'src/models/user/user.module';

import { AccountController } from './account/account.controller';
import { AccountStatementController } from './account-statement/account-statement.controller';
import { AccountStatementJobController } from './account-statement-job/account-statement-job.controller';
import { AccountStatementJobModule } from 'src/models/account-statement-job/account-statement-job.module';
import { ApiKeyController } from './api-key/api-key.controller';
import { AuditLogController } from './audit-log/audit-log.controller';
import { AuthController } from './auth/auth.controller';
import { BankController } from './bank/bank.controller';
import { ManagementController } from './management/management.controller';
import { MerchantLimitController } from './merchant-limit/merchant-limit.controller';
import { MerchantController } from './merchant/merchant.controller';
import { PayoutController } from './payout/payout.controller';
import { ProviderController } from './provider/provider.controller';
import { ProviderWebHooksController } from './provider/webhooks/provider-webhooks.controller';
import { ReconciliationController } from './reconciliation/reconciliation.controller';
import { TransferMethodController } from './transfer-method/transfer-method.controller';
import { UserController } from './user/user.controller';
import { AuthorizationCodeController } from './authorization-code/authorization-code.controller';
import { AuthorizationCodeModule } from 'src/models/authorization-code/authorization-code.module';
import { TransferJobModule } from 'src/models/transfer-job/transfer-job.module';
import { TransferJobController } from './transfer-job/transfer-job.controller';
import { WebhookEndpointController } from './webhook-endpoint/webhook-endpoint.controller';
import { WebhookEndpointModule } from 'src/models/webhook-endpoint/webhook-endpoint.module';
import { TransferErrorModule } from 'src/models/transfer-error/transfer-error.module';
import { MetricsController } from './metrics/metrics.controller';
import { PayoutNewModule } from 'src/models/payout/payout.new.module';
import { MetricsModule } from 'src/services/metrics/metrics.module';
import { PayoutActionController } from './payout-action/payout-action.controller';
import { PayoutActionsModule } from 'src/models/payout-actions/payout-actions.module';
import { TransferErrorController } from './transfer-error/transfer-error.controller';

@Module({
  imports: [
    AccountModule,
    AccountStatementJobModule,
    AccountStatementModule,
    ApiKeyModule,
    AuditLogModule,
    AuthModule,
    AuthorizationCodeModule,
    BankModule,
    ExcelModule,
    LiquidoProviderModule,
    FeatureFlagModule,
    MailModule,
    MetricsModule,
    MerchantLimitEvaluatorModule,
    MerchantLimitModule,
    MerchantModule,
    PayoutManagementModule,
    PayoutModule,
    PayoutNewModule,
    ProviderModule,
    ShinkansenProviderModule,
    TransferJobModule,
    TransferMethodModule,
    TransferModule,
    TransferProviderModule,
    TransferReconciliationModule,
    UserModule,
    WebhookEndpointModule,
    TransferErrorModule,
    PayoutActionsModule,
  ],
  controllers: [
    AccountController,
    AccountStatementController,
    AccountStatementJobController,
    ApiKeyController,
    AuditLogController,
    AuthController,
    AuthorizationCodeController,
    BankController,
    ManagementController,
    MerchantController,
    MerchantLimitController,
    MetricsController,
    PayoutController,
    ProviderController,
    ProviderWebHooksController,
    ReconciliationController,
    TransferJobController,
    TransferMethodController,
    UserController,
    WebhookEndpointController,
    PayoutActionController,
    TransferErrorController,
  ],
})
export class ApiV2Module {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/authorization-code/dto/get-authorization-codes-query.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetAuthorizationCodesQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/authorization-code/dto/device-code-message.dto.ts
import { IsNotEmpty, IsNumber, IsString } from 'class-validator';
export class DeviceCodeMessageDto {
  @IsString()
  @IsNotEmpty()
  code: string;

  @IsNumber()
  @IsNotEmpty()
  expiration: number;

  @IsString()
  @IsNotEmpty()
  identifier: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/authorization-code/dto/create-authorization-code.dto.ts
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';

export class CreateAuthorizationCodeDto {
  @IsNumber()
  transferMethodId: number;

  @IsString()
  @IsOptional()
  code?: string;

  @IsDate()
  @IsOptional()
  expiresAt?: Date;

  @IsEnum(AuthorizationCodeState)
  @IsOptional()
  state?: AuthorizationCodeState;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/authorization-code/authorization-code.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { DeviceCodeGuard } from 'src/common/guards/device.guard';
import { TwilioGuard } from 'src/common/guards/twilio.guard';
import { AuthorizationCodeController } from './authorization-code.controller';
import { AuthorizationCodeService } from 'src/models/authorization-code/authorization-code.service';

describe.skip('given a AuthorizationCodeController', () => {
  let controller: AuthorizationCodeController;

  beforeEach(async () => {
    const mockAuthorizationCodeService = {
      findAll: () => {
        return [];
      },
      saveTwilioMessage: async () => {
        return Promise.resolve({ name: 'nameMy' });
      },
    };
    const mockTwillioGuard = {
      saveTwilioMessage: () => {
        return {};
      },
    };
    const mockDeviceCodeGuard = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthorizationCodeController],
      providers: [
        AuthorizationCodeController,
        {
          provide: AuthorizationCodeService,
          useValue: mockAuthorizationCodeService,
        },
      ],
    })
      .overrideGuard(TwilioGuard)
      .useValue(mockTwillioGuard)
      .overrideGuard(DeviceCodeGuard)
      .useValue(mockDeviceCodeGuard)
      .compile();

    controller = module.get<AuthorizationCodeController>(
      AuthorizationCodeController,
    );
  });

  it('should be defined', async () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/authorization-code/authorization-code.controller.ts
import {
  Body,
  Controller,
  Get,
  Header,
  HttpCode,
  Param,
  Post,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { TwilioGuard } from 'src/common/guards/twilio.guard';
import { DeviceCodeGuard } from 'src/common/guards/device.guard';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { TwilioMessageDto } from 'src/services/twilio/dto/twilio-message.dto';
import { AuthorizationCodeService } from 'src/models/authorization-code/authorization-code.service';
import { DeviceCodeMessageDto } from './dto/device-code-message.dto';
import { GetAuthorizationCodesQueryDto } from './dto/get-authorization-codes-query.dto';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Authorization Code')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.AuthorizationCode,
})
export class AuthorizationCodeController {
  constructor(
    private readonly authorizationCodeService: AuthorizationCodeService,
  ) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  @UseInterceptors(PaginatedInterceptor)
  findAll(@Query() query: GetAuthorizationCodesQueryDto) {
    return this.authorizationCodeService.findAllPaginated(query);
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  findOne(@Param('id') id: string) {
    return this.authorizationCodeService.findOneAndClaim(+id);
  }

  @Post('webhooks/twilio')
  @HttpCode(200)
  @Header('Content-Length', '0')
  @UseGuards(TwilioGuard)
  @RequireAuth('none')
  async saveTwilioCode(@Body() twilioMessageDto: TwilioMessageDto) {
    await this.authorizationCodeService.saveTwilioMessage(twilioMessageDto);
    return;
  }

  @Post('webhooks/digipass')
  @HttpCode(200)
  @Header('Content-Length', '0')
  @UseGuards(DeviceCodeGuard)
  @RequireAuth('none')
  async saveDigipassCode(@Body() deviceCodeMessageDto: DeviceCodeMessageDto) {
    await this.authorizationCodeService.saveDigipassMessage(
      deviceCodeMessageDto,
    );
    return;
  }

  @Post('webhooks/mobile')
  @HttpCode(200)
  @Header('Content-Length', '0')
  @UseGuards(DeviceCodeGuard)
  @RequireAuth('none')
  async saveMobileAppCode(@Body() deviceCodeMessageDto: DeviceCodeMessageDto) {
    await this.authorizationCodeService.saveMobileMessage(deviceCodeMessageDto);
    return;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/management/management.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { PayoutManagementService } from 'src/services/payout-management/payout-management.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { ManagementController } from './management.controller';

describe('ManagementController', () => {
  let controller: ManagementController;
  const mockPayoutManagementService = {};
  const mockFeatureFlagService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ManagementController],
      providers: [
        {
          provide: PayoutManagementService,
          useValue: mockPayoutManagementService,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    controller = module.get<ManagementController>(ManagementController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/management/management.controller.ts
import {
  BadRequestException,
  Body,
  Controller,
  HttpCode,
  Param,
  Patch,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { ReassignPayoutDto } from './dto/reassign-payout.dto';
import { CancelPayoutDto } from './dto/cancel-payout.dto';
import { CompletePayoutDto } from './dto/complete-payout.dto';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { PayoutManagementService } from 'src/services/payout-management/payout-management.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';

@ApiTags('Management')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Management })
export class ManagementController {
  constructor(
    private readonly managementService: PayoutManagementService,
    private readonly featureFlagService: FeatureFlagService,
  ) {}

  @Patch('payouts/:id/reassign')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async reassign(
    @Param('id') id: string,
    @Body() reassignPayoutDto: ReassignPayoutDto,
  ) {
    const { providerId } = reassignPayoutDto;

    const canUseFeatureFlag = await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_REASSIGN,
    );

    if (canUseFeatureFlag) {
      return this.managementService.newReassignPayout(+id, providerId);
    }
    return this.managementService.reassignPayout(+id, providerId);
  }

  @Patch('payouts/:id/retry')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async retry(@Param('id') id: string) {
    const canUseFeatureFlag = await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_REASSIGN,
    );

    if (canUseFeatureFlag) {
      return this.managementService.newReassignPayout(+id);
    }

    const [retriedPayout] = await this.managementService.reassignPayout(+id);

    return retriedPayout;
  }

  @Patch('payouts/:id/complete')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async complete(
    @Param('id') id: string,
    @Body() completePayoutDto?: CompletePayoutDto,
  ) {
    const { transferId, ...metadata } = completePayoutDto ?? {};

    const canUseFeatureFlag = await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_COMPLETION,
    );
    if (canUseFeatureFlag) {
      if (!transferId) throw new BadRequestException('Missing transfer id');
      return this.managementService.completePayoutAndTransfer(
        +id,
        +transferId,
        metadata,
      );
    }
    return this.managementService.completePayout(+id);
  }

  @Patch('payouts/:id/cancel')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async cancel(
    @Param('id') id: string,
    @Body() cancelPayoutDto?: CancelPayoutDto,
  ) {
    const { transferId, ...rest } = cancelPayoutDto ?? {};

    const canUseFeatureFlag = await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_CANCELATION,
    );
    if (canUseFeatureFlag) {
      if (!transferId) throw new BadRequestException('Missing transfer id');
      return this.managementService.cancelPayoutAndTransfer(
        +id,
        transferId,
        rest,
      );
    }
    return this.managementService.cancelPayout(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/management/dto/cancel-payout.dto.ts
import { Type } from 'class-transformer';
import {
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { PayoutAction } from 'src/common/enums/payout-action.enum';

class PayoutMetadata {
  @IsString()
  @IsOptional()
  message?: string;

  @IsEnum(PayoutAction)
  @IsOptional()
  action?: PayoutAction;
}
export class CancelPayoutDto {
  @IsString()
  @IsOptional()
  message?: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  transferId?: number;

  @IsObject()
  @IsOptional()
  @Type(() => PayoutMetadata)
  metadata?: PayoutMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/management/dto/reassign-payout.dto.ts
import { IsNumber, IsPositive } from 'class-validator';

export class ReassignPayoutDto {
  @IsNumber()
  @IsPositive()
  providerId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/management/dto/complete-payout.dto.ts
import { IsNumber, IsOptional, IsPositive, IsString } from 'class-validator';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

export class CompletePayoutDto {
  @IsNumber()
  @IsPositive()
  @IsOptional() // TODO: Should not be optional
  transferId?: TransferEntity['id'];

  @IsString()
  @IsOptional()
  message?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement/account-statement.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountStatementController } from './account-statement.controller';
import { AccountStatementService } from 'src/models/account-statement/account-statement.service';

describe('AccountStatementController', () => {
  let controller: AccountStatementController;

  beforeEach(async () => {
    const mockAccountStatementService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AccountStatementController],
      providers: [
        AccountStatementController,
        {
          provide: AccountStatementService,
          useValue: mockAccountStatementService,
        },
      ],
    }).compile();

    controller = module.get<AccountStatementController>(
      AccountStatementController,
    );
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement/dto/query-account-statement.dto.ts
import { IsDateString, IsOptional, IsString } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class QueryAccountStatementQueryDto extends QueryPaginatedDto {
  @IsString()
  public originBankAccountIdentifier: string;

  @IsString()
  @IsOptional()
  public amount?: string;

  @IsDateString()
  @IsOptional()
  public from?: string;

  @IsDateString()
  @IsOptional()
  public to?: string;

  @IsString()
  @IsOptional()
  public destinationBankCode?: string;

  @IsString()
  @IsOptional()
  public destinationHolderId?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement/dto/create-account-statement.dto.ts
import {
  IsDateString,
  IsEnum,
  IsIn,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountStatementMetadata } from '../types';

export class CreateAccountStatementDto {
  @IsDateString()
  @IsNotEmpty()
  date: string;

  @IsString()
  @IsNotEmpty()
  originBankCode: string;

  @IsString()
  @IsNotEmpty()
  originBankAccountIdentifier: string;

  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @IsString()
  concept: string;

  @IsEnum(CountryCode)
  @IsNotEmpty()
  countryCode: CountryCode;

  @IsNumber()
  @IsPositive()
  amount: number;

  @IsEnum(TransferState)
  @IsIn([TransferState.COMPLETED])
  @IsNotEmpty()
  state: TransferState;

  @IsString()
  @IsNotEmpty()
  transactionCode: string;

  @IsString()
  @IsNotEmpty()
  destinationHolderId: string;

  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @IsString()
  @IsOptional()
  destinationEmail?: string;

  @IsString()
  @IsOptional()
  destinationBankCode?: string;

  @IsDateString()
  @IsOptional()
  retrievedAt?: string;

  @IsObject()
  metadata: AccountStatementMetadata;

  @IsNumber()
  accountStatementJobId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement/account-statement.controller.ts
import {
  Controller,
  HttpCode,
  Get,
  UseInterceptors,
  Query,
  Post,
  Body,
  ParseArrayPipe,
} from '@nestjs/common';
import { FindManyOptions } from 'typeorm';

import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { AccountStatementService } from 'src/models/account-statement/account-statement.service';
import { QueryAccountStatementQueryDto } from './dto/query-account-statement.dto';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { buildTimeQuery } from 'src/common/queries/time.query';
import { CreateAccountStatementDto } from './dto/create-account-statement.dto';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Account Statement')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.AccountStatement,
})
export class AccountStatementController {
  constructor(
    private readonly accountStatementService: AccountStatementService,
  ) {}

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  async createMany(
    @Body(new ParseArrayPipe({ items: CreateAccountStatementDto }))
    createAccountStatementDto: CreateAccountStatementDto[],
  ) {
    const accountStatements = await this.accountStatementService.createMany(
      createAccountStatementDto,
    );

    return accountStatements;
  }

  @Get()
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  async findAll(@Query() query: QueryAccountStatementQueryDto) {
    const {
      page,
      limit,
      originBankAccountIdentifier,
      amount,
      destinationBankCode,
      destinationHolderId,
      from,
      to,
    } = query;

    const filterByDate = buildTimeQuery({ from, to });

    const options: FindManyOptions<AccountStatementEntity> = {
      relations: ['accountStatementJob'],
      order: {
        date: DESCENDING_ORDER,
      },
      where: {
        ...(originBankAccountIdentifier && { originBankAccountIdentifier }),
        ...(amount && { amount: +amount }),
        ...(destinationBankCode && { destinationBankCode }),
        ...(destinationHolderId && { destinationHolderId }),
        ...(filterByDate && { date: filterByDate }),
        accountStatementJob: {
          state: AccountStatementJobState.FINISHED,
        },
      },
    };

    return this.accountStatementService.findAllPaginated({
      page,
      limit,
      options,
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement/types/index.ts
export type AccountStatementMetadata = {
  status: string;
  destinationBank: string;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant-limit/merchant-limit.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';

import { MerchantLimitController } from './merchant-limit.controller';
import { MerchantLimitService } from 'src/models/merchant-limit/merchant-limit.service';

describe('LimitController', () => {
  let controller: MerchantLimitController;

  beforeEach(async () => {
    const mockLimitService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MerchantLimitController],
      providers: [
        MerchantLimitService,
        {
          provide: MerchantLimitService,
          useValue: mockLimitService,
        },
      ],
    }).compile();

    controller = module.get<MerchantLimitController>(MerchantLimitController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant-limit/merchant-limit.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';

import { GetMerchantLimitsQueryDto } from './dto/get-merchant-limits-query.dto';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { CreateMerchantLimitDto } from './dto/create-limit.dto';
import { MerchantLimitService } from 'src/models/merchant-limit/merchant-limit.service';
import { PatchMerchantLimitDto } from './dto/patch-merchant-limit.dto';

const ByMerchantPath = `${ControllerRoute.Merchant}/:merchantId/${ControllerRoute.Limit}`;

@ApiBearerAuth()
@ApiTags('MerchantLimit')
@Controller({ version: ControllerVersion.V2 })
export class MerchantLimitController {
  constructor(private readonly merchantLimitService: MerchantLimitService) {}

  @Get(ByMerchantPath)
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Roles(UserRole.SUPER, UserRole.SUPPORT, UserRole.ADMIN)
  findAllForMerchant(
    @MerchantId({ required: true })
    merchantId: number,
    @Query() query: GetMerchantLimitsQueryDto,
  ) {
    return this.merchantLimitService.findAllForMerchant(+merchantId, query);
  }

  @Post(ByMerchantPath)
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  async create(
    @Param('merchantId') merchantId: string,
    @Body() createLimitDto: CreateMerchantLimitDto,
  ) {
    return this.merchantLimitService.create(+merchantId, {
      ...createLimitDto,
    });
  }

  @Patch(`${ByMerchantPath}/:id`)
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  async patch(
    @Param('merchantId') merchantId: string,
    @Param('id') id: string,
    @Body() patchMerchantLimitDto: PatchMerchantLimitDto,
  ) {
    const accountStatementJob = await this.merchantLimitService.update(
      +id,
      +merchantId,
      patchMerchantLimitDto,
    );

    return accountStatementJob;
  }

  @Delete(`${ByMerchantPath}/:id`)
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  async delete(
    @Param('merchantId') merchantId: string,
    @Param('id') id: string,
  ) {
    const accountStatementJob = await this.merchantLimitService.remove(
      +id,
      +merchantId,
    );

    return accountStatementJob;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant-limit/dto/create-limit.dto.ts
import { Type } from 'class-transformer';
import {
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  ValidateNested,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';

class MerchantLimitDefinitionDto {
  @IsPositive()
  @IsNumber()
  value: number;

  @IsEnum(LimitCriteria)
  criteria: LimitCriteria;

  @IsEnum(LimitScope)
  scope: LimitScope;

  @IsEnum(LimitAggregation)
  aggregation: LimitAggregation;

  @IsOptional()
  @IsEnum(Currency)
  currency?: Currency;
}

export class CreateMerchantLimitDto {
  @IsEnum(MerchantLimitType)
  limitType: MerchantLimitType;

  @ValidateNested()
  @IsObject()
  @Type(() => MerchantLimitDefinitionDto)
  limitDefinition: MerchantLimitDefinitionDto;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant-limit/dto/get-merchant-limits-query.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetMerchantLimitsQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/merchant-limit/dto/patch-merchant-limit.dto.ts
import { Type } from 'class-transformer';
import {
  IsEnum,
  IsNumber,
  IsOptional,
  IsPositive,
  ValidateNested,
} from 'class-validator';
import { ExcludeDeletedState } from 'src/common/decorators/custom-validators/exclude-deleted-state.decorator';
import { State } from 'src/common/enums/state.enum';

class MerchantLimitDefinitionDto {
  @IsPositive()
  @IsNumber()
  value: number;
}

export class PatchMerchantLimitDto {
  @IsOptional()
  @ValidateNested()
  @Type(() => MerchantLimitDefinitionDto)
  limitDefinition?: MerchantLimitDefinitionDto;

  @IsOptional()
  @ExcludeDeletedState()
  @IsEnum(State)
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/account.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { AccountService } from 'src/models/account/account.service';
import { AccountController } from './account.controller';

describe('AccountController', () => {
  let controller: AccountController;
  const fakeAccountService = {};
  const mockAccountStatementJobService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AccountController],
      providers: [
        { provide: AccountService, useValue: fakeAccountService },
        {
          provide: AccountStatementJobService,
          useValue: mockAccountStatementJobService,
        },
      ],
    }).compile();

    controller = module.get<AccountController>(AccountController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/dto/create-account.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';

export class CreateAccountDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  bankCode: string;

  @IsString()
  @IsNotEmpty()
  identifier: string;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  holderId?: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;

  @IsObject()
  @IsOptional()
  rules?: RuleDefinition;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  merchantId: number;

  @IsEnum(Currency)
  currency: Currency;

  @IsEnum(CountryCode)
  countryCode: CountryCode;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/dto/get-accounts-dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetAccountsQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/dto/download-account-statement.dto.ts
import { IsDateString } from 'class-validator';
import {
  IsGreaterThanOrEqualDate,
  DaysBetweenRange,
} from 'src/common/decorators/custom-validators';
import { HasDateFormat } from 'src/common/decorators/custom-validators/has-date-format';

const DATE_FORMAT = 'YYYY-MM-DD';
export class DownloadAccountStatementDto {
  @IsDateString()
  @HasDateFormat(DATE_FORMAT)
  startDate: string;

  @IsDateString()
  @IsGreaterThanOrEqualDate('startDate')
  @HasDateFormat(DATE_FORMAT)
  @DaysBetweenRange(31)
  endDate: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/dto/update-account.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsObject,
  IsOptional,
  IsString,
} from 'class-validator';
import { State } from 'src/common/enums/state.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';

export class UpdateAccountDto {
  @IsString()
  @IsNotEmpty()
  @IsOptional()
  name?: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;

  @IsObject()
  @IsOptional()
  rules?: RuleDefinition;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account/account.controller.ts
import {
  Body,
  Controller,
  Delete,
  ForbiddenException,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { FindManyOptions, FindOneOptions } from 'typeorm';
import { CreateAccountDto } from './dto/create-account.dto';
import { GetAccountsQueryDto } from './dto/get-accounts-dto';
import { UpdateAccountDto } from './dto/update-account.dto';
import { ASCENDING_ORDER } from 'src/database/query.constants';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { DownloadAccountStatementDto } from 'src/api/v2/account/dto/download-account-statement.dto';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Account')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Account })
export class AccountController {
  constructor(
    private readonly accountService: AccountService,
    private readonly accountStatementJobService: AccountStatementJobService,
  ) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT, UserRole.ADMIN)
  @UseInterceptors(PaginatedInterceptor)
  findAll(
    @MerchantId() // TODO: Required option should be truthy to this controller
    merchantId: number,
    @Query() query: GetAccountsQueryDto,
  ) {
    const options: FindManyOptions<AccountEntity> = {
      where: {
        ...(merchantId && { merchantId }),
      },
      order: {
        bankCode: ASCENDING_ORDER,
        name: ASCENDING_ORDER,
      },
    };

    return this.accountService.findAllPaginated({ ...query, options });
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async findOne(@MerchantId() merchantId: number, @Param('id') id: string) {
    const options: FindOneOptions<AccountEntity> = {
      where: {
        id: +id,
        ...(merchantId && { merchantId }),
      },
    };

    const account = await this.accountService.findOneByConditions(options);

    if (!account) throw new NotFoundException(`Account ${id} not found`);

    return account;
  }

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  create(
    @User('merchantId') merchantId: number,
    @Body() createAccountDto: CreateAccountDto,
  ) {
    createAccountDto.merchantId = merchantId;
    return this.accountService.create(createAccountDto);
  }

  @Post(':id/statements')
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async downloadAccountStatement(
    @Param('id') id: string,
    @Body() params: DownloadAccountStatementDto,
  ) {
    return this.accountStatementJobService.startScraper(Number(id), params);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  async update(
    @User('merchantId') merchantId: number,
    @Param('id') id: string,
    @Body() updateAccountDto: UpdateAccountDto,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +id, merchantId },
    });

    if (!account) throw new ForbiddenException(`Can't update account ${id}`);

    return this.accountService.update(+id, updateAccountDto);
  }

  @Delete(':id')
  @Roles(UserRole.SUPER)
  async remove(
    @User('merchantId') merchantId: number,
    @Param('id') id: string,
  ) {
    const account = await this.accountService.findOneByConditions({
      where: { id: +id, merchantId },
    });

    if (!account) throw new ForbiddenException(`Can't update account ${id}`);

    return this.accountService.remove(+id);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/reconciliation/reconciliation.controller.ts
import { Controller, Get, HttpCode, Query } from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { TransferReconciliationService } from 'src/services/transfer-reconciliation/transfer-reconciliation.service';
import { TransferReconciliationDto } from '../transfer/dto/transfer-reconciliation.dto';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Reconciliations')
@Controller({
  path: ControllerRoute.Reconciliations,
  version: ControllerVersion.V2,
})
export class ReconciliationController {
  constructor(private reconciliationService: TransferReconciliationService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  findTransferMismatch(
    @Query() transferReconciliationDto: TransferReconciliationDto,
  ) {
    return this.reconciliationService.reconciliate(transferReconciliationDto);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/reconciliation/reconciliation.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferReconciliationService } from 'src/services/transfer-reconciliation/transfer-reconciliation.service';
import { ReconciliationController } from './reconciliation.controller';

describe('ReconciliationController', () => {
  let controller: ReconciliationController;
  const mockReconciliationService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ReconciliationController],
      providers: [
        {
          provide: TransferReconciliationService,
          useValue: mockReconciliationService,
        },
      ],
    }).compile();

    controller = module.get<ReconciliationController>(ReconciliationController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/payout.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { PayoutController } from './payout.controller';
import { PayoutService } from 'src/models/payout/payout.service';
import { ExcelService } from 'src/services/excel/excel.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { PayoutNewService } from 'src/models/payout/payout.new.service';

describe('PayoutController', () => {
  let controller: PayoutController;

  beforeEach(async () => {
    const mockPayoutService = {};
    const mockPayoutNewService = {};
    const mockExcelService = {};
    const mockFeatureFlagService = {};

    const module: TestingModule = await Test.createTestingModule({
      controllers: [PayoutController],
      providers: [
        {
          provide: PayoutService,
          useValue: mockPayoutService,
        },
        {
          provide: PayoutNewService,
          useValue: mockPayoutNewService,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
        {
          provide: ExcelService,
          useValue: mockExcelService,
        },
      ],
    }).compile();

    controller = module.get<PayoutController>(PayoutController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/payout.controller.ts
import {
  Controller,
  Post,
  Body,
  HttpCode,
  ConflictException,
  Get,
  UseInterceptors,
  Query,
  HttpStatus,
  Res,
  Param,
} from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiResponse,
  ApiSecurity,
  ApiTags,
} from '@nestjs/swagger';
import { PayoutService } from 'src/models/payout/payout.service';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { CreatePayoutDto } from './dto/create-payout.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { State } from 'src/common/enums/state.enum';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { QueryPayoutDto } from './dto/query-payout.dto';
import { FindManyOptions, FindOneOptions, In } from 'typeorm';
import { buildPayoutQuery } from 'src/common/queries/payout.query';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TrimmedPayout } from './dto/trimmed-payout.example.dto';
import { Response } from 'express';
import { ExcelService, ExcelSheet } from 'src/services/excel/excel.service';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Payout')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Payout })
export class PayoutController {
  constructor(
    private readonly payoutService: PayoutService,
    private readonly payoutServiceNew: PayoutNewService,
    private readonly excelService: ExcelService,
    private readonly featureFlagService: FeatureFlagService,
  ) {}

  @Post()
  @HttpCode(201)
  @ApiOperation({
    summary: 'Create a single Payout',
    operationId: 'CreatePayout',
  })
  @ApiResponse({
    status: 201,
    description: 'Successfully generated a Payout in pending status',
  })
  @Roles(UserRole.ADMIN, UserRole.SUPER)
  async create(
    @User('merchant') merchant: MerchantEntity,
    @Body() createPayoutDto: CreatePayoutDto,
  ) {
    if (merchant.state !== State.ACTIVE) {
      throw new ConflictException(
        'Merchant must be active to request for Payouts',
      );
    }
    createPayoutDto.merchantId = merchant.id;
    createPayoutDto.version = EntityVersion.v2;

    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_CREATION,
      );
    if (canUseNewPayoutCreation) {
      return this.payoutServiceNew.createPayoutAndTransfer(createPayoutDto);
    } else {
      return this.payoutService.create(createPayoutDto);
    }
  }

  @Get()
  @HttpCode(200)
  @ApiOperation({
    summary: 'Get paginated Payout list for v1 and v2 version',
    operationId: 'findAllPaginated',
  })
  @ApiResponse({
    status: 200,
    description:
      'Successfully returned paginated Payout list sorted by createdAt property. Default 10 results per page.',
    type: TrimmedPayout,
  })
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  async findAll(
    @MerchantId()
    merchantId: number,
    @Query() query: QueryPayoutDto,
  ) {
    const { page, limit } = query;

    const options: FindManyOptions<PayoutEntity> = buildPayoutQuery(query);

    if (query?.version) {
      options.where['version'] = In(query.version);
    } else {
      // TODO: should change the default version as v2
      options.where['version'] = In([EntityVersion.v1, EntityVersion.v2]);
    }

    if (merchantId) {
      options.where['merchantId'] = merchantId;
    }

    const payouts = await this.payoutService.findAllPaginated({
      page,
      limit,
      options,
    });
    return payouts;
  }

  /**
   * Must be after any GET route with route params to avoid wrong routing
   * If we put the /payouts/:id before /payouts/export, then the first route will process 'export' as :id
   */

  @Get('/export')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  async export(@Query() query: QueryPayoutDto, @Res() res: Response) {
    const transfers = await this.payoutServiceNew.getExportableTransfers(query);

    if (transfers.length === 0) {
      res.status(HttpStatus.NO_CONTENT).send();
      return;
    }

    let nameSuffix = '';

    if (query.from) nameSuffix += ` - Desde ${query.from}-`;

    if (query.to) nameSuffix += `Hasta ${query.to}`;

    const sheet: ExcelSheet = {
      name: 'Transferencias',
      data: transfers,
      headers: {
        id: 'ID',
        createdAt: 'Fecha de Creación',
        finishedAt: 'Fecha de Finalización',
        state: 'Estado',
        'originBankAccess.name': 'Acceso de Origen',
        'originBankAccount.name': 'Cuenta de Origen',
        'originBank.name': 'Banco de Origen',
        payoutId: 'ID Pago',
        destinationName: 'Nombre Destinatario',
        destinationHolderId: 'RUT',
        destinationEmail: 'Correo Destinatario',
        destinationPhone: 'Teléfono Destinatario',
        amount: 'Monto',
        currency: 'Moneda',
      },
    };

    const buffer = this.excelService.createXlsx([sheet]);

    res.set({
      'Content-Type':
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': `attachment; filename=HistorialTransferecias${nameSuffix}.xlsx`,
    });

    res.send(buffer);
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  findOne(
    @User('merchantId') merchantId: number,
    @User('role') role: UserRole,
    @Param('id') id: string,
  ) {
    const filterByMerchant = role === UserRole.ADMIN;
    const options: FindOneOptions<PayoutEntity> = {
      where: {
        id: +id,
        ...(filterByMerchant && { merchantId }),
        version: EntityVersion.v2,
      },
      relations: ['merchant', 'transfers'],
    };
    return this.payoutServiceNew.findOneByConditions(options);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/dto/trimmed-payout.example.dto.ts
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

class TrimmedTransfer {
  id: TransferEntity['id'];
  uuid: TransferEntity['uuid'];
  createdAt: TransferEntity['createdAt'];
  updatedAt: TransferEntity['updatedAt'];
  state: TransferEntity['state'];
  amount: TransferEntity['amount'];
  currency: TransferEntity['currency'];
  mode: TransferEntity['mode'];
  concept: TransferEntity['concept'];
  trackingCode: TransferEntity['trackingCode'];
  destinationEmail: TransferEntity['destinationEmail'];
  destinationName: TransferEntity['destinationName'];
  destinationHolderId: TransferEntity['destinationHolderId'];
  destinationAccount: TransferEntity['destinationAccount'];
  destinationBankCode: TransferEntity['destinationBankCode'];
  merchantId: TransferEntity['merchantId'];
  payoutId: TransferEntity['payoutId'];
  originBankCode: TransferEntity['originBankCode'];
  originBankAccessId: TransferEntity['originBankAccessId'];
  originBankAccountId: TransferEntity['originBankAccountId'];
  message: TransferEntity['message'];
  startedAt: TransferEntity['startedAt'];
  finishedAt: TransferEntity['finishedAt'];
  metadata: TransferEntity['metadata'];
  externalId: TransferEntity['externalId'];
  destinationPhone: TransferEntity['destinationPhone'];
  errorCode: TransferEntity['errorCode'];
  providerId: TransferEntity['providerId'];
  version: TransferEntity['version'];
}

export class TrimmedPayout {
  id: PayoutEntity['id'];
  uuid: PayoutEntity['uuid'];
  createdAt: PayoutEntity['createdAt'];
  updatedAt: PayoutEntity['updatedAt'];
  state: PayoutEntity['state'];
  amount: PayoutEntity['amount'];
  currency: PayoutEntity['currency'];
  concept: PayoutEntity['concept'];
  trackingCode: PayoutEntity['trackingCode'];
  metadata: PayoutEntity['metadata'];
  destinationEmail: PayoutEntity['destinationEmail'];
  destinationName: PayoutEntity['destinationName'];
  destinationHolderId: PayoutEntity['destinationHolderId'];
  destinationAccount: PayoutEntity['destinationAccount'];
  destinationBankCode: PayoutEntity['destinationBankCode'];
  merchantId: PayoutEntity['merchantId'];
  destinationPhone: PayoutEntity['destinationPhone'];
  version: PayoutEntity['version'];
  errorCode: PayoutEntity['errorCode'];
  message: PayoutEntity['message'];
  transfers: TrimmedTransfer[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/dto/query-payout.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import {
  IsArray,
  IsDateString,
  IsEnum,
  IsIn,
  IsNumberString,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { SortOrder } from 'src/utils/array-methods.util';
class PayoutMetadataDto {
  @IsNumberString()
  @IsOptional()
  paymentId?: number;
}

class PayoutTransferDto {
  @IsString()
  @IsOptional()
  public originBankCode?: string;

  @IsNumberString()
  @IsOptional()
  public providerId?: number;
}

export class QueryPayoutDto extends QueryPaginatedDto {
  @IsEnum(PayoutState)
  @IsOptional()
  public state?: PayoutState;

  @IsOptional()
  @IsArray()
  @IsEnum(PayoutState, { each: true })
  public states?: PayoutState[];

  @IsOptional()
  @IsString()
  public search?: string;

  @IsString()
  @IsOptional()
  public destinationBankCode?: string;

  @ValidateNested()
  @IsOptional()
  @ApiProperty({ type: () => PayoutTransferDto })
  @Type(() => PayoutTransferDto)
  public transfer?: PayoutTransferDto;

  @ValidateNested()
  @IsOptional()
  @ApiProperty({ type: () => PayoutMetadataDto })
  @Type(() => PayoutMetadataDto)
  public metadata?: PayoutMetadataDto;

  @IsString()
  @IsOptional()
  public trackingCode?: string;

  @IsDateString()
  @IsOptional()
  public from?: string;

  @IsDateString()
  @IsOptional()
  public to?: string;

  @IsEnum(SortOrder)
  @IsOptional()
  public sort? = SortOrder.ASCENDING;

  @IsEnum(Currency)
  @IsOptional()
  currency?: Currency;

  @IsOptional()
  @IsArray()
  @IsIn([EntityVersion.v1, EntityVersion.v2], { each: true })
  version?: EntityVersion[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/dto/update-payout.dto.ts
import { IsEnum, IsObject, IsOptional } from 'class-validator';
import { PayoutState } from 'src/common/enums/payout-state.enum';

export class UpdatePayoutDto {
  @IsObject()
  @IsOptional()
  metadata?: any;

  @IsEnum(PayoutState)
  @IsOptional()
  state: PayoutState;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout/dto/create-payout.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';

export class CreatePayoutDto {
  @IsNumber()
  @IsPositive()
  amount: number;

  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @IsString()
  concept: string;

  @IsString()
  @IsNotEmpty()
  trackingCode: string;

  @IsObject()
  @IsOptional()
  metadata?: any;

  @IsString()
  @IsNotEmpty()
  destinationEmail: string;

  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @IsString()
  @IsNotEmpty()
  destinationHolderId: string;

  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @IsString()
  @IsNotEmpty()
  destinationBankCode: string;

  @IsNumber()
  @IsOptional()
  merchantId: number;

  @IsString()
  @IsOptional()
  destinationPhone: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  providerId?: number;

  // TODO: Should only allow to set this to v2
  @IsEnum(EntityVersion)
  @IsOptional()
  version?: EntityVersion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-error/transfer-error.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferErrorService } from 'src/models/transfer-error/transfer-error.service';
import { TransferErrorController } from './transfer-error.controller';

describe('TransferErrorController', () => {
  let controller: TransferErrorController;

  const mockTransferErrorService = {};
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TransferErrorController],
      providers: [
        { provide: TransferErrorService, useValue: mockTransferErrorService },
      ],
    }).compile();

    controller = module.get<TransferErrorController>(TransferErrorController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-error/transfer-error.controller.ts
import {
  Controller,
  Get,
  HttpCode,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { TransferErrorService } from 'src/models/transfer-error/transfer-error.service';
import { GetTransferErrors } from './dto/get-transfer-errors.dto';

@ApiBearerAuth()
@ApiTags('Transfer Errors')
@Controller({
  path: ControllerRoute.TransferError,
  version: ControllerVersion.V2,
})
export class TransferErrorController {
  constructor(private transferErrorService: TransferErrorService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  async findAll(@Query() query: GetTransferErrors) {
    const { page, limit } = query;
    return this.transferErrorService.findAllPaginated({
      page,
      limit,
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer-error/dto/get-transfer-errors.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetTransferErrors extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/user.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';
import { UserService } from 'src/models/user/user.service';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const mockUserService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
      providers: [
        UserService,
        {
          provide: UserService,
          useValue: mockUserService,
        },
      ],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/dto/get-user.dto.ts
import { UserRole } from 'src/common/enums/user-role.enum';
import { Expose } from 'class-transformer';
import { State } from 'src/common/enums/state.enum';

export class GetUserDto {
  @Expose()
  id: number;

  @Expose()
  uuid: string;

  @Expose()
  createdAt: string;

  @Expose()
  updatedAt: string;

  @Expose()
  email: string;

  @Expose()
  name: string;

  @Expose()
  state: State;

  @Expose()
  role: UserRole;

  @Expose()
  mfa: boolean;

  @Expose()
  mfaState: string;

  @Expose()
  merchantId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/dto/get-users-query.dto.ts
import { IsOptional, IsString, Length } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetUsersQueryDto extends QueryPaginatedDto {
  @IsOptional()
  @IsString()
  @Length(1, 50)
  search?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/dto/create-user.dto.ts
import { IsEmail, IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsString()
  @IsNotEmpty()
  name: string;

  @IsNumber()
  @IsNotEmpty()
  merchantId: number;

  @IsString()
  @IsNotEmpty()
  password: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/dto/update-user.dto.ts
import { IsBoolean, IsEnum, IsOptional, IsString } from 'class-validator';
import { ExcludeDeletedState } from 'src/common/decorators/custom-validators/exclude-deleted-state.decorator';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';

export class UpdateUserDto {
  @IsString()
  @IsOptional()
  seed?: string;

  @IsBoolean()
  @IsOptional()
  mfa?: boolean;

  @IsString()
  @IsOptional()
  code?: string;

  @IsString()
  @IsOptional()
  mfaState?: MFAState;

  @IsString()
  @IsOptional()
  name?: string;

  @IsEnum(UserRole)
  @IsOptional()
  role?: UserRole;

  @IsEnum(State)
  @ExcludeDeletedState()
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/user/user.controller.ts
import {
  Controller,
  Get,
  Body,
  Patch,
  HttpCode,
  Param,
  UseInterceptors,
  Query,
  BadRequestException,
  Delete,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { UserService } from 'src/models/user/user.service';
import { GetUserDto } from './dto/get-user.dto';
import { GetUsersQueryDto } from './dto/get-users-query.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { User } from 'src/common/decorators/user.decorator';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Serialize } from 'src/common/interceptors/serialize.interceptor';
import { State } from 'src/common/enums/state.enum';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';
import { FindManyOptions, Like } from 'typeorm';
import { DESCENDING_ORDER } from 'src/database/query.constants';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('User')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.User })
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get('me')
  @HttpCode(200)
  @RequireAuth('jwt')
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  show(@User() user: UserEntity) {
    if (user.state !== State.ACTIVE)
      throw new BadRequestException('User is not active');
    return user;
  }

  @Patch('me')
  @HttpCode(200)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT, UserRole.USER)
  async update(@User() user: UserEntity, @Body() updateUserDto: UpdateUserDto) {
    // TODO: check what attributes a user should be able to update
    const updatedUser = await this.userService.update(user.id, updateUserDto);
    return updatedUser;
  }

  @Get('is-email-in-use/:email')
  @Roles(UserRole.SUPER)
  async isEmailInUse(
    @Param('email') email: string,
  ): Promise<{ isInUse: boolean }> {
    return { isInUse: await this.userService.isEmailInUse(email) };
  }

  @Get()
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Serialize(GetUserDto)
  @Roles(UserRole.SUPER, UserRole.SUPPORT, UserRole.ADMIN)
  findAll(
    @Query() query: GetUsersQueryDto,
    @MerchantId()
    merchantId?: number,
  ) {
    const options: FindManyOptions<UserEntity> = {
      order: {
        createdAt: DESCENDING_ORDER,
      },
    };

    if (query.search) {
      options.where = [
        { email: Like(`%${query.search}%`), ...(merchantId && { merchantId }) },
        { name: Like(`%${query.search}%`), ...(merchantId && { merchantId }) },
      ];
    } else {
      options.where = { ...(merchantId && { merchantId }) };
    }

    return this.userService.findAllPaginated({ ...query, options });
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  findOne(@Param('id') id: string) {
    return this.userService.findOne(+id);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  updateOne(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto,
  ): Promise<UserEntity> {
    return this.userService.update(+id, updateUserDto);
  }

  @Delete(':id')
  @Roles(UserRole.SUPER)
  async remove(@Param('id') id: string) {
    await this.userService.remove(+id);
    return { message: 'User was deleted successfully' };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement-job/account-statement-job.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountStatementJobController } from './account-statement-job.controller';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';

describe('AccountStetementJobController', () => {
  let controller: AccountStatementJobController;

  beforeEach(async () => {
    const mockAccountStatementService = {
      enqueueJob: () => {
        return [];
      },
      create: () => {
        return {};
      },
    };
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AccountStatementJobController],
      providers: [
        AccountStatementJobController,
        {
          provide: AccountStatementJobService,
          useValue: mockAccountStatementService,
        },
      ],
    }).compile();

    controller = module.get<AccountStatementJobController>(
      AccountStatementJobController,
    );
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement-job/account-statement-job.controller.ts
import {
  Controller,
  HttpCode,
  Get,
  Query,
  UseInterceptors,
  Post,
  Body,
  Patch,
  Param,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { PatchAccountStatementJobDto } from './dto/patch-account-statement-job.dto';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { SortOrder } from 'src/utils/array-methods.util';
import { FindManyOptions, In } from 'typeorm';
import { CreateAccountStatementJobDto } from './dto/create-account-statement-job.dto';
import { QueryAccountStatementJobQueryDto } from './dto/query-account-statement-job.dto';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Account Statement Job')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.AccountStatementJob,
})
export class AccountStatementJobController {
  constructor(
    private readonly accountStatementJobService: AccountStatementJobService,
  ) {}

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async create(
    @Body() createAccountStatementJobDto: CreateAccountStatementJobDto,
  ) {
    const accountStatementJob = await this.accountStatementJobService.create(
      createAccountStatementJobDto,
    );

    return accountStatementJob;
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  async patch(
    @Param('id') id: string,
    @Body() patchAccountStatementJobDto: PatchAccountStatementJobDto,
  ) {
    const accountStatementJob = await this.accountStatementJobService.update(
      +id,
      patchAccountStatementJobDto,
    );

    return accountStatementJob;
  }

  @Get()
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  async get(@Query() query: QueryAccountStatementJobQueryDto) {
    const { accountId, sort, limit, page, states } = query;

    const options: FindManyOptions<AccountStatementJobEntity> = {
      where: {
        ...(accountId && { accountId: +accountId }),
        ...(states && { state: In(states) }),
      },
      order: { createdAt: sort ?? SortOrder.DESCENDING },
    };

    return this.accountStatementJobService.findAllPaginated({
      page,
      limit,
      options,
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement-job/dto/patch-account-statement-job.dto.ts
import { Type } from 'class-transformer';
import {
  IsDate,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  Min,
} from 'class-validator';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';

export class PatchAccountStatementJobDto {
  @Type(() => Date)
  @IsDate()
  @IsOptional()
  endDate?: Date;

  @Type(() => Date)
  @IsDate()
  @IsOptional()
  startDate?: Date;

  @IsEnum(AccountStatementJobState)
  @IsNotEmpty()
  state: AccountStatementJobState;

  @Type(() => Date)
  @IsDate()
  @IsOptional()
  endedAt?: Date;

  @IsNumber()
  @Min(0)
  @IsOptional()
  balance?: number;

  @Type(() => Date)
  @IsDate()
  @IsOptional()
  retrievedAt?: Date;

  @Type(() => Date)
  @IsDate()
  @IsOptional()
  startedAt?: Date;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  jobId?: string;

  @IsNumber()
  @Min(0)
  @IsOptional()
  totalRetrieved?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement-job/dto/create-account-statement-job.dto.ts
import { Type } from 'class-transformer';
import {
  IsDate,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';

export class CreateAccountStatementJobDto {
  @Type(() => Date)
  @IsDate()
  endDate: Date;

  @Type(() => Date)
  @IsDate()
  startDate: Date;

  @IsEnum(AccountStatementJobState)
  @IsNotEmpty()
  state: AccountStatementJobState;

  @Type(() => Date)
  @IsDate()
  @IsOptional()
  startedAt?: Date;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  jobId?: string;

  @IsNumber()
  @IsOptional()
  bankAccountId?: number;

  @IsNumber()
  accountId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/account-statement-job/dto/query-account-statement-job.dto.ts
import { IsArray, IsEnum, IsOptional, IsString } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';
import { SortOrder } from 'src/utils/array-methods.util';
import { AccountStatementJobState } from '../../../../common/enums/account-statement-job.enum';

export class QueryAccountStatementJobQueryDto extends QueryPaginatedDto {
  @IsString()
  @IsOptional()
  public accountId?: string;

  @IsOptional()
  @IsArray()
  @IsEnum(AccountStatementJobState, { each: true })
  public states?: AccountStatementJobState[];

  @IsEnum(SortOrder)
  @IsOptional()
  public sort? = SortOrder.ASCENDING;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout-action/payout-action.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { PayoutActionsService } from 'src/models/payout-actions/payout-actions.service';
import { PayoutActionController } from './payout-action.controller';

describe('PayoutActionController', () => {
  let controller: PayoutActionController;
  const mockPayoutActionService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PayoutActionController],
      providers: [
        { provide: PayoutActionsService, useValue: mockPayoutActionService },
      ],
    }).compile();

    controller = module.get<PayoutActionController>(PayoutActionController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout-action/dto/get-payout-actions.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetPayoutActionsDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/payout-action/payout-action.controller.ts
import {
  Controller,
  Get,
  HttpCode,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { PayoutActionsService } from 'src/models/payout-actions/payout-actions.service';
import { MAPPED_ERROR_TYPE } from '../../../models/transfer-error/error.definition.type';
import { GetPayoutActionsDto } from './dto/get-payout-actions.dto';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Payout Actions')
@Controller({
  path: ControllerRoute.PayoutActions,
  version: ControllerVersion.V2,
})
export class PayoutActionController {
  constructor(private payoutActionsService: PayoutActionsService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  async findAll(@Query() query: GetPayoutActionsDto) {
    const { page, limit } = query;
    const response = await this.payoutActionsService.findAllPaginated({
      page,
      limit,
    });

    const data = response.data.map((payoutAction) => ({
      ...payoutAction,
      errorType: MAPPED_ERROR_TYPE[payoutAction.errorCode],
    }));

    return { ...response, data };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/audit-log/audit-log.controller.ts
import { FindManyOptions } from 'typeorm';
import {
  Controller,
  Get,
  HttpCode,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiSecurity, ApiTags } from '@nestjs/swagger';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { GetAuditLogDto } from './dto/get-audit-log.dto';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';
import { AuditLogEntity } from 'src/models/audit-log/entities/audit-log.entity';

@ApiBearerAuth()
@ApiSecurity('apiKey')
@ApiTags('Audit-Logs')
@Controller({
  version: ControllerVersion.V2,
  path: ControllerRoute.AuditLogs,
})
export class AuditLogController {
  constructor(private auditLogService: AuditLogService) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER, UserRole.SUPPORT)
  @UseInterceptors(PaginatedInterceptor)
  findAll(@Query() query: GetAuditLogDto) {
    const options: FindManyOptions<AuditLogEntity> = {
      where: {
        entityId: query.entityId,
        entityType: query.entityType,
      },
    };

    return this.auditLogService.findAllPaginated({ ...query, options });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/audit-log/audit-log.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AuditLogController } from './audit-log.controller';
import { AuditLogService } from 'src/models/audit-log/audit-log.service';

describe('AuditLogController', () => {
  let controller: AuditLogController;
  const mockAuditLogService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuditLogController],
      providers: [{ provide: AuditLogService, useValue: mockAuditLogService }],
    }).compile();

    controller = module.get<AuditLogController>(AuditLogController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/audit-log/dto/get-audit-log.dto.ts
import { IsEnum, IsString } from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export enum AuditLogEntityType {
  PayoutEntity = 'PayoutEntity',
  TransferEntity = 'TransferEntity',
  UserEntity = 'UserEntity',
}

export class GetAuditLogDto extends QueryPaginatedDto {
  @IsEnum(AuditLogEntityType)
  entityType: AuditLogEntityType;

  @IsString()
  entityId: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/audit-log/dto/create-audit-log.dto.ts
import { IsEnum, IsNumber, IsOptional, IsString } from 'class-validator';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';

export class CreateAuditLogDto {
  @IsString()
  @IsOptional()
  context?: string;

  @IsNumber()
  @IsOptional()
  authorId?: number;

  @IsString()
  @IsOptional()
  authorType?: string;

  @IsEnum(AuditLogEvent)
  event: AuditLogEvent;

  @IsString()
  entityType: string;

  @IsString()
  entityId: string;

  @IsString()
  @IsOptional()
  entityAfter?: string;

  @IsString()
  @IsOptional()
  entityBefore?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/bank/bank.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { BankController } from './bank.controller';
import { BankService } from 'src/models/bank/bank.service';

describe('BankController', () => {
  let controller: BankController;

  beforeEach(async () => {
    const mockBankService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [BankController],
      providers: [
        BankService,
        {
          provide: BankService,
          useValue: mockBankService,
        },
      ],
    }).compile();

    controller = module.get<BankController>(BankController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/bank/bank.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  HttpCode,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { BankService } from 'src/models/bank/bank.service';
import { CreateBankDto } from './dto/create-bank.dto';
import { GetBanksQueryDto } from './dto/get-banks-query.dto';
import { ControllerRoute, ControllerVersion } from 'src/api/common';

@ApiBearerAuth()
@ApiTags('Bank')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.Bank })
export class BankController {
  constructor(private readonly bankService: BankService) {}

  @Get()
  @HttpCode(200)
  @RequireAuth('none')
  @UseInterceptors(PaginatedInterceptor)
  findAll(@Query() query: GetBanksQueryDto) {
    return this.bankService.findAllPaginated(query);
  }

  @Get(':code')
  @HttpCode(200)
  @RequireAuth('none')
  findOne(@Param('code') code: string) {
    return this.bankService.findOneByConditions({ where: { code } });
  }

  @Post()
  @HttpCode(201)
  @Roles(UserRole.SUPER)
  create(@Body() createBankDto: CreateBankDto) {
    return this.bankService.create(createBankDto);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/bank/dto/update-bank.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { State } from 'src/common/enums/state.enum';

export class UpdateBankDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/bank/dto/get-banks-query.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetBanksQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/bank/dto/create-bank.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { State } from 'src/common/enums/state.enum';

export class CreateBankDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  code: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer/dto/create-transfer.dto.ts
import { Expose } from 'class-transformer';
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferMode } from 'src/common/enums/transfer-mode.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class CreateTransferDto {
  @Expose()
  @IsNumber()
  @IsPositive()
  amount: number;

  @Expose()
  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @Expose()
  @IsEnum(TransferMode)
  @IsOptional()
  mode?: TransferMode;

  @Expose()
  @IsString()
  concept: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  trackingCode: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationEmail?: string;

  @Expose()
  @IsString()
  destinationHolderId: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationBankCode: string;

  @Expose()
  @IsNumber()
  @IsNotEmpty()
  @IsOptional()
  originBankAccessId?: number;

  @Expose()
  @IsNumber()
  @IsOptional()
  originBankAccountId?: number;

  @Expose()
  @IsString()
  @IsOptional()
  originBankCode?: string;

  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @Expose()
  @IsNumber()
  @IsOptional()
  merchantId: number;

  @Expose()
  @IsNumber()
  payoutId: number;

  @Expose()
  @IsString()
  destinationPhone: string;

  @Expose()
  @IsEnum(EntityVersion)
  @IsOptional()
  version?: EntityVersion;

  @IsNumber()
  @IsPositive()
  providerId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer/dto/transfer-mismatch.dto.ts
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

export class TransferMismatchDto {
  destinationHolderId: string;
  diffCount: number;
  amountMismatch: number;
  transfers: TransferEntity[];
  accountStatements: AccountStatementEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer/dto/authorize-transfer.dto.ts
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
} from 'class-validator';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';

export interface SecurityCardPayload {
  coordinates: string[];
}

export class AuthorizeTransferDto {
  @IsNumber()
  @IsPositive()
  bankAccessId: number;

  @IsEnum(TransferMethodType)
  transferMethodType: TransferMethodType;

  @IsObject()
  @IsOptional()
  payload?: SecurityCardPayload;

  @IsDate()
  @IsOptional()
  limitDate?: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer/dto/update-transfer.dto.ts
import { Expose } from 'class-transformer';
import {
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class UpdateTransferDto {
  @Expose()
  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @Expose()
  @IsString()
  @IsOptional()
  message?: string;

  @Expose()
  @IsObject()
  @IsOptional()
  metadata?: object;

  @Expose()
  @IsString()
  @IsOptional()
  externalId?: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  providerId?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/transfer/dto/transfer-reconciliation.dto.ts
import { IsGreaterThanOrEqualDate } from 'src/common/decorators/custom-validators';
import { IsUTCDateString } from 'src/common/decorators/custom-validators/isUTCDateString.validator';

export class TransferReconciliationDto {
  @IsUTCDateString()
  startDate: string;

  @IsUTCDateString()
  @IsGreaterThanOrEqualDate('startDate')
  endDate: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/api-key.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ApiKeyController } from './api-key.controller';
import { ApiKeyService } from 'src/models/apikey/apikey.service';

describe('ApiKeyController', () => {
  let controller: ApiKeyController;

  beforeEach(async () => {
    const mockApiKeyService = {};
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ApiKeyController],
      providers: [
        ApiKeyService,
        {
          provide: ApiKeyService,
          useValue: mockApiKeyService,
        },
      ],
    }).compile();

    controller = module.get<ApiKeyController>(ApiKeyController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/dto/update-api-key.dto.ts
import { State } from 'src/common/enums/state.enum';
import { IsEnum, IsOptional, IsString } from 'class-validator';

export class UpdateApiKeyDto {
  @IsString()
  @IsOptional()
  name: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/dto/created-api-key.dto.ts
import { Expose } from 'class-transformer';

/** DTO for created ApiKey
 * Used to send back the created ApiKey. This is the only time the key is sent back to the client.
 */
export class CreatedApiKeyDto {
  @Expose()
  id: number;

  @Expose()
  name: string;

  @Expose()
  key: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/dto/get-api-key-dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetApiKeysQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/dto/create-api-key.dto.ts
import { IsString, IsNotEmpty, IsNumber, IsOptional } from 'class-validator';

/** Create ApiKey DTO
 * Used to create a new ApiKey
 */
export class CreateApiKeyDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsOptional()
  @IsNumber()
  merchantId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/v2/api-key/api-key.controller.ts
import {
  Body,
  Controller,
  Get,
  HttpCode,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { FindManyOptions } from 'typeorm';
import { ApiTags } from '@nestjs/swagger';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';
import { Serialize } from 'src/common/interceptors/serialize.interceptor';
import { ApiKeyService } from 'src/models/apikey/apikey.service';
import { CreateApiKeyDto } from './dto/create-api-key.dto';
import { CreatedApiKeyDto } from './dto/created-api-key.dto';
import { UpdateApiKeyDto } from './dto/update-api-key.dto';
import { ControllerRoute, ControllerVersion } from 'src/api/common';
import { GetApiKeysQueryDto } from './dto/get-api-key-dto';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { PaginatedInterceptor } from 'src/common/interceptors/paginated.interceptor';
import { MerchantId } from 'src/common/decorators/merchantId.decorator';
import { RequireAuth } from '../auth/decorators/requireAuth.decorator';
@ApiTags('ApiKey')
@Controller({ version: ControllerVersion.V2, path: ControllerRoute.ApiKey })
export class ApiKeyController {
  constructor(private readonly apiKeyService: ApiKeyService) {}

  @Get()
  @HttpCode(200)
  @UseInterceptors(PaginatedInterceptor)
  @Roles(UserRole.SUPER, UserRole.SUPPORT, UserRole.ADMIN)
  @RequireAuth('jwt')
  findAll(
    @MerchantId() merchantId: number,
    @Query() query: GetApiKeysQueryDto,
  ) {
    const options: FindManyOptions<ApiKeyEntity> = {
      where: {},
      order: {
        createdAt: DESCENDING_ORDER,
      },
    };
    if (merchantId) options.where['merchantId'] = merchantId;

    return this.apiKeyService.findAllPaginated({ ...query, options });
  }

  @Get(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  @RequireAuth('jwt')
  findOne(@Param('id') id: string) {
    return this.apiKeyService.findOne(+id);
  }

  @Post()
  @HttpCode(201)
  @Serialize(CreatedApiKeyDto)
  @Roles(UserRole.SUPER)
  @RequireAuth('jwt')
  create(@Body() createApiKeyDto: CreateApiKeyDto) {
    return this.apiKeyService.create(createApiKeyDto);
  }

  @Patch(':id')
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  @RequireAuth('jwt')
  update(@Param('id') id: string, @Body() updateApiKeyDto: UpdateApiKeyDto) {
    return this.apiKeyService.update(+id, updateApiKeyDto);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/provider/provider.controller.ts
import {
  Controller,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  VERSION_NEUTRAL,
} from '@nestjs/common';
import { ApiSecurity, ApiTags } from '@nestjs/swagger';
import { plainToClass } from 'class-transformer';
import { ControllerRoute } from 'src/api/common';

import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { FindOneOptions, In } from 'typeorm';
import { ScraperProviderDto } from './dto/scraper-provider.dto';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { Roles } from 'src/common/decorators/roles.decorator';
import { UserRole } from 'src/common/enums/user-role.enum';

@Controller({
  version: VERSION_NEUTRAL,
  path: `${ControllerRoute.Internal}/${ControllerRoute.Provider}`,
})
@ApiSecurity('apiKey')
@ApiTags('Provider')
export class ProviderController {
  constructor(private providerService: ProviderService) {}

  @Get(`/:id/${ControllerRoute.Scraper}`)
  @Roles(UserRole.SUPER)
  @HttpCode(200)
  async findOneForScraper(@Param('id') id: string) {
    const options: FindOneOptions<ProviderEntity> = {
      where: {
        id: +id,
        providerType: In([ProviderType.ScraperCG, ProviderType.ScraperPW]),
      },
      relations: ['account'],
    };

    const provider = await this.providerService.findOneByConditions(options);

    if (!provider) throw new NotFoundException(`Provider ${id} not found`);

    const scraperProviderDto = plainToClass(ScraperProviderDto, provider);

    return scraperProviderDto;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/provider/dto/scraper-provider.dto.ts
import { Expose, Type } from 'class-transformer';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { State } from 'src/common/enums/state.enum';
import { AccountEntity } from 'src/models/account/entities/account.entity';

export class ScraperProviderDto {
  @Expose()
  id: number;

  @Expose()
  @Type(() => AccountEntity)
  account: AccountEntity;

  @Expose()
  providerType: ProviderType;

  @Expose()
  credentials?: string;

  @Expose()
  state: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/provider/provider.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ProviderService } from 'src/models/provider/provider.service';
import { ProviderController } from './provider.controller';

describe('ProviderController', () => {
  let controller: ProviderController;
  const mockProviderService: Partial<ProviderService> = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProviderController],
      providers: [{ provide: ProviderService, useValue: mockProviderService }],
    }).compile();

    controller = module.get<ProviderController>(ProviderController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/api.module.ts
import { Module } from '@nestjs/common';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { TransferAuthModule } from 'src/services/transfer-auth/transfer-auth.module';
import { TransferFirebreakModule } from 'src/services/transfer-firebreak/transfer-firebreak.module';
import { TransactionsController } from './transactions/transactions.controller';
import { ProviderController } from './provider/provider.controller';
import { FeatureFlagController } from './feature-flag/feature-flag.controller';
import { ProviderModule } from 'src/models/provider/provider.module';
import { FeatureFlagModule } from 'src/services/feature-flag/feature-flag.module';

@Module({
  imports: [
    TransferModule,
    TransferFirebreakModule,
    TransferAuthModule,
    ProviderModule,
    FeatureFlagModule,
  ],
  controllers: [
    TransactionsController,
    ProviderController,
    FeatureFlagController,
  ],
})
export class ApiInternalModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/transactions/transactions.controller.ts
import {
  Body,
  Controller,
  Get,
  HttpCode,
  Post,
  Query,
  VERSION_NEUTRAL,
} from '@nestjs/common';
import { ApiSecurity } from '@nestjs/swagger';
import { plainToInstance } from 'class-transformer';
import { ControllerRoute } from 'src/api/common';
import { AuthorizeTransferDto } from 'src/api/v2/transfer/dto/authorize-transfer.dto';
import { Roles } from 'src/common/decorators/roles.decorator';
import { User } from 'src/common/decorators/user.decorator';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { TransferAuthService } from 'src/services/transfer-auth/transfer-auth.service';
import { TransferFirebreakService } from 'src/services/transfer-firebreak/transfer-firebreak.service';
import { FindManyOptions } from 'typeorm';
import { QueryTransactionsDto } from './dto/query-transactions-dto';

@ApiSecurity('apiKey')
@Controller({
  version: VERSION_NEUTRAL,
  path: `${ControllerRoute.Internal}/${ControllerRoute.Transactions}`,
})
export class TransactionsController {
  constructor(
    private transferService: TransferService,
    private transferFirebreakService: TransferFirebreakService,
    private transferAuthService: TransferAuthService,
  ) {}

  @Get()
  @HttpCode(200)
  @Roles(UserRole.SUPER)
  async findAll(
    @User('merchantId') merchantId: number,
    @User('role') role: UserRole,
    @Query() query: QueryTransactionsDto,
  ) {
    const isSuper = role === UserRole.SUPER;

    const { providerId, transferId, state, sort } = query;

    const filterByMerchant = !isSuper && { merchantId, state: State.ACTIVE };

    const options: FindManyOptions<TransferEntity> = {
      where: {
        ...filterByMerchant,
        provider: {
          id: providerId,
          state: State.ACTIVE,
        },
        version: EntityVersion.v2,
        ...(state && { state }),
        ...(transferId && { id: transferId }),
      },
      order: {
        createdAt: sort,
      },
    };

    const transfers = await this.transferService.findAll(options, false);

    const transactions = plainToInstance(TransactionDto, transfers, {
      excludeExtraneousValues: true,
    });

    return transactions;
  }

  @Post('firebreak')
  @HttpCode(200)
  async firebreak(@Body() transactionDto: TransactionDto) {
    const validation = await this.transferFirebreakService.validate(
      transactionDto,
    );

    return validation;
  }

  @Post('authorize')
  @HttpCode(200)
  async authorize(@Body() authorizeTransferDto: AuthorizeTransferDto) {
    const { bankAccessId, transferMethodType } = authorizeTransferDto;
    const transferMethod =
      await this.transferAuthService.findBankAccessTransferMethod(
        bankAccessId,
        transferMethodType,
      );

    const response = await this.transferAuthService.authorizeTransfer(
      transferMethod,
      authorizeTransferDto,
    );

    return response;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/transactions/transactions.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransferAuthService } from 'src/services/transfer-auth/transfer-auth.service';
import { TransferFirebreakService } from 'src/services/transfer-firebreak/transfer-firebreak.service';
import { TransactionsController } from './transactions.controller';

describe('TransactionsController', () => {
  let controller: TransactionsController;
  const mockTransferService = {};
  const mockTransferFirebreakService = {};
  const mockTransferAuthService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TransactionsController],
      providers: [
        { provide: TransferService, useValue: mockTransferService },
        {
          provide: TransferFirebreakService,
          useValue: mockTransferFirebreakService,
        },
        {
          provide: TransferAuthService,
          useValue: mockTransferAuthService,
        },
      ],
    }).compile();

    controller = module.get<TransactionsController>(TransactionsController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/transactions/dto/query-transactions-dto.ts
import { IsEnum, IsNumberString, IsOptional } from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { SortOrder } from 'src/utils/array-methods.util';

export class QueryTransactionsDto {
  @IsNumberString()
  providerId: number;

  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @IsNumberString()
  @IsOptional()
  transferId?: number;

  @IsEnum(SortOrder)
  @IsOptional()
  sort? = SortOrder.ASCENDING;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/feature-flag/feature-flag.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { FeatureFlagController } from './feature-flag.controller';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

describe('FeatureFlagController', () => {
  let controller: FeatureFlagController;
  const mockFeatureFlagService: Partial<FeatureFlagService> = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FeatureFlagController],
      providers: [
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    controller = module.get<FeatureFlagController>(FeatureFlagController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/internal/feature-flag/feature-flag.controller.ts
import {
  Controller,
  Get,
  HttpCode,
  Param,
  VERSION_NEUTRAL,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { ControllerRoute } from 'src/api/common';
import { Roles } from 'src/common/decorators/roles.decorator';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

@Controller({
  version: VERSION_NEUTRAL,
  path: `${ControllerRoute.Internal}/${ControllerRoute.FeatureFlags}`,
})
@ApiBearerAuth()
@ApiTags('FeatureFlags')
export class FeatureFlagController {
  constructor(private featureFlagService: FeatureFlagService) {}

  @Get(`/:featureFlag`)
  @Roles(UserRole.ADMIN, UserRole.SUPER, UserRole.SUPPORT)
  @HttpCode(200)
  async getFeatureValue(@Param('featureFlag') featureFlag: FEATURE_FLAG) {
    const result = await this.featureFlagService.getFeatureStatus(featureFlag);
    return { value: result };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/common/enums/controller-route.ts
export enum ControllerRoute {
  Account = 'accounts',
  Auth = 'auth',
  AccountStatement = 'account-statements',
  AccountStatementJob = 'account-statement-jobs',
  Apikey = 'apikeys',
  ApiKey = 'api-keys',
  AuthorizationCode = 'authorization-codes',
  Bank = 'banks',
  Merchant = 'merchants',
  Metrics = 'metrics',
  Management = 'management',
  Limit = 'limits',
  Payout = 'payouts',
  Provider = 'providers',
  Transfer = 'transfers',
  TransferJob = 'transfer-jobs',
  TransferMethod = 'transfer-methods',
  TransferError = 'transfer-errors',
  User = 'users',
  WebhookEndpoint = 'webhook-endpoints',
  Internal = 'internal',
  Transactions = 'transactions',
  Scraper = 'scrapers',
  Webhooks = 'webhooks',
  AuditLogs = 'audit-logs',
  Reconciliations = 'reconciliations',
  FeatureFlags = 'feature-flags',
  PayoutActions = 'payout-actions',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/common/enums/controller-version.ts
export enum ControllerVersion {
  V1 = '1',
  V2 = '2',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/api/common/index.ts
export * from './enums/controller-route';
export * from './enums/controller-version';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/encryption.util.spec.ts
import { EncryptionService } from './encryption.util';

describe('EncryptionService', () => {
  it('should encrypt a string with a custom key', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const text = 'Hello World!';
    const encryptedText = encryptionService.encrypt(text);
    expect(encryptedText).not.toBe(text);
  });

  it('should decrypt a string with a custom key', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const text = 'Hello World!';
    const encryptedText = encryptionService.encrypt(text);
    const decryptedText = encryptionService.decrypt(encryptedText);
    expect(decryptedText).toBe(text);
  });

  it('should encrypt a plain object with a custom key', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const credentials = { username: 'username', password: 'password' };
    const encryptedCredentials =
      encryptionService.encryptCredential(credentials);
    expect(encryptedCredentials).not.toBe(credentials);
  });

  it('should decrypt a plain object with a custom key', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const credentials = { username: 'username', password: 'password' };
    const encryptedCredentials =
      encryptionService.encryptCredential(credentials);
    const decryptedCredentials =
      encryptionService.decryptCredential(encryptedCredentials);
    expect(decryptedCredentials).toEqual(credentials);
  });

  it('should encrypt a plain object and preserve the original key names', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const credentials = { username: 'username', password: 'password' };
    const encryptedCredentials =
      encryptionService.encryptCredential(credentials);
    expect(Object.keys(encryptedCredentials)).toEqual(Object.keys(credentials));
    expect(Object.values(encryptedCredentials)).not.toEqual(
      Object.values(credentials),
    );
  });

  it('should generate different outputs for the same input', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const text = 'Hello World!';
    const encryptedText = encryptionService.encrypt(text);
    const encryptedText2 = encryptionService.encrypt(text);
    expect(encryptedText).not.toBe(encryptedText2);
  });

  it('should generate different outputs for the same input with different keys', () => {
    const encryptionKey = EncryptionService.generateKey();
    const encryptionService = new EncryptionService(encryptionKey);
    const encryptionKey2 = EncryptionService.generateKey();
    const encryptionService2 = new EncryptionService(encryptionKey2);
    const text = 'Hello World!';
    const encryptedText = encryptionService.encrypt(text);
    const encryptedText2 = encryptionService2.encrypt(text);
    expect(encryptionKey).not.toBe(encryptionKey2);
    expect(encryptedText).not.toBe(encryptedText2);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/json-util.spec.ts
import { jsonStringify, mapStringToClass } from './json.util';

describe('Given a Object', () => {
  describe('When the user call the method jsonStringify', () => {
    it('then it should correctly stringify an object without Date properties', () => {
      const inputObject = {
        state: 'finished',
        totalCompleted: 0,
        totalFailed: 1,
      };

      const jsonString = jsonStringify(inputObject);

      expect(jsonString).toEqual(JSON.stringify(inputObject));
    });

    it('then it should correctly stringify an object with Date properties', () => {
      const inputObject = {
        state: 'finished',
        endedAt: new Date('2023-08-10T14:59:44.327Z'),
        totalCompleted: 0,
        totalFailed: 1,
      };

      const expectedJsonString = JSON.stringify({
        ...inputObject,
        endedAt: inputObject.endedAt.toISOString(),
      });

      const jsonString = jsonStringify(inputObject);

      expect(jsonString).toEqual(expectedJsonString);
    });
  });

  describe('When the user call the method jsonStringify', () => {
    it('then should correctly parse a valid JSON string into an object', () => {
      const jsonString = '{"name": "Alice", "age": 30}';
      const expectedObject = { name: 'Alice', age: 30 };

      const result = mapStringToClass<typeof expectedObject>(jsonString);

      expect(result).toEqual(expectedObject);
    });

    it('should return undefined and log an error for an invalid JSON string', () => {
      const invalidJsonString = '{name: "Alice", age: 30}';

      const result = mapStringToClass<any>(invalidJsonString);

      expect(result).toBeUndefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/token-expiration-validator.spec.ts
import { isTokenExpired } from './token-expiration-validator';
import * as jwt from 'jsonwebtoken';

describe('Given the isTokenExpired function', () => {
  let token: string;

  beforeEach(() => {
    const payload = { payload: 'payload' };
    const options = { expiresIn: 3600 };
    token = jwt.sign(payload, 'yourSecretKey', options);
  });

  describe('when token is not expired', () => {
    it('returns false', () => {
      expect(isTokenExpired(token)).toBe(false);
    });
  });

  describe('when token is expired', () => {
    it('returns true', () => {
      const payload = { payload: 'payload' };
      const options = { expiresIn: -3600 };
      const expiredToken = jwt.sign(payload, 'yourSecretKey', options);
      expect(isTokenExpired(expiredToken)).toBe(true);
    });
  });

  describe('when token will expire within 5 minutes', () => {
    it('returns true', () => {
      const payload = { payload: 'payload' };
      const options = { expiresIn: 60 };
      const expiringToken = jwt.sign(payload, 'yourSecretKey', options);
      expect(isTokenExpired(expiringToken)).toBe(true);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/obfuscation.util.ts
import {
  OBFUSCATE_KEY,
  OBFUSCATE_VALUE,
} from 'src/common/decorators/exclude-from-logs.decorator';

export function obfuscateObject<T extends object>(object?: T): T | undefined {
  try {
    if (!object) return;

    const fieldsToObfuscate: string[] = Object.keys(object).filter(
      (propertyName) =>
        Reflect.getMetadata(OBFUSCATE_KEY, object, propertyName),
    );

    const objectCopy = { ...object };

    for (const [key, value] of Object.entries(objectCopy)) {
      if (fieldsToObfuscate.includes(key)) {
        objectCopy[key] = OBFUSCATE_VALUE;
      } else if (Array.isArray(value)) {
        objectCopy[key] = value.map((item) => obfuscateObject(item));
      } else if (
        value !== null &&
        typeof value === 'object' &&
        Object.keys(value).length > 0
      ) {
        objectCopy[key] = obfuscateObject(value);
      }
    }

    return objectCopy;
  } catch {
    return undefined;
  }
}

export function obfuscatePlainObject<T extends object>(obj: T): T {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => {
      if (typeof value === 'string') {
        const obfuscatedValue = value.replace(/./g, '*');
        return [key, obfuscatedValue];
      }
      return [key, value];
    }),
  ) as T;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/secrets.util.ts
import * as crypto from 'crypto';
import * as moment from 'moment';

type HmacSignature = {
  signature: string;
  timestamp: string;
};

export function generateSecret(): string {
  const key = crypto.generateKeySync('hmac', { length: 256 });
  return key.export().toString('hex');
}

export function hmacSignature(
  payload: unknown,
  key: string,
  _timestamp?: string,
): HmacSignature {
  const text = JSON.stringify(payload);
  const timestamp = _timestamp ?? moment().unix().toString();
  const content = `${timestamp}.${text}`;

  const signature: string = crypto
    .createHmac('sha256', key)
    .update(content, 'utf8')
    .digest('base64');
  return { signature, timestamp };
}

export function generatePayloadSignature(
  payload: unknown,
  key: string,
  _timestamp?: string,
): string {
  const { signature, timestamp } = hmacSignature(payload, key, _timestamp);
  return `t=${timestamp},v1=${signature}`;
}

export function parseSignatureHeader(header) {
  if (header == null || header === '') return;

  const HEADER_REGEX = /^t=(?<timestamp>.+),v1=(?<signature>.+)$/i;
  const match = HEADER_REGEX.exec(header);
  if (match == null) return;

  const { timestamp, signature } = match.groups;
  return { timestamp, signature };
}

export function validateSignature(
  token: string,
  header: string,
  body: unknown,
) {
  const signatureObject = parseSignatureHeader(header);
  if (!signatureObject) return false;

  const { timestamp, signature } = signatureObject;
  const { signature: expectedSignature } = hmacSignature(
    body,
    token,
    timestamp,
  );
  const expectedBuffer = Buffer.from(expectedSignature, 'base64');
  const signatureBuffer = Buffer.from(signature, 'base64');
  return Buffer.compare(signatureBuffer, expectedBuffer) === 0;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/hash-apiKey.util.ts
import { createHash } from 'crypto';
import generalConfig from 'src/config/general.config';

export function hashApiKey(apiKey) {
  const secret = generalConfig().security.securityKey;
  return createHash('sha256')
    .update(apiKey + secret)
    .digest('hex');
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/obfuscation.spec.ts
import {
  ExcludeFromLogs,
  OBFUSCATE_VALUE,
} from 'src/common/decorators/exclude-from-logs.decorator';
import { obfuscateObject } from './obfuscation.util';

class ExampleObjectWithoutObfuscation {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class ExampleObjectWithObfuscation {
  @ExcludeFromLogs()
  secret: string;
  publicData: number;

  constructor(secret: string, publicData: number) {
    this.secret = secret;
    this.publicData = publicData;
  }
}

describe('obfuscateObject', () => {
  it('should not obfuscate properties without the ExcludeFromLogs decorator', () => {
    const object = new ExampleObjectWithoutObfuscation('Alicia', 10);

    const originalObject = JSON.parse(JSON.stringify(object));

    obfuscateObject(object);
    expect(object.name).toEqual(originalObject.name);
    expect(object.age).toEqual(originalObject.age);
  });

  it('should obfuscate properties with the ExcludeFromLogs decorator', () => {
    const object = new ExampleObjectWithObfuscation('Alicia', 10);

    const result = obfuscateObject(object);
    expect(result.secret).toEqual(OBFUSCATE_VALUE);
    expect(result.publicData).toEqual(object.publicData);
  });

  it('should not obfuscate properties if the object is undefined', () => {
    const result = obfuscateObject(undefined);

    expect(result).toEqual(undefined);
  });

  it('should return a copy of the object and not modify the object passed as an argument', () => {
    const object = new ExampleObjectWithObfuscation('Alicia', 10);

    const originalObject = JSON.parse(JSON.stringify(object));
    const result = obfuscateObject(object);

    expect(result).not.toEqual(object);
    expect(object).toEqual(originalObject);
  });
  it('should obfuscate nested object arrays in the main object', () => {
    const object = {
      name: 'John',
      data: [
        new ExampleObjectWithObfuscation('secret', 12),
        new ExampleObjectWithObfuscation('secret-2', 14),
      ],
    };

    const result = obfuscateObject(object);

    expect(result.name).toEqual(object.name);
    expect(result.data[0].secret).toEqual(OBFUSCATE_VALUE);
    expect(result.data[0].publicData).toEqual(object.data[0].publicData);
    expect(result.data[1].secret).toEqual(OBFUSCATE_VALUE);
    expect(result.data[1].publicData).toEqual(object.data[1].publicData);
  });

  it('should obfuscate nested object in the main object', () => {
    const object = {
      name: 'John',
      data: new ExampleObjectWithObfuscation('secret', 12),
    };

    const result = obfuscateObject(object);

    expect(result.name).toEqual(object.name);
    expect(result.data.secret).toEqual(OBFUSCATE_VALUE);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/token-expiration-validator.ts
import * as jwt from 'jsonwebtoken';
import * as moment from 'moment-timezone';

export function isTokenExpired(token: string): boolean {
  if (!token) throw new Error('Liquido: token not present');

  if (typeof token !== 'string') throw new Error('Liquido: Wrong type token');

  const decodedToken = jwt.decode(token) as jwt.JwtPayload;
  if (!decodedToken) throw new Error('Liquido: unable to decode token');

  const { exp } = decodedToken;
  if (!exp) throw new Error('Liquido: Token without expiration');

  const minimumDate = moment().add(5, 'minutes');
  const expiresAt = moment.unix(exp);

  const expiredToken = expiresAt.isBefore(minimumDate);
  return expiredToken;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/currency-methods.util.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { LanguageTag } from 'src/common/enums/language-tag.enum';
import {
  MapCountryCodeToCurrency,
  MapCountryCodeToLanguageTag,
} from 'src/common/maps/country.map';

export function countryCodeToLanguageTag(
  countryCode: CountryCode,
): LanguageTag {
  if (!countryCode) return null;

  const languageTag = MapCountryCodeToLanguageTag[countryCode];
  return languageTag;
}

export function countryCodeToCurrencyCode(countryCode: CountryCode): Currency {
  if (!countryCode) return null;

  const currency = MapCountryCodeToCurrency[countryCode];
  return currency;
}

export function formatAmount(
  amount: number,
  countryCode = CountryCode.CHILE,
): string {
  if (!amount) return null;

  const languageTag = countryCodeToLanguageTag(countryCode);
  const currency = countryCodeToCurrencyCode(countryCode);

  const formatOptions = {
    style: 'currency',
    currency: currency.toUpperCase(),
    minimumFractionDigits: 0,
    maximumFractionDigits: 2,
  };
  const formattedAmount = new Intl.NumberFormat(
    languageTag,
    formatOptions,
  ).format(amount);

  return formattedAmount;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/array-methods.util.ts
export enum SortOrder {
  ASCENDING = 'ASC',
  DESCENDING = 'DESC',
}

export function sumArray(array: number[]) {
  return array.reduce((acc, curr) => {
    return acc + curr;
  }, 0);
}

/**
 * Picks a random element from an array
 * @param array - the array to pick from
 * @returns a random element from the array
 */
export function pick<T>(array: T[]): T {
  const randomIndex = Math.floor(Math.random() * array.length);
  return array[randomIndex];
}

export function sortByField<T extends object>(
  array: T[],
  field: string,
  order: SortOrder = SortOrder.ASCENDING,
): T[] {
  const weight = order === SortOrder.DESCENDING ? 1 : -1;

  return array.sort((element, other) => {
    const value = Reflect.get(element, field);
    const otherValue = Reflect.get(other, field);
    return value < otherValue ? weight : -1 * weight;
  });
}

export function filterUndefined<T>(array: T[]): T[] {
  return array.filter((element) => element !== undefined);
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/json.util.ts
import { Logger } from '@nestjs/common';

const logger = new Logger('JsonUtil');

export function jsonStringify(object: any): string {
  const jsonString = JSON.stringify(object, (_key, value) => {
    if (value instanceof Date) {
      return value.toISOString();
    }
    return value;
  });
  return jsonString;
}

export function mapStringToClass<Type>(stringify: string): Type {
  try {
    const obj = JSON.parse(stringify);
    return obj;
  } catch (error) {
    logger.debug(error.message);
    return undefined;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/encryption.util.ts
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

export interface Credential {
  [key: string]: string;
}

export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';

  private encryptionKey: Buffer;

  constructor(encryptionKey: string) {
    this.encryptionKey = Buffer.from(encryptionKey, 'hex');
  }

  public static generateKey(): string {
    const key = randomBytes(32).toString('hex'); // 32 bytes for AES-256
    return key;
  }

  public encrypt(text: string): string {
    const iv = randomBytes(12); // 12 bytes for AES-GCM
    const cipher = createCipheriv(this.algorithm, this.encryptionKey, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const tag = cipher.getAuthTag().toString('hex');

    return iv.toString('hex') + encrypted + tag;
  }

  public decrypt(text: string): string {
    const iv = Buffer.from(text.slice(0, 24), 'hex'); // Extract IV (12 bytes) from the beginning
    const encryptedText = Buffer.from(text.slice(24, -32), 'hex'); // Extract encrypted data
    const tag = Buffer.from(text.slice(-32), 'hex'); // Extract authentication tag (16 bytes) from the end

    const decipher = createDecipheriv(this.algorithm, this.encryptionKey, iv);
    decipher.setAuthTag(tag);

    let decrypted = decipher.update(encryptedText); // Pass the encryptedText buffer directly
    decrypted = Buffer.concat([decrypted, decipher.final()]); // Concatenate the final buffer

    return decrypted.toString('utf8');
  }

  public encryptCredential(credential: Credential): Credential {
    const encryptedObject = {};

    if (typeof credential !== 'object') {
      throw new Error(
        `Credential must be an object. Received ${typeof credential}`,
      );
    }

    for (const [key, value] of Object.entries(credential)) {
      if (typeof value !== 'string') {
        throw new Error(
          `Credential value must be a string. Received ${typeof value}`,
        );
      }
      encryptedObject[key] = this.encrypt(value);
    }
    return encryptedObject;
  }

  public decryptCredential(credential: Credential): Credential {
    if (typeof credential !== 'object') {
      throw new Error(
        `Credential must be an object. Received ${typeof credential}`,
      );
    }

    const decryptedObject = {};
    for (const [key, value] of Object.entries(credential)) {
      if (typeof value !== 'string') {
        throw new Error(
          `Credential value must be a string. Received ${typeof value}`,
        );
      }

      decryptedObject[key] = this.decrypt(value);
    }
    return decryptedObject;
  }

  public encryptString = (data: string): string => {
    if (typeof data !== 'string') {
      throw new Error(`Encrypt data must be a string. Received ${typeof data}`);
    }

    return this.encrypt(data);
  };

  public decryptString = (data: string): string => {
    if (typeof data !== 'string') {
      throw new Error(`Decrypt data must be a string. Received ${typeof data}`);
    }

    return this.decrypt(data);
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/certificates.util.ts
import * as jose from 'jose';
import * as forge from 'node-forge';

export enum CertificateType {
  CERTIFICATE = 'CERTIFICATE',
  PRIVATE_KEY = 'PRIVATE KEY',
  RSA_PRIVATE_KEY = 'RSA PRIVATE KEY',
  PUBLIC_KEY = 'PUBLIC KEY',
}

export function stripPemHeaders(pem: string): string {
  return pem
    .replace(/-----BEGIN (CERTIFICATE|PRIVATE KEY|RSA PRIVATE KEY)-----/, '')
    .replace(/-----END (CERTIFICATE|PRIVATE KEY|RSA PRIVATE KEY)-----/, '')
    .replace(/\s+/g, '');
}

export function addPemHeaders(pem: string, type: CertificateType): string {
  const header = `-----BEGIN ${type}-----`.toUpperCase();
  const footer = `-----END ${type}-----`.toUpperCase();

  const formattedContent = pem.match(/.{1,64}/g).join('\n');

  return `${header}\n${formattedContent}\n${footer}\n`;
}

export function formatPem(pem: string, type: CertificateType): string {
  const strippedPem = stripPemHeaders(pem);
  return addPemHeaders(strippedPem, type);
}

export function validatePemCertificate(pem: string): boolean {
  try {
    forge.pki.certificateFromPem(pem);
    return true;
  } catch (error) {
    return false;
  }
}

export function validatePemPrivateKey(pem: string): boolean {
  try {
    forge.pki.privateKeyFromPem(pem);
    return true;
  } catch (error) {
    return false;
  }
}

export function convertPKCS1toPKCS8(pem: string): string {
  const privateKey = forge.pki.privateKeyFromPem(pem);
  const rsaPrivateKey = forge.pki.privateKeyToAsn1(privateKey);
  const privateKeyInfo = forge.pki.wrapRsaPrivateKey(rsaPrivateKey);
  const privateKeyPkcs8 = forge.pki.privateKeyInfoToPem(privateKeyInfo);
  return privateKeyPkcs8;
}

export async function buildPrivateKey(
  pkcs8: string,
  algorithm = 'PS256',
): Promise<jose.KeyLike> {
  const privateKey = await jose.importPKCS8(pkcs8, algorithm);
  return privateKey;
}

export function createJws(
  certificatePem: string,
  payload: unknown,
  algorithm = 'PS256',
): jose.FlattenedSign {
  const x509Certificate = stripPemHeaders(certificatePem);
  const data = JSON.stringify(payload);

  const buffer = Buffer.from(data, 'utf-8');
  const arrayBuffer = new Uint8Array(buffer);
  const flatSignature = new jose.FlattenedSign(arrayBuffer);
  const jws = flatSignature.setProtectedHeader({
    alg: algorithm,
    b64: false,
    crit: ['b64'],
    x5c: [x509Certificate],
  });
  return jws;
}

export async function signJws(jws: jose.FlattenedSign, privateKeyPem?: string) {
  const privateKey = await buildPrivateKey(privateKeyPem);
  const signedJws = await jws.sign(privateKey);
  const signature = [signedJws.protected, signedJws.signature].join('..');
  return signature;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/string-methods.util.ts
export function nullIfEmpty(text: string): string | null {
  if (typeof text !== 'string') return null;
  if (text === null || text === undefined) return null;
  const textEmail = text?.replace(/\s/gi, '');
  if (textEmail === '') return null;
  return textEmail;
}

export function cleanMessage(message: string): string {
  const cleanMessage = message.replace(/['"`]/g, '').replace(/;/g, '.');
  return cleanMessage;
}

export function parsePort(port: string | number): number {
  const parsedPort = parseInt(port as string);
  if (isNaN(parsedPort)) return null;
  return parsedPort;
}

export function parseBoolean(value: string): boolean {
  return value === 'true';
}

export function splitOrDefault(
  values: string,
  defaultValue: string,
  splitter = ',',
): string[] {
  if (!defaultValue) return [];
  if (!values) return [defaultValue];

  const result = values.split(splitter);

  return result;
}

/**
 * Sanitizes a string for HTML.
 * @param {string} text - The text to sanitize.
 * @returns {string} - The sanitized text.
 */
export function safetext(text: string): string {
  const table = {
    '<': 'lt',
    '>': 'gt',
    '"': 'quot',
    "'": 'apos',
    '&': 'amp',
    '\r': '#10',
    '\n': '#13',
  };

  return text
    .toString()
    .replace(/[<>"'\r\n&]/g, (chr) => '&' + table[chr] + ';');
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/date-util.ts
import * as moment from 'moment-timezone';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { MapCountryCodeToTimezone } from 'src/common/maps/timezone.map';

export const DEFAULT_DATE_FORMAT = 'DD-MM-YYYY';
export const ETC_UTC_TIMEZONE = 'Etc/UTC';

/**
 *
 * @param date A date object on UTC timezone
 * @param format The format to use
 * @returns The formatted date
 */
export function formatDate(
  date: Date | string,
  format = DEFAULT_DATE_FORMAT,
): string {
  const formattedDate = moment.utc(date).format(format);

  return formattedDate;
}

export function startOfDateISOString(
  date: string,
  countryCode?: CountryCode,
): string {
  const timezone = countryCode
    ? moment.tz(date, MapCountryCodeToTimezone[countryCode])
    : moment.tz(date, ETC_UTC_TIMEZONE);

  return timezone.startOf('day').toISOString();
}

export function endOfDateISOString(
  date: string,
  countryCode?: CountryCode,
): string {
  const timezone = countryCode
    ? moment.tz(date, MapCountryCodeToTimezone[countryCode])
    : moment.tz(date, ETC_UTC_TIMEZONE);

  return timezone.endOf('day').toISOString();
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/array-methods.spec.ts
import { sumArray, pick, sortByField, SortOrder } from './array-methods.util';

describe('Utils array-method related', () => {
  it('should return a reduce sum of one array of numbers', () => {
    const a: Array<number> = [1, 2, 3];

    const result = sumArray(a);
    expect(result).toBe(6);
  });

  it('should return a random picked number from array', () => {
    const a: Array<number> = [1, 2, 3];

    const result = pick(a);
    const isIndex = a.indexOf(result) === -1 ? false : true;
    expect(isIndex).toBe(true);
  });

  it('should return sort by field array, DESCENDING', () => {
    const a: Array<object> = [{ edad: 15 }, { edad: 22 }, { edad: 13 }];

    const result = sortByField(a, 'edad', SortOrder.DESCENDING);
    expect(result.length).toBe(3);
    const ascendingArr: Array<object> = [
      { edad: 22 },
      { edad: 15 },
      { edad: 13 },
    ];
    expect(result).toEqual(ascendingArr);
  });

  it('should return sort by field array, ASCENDING', () => {
    const a: Array<object> = [{ edad: 15 }, { edad: 22 }, { edad: 13 }];

    const result = sortByField(a, 'edad', SortOrder.ASCENDING);
    expect(result.length).toBe(3);
    const descendinArr: Array<object> = [
      { edad: 13 },
      { edad: 15 },
      { edad: 22 },
    ];
    expect(result).toEqual(descendinArr);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/secret.spec.ts
import {
  generateSecret,
  parseSignatureHeader,
  generatePayloadSignature,
  hmacSignature,
} from './secrets.util';

describe('given a secrets-methods', () => {
  describe('generateSecret method related', () => {
    it('should return a string of length 64', () => {
      const result = generateSecret();

      expect(result.length).toBe(64);
    });

    it('should return a string of length 64 and distinct from each call', () => {
      const result = generateSecret();

      expect(result.length).toBe(64);
      const resultB = generateSecret();
      const areEquals = result === resultB;
      expect(areEquals).toBe(false);
    });
  });

  describe('hmacSignature method related', () => {
    it('should return an object with signature and timestamp', () => {
      const payload = {};
      const key = '';
      const stamp = '';
      const result = hmacSignature(payload, key, stamp);

      expect(result.signature).toBeDefined();
      expect(result.timestamp).toBeDefined();
    });
  });

  describe('generatePayloadSignature method related', () => {
    it('should return a string of length 50', () => {
      const payload = {};
      const key = '';
      const stamp = '';
      const result = generatePayloadSignature(payload, key, stamp);

      expect(result.length).toBe(50);
    });
  });

  describe.skip('parseSignatureHeader method related', () => {
    it('should return an object with signature and timestamp', () => {
      const header = 't=,v1=64OTZ2AXprCmWEW19w61YpiqBQ3mroIbPSJDDSYd5+A=';
      const result = parseSignatureHeader(header);

      expect(result.signature).toBeDefined();
      expect(result.timestamp).toBeDefined();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/currency-methods.spec.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import {
  countryCodeToCurrencyCode,
  countryCodeToLanguageTag,
  formatAmount,
} from './currency-methods.util';
import { Currency } from 'src/common/enums/currency.enum';

describe('Currency Methods Util', () => {
  describe('countryCodeToLanguageTag method', () => {
    it('should return null if countryCode is null', () => {
      const result = countryCodeToLanguageTag(null);
      expect(result).toBeNull();
    });

    it('should return null if countryCode is undefined', () => {
      const result = countryCodeToLanguageTag(undefined);
      expect(result).toBeNull();
    });

    it('should return null if countryCode is empty', () => {
      const result = countryCodeToLanguageTag('' as CountryCode);
      expect(result).toBeNull();
    });

    it('should return a language tag if countryCode is valid', () => {
      const result = countryCodeToLanguageTag(CountryCode.CHILE);
      expect(result).toBe('es-CL');
    });
  });

  describe('countryCodeToCurrencyCode method', () => {
    it('should return null if countryCode is null', () => {
      const result = countryCodeToCurrencyCode(null);
      expect(result).toBeNull();
    });

    it('should return null if countryCode is undefined', () => {
      const result = countryCodeToCurrencyCode(undefined);
      expect(result).toBeNull();
    });

    it('should return null if countryCode is empty', () => {
      const result = countryCodeToCurrencyCode('' as CountryCode);
      expect(result).toBeNull();
    });

    it('should return a currency code if countryCode is valid', () => {
      const result = countryCodeToCurrencyCode(CountryCode.CHILE);
      expect(result).toBe(Currency.CHILE);
    });
  });

  describe('formatAmount method', () => {
    it('should return null if amount is null', () => {
      const result = formatAmount(null);
      expect(result).toBeNull();
    });

    it('should return null if amount is undefined', () => {
      const result = formatAmount(undefined);
      expect(result).toBeNull();
    });

    it('should return null if amount is empty', () => {
      const result = formatAmount(0);
      expect(result).toBeNull();
    });

    it('should return a formatted amount if amount is valid', () => {
      const amount = 1234.12;

      const chileanFormat = formatAmount(amount, CountryCode.CHILE);
      expect(chileanFormat).toBe('$1.234,12');

      const colombianFormat = formatAmount(amount, CountryCode.COLOMBIA);
      expect(colombianFormat).toBe('$ 1.234,12');

      const mexicanFormat = formatAmount(amount, CountryCode.MEXICO);
      expect(mexicanFormat).toBe('$1,234.12');

      const peruvianFormat = formatAmount(amount, CountryCode.PERU);
      expect(peruvianFormat).toBe('S/ 1,234.12');
    });

    it('should return a formatted amount with 2 decimals if amount has more than 2 decimals', () => {
      const amount = 1234.123456;

      const chileanFormat = formatAmount(amount, CountryCode.CHILE);
      expect(chileanFormat).toBe('$1.234,12');

      const colombianFormat = formatAmount(amount, CountryCode.COLOMBIA);
      expect(colombianFormat).toBe('$ 1.234,12');

      const mexicanFormat = formatAmount(amount, CountryCode.MEXICO);
      expect(mexicanFormat).toBe('$1,234.12');

      const peruvianFormat = formatAmount(amount, CountryCode.PERU);
      expect(peruvianFormat).toBe('S/ 1,234.12');
    });

    it('should return a formatted amount with 0 decimals if amount has 0 decimals', () => {
      const amount = 1234;

      const chileanFormat = formatAmount(amount, CountryCode.CHILE);
      expect(chileanFormat).toBe('$1.234');

      const colombianFormat = formatAmount(amount, CountryCode.COLOMBIA);
      expect(colombianFormat).toBe('$ 1.234');

      const mexicanFormat = formatAmount(amount, CountryCode.MEXICO);
      expect(mexicanFormat).toBe('$1,234');

      const peruvianFormat = formatAmount(amount, CountryCode.PERU);
      expect(peruvianFormat).toBe('S/ 1,234');
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/enviroment-setup.util.ts
import { Environment } from 'src/common/enums/environment.enum';

/**
 * Retrieves and ensures the value of an environment variable.
 *
 * @param {string} key - The key of the environment variable.
 * @returns {string} The value of the environment variable or a random password in the development environment.
 * @throws {Error} If the specified environment variable has no value and is required.
 */
export function enforceEnvValue(key: string, fallback: string): string {
  const enviroment = process.env.NODE_ENV as Environment;

  if ([Environment.DEVELOPMENT, Environment.TEST].includes(enviroment)) {
    // TODO debemos refactorizar la forma en que se usa esta llave, ahora comparte responsabilidad entre apikey,pasword,credentials, y queremos evitar esto
    return fallback;
  }

  const value = process.env[key];

  if (!value) throw new Error(`${key} env value is required!`);

  return value;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/string-methods.spec.ts
import { nullIfEmpty, safetext } from './string-methods.util';

describe('Utils string-method related', () => {
  it('should return a string is input is a string', () => {
    const a = 'uncorreo@gmail.com';

    const result = nullIfEmpty(a);
    expect(result).toBe('uncorreo@gmail.com');
  });

  it('should return null if input is a empty string', () => {
    const a = '';

    const result = nullIfEmpty(a);
    expect(result).toBe(null);
  });

  it('should return null if input is undefined', () => {
    const a = undefined;

    const result = nullIfEmpty(a);
    expect(result).toBe(null);
  });
});

describe('when call safetext', () => {
  it('should sanitize a string by replacing unsafe HTML characters', () => {
    const text = '<>&"\'\r\n';

    const result = safetext(text);

    expect(result).toBe('&lt;&gt;&amp;&quot;&apos;&#10;&#13;');
  });

  it('should return the same string if there are no unsafe HTML characters', () => {
    const text = 'Hello, world!';

    const result = safetext(text);

    expect(result).toBe(text);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/date-util.spec.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import {
  endOfDateISOString,
  formatDate,
  startOfDateISOString,
} from './date-util';

describe('Given a Date Object', () => {
  describe('When the user call the method formatDate', () => {
    it('then it should return the date in the default format (DD-MM-YYYY) if no format is provided', () => {
      const date = new Date('2020-01-30');
      const expected = '30-01-2020';

      const result = formatDate(date);

      expect(result).toBe(expected);
    });

    it('then it should return the date with the specified format DD-MM-YYYY HH:mm:ss', () => {
      const date = new Date('2020-01-30T13:24:45Z');
      const expected = '30-01-2020 13:24:45';

      const result = formatDate(date, 'DD-MM-YYYY HH:mm:ss');

      expect(result).toBe(expected);
    });
  });
});

describe('startOfDateISOString', () => {
  it('should return the start of the day in the given timezone', () => {
    const date = '2023-09-08';
    const expected = '2023-09-08T03:00:00.000Z';
    const actual = startOfDateISOString(date, CountryCode.CHILE);
    expect(actual).toEqual(expected);
  });

  it('should return the start of the day in the UTC timezone if no country code is passed', () => {
    const date = '2023-09-08';
    const expected = '2023-09-08T00:00:00.000Z';
    const actual = startOfDateISOString(date);
    expect(actual).toEqual(expected);
  });
});

describe('endOfDateISOString', () => {
  it('should return the start of the day in the given timezone', () => {
    const date = '2023-09-08';
    const expected = '2023-09-09T02:59:59.999Z';
    const actual = endOfDateISOString(date, CountryCode.CHILE);
    expect(actual).toEqual(expected);
  });

  it('should return the start of the day in the UTC timezone if no country code is passed', () => {
    const date = '2023-09-08';
    const expected = '2023-09-08T23:59:59.999Z';
    const actual = endOfDateISOString(date);
    expect(actual).toEqual(expected);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/utils/request.util.ts
export interface CreateTransactionOptions {
  attempt: number;
  attempts: number;
  delay: number;
}

export async function waitFor(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/auth.guard.spec.ts
import { createMock } from '@golevelup/ts-jest';
import { UnauthorizedException } from '@nestjs/common';
import { ExecutionContext } from '@nestjs/common/interfaces';
import { Reflector } from '@nestjs/core';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { ApiKeyStrategy } from './apiKey.strategy';
import { AuthGuard } from './auth.guard';
import { JwtStrategy } from './jwt.strategy';
import { JwtMFAStrategy } from './jwtMFA.strategy';
import type { UserLike } from './requestWithUser.interface';
import { ClsService } from 'nestjs-cls';

describe('given an AuthGuard', () => {
  let guard: AuthGuard;
  let reflector: Reflector;
  let jwtMFAStrategy: JwtMFAStrategy;
  let jwtStrategy: JwtStrategy;
  let apiKeyStrategy: ApiKeyStrategy;
  let context: ExecutionContext;
  let userLikeInstance: UserLike;
  let clsService: ClsService;

  const userData = {
    id: 1,
    state: State.ACTIVE,
    mfa: true,
    mfaState: MFAState.VERIFIED,
  };

  beforeEach(async () => {
    reflector = createMock<Reflector>({
      get: jest.fn(),
    });
    jwtMFAStrategy = createMock<JwtMFAStrategy>();
    jwtStrategy = createMock<JwtStrategy>();
    apiKeyStrategy = createMock<ApiKeyStrategy>();
    context = createMock<ExecutionContext>({
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: jest.fn().mockReturnValue({}),
      }),
    });
    userLikeInstance = createMock<UserLike>(userData);
    clsService = createMock<ClsService>({ set: jest.fn() });
    guard = new AuthGuard(
      reflector,
      jwtMFAStrategy,
      jwtStrategy,
      apiKeyStrategy,
      clsService,
    );
  });

  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  describe('when canActivate is called', () => {
    describe('with no auth strategies provided to use (only default to use)', () => {
      it('using only a valid jwt MFA strategy then allow access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest
          .spyOn(jwtMFAStrategy, 'validate')
          .mockResolvedValue(userLikeInstance);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        const result = await guard.canActivate(context);
        expect(spiedJwtMFAStrategyValidate).toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('using only a valid apikey strategy then allow access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        jest
          .spyOn(apiKeyStrategy, 'validate')
          .mockResolvedValue(userLikeInstance);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        const result = await guard.canActivate(context);
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('using only a valid jwt MFA strategy then deny access if user state is not active', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const inactiveUser = { ...userLikeInstance, state: State.INACTIVE };
        jest.spyOn(jwtMFAStrategy, 'validate').mockResolvedValue(inactiveUser);

        const result = await guard.canActivate(context);
        expect(result).toBe(false);
      });

      it('using only an invalid jwt strategy then deny access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest.spyOn(jwtMFAStrategy, 'validate').mockImplementation(async () => {
          throw new UnauthorizedException('Invalid token');
        });

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using only an invalid apikey strategy then deny access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        jest.spyOn(apiKeyStrategy, 'validate').mockImplementation(async () => {
          throw new UnauthorizedException('Invalid API key');
        });

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).toHaveBeenCalled();
      });

      it('using both jwt and apikey strategy then throw multiple strategies error', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );

        await expect(guard.canActivate(context)).rejects.toThrow(
          new UnauthorizedException('Multiple auth strategies'),
        );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using no strategies then throw no strategies error', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(undefined);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        await expect(guard.canActivate(context)).rejects.toThrow(
          new UnauthorizedException('No usable credentials found'),
        );
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });
    });

    describe('with jwt MFA strategy only provided to use', () => {
      it('using only a valid jwt MFA strategy then allow access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwtMFA']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest
          .spyOn(jwtMFAStrategy, 'validate')
          .mockResolvedValue(userLikeInstance);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        const result = await guard.canActivate(context);

        expect(spiedJwtMFAStrategyValidate).toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('using only an invalid jwt MFA strategy then deny access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwtMFA']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest.spyOn(jwtMFAStrategy, 'validate').mockImplementation(async () => {
          throw new UnauthorizedException('Invalid token');
        });

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using an apikey strategy then throw UnauthorizedException', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwtMFA']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using no strategies then throw no strategies error', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwtMFA']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });
    });

    describe('with jwt strategy only provided to use', () => {
      it('using only a valid jwt strategy then allow access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwt']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest.spyOn(jwtStrategy, 'validate').mockResolvedValue(userLikeInstance);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        const result = await guard.canActivate(context);
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('using only an invalid jwt strategy then deny access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwt']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        jest.spyOn(jwtStrategy, 'validate').mockImplementation(async () => {
          throw new UnauthorizedException('Invalid token');
        });

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using an apikey strategy then throw UnauthorizedException', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwt']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using no strategies then throw no strategies error', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['jwt']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });
    });

    describe('with apikey strategy only provided to use', () => {
      it('using only a valid apikey strategy then allow access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['apikey']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        jest
          .spyOn(apiKeyStrategy, 'validate')
          .mockResolvedValue(userLikeInstance);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        const result = await guard.canActivate(context);
        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('using only an invalid apikey strategy then deny access', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['apikey']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(jwtStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(true);

        jest.spyOn(apiKeyStrategy, 'validate').mockImplementation(async () => {
          throw new UnauthorizedException('Invalid token');
        });

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedJwtStrategyValidate = jest.spyOn(jwtStrategy, 'validate');
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedJwtStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).toHaveBeenCalled();
      });

      it('using a jwt strategy then throw UnauthorizedException', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['apikey']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(true);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });

      it('using no strategies then throw no strategies error', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['apikey']);

        jest.spyOn(jwtMFAStrategy, 'precheck').mockReturnValue(false);
        jest.spyOn(apiKeyStrategy, 'precheck').mockReturnValue(false);

        const spiedJwtMFAStrategyValidate = jest.spyOn(
          jwtMFAStrategy,
          'validate',
        );
        const spiedApiKeyStrategyValidate = jest.spyOn(
          apiKeyStrategy,
          'validate',
        );
        guard
          .canActivate(context)
          .catch((error) =>
            expect(error).toBeInstanceOf(UnauthorizedException),
          );

        expect(spiedJwtMFAStrategyValidate).not.toHaveBeenCalled();
        expect(spiedApiKeyStrategyValidate).not.toHaveBeenCalled();
      });
    });

    describe('with "none" strategies provided to use (public)', () => {
      it('then allow access regardless of strategies', async () => {
        jest.spyOn(reflector, 'get').mockReturnValue(['none']);
        const result = await guard.canActivate(context);
        expect(result).toBe(true);
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/auth.module.ts
import { JwtMFAStrategy } from './jwtMFA.strategy';
import { ApiKeyEntity } from '../../models/apikey/entities/apikey.entity';
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { ApiKeyModule } from 'src/models/apikey/apikey.module';
import { ApiKeyStrategy } from './apiKey.strategy';
import { JwtStrategy } from './jwt.strategy';
import { MailModule } from '../mail/mail.module';
import { UserModule } from 'src/models/user/user.module';

@Module({
  imports: [
    UserModule,
    ApiKeyModule,
    ConfigModule,
    TypeOrmModule.forFeature([UserEntity, ApiKeyEntity]),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>(
          'general.jwt.secret',
          'jwt_secret_dev',
        ),
        signOptions: {
          expiresIn: configService.get<string>('general.jwt.expiration', '30m'),
        },
      }),
    }),
    MailModule,
  ],
  providers: [AuthService, JwtMFAStrategy, ApiKeyStrategy, JwtStrategy],
  exports: [AuthService, JwtMFAStrategy, ApiKeyStrategy, JwtStrategy],
})
export class AuthModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/jwt.strategy.ts
import { JwtService } from '@nestjs/jwt';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UserService } from 'src/models/user/user.service';
import AuthStrategy, { AuthStrategyName } from './authStrategy.interface';
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';
import TokenPayload from './tokenPayload.interface';
import { State } from 'src/common/enums/state.enum';

@Injectable()
export class JwtStrategy implements AuthStrategy {
  name: AuthStrategyName = 'jwt';

  constructor(
    private readonly jwtService: JwtService,
    private readonly userService: UserService,
  ) {}

  precheck(payload: RequestWithUserLike): boolean {
    return payload.headers.authorization?.startsWith('Bearer ');
  }

  public async validate(payload: RequestWithUserLike): Promise<UserLike> {
    const token = payload.headers.authorization?.split(' ')[1];
    try {
      const { id, lastPasswordUpdate } =
        this.jwtService.verify<TokenPayload>(token);
      return await this.userService.findOne(
        id,
        State.ACTIVE,
        lastPasswordUpdate,
      );
    } catch (err) {
      throw new UnauthorizedException('Invalid token');
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/jwt.strategy.spec.ts
// given an JwtStrategy
// when precheck is called
// -- with a request with no authorization header
// -> then it should return false
// -- with a request with an authorization header that does not start with Bearer
// -> then it should return false
// -- with a request with an authorization header that starts with Bearer
// -> then it should return true
// when validate is called
// -- with a valid jwt token
// -> then it should return the user associated with the token
// -- with an invalid jwt token
// -> then it should throw an UnauthorizedException

import { createMock } from '@golevelup/ts-jest';
import { JwtService } from '@nestjs/jwt';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { UserService } from 'src/models/user/user.service';
import { JwtStrategy } from './jwt.strategy';
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';
import TokenPayload from './tokenPayload.interface';

describe('given a JwtStrategy', () => {
  let jwtStrategy: JwtStrategy;
  let userService: UserService;
  let jwtService: JwtService;

  beforeEach(() => {
    jwtService = createMock<JwtService>({
      verify: jest.fn(),
    });
    userService = createMock<UserService>({
      findOne: jest.fn(),
    });
    jwtStrategy = new JwtStrategy(jwtService, userService);
  });

  describe('when precheck is called', () => {
    describe('with a request with no authorization header', () => {
      it('then it should return false', () => {
        const request = createMock<RequestWithUserLike>({ headers: {} });
        const result = jwtStrategy.precheck(request);
        expect(result).toBeFalsy();
      });
    });
    describe('with a request with an authorization header that does not start with Bearer', () => {
      it('then it should return false', () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Basic 123' },
        });
        const result = jwtStrategy.precheck(request);
        expect(result).toBeFalsy();
      });
    });
    describe('with a request with an authorization header that starts with Bearer', () => {
      it('then it should return true', () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });
        const result = jwtStrategy.precheck(request);
        expect(result).toBeTruthy();
      });
    });
  });

  describe('when validate is called', () => {
    describe('with a valid jwt token', () => {
      it('then it should return the user associated with the token', async () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });
        const user = createMock<UserLike>({
          id: 1,
        });

        const spiedJwtService = jest
          .spyOn(jwtService, 'verify')
          .mockReturnValue({
            id: 1,
          } as TokenPayload);

        const spiedUserService = jest
          .spyOn(userService, 'findOne')
          .mockResolvedValue(createMock<UserEntity>(user));
        jest
          .spyOn(userService, 'findOne')
          .mockResolvedValue(createMock<UserEntity>(user));

        const result = await jwtStrategy.validate(request);
        expect(spiedUserService).toHaveBeenCalledWith(1, 'active', undefined);
        expect(spiedJwtService).toHaveBeenCalledWith('123');
        expect(result.id).toEqual(user.id);
      });
    });
    describe('with an invalid jwt token', () => {
      it('then it should throw an UnauthorizedException', async () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });
        const spiedJwtService = jest
          .spyOn(jwtService, 'verify')
          .mockImplementation(() => {
            throw new Error();
          });

        await expect(jwtStrategy.validate(request)).rejects.toThrow();
        expect(spiedJwtService).toHaveBeenCalledWith('123');
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/jwtMFA.strategy.ts
import { JwtService } from '@nestjs/jwt';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UserService } from 'src/models/user/user.service';
import AuthStrategy, { AuthStrategyName } from './authStrategy.interface';
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';
import TokenPayload from './tokenPayload.interface';
import { Errors } from 'src/common/enums/errors.enum';
import { AuthService } from './auth.service';

@Injectable()
export class JwtMFAStrategy implements AuthStrategy {
  name: AuthStrategyName = 'jwtMFA';

  constructor(
    private readonly jwtService: JwtService,
    private readonly userService: UserService,
    private readonly authService: AuthService,
  ) {}

  precheck(payload: RequestWithUserLike): boolean {
    return payload.headers.authorization?.startsWith('Bearer ');
  }

  public async validate(payload: RequestWithUserLike): Promise<UserLike> {
    const token = payload.headers.authorization?.split(' ')[1];

    try {
      const decoded = this.jwtService.verify<TokenPayload>(token);
      const user = await this.userService.findOne(decoded.id);

      const { mfaEnforced } = this.authService;

      if (mfaEnforced && !user.mfa) {
        throw new UnauthorizedException(Errors.DISABLED_MFA);
      }

      return user;
    } catch (err) {
      throw new UnauthorizedException(Errors.INVALID_TOKEN);
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/auth.service.spec.ts
import { JwtService } from '@nestjs/jwt';
import { TestingModule, Test } from '@nestjs/testing';
import * as speakeasy from 'speakeasy';
import * as bcrypt from 'bcrypt';
import * as generatePassword from 'generate-password';
import * as stringMethods from 'src/utils/string-methods.util';

import { UserService } from '../../models/user/user.service';
import { AuthService } from './auth.service';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { UserRole } from 'src/common/enums/user-role.enum';
import { LoginUserDto } from 'src/api/v2/auth/dto/login-user.dto';
import { RegisterUserDto } from 'src/api/v2/auth/dto/register-user.dto';
import { UpdateMFAVerifyUserDto } from 'src/api/v2/auth/dto/update-mfa-verify-user.dto';
import { UpdateMFAEnrollUserDto } from 'src/api/v2/auth/dto/update-mfa-enroll-user.dto';
import { Errors } from 'src/common/enums/errors.enum';
import {
  BadRequestException,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { MailService } from '../mail/mail.service';
import { State } from 'src/common/enums/state.enum';
import { ChangeUserPasswordDto } from 'src/api/v2/auth/dto/change-user-password.dto';

const SECRET = {
  ascii: 'seed',
  base32: '',
  hex: '123',
  otpauth_url: 'otpauth://totp/payouts-engine-mfa-name-dev?secret=secret',
  google_auth_qr: '',
};
describe('given an AuthService', () => {
  let authService: AuthService;
  let usersService: UserService;
  let jwtService: JwtService;
  let mailService: MailService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: UserService,
          useValue: {
            findOneByEmail: jest.fn(),
            create: jest.fn(),
            update: jest.fn(),
            findOne: jest.fn(),
            setPassword: jest.fn(),
          },
        },
        {
          provide: JwtService,
          useValue: {
            sign: jest.fn(),
          },
        },
        {
          provide: MailService,
          useValue: {
            sendEmail: jest.fn(),
          },
        },
      ],
    }).compile();

    authService = module.get<AuthService>(AuthService);
    jwtService = module.get<JwtService>(JwtService);
    usersService = module.get<UserService>(UserService);
    mailService = module.get<MailService>(MailService);

    jest.spyOn(authService, 'mfaEnforced', 'get').mockReturnValue(false);
  });

  it('should be defined', () => {
    expect(authService).toBeDefined();
  });

  describe('when call encrypt', () => {
    it('with a plain text password then return the bcrypt hashed password', async () => {
      const password = '123456';

      const spiedBcrypt = jest
        .spyOn(bcrypt, 'hash')
        .mockImplementation(async () => 'encryptedPassword');

      const encryptedPassword = await authService.encrypt(password);

      expect(spiedBcrypt).toHaveBeenCalledWith(password, 10);
      expect(encryptedPassword).toBe('encryptedPassword');
    });
  });

  describe('when call validate', () => {
    it('with a plain text password and a bcrypt hashed password then return true', async () => {
      const password = '123456';
      const encryptedPassword = 'encryptedPassword';

      const spiedBcrypt = jest
        .spyOn(bcrypt, 'compare')
        .mockImplementation(async () => true);

      const isValid = await authService.validate(password, encryptedPassword);

      expect(spiedBcrypt).toHaveBeenCalledWith(password, encryptedPassword);
      expect(isValid).toBe(true);
    });
  });

  describe('when call generateToken', () => {
    it('with a user then return a jwt token', async () => {
      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.ADMIN;
      user.name = 'username';
      user.merchantId = 1;
      user.email = 'some@email.com';

      const spiedJwtService = jest
        .spyOn(jwtService, 'sign')
        .mockImplementation(() => 'token');
      const obj = {
        id: 1,
        uuid: 'uuid',
        role: UserRole.ADMIN,
        name: 'username',
        merchantId: 1,
        email: 'some@email.com',
        mfa: undefined,
      };
      const token = await authService.generateToken(user);
      expect(spiedJwtService).toHaveBeenCalledWith(
        expect.objectContaining(obj),
      );
      expect(token).toBe('token');
    });
  });

  describe('when call login', () => {
    it('with valid LoginUserDto and no mfa active then return a UserEntity', async () => {
      const loginUserDto = new LoginUserDto();
      loginUserDto.email = 'username@gmail.com';
      loginUserDto.password = 'password';

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.ADMIN;
      user.name = 'username';
      user.merchantId = 1;
      user.mfa = false;
      user.state = State.ACTIVE;

      const spiedUsersServiceFindOneByEmail = jest
        .spyOn(usersService, 'findOneByEmail')
        .mockReturnValue(Promise.resolve(user));

      const spiedAuthServiceValidate = jest
        .spyOn(authService, 'validate')
        .mockImplementation(async () => true);

      const loggedUser = await authService.login(loginUserDto);

      expect(spiedUsersServiceFindOneByEmail).toHaveBeenCalledWith(
        loginUserDto.email,
      );
      expect(spiedAuthServiceValidate).toHaveBeenCalledWith(
        'password',
        user.password,
      );
      expect(loggedUser).toBe(user);
    });
    it('with valid LoginUserDto and mfa active then return a UserEntity', async () => {
      const loginUserDto = new LoginUserDto();
      loginUserDto.email = 'username@gmail.com';
      loginUserDto.password = 'password';
      loginUserDto.mfaCode = '1234';

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.ADMIN;
      user.name = 'username';
      user.merchantId = 1;
      user.mfa = true;
      user.state = State.ACTIVE;

      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(true);

      const spiedUsersServiceFindOneByEmail = jest
        .spyOn(usersService, 'findOneByEmail')
        .mockReturnValue(Promise.resolve(user));

      const spiedAuthService = jest
        .spyOn(authService, 'validate')
        .mockImplementation(async () => true);

      const loggedUser = await authService.login(loginUserDto);

      expect(spiedUsersServiceFindOneByEmail).toHaveBeenCalledWith(
        loginUserDto.email,
      );
      expect(spiedAuthService).toHaveBeenCalledWith('password', user.password);
      expect(loggedUser).toBe(user);
    });
    it('with invalid LoginUserDto and mfa active then throw BadRequestException', async () => {
      jest.spyOn(authService, 'mfaEnforced', 'get').mockReturnValue(true);

      const loginUserDto = new LoginUserDto();
      loginUserDto.email = 'username@gmail.com';
      loginUserDto.password = 'password';

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.ADMIN;
      user.name = 'username';
      user.merchantId = 1;
      user.mfa = true;
      user.state = State.ACTIVE;

      const spiedUsersService = jest
        .spyOn(usersService, 'findOneByEmail')
        .mockImplementation(async () => user);

      const spiedAuthService = jest
        .spyOn(authService, 'validate')
        .mockImplementation(async () => false);

      try {
        await authService.login(loginUserDto);
      } catch (error) {
        expect(spiedUsersService).toHaveBeenCalledWith('username@gmail.com');
        expect(spiedAuthService).toHaveBeenCalledTimes(0);
        expect(error instanceof BadRequestException).toBe(true);
        expect(error.message).toBe(Errors.MISSING_MFA_CODE);
        expect(error.response.statusCode).toBe(400);
        expect(error.response.error).toBe(Errors.BAD_REQUEST);
      }
    });
    it('with invalid LoginUserDto then throw UnauthorizedException', async () => {
      const loginUserDto = new LoginUserDto();
      loginUserDto.email = 'username@gmail.com';
      loginUserDto.password = 'password';

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.ADMIN;
      user.name = 'username';
      user.merchantId = 1;
      user.state = State.ACTIVE;

      const spiedUsersService = jest
        .spyOn(usersService, 'findOneByEmail')
        .mockImplementation(async () => user);

      const spiedAuthService = jest
        .spyOn(authService, 'validate')
        .mockImplementation(async () => false);

      await expect(authService.login(loginUserDto)).rejects.toThrow(
        new UnauthorizedException(Errors.INVALID_CREDENTIALS),
      );

      expect(spiedUsersService).toHaveBeenCalledWith('username@gmail.com');
      expect(spiedAuthService).toHaveBeenCalledWith('password', user.password);
    });
  });

  describe('when call register', () => {
    it('with a valid RegisterUserDto then return a UserEntity', async () => {
      const registerUserDto = new RegisterUserDto();
      registerUserDto.name = 'username';
      registerUserDto.role = UserRole.ADMIN;
      registerUserDto.merchantId = 1;

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.USER;
      user.name = 'username';
      user.merchantId = 1;

      const spiedUsersService = jest
        .spyOn(usersService, 'create')
        .mockReturnValue(Promise.resolve(user));

      const registeredUser = await authService.register(registerUserDto);

      expect(spiedUsersService).toHaveBeenCalledWith(
        expect.objectContaining(registerUserDto),
      );

      expect(registeredUser).toMatchObject(user);
    });

    it("and a new password is generated, the email sent to the user shouldn't include unsafe html characters", async () => {
      const registerUserDto = new RegisterUserDto();
      registerUserDto.name = 'username';
      registerUserDto.role = UserRole.ADMIN;
      registerUserDto.merchantId = 1;

      const user = new UserEntity();
      user.id = 1;
      user.uuid = 'uuid';
      user.role = UserRole.USER;
      user.name = 'username';
      user.merchantId = 1;

      const spiedUsersService = jest
        .spyOn(usersService, 'create')
        .mockReturnValue(Promise.resolve(user));

      const spiedMailServiceSendEmail = jest.spyOn(mailService, 'sendEmail');
      jest.spyOn(generatePassword, 'generate').mockReturnValue('<>&"\'');
      await authService.register(registerUserDto);

      expect(spiedUsersService).toHaveBeenCalledWith(
        expect.objectContaining(registerUserDto),
      );
      expect(spiedMailServiceSendEmail).toHaveBeenCalled();
      const emailContent = spiedMailServiceSendEmail.mock.calls[0][2]; // Get the email content from the spy
      expect(emailContent).not.toMatch(/[<>]/); // Check for '<' and '>'
      expect(emailContent).not.toMatch(
        /&(?!([a-z0-9]+|#[0-9]+|#x[0-9a-f]+);)/i,
      ); // Check for '&' that is not part of an HTML entity
      expect(emailContent).not.toMatch(/["']/); // Check for '"' and "'"
    });
  });

  describe('when call verifyHasMFA', () => {
    beforeEach(() => {
      jest.spyOn(authService, 'mfaEnforced', 'get').mockReturnValue(true);
    });

    it('with true mfa, valid code and valid seed then do not throw error', async () => {
      const user = new UserEntity();
      user.mfa = true;
      user.seed = 'asdasd';
      const code = '123';

      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(true);
      const spiedAuthServiceVerify = jest.spyOn(authService, 'verifyCode');

      authService.verifyHasMFA(user.mfa, user.seed, code);

      expect(spiedAuthServiceVerify).toHaveBeenCalledWith(user.seed, code);
      expect(spiedAuthServiceVerify).toBeTruthy();
    });
    it('with false mfa, no code and no seed then do not throw error', async () => {
      const user = new UserEntity();
      user.mfa = false;

      const spiedAuthService = jest
        .spyOn(authService, 'verifyHasMFA')
        .mockImplementation(() => ({}));

      authService.verifyHasMFA(user.mfa, user.seed, null);
      expect(spiedAuthService).toHaveBeenCalledWith(user.mfa, user.seed, null);
      expect(spiedAuthService).toHaveReturned();
    });
    it('with a true mfa, no code and valid seed then throw BadRequestException ', async () => {
      const user = new UserEntity();
      user.mfa = true;
      user.seed = 'asdasd';
      const spiedAuthService = jest.spyOn(authService, 'verifyHasMFA');

      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(false);
      const spiedAuthServiceVerify = jest.spyOn(authService, 'verifyCode');

      expect(() => authService.verifyHasMFA(user.mfa, user.seed, null)).toThrow(
        new BadRequestException(Errors.MISSING_MFA_CODE),
      );

      expect(spiedAuthService).toHaveBeenCalledWith(user.mfa, user.seed, null);
      expect(spiedAuthServiceVerify).not.toHaveBeenCalled();
    });
    it('with a true mfa, valid code and invalid seed then throw UnauthorizedException ', async () => {
      const user = new UserEntity();
      user.mfa = true;
      user.seed = 'invalidseed';
      const code = '123';
      const spiedAuthService = jest.spyOn(authService, 'verifyHasMFA');

      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(false);
      const spiedAuthServiceVerify = jest.spyOn(authService, 'verifyCode');

      expect(() => authService.verifyHasMFA(user.mfa, user.seed, code)).toThrow(
        new UnauthorizedException(Errors.INVALID_CODE),
      );

      expect(spiedAuthService).toHaveBeenCalledWith(user.mfa, user.seed, code);
      expect(spiedAuthService).not.toHaveReturned();
      expect(spiedAuthServiceVerify).toHaveBeenCalledWith(user.seed, code);
      expect(spiedAuthServiceVerify).toHaveReturnedWith(false);
    });
  });
  describe('when call generateSeed', () => {
    it('then should return seecret object', async () => {
      const secret = {
        ascii: 'v}f}IgA4V3d@KE9MsK7e>NXn:8b9GS$r',
        base32: 'OZ6WM7KJM5ATIVRTMRAEWRJZJVZUWN3FHZHFQ3R2HBRDSR2TERZA',
        hex: '767d667d49674134563364404b45394d734b37653e4e586e3a38623947532472',
        otpauth_url:
          'otpauth://totp/payouts-engine-mfa-name-dev?secret=OZ6WM7KJM5ATIVRTMRAEWRJZJVZUWN3FHZHFQ3R2HBRDSR2TERZA',
        google_auth_qr: 'qr',
      };
      jest.spyOn(speakeasy, 'generateSecret').mockReturnValue(secret);

      const generatedSeed = authService.generateSeed();
      expect(generatedSeed);
    });
  });
  describe('when call mfaInit', () => {
    it('then should return otpauth url string and update user seed', async () => {
      jest.spyOn(speakeasy, 'generateSecret').mockReturnValue(SECRET);

      const user = new UserEntity();
      user.id = 1;
      user.name = 'username';
      user.mfa = false;
      user.seed = null;
      user.mfaState = MFAState.DISABLED;

      jest
        .spyOn(usersService, 'findOneByEmail')
        .mockImplementation(async () => user);

      const otpauthUrl = await authService.mfaInit(user.id);

      expect(user.seed).toBe(null);
      expect(otpauthUrl).toBe(
        'otpauth://totp/payouts-engine-mfa-name-dev?secret=secret',
      );
      // expect(userUpdated.seed).toBe('seed');
    });
  });
  describe('when call mfaEnroll', () => {
    it('then should return true if code correspond to seed', async () => {
      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(true);

      const user = new UserEntity();
      user.id = 1;
      user.name = 'username';
      user.mfa = false;
      user.seed = SECRET.ascii;
      user.mfaState = MFAState.DISABLED;

      const updateMFAEnrollUserDto = new UpdateMFAEnrollUserDto();
      updateMFAEnrollUserDto.code = '1234';

      const enrolled = await authService.mfaEnroll(
        user.id,
        user.seed,
        updateMFAEnrollUserDto,
      );

      expect(enrolled).toBeTruthy();
      // expect(userUpdated.mfaState).toBe(MFAState.ENROLLED)
    });
    it('then should return false if code does not correspond to seed', async () => {
      jest.spyOn(speakeasy.totp, 'verify').mockReturnValue(false);

      const user = new UserEntity();
      user.id = 1;
      user.name = 'username';
      user.mfa = false;
      user.seed = SECRET.ascii;
      user.mfaState = MFAState.DISABLED;

      const updateMFAEnrollUserDto = new UpdateMFAEnrollUserDto();
      updateMFAEnrollUserDto.code = '1233';

      const spiedAuthService = jest.spyOn(authService, 'verifyCode');
      try {
        await authService.mfaEnroll(user.id, user.seed, updateMFAEnrollUserDto);
      } catch (error) {
        expect(spiedAuthService).toHaveBeenCalledTimes(1);
        expect(spiedAuthService).toHaveBeenCalledWith(
          user.seed,
          updateMFAEnrollUserDto.code,
        );
        expect(error instanceof BadRequestException).toBe(true);
        expect(error.message).toBe(Errors.INVALID_CODE);
        expect(error.response.statusCode).toBe(400);
        expect(error.response.error).toBe(Errors.BAD_REQUEST);
      }
    });
  });
  describe('when call mfaVerify', () => {
    it('then should return true if password correspond to user', async () => {
      const plainPassword = 'pass';
      const hashedPassword = await bcrypt.hash(plainPassword, 10);

      const user = new UserEntity();
      user.id = 1;
      user.name = 'username';
      user.password = hashedPassword;
      user.mfa = false;
      user.seed = SECRET.ascii;
      user.mfaState = MFAState.ENROLLED;

      const updateMFAVerifyUserDto = new UpdateMFAVerifyUserDto();
      updateMFAVerifyUserDto.password = plainPassword;

      const verified = await authService.mfaVerify(
        user,
        updateMFAVerifyUserDto,
      );

      expect(verified).toBeTruthy();
      // expect(userUpdated.mfaState).toBe(MFAState.VERIFIED);
      // expect(userUpdated.mfa).toBeTruthy();
    });
    it('then should return false if password does not correspond to user', async () => {
      const pass = await bcrypt.hash('pass', 10);

      const user = new UserEntity();
      user.id = 1;
      user.name = 'username';
      user.password = pass;
      user.mfa = false;
      user.seed = SECRET.ascii;
      user.mfaState = MFAState.ENROLLED;

      const updateMFAVerifyUserDto = new UpdateMFAVerifyUserDto();
      updateMFAVerifyUserDto.password = 'wrongPassword';

      const spiedAuthService = jest.spyOn(authService, 'validate');

      try {
        await authService.mfaVerify(user, updateMFAVerifyUserDto);
      } catch (error) {
        expect(spiedAuthService).toHaveBeenCalledTimes(1);
        expect(spiedAuthService).toHaveBeenCalledWith(
          updateMFAVerifyUserDto.password,
          user.password,
        );
        expect(error instanceof BadRequestException).toBe(true);
        expect(error.message).toBe(Errors.INVALID_PASSWORD);
        expect(error.response.statusCode).toBe(400);
        expect(error.response.error).toBe(Errors.BAD_REQUEST);
      }
    });
  });
  describe('login', () => {
    it('should return a JWT when given valid credentials', async () => {
      const loginDto = {
        email: 'test@example.com',
        password: 'password',
        mfaCode: 'someString',
      };
      const user = new UserEntity();
      user.email = loginDto.email;
      user.password = loginDto.password;
      jest.spyOn(authService, 'login').mockReturnValue(Promise.resolve(user));

      expect(await authService.login(loginDto)).toMatchObject(user);
    });
  });
  describe('register', () => {
    it('should return a user when given valid data', async () => {
      const registerDto: RegisterUserDto = {
        email: 'test@example.com',
        name: 'Test User',
        merchantId: 1,
        role: UserRole.ADMIN,
      };
      const user = new UserEntity();
      user.email = registerDto.email;
      user.name = registerDto.name;
      jest
        .spyOn(authService, 'register')
        .mockImplementation(() => Promise.resolve(user));

      expect(await authService.register(registerDto)).toBe(user);
    });
  });
  describe('resetMFA', () => {
    it('should reset MFA settings for a user', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.mfa = true;
      user.mfaState = MFAState.VERIFIED;
      user.seed = 'someSeed';
      const spiedUsersServiceFindOne = jest
        .spyOn(usersService, 'findOne')
        .mockReturnValue(Promise.resolve(user));

      const spiedUsersServiceUpdate = jest
        .spyOn(usersService, 'update')
        .mockReturnValue(Promise.resolve(user));

      await authService.resetMFA(userId);

      expect(spiedUsersServiceFindOne).toHaveBeenCalledWith(userId);
      expect(spiedUsersServiceUpdate).toHaveBeenCalledWith(userId, {
        mfa: false,
        mfaState: MFAState.DISABLED,
        seed: null,
      });
    });

    it('should throw an error if user is not found', async () => {
      const userId = 1;

      jest
        .spyOn(usersService, 'findOne')
        .mockRejectedValue(new NotFoundException());

      await expect(authService.resetMFA(userId)).rejects.toThrow(
        NotFoundException,
      );
    });
  });

  describe('resetPassword', () => {
    it('should reset the password for a user and send an email', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.email = 'test@example.com';
      user.name = 'Test User';
      const newPassword = '<>&"\'';
      const hashedPassword = 'hashedPassword';

      // jest.spyOn(service, 'generatePassword').mockReturnValue(newPassword);
      const spiedGenerate = jest.spyOn(generatePassword, 'generate');
      spiedGenerate.mockReturnValue(newPassword);

      jest.spyOn(authService, 'encrypt').mockResolvedValue(hashedPassword);
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);
      jest.spyOn(usersService, 'setPassword').mockResolvedValue();
      jest.spyOn(mailService, 'sendEmail').mockImplementation();
      jest.spyOn(stringMethods, 'safetext').mockImplementation((str) => str);

      await authService.resetPassword(userId);

      expect(usersService.findOne).toHaveBeenCalledWith(userId);
      expect(spiedGenerate).toHaveBeenCalled();
      expect(authService.encrypt).toHaveBeenCalledWith(newPassword);
      expect(usersService.setPassword).toHaveBeenCalledWith(
        userId,
        hashedPassword,
      );
      expect(mailService.sendEmail).toHaveBeenCalledWith(
        user.email,
        expect.stringContaining(`Contraseña nueva`),
        expect.stringContaining(newPassword),
      );
    });
  });

  describe('changePassword', () => {
    it('should change the password successfully', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.password = 'oldPassword';
      user.mfa = false;

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'oldPassword',
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
        mfaCode: null,
      };

      jest.spyOn(authService, 'validate').mockResolvedValue(true);
      jest.spyOn(authService, 'encrypt').mockResolvedValue('encryptedPassword');
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);
      jest.spyOn(usersService, 'setPassword').mockResolvedValue();

      await authService.changePassword(userId, changePasswordDto);

      expect(usersService.findOne).toHaveBeenCalledWith(userId);
      expect(authService.validate).toHaveBeenCalledWith(
        changePasswordDto.oldPassword,
        user.password,
      );
      expect(authService.encrypt).toHaveBeenCalledWith(
        changePasswordDto.newPassword,
      );
      expect(usersService.setPassword).toHaveBeenCalledWith(
        userId,
        'encryptedPassword',
      );
    });

    it('should throw an error if old password is invalid', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.password = 'oldPassword';
      user.mfa = false;

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'invalidOldPassword',
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
        mfaCode: null,
      };

      jest.spyOn(authService, 'validate').mockResolvedValue(false);
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);

      await expect(
        authService.changePassword(userId, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw an error if new password is the same as the old password', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.password = 'oldPassword';
      user.mfa = false;

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'oldPassword',
        newPassword: 'oldPassword',
        confirmNewPassword: 'oldPassword',
        mfaCode: null,
      };

      jest.spyOn(authService, 'validate').mockResolvedValue(true);
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);

      await expect(
        authService.changePassword(userId, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw an error if new password and confirm new password do not match', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.password = 'oldPassword';
      user.mfa = false;

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'oldPassword',
        newPassword: 'newPassword',
        confirmNewPassword: 'differentNewPassword',
        mfaCode: null,
      };

      jest.spyOn(authService, 'validate').mockResolvedValue(true);
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);

      await expect(
        authService.changePassword(userId, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw an error if 2FA code is invalid', async () => {
      const userId = 1;
      const user = new UserEntity();
      user.id = userId;
      user.password = 'oldPassword';
      user.mfa = true;
      user.seed = 'seed';

      const changePasswordDto: ChangeUserPasswordDto = {
        oldPassword: 'oldPassword',
        newPassword: 'newPassword',
        confirmNewPassword: 'newPassword',
        mfaCode: 'invalidCode',
      };

      jest.spyOn(authService, 'validate').mockResolvedValue(true);
      jest.spyOn(usersService, 'findOne').mockResolvedValue(user);
      jest.spyOn(authService, 'verifyHasMFA').mockImplementation(() => {
        throw new BadRequestException();
      });

      await expect(
        authService.changePassword(userId, changePasswordDto),
      ).rejects.toThrow(BadRequestException);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/apiKey.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ApiKeyService } from 'src/models/apikey/apikey.service';
import AuthStrategy, { AuthStrategyName } from './authStrategy.interface';
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';

const API_KEY_HEADER = 'x-api-key';
@Injectable()
export class ApiKeyStrategy implements AuthStrategy {
  name: AuthStrategyName = 'apikey';

  constructor(private readonly apiKeyService: ApiKeyService) {}

  precheck(payload: RequestWithUserLike): boolean {
    const hasHeader = payload.headers[API_KEY_HEADER] ?? false;
    return !!hasHeader;
  }

  public async validate(payload: RequestWithUserLike): Promise<UserLike> {
    let apiKey = `${payload.headers[API_KEY_HEADER]}`;
    apiKey = apiKey.replace(/<|>|'|;/g, '');
    const user = await this.apiKeyService.findOneByKey(apiKey);
    if (!user) {
      throw new UnauthorizedException('Invalid API key');
    }
    return user;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/requestWithUser.interface.ts
import { Request } from 'express';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { UserEntity } from 'src/models/user/entities/user.entity';

/**
 * Type union of all possible User-like entities.
 */
export type UserLike = UserEntity | ApiKeyEntity;

interface RequestWithUserLike extends Request {
  /**
   * The entity representing the user. Can be a `UserEntity` or an `ApiKeyEntity`.
   */
  user?: UserLike;
}

export default RequestWithUserLike;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/apiKey.strategy.spec.ts
// given a ApiKeyStrategy
// when precheck is called
// -- with a request with no x-api-key header
// -> then it should return false
// -- with a request with an x-api-key header
// -> then it should return true
// when validate is called
// -- with a valid api key
// -> then it should return the user associated with the api key
// -- with an invalid api key
// -> then it should throw an UnauthorizedException
//

import { createMock } from '@golevelup/ts-jest';
import { UnauthorizedException } from '@nestjs/common';
import { State } from 'src/common/enums/state.enum';
import { ApiKeyService } from 'src/models/apikey/apikey.service';
import { ApiKeyEntity } from 'src/models/apikey/entities/apikey.entity';
import { ApiKeyStrategy } from './apiKey.strategy';
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';

describe('given a ApiKeyStrategy', () => {
  let apiKeyStrategy: ApiKeyStrategy;
  let apiKeyService: ApiKeyService;
  let request: RequestWithUserLike;
  let user: UserLike;
  let apiKey: string;

  beforeEach(() => {
    apiKeyService = createMock<ApiKeyService>({
      findOneByKey: async () => {
        return Promise.resolve({ id: 1, state: State.ACTIVE } as ApiKeyEntity);
      },
    });
    apiKeyStrategy = new ApiKeyStrategy(apiKeyService);
    request = createMock<RequestWithUserLike>({ headers: {} });
    user = createMock<UserLike>({ id: 1 });
    apiKey = '123';
  });

  describe('when precheck is called', () => {
    describe('with a request with no x-api-key header', () => {
      it('then it should return false', () => {
        const result = apiKeyStrategy.precheck(request);
        expect(result).toBeFalsy();
      });
    });
    describe('with a request with an x-api-key header', () => {
      it('then it should return true', () => {
        request.headers['x-api-key'] = apiKey;
        const result = apiKeyStrategy.precheck(request);
        expect(result).toBeTruthy();
      });
    });
  });

  describe('when validate is called', () => {
    describe('with a valid api key', () => {
      it('then it should return the user associated with the api key', async () => {
        request.headers['x-api-key'] = apiKey;
        const result = await apiKeyStrategy.validate(request);
        expect(result.id).toStrictEqual(user.id);
      });
    });
    describe('with an invalid api key', () => {
      it('then it should throw an UnauthorizedException', async () => {
        request.headers['x-api-key'] = apiKey;
        apiKeyService.findOneByKey = async () => {
          return Promise.resolve(null);
        };
        await expect(apiKeyStrategy.validate(request)).rejects.toThrow(
          UnauthorizedException,
        );
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/auth.guard.ts
import AuthStrategy, { AuthStrategyName } from './authStrategy.interface';
import {
  BadRequestException,
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import RequestWithUserLike from './requestWithUser.interface';
import { JwtMFAStrategy } from './jwtMFA.strategy';
import { JwtStrategy } from './jwt.strategy';
import { ApiKeyStrategy } from './apiKey.strategy';
import { ClsService } from 'nestjs-cls';
import { State } from 'src/common/enums/state.enum';

@Injectable()
export class AuthGuard implements CanActivate {
  strategies: Record<AuthStrategyName, AuthStrategy>;

  constructor(
    private reflector: Reflector,
    private jwtMFAStrategy: JwtMFAStrategy,
    private jwtStrategy: JwtStrategy,
    private apiKeyStrategy: ApiKeyStrategy,
    private clsService: ClsService,
  ) {
    this.strategies = {
      jwtMFA: this.jwtMFAStrategy,
      jwt: this.jwtStrategy,
      apikey: this.apiKeyStrategy,
    };
  }

  async canActivate(context: ExecutionContext) {
    const request = context.switchToHttp().getRequest<RequestWithUserLike>();
    const strategies = this.reflector.get<string[]>(
      'auth',
      context.getHandler(),
    );
    let strategiesToUse: AuthStrategy[] = [];
    if (!strategies) {
      // use this specified strategies as default
      strategiesToUse = [this.strategies.jwtMFA, this.strategies.apikey];
    } else if (strategies.includes('none')) {
      // public
      return true;
    } else if (strategies.includes('jwt')) {
      strategiesToUse = [this.strategies.jwt];
    } else {
      strategiesToUse = strategies.map((strategy) => this.strategies[strategy]);
    }

    const matchinStrategies = strategiesToUse.filter((strategy) =>
      strategy.precheck(request),
    );

    if (matchinStrategies.length === 0) {
      throw new UnauthorizedException('No usable credentials found');
      // return false;
    } else if (matchinStrategies.length > 1) {
      throw new BadRequestException('Multiple auth strategies');
    }
    const userLike = await matchinStrategies[0].validate(request);

    if (userLike.state !== State.ACTIVE) return false;

    request.user = userLike;

    this.clsService.set('user', userLike);
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/jwtMFA.strategy.spec.ts
// given an JwtMFAStrategy
// when precheck is called
// -- with a request with no authorization header
// -> then it should return false
// -- with a request with an authorization header that does not start with Bearer
// -> then it should return false
// -- with a request with an authorization header that starts with Bearer
// -> then it should return true
// when validate is called
// -- with a valid jwt token
// -> then it should return the user associated with the token
// -- with an invalid jwt token
// -> then it should throw an UnauthorizedException

import { createMock } from '@golevelup/ts-jest';
import { UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { UserService } from 'src/models/user/user.service';
import { changeEnv } from '../../../test/utils/testUtils';
import { JwtMFAStrategy } from './jwtMFA.strategy';
import RequestWithUserLike from './requestWithUser.interface';
import TokenPayload from './tokenPayload.interface';
import { AuthService } from './auth.service';

const userData = {
  id: 1,
  state: State.ACTIVE,
  mfa: true,
};
const tokenData = {
  id: 1,
};

describe('given a JwtMFAStrategy', () => {
  let jwtMFAStrategy: JwtMFAStrategy;
  let userService: UserService;
  let jwtService: JwtService;
  let authService: AuthService;

  beforeEach(() => {
    jwtService = createMock<JwtService>({
      verify: () => tokenData as TokenPayload,
    });
    userService = createMock<UserService>({
      findOne: async () => {
        return Promise.resolve(userData as UserEntity);
      },
    });
    authService = createMock<AuthService>({
      mfaEnforced: true,
    });

    jwtMFAStrategy = new JwtMFAStrategy(jwtService, userService, authService);
  });

  describe('when precheck is called', () => {
    describe('with a request with no authorization header', () => {
      it('then it should return false', () => {
        const request = createMock<RequestWithUserLike>({ headers: {} });
        const result = jwtMFAStrategy.precheck(request);
        expect(result).toBeFalsy();
      });
    });
    describe('with a request with an authorization header that does not start with Bearer', () => {
      it('then it should return false', () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Basic 123' },
        });
        const result = jwtMFAStrategy.precheck(request);
        expect(result).toBeFalsy();
      });
    });
    describe('with a request with an authorization header that starts with Bearer', () => {
      it('then it should return true', () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });
        const result = jwtMFAStrategy.precheck(request);
        expect(result).toBeTruthy();
      });
    });
  });

  describe('when validate is called', () => {
    describe('with a valid jwtMFA token and mfa enabled', () => {
      it('then it should return the user associated with the token', async () => {
        changeEnv();
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });

        const spiedJwtService = jest.spyOn(jwtService, 'verify');
        const spiedUserService = jest.spyOn(userService, 'findOne');

        const result = await jwtMFAStrategy.validate(request);

        expect(spiedUserService).toHaveBeenCalledWith(1);
        expect(spiedJwtService).toHaveBeenCalledWith('123');
        expect(result.id).toEqual(userData.id);
        changeEnv(Environment.TEST);
      });
    });
    describe('with a valid jwtMFA token and mfa disabled', () => {
      it('then it should throw an UnauthorizedException', async () => {
        changeEnv();
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });

        const spiedJwtService = jest.spyOn(jwtService, 'verify');

        const spiedUserService = jest
          .spyOn(userService, 'findOne')
          .mockResolvedValue(
            createMock<UserEntity>({
              ...userData,
              mfa: false,
              mfaState: MFAState.DISABLED,
            }),
          );

        await expect(jwtMFAStrategy.validate(request)).rejects.toThrow(
          UnauthorizedException,
        );
        expect(spiedUserService).toHaveBeenCalledWith(1);
        expect(spiedJwtService).toHaveBeenCalledWith('123');

        changeEnv(Environment.TEST);
      });
    });
    describe('with an invalid jwtMFA token', () => {
      it('then it should throw an UnauthorizedException', async () => {
        const request = createMock<RequestWithUserLike>({
          headers: { authorization: 'Bearer 123' },
        });
        const spiedJwtService = jest
          .spyOn(jwtService, 'verify')
          .mockImplementation(() => {
            throw new Error();
          });

        await expect(jwtMFAStrategy.validate(request)).rejects.toThrow(
          UnauthorizedException,
        );
        expect(spiedJwtService).toHaveBeenCalledWith('123');
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/authStrategy.interface.ts
import RequestWithUserLike, { UserLike } from './requestWithUser.interface';

export type AuthStrategyName = 'jwtMFA' | 'apikey' | 'jwt';

export default interface AuthStrategy {
  name: AuthStrategyName;

  /**
   * Checks if the user has the required data to authenticate.
   * @param {RequestWithUserLike} payload
   */
  precheck(payload: RequestWithUserLike): boolean;

  /**
   * Returns the user data if a valid user is found.
   * @param {RequestWithUserLike} payload
   * @returns {Promise<UserLike>}
   * @throws {Error} if the user is not authorized.
   */
  validate(payload: RequestWithUserLike): Promise<UserLike>;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/auth.service.ts
import * as bcrypt from 'bcrypt';
import * as speakeasy from 'speakeasy';
import {
  Injectable,
  BadRequestException,
  UnauthorizedException,
  Logger,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { RegisterUserDto } from 'src/api/v2/auth/dto/register-user.dto';
import { LoginUserDto } from 'src/api/v2/auth/dto/login-user.dto';
import { UserService } from '../../models/user/user.service';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { UpdateMFAEnrollUserDto } from 'src/api/v2/auth/dto/update-mfa-enroll-user.dto';
import { UpdateMFAVerifyUserDto } from 'src/api/v2/auth/dto/update-mfa-verify-user.dto';
import TokenPayload from './tokenPayload.interface';
import { Errors } from 'src/common/enums/errors.enum';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import generalConfig from 'src/config/general.config';
import { Environment } from 'src/common/enums/environment.enum';
import { generate } from 'generate-password';
import { MailService } from '../mail/mail.service';
import { safetext } from 'src/utils/string-methods.util';
import { State } from 'src/common/enums/state.enum';
import { ChangeUserPasswordDto } from 'src/api/v2/auth/dto/change-user-password.dto';

export interface ISecret {
  ascii: string;
  base32: string;
  hex: string;
  otpauth_url?: string;
}

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly mailService: MailService,
  ) {}

  public async encrypt(password: string): Promise<string> {
    return await bcrypt.hash(password, 10);
  }

  public async validate(
    password: string,
    encryptedPassword: string,
  ): Promise<boolean> {
    return await bcrypt.compare(password, encryptedPassword);
  }

  public generateSeed = (): ISecret => {
    const config = generalConfig();
    const mfaName = config.security.mfaName;
    const secret = speakeasy.generateSecret({
      name: mfaName,
    });
    return secret;
  };

  public verifyCode = (asciiDecrypt: string, code: string): boolean => {
    const validCode: boolean = speakeasy.totp.verify({
      secret: asciiDecrypt,
      encoding: 'ascii',
      token: code,
    });

    return validCode;
  };

  /**
   * @returns {boolean} - Indicates if MFA is enforced in the current environment.
   **/
  public get mfaEnforced(): boolean {
    const config = generalConfig();
    const environment = config.api.env;
    const mfaPerEnvironment = [Environment.PRODUCTION, Environment.STAGING];
    return mfaPerEnvironment.includes(environment);
  }

  /**
   * @param {boolean} mfa - Indicates if the user has MFA enabled.
   * @param {string} seed - The user's MFA seed.
   * @param {string} [code] - The MFA code provided by the user.
   *
   * @throws {BadRequestException} If the MFA code is not provided.
   * @throws {UnauthorizedException} If the provided MFA code is invalid.
   *
   * @returns {void} This method does not return a value on success.
   **/
  public verifyHasMFA = (mfa: boolean, seed: string, code?: string): void => {
    if (mfa && this.mfaEnforced) {
      if (!code) {
        throw new BadRequestException(Errors.MISSING_MFA_CODE);
      }
      if (!this.verifyCode(seed, code)) {
        throw new UnauthorizedException(Errors.INVALID_CODE);
      }
    }
  };

  /**
   * ** TODO: ** specific strategy methods should be moved to a strategy service
   */
  public generateToken(userEntity: UserEntity): string {
    const payload: TokenPayload = {
      id: userEntity.id,
      uuid: userEntity.uuid,
      role: userEntity.role,
      email: userEntity.email,
      merchantId: userEntity.merchantId,
      mfa: userEntity.mfa,
      name: userEntity.name,
      lastPasswordUpdate: userEntity.passwordUpdatedAt,
    };
    return this.jwtService.sign(payload);
  }

  private generatePassword(): string {
    const password = generate({
      length: 24,
      numbers: true,
      uppercase: true,
      lowercase: true,
      symbols: false,
    });

    return password;
  }
  public async login(loginUserDto: LoginUserDto): Promise<UserEntity> {
    // TODO: email are not unique. Uniqueness is a composite key with email and merchantId
    let user: UserEntity;
    try {
      user = await this.userService.findOneByEmail(loginUserDto.email);
    } catch (error) {
      throw new UnauthorizedException(Errors.INVALID_CREDENTIALS);
    }

    if (user.state !== State.ACTIVE) {
      throw new UnauthorizedException();
    }

    this.verifyHasMFA(user.mfa, user.seed, loginUserDto.mfaCode);

    const valid = await this.validate(loginUserDto.password, user.password);
    if (valid) return user;
    throw new UnauthorizedException(Errors.INVALID_CREDENTIALS);
  }

  public async register(registerUserDto: RegisterUserDto): Promise<UserEntity> {
    const password = this.generatePassword();
    const hashedPassword = await this.encrypt(password);
    const user = await this.userService.create({
      ...registerUserDto,
      password: hashedPassword,
    });

    this.mailService.sendEmail(
      user.email,
      'Contraseña nueva en dashboard Payouts 🔑',
      `¡Hola ${user.name}!\n\nTu nueva clave es: ${safetext(
        password,
      )}\n\nPor favor, cámbiala después de iniciar sesión.`,
    );

    return user;
  }

  /**
   * mfaInit
   * generates user mfa seed
   * updates user seed, mfa, mfaState
   * @param {number} id
   * @returns {string} otp auth url
   */
  public async mfaInit(id: number): Promise<string> {
    const { otpauth_url, ascii } = this.generateSeed();
    await this.userService.update(id, {
      seed: ascii,
      mfaState: MFAState.DISABLED,
      mfa: false,
    });
    return otpauth_url;
  }

  /**
   * mfaEnroll
   * verify code with user seed
   * updates user mfaState
   * @param {number} id
   * @param {string} seed
   * @param {UpdateMFAEnrollUserDto} UpdateMFAEnrollUserDto
   * @returns {boolean}
   */
  public async mfaEnroll(
    id: number,
    seed: string,
    updateMFAEnrollUserDto: UpdateMFAEnrollUserDto,
  ): Promise<boolean> {
    const result = this.verifyCode(seed, updateMFAEnrollUserDto.code);
    if (!result) throw new BadRequestException(Errors.INVALID_CODE);

    await this.userService.update(id, { mfaState: MFAState.ENROLLED });
    return result;
  }

  /**
   * mfaVerify
   * verify user password
   * updates user mfa
   * @param {UserEntity} user
   * @param {UpdateMFAVerifyUserDto} UpdateMFAVerifyUserDto
   * @returns {boolean}
   */
  public async mfaVerify(
    user: UserEntity,
    updateMFAVerifyUserDto: UpdateMFAVerifyUserDto,
  ): Promise<boolean> {
    if (user.mfaState !== MFAState.ENROLLED) {
      throw new BadRequestException(Errors.INVALID_STEP);
    }

    const valid = await this.validate(
      updateMFAVerifyUserDto.password,
      user.password,
    );
    if (!valid) throw new BadRequestException(Errors.INVALID_PASSWORD);

    // TODO: create a method in user service to update mfa properties
    await this.userService.update(user.id, {
      mfa: valid,
      mfaState: MFAState.VERIFIED,
    });

    return valid;
  }

  /**
   * Resets the MFA for a user.
   * @param {number} userId
   * @returns {Promise<UserEntity>}
   * @throws {NotFoundException} Throws an exception if no user is found.
   */
  public async resetMFA(userId: number): Promise<UserEntity> {
    const user = await this.userService.findOne(userId);
    return await this.userService.update(user.id, {
      mfa: false,
      mfaState: MFAState.DISABLED,
      seed: null,
    });
  }

  /**
   * Resets the password for a user.
   * @param {number} userId
   * @returns {Promise<UserEntity>}
   * @throws {NotFoundException} Throws an exception if no user is found.
   */
  public async resetPassword(userId: number): Promise<void> {
    const user = await this.userService.findOne(userId);
    const newPassword = this.generatePassword();
    const hashedPassword = await this.encrypt(newPassword);
    await this.userService.setPassword(user.id, hashedPassword);

    this.mailService.sendEmail(
      user.email,
      'Contraseña nueva en dashboard Payouts 🔑',
      `¡Hola ${user.name}!\n\nTu nueva clave es: ${safetext(
        newPassword,
      )}\n\nPor favor, cámbiala después de iniciar sesión.`,
    );
  }

  public async changePassword(
    userId: number,
    changePasswordDto: ChangeUserPasswordDto,
  ): Promise<void> {
    const { oldPassword, newPassword, confirmNewPassword, mfaCode } =
      changePasswordDto;

    const user = await this.userService.findOne(userId);

    // Validate old password
    const isOldPasswordValid = await this.validate(oldPassword, user.password);
    if (!isOldPasswordValid) {
      throw new BadRequestException('Invalid old password');
    }

    // Check if new password is the same as the old password
    if (oldPassword === newPassword) {
      throw new BadRequestException(
        'New password cannot be the same as the old password',
      );
    }

    // Validate 2FA code (if enabled, will throw an exception if invalid)
    this.verifyHasMFA(user.mfa, user.seed, mfaCode);

    // Check if new password and confirm new password are the same
    if (newPassword !== confirmNewPassword) {
      throw new BadRequestException(
        'New password and confirm new password do not match',
      );
    }

    // Hash the new password
    const hashedPassword = await this.encrypt(newPassword);

    // Update the user's password
    await this.userService.setPassword(userId, hashedPassword);

    // Send an email notification
    this.mailService.sendEmail(
      user.email,
      'Cambio de contraseña en dashboard Payouts 🔑',
      `¡Hola ${user.name}!\n\nTu contraseña ha sido cambiada exitosamente. Si no solicitaste este cambio, por favor, contacta a nuestro equipo de soporte inmediatamente.`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/auth/tokenPayload.interface.ts
export default interface TokenPayload {
  id: number;
  uuid: string;
  role: string;
  email: string;
  merchantId: number;
  mfa: boolean;
  name: string;
  lastPasswordUpdate: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/entities-validation/entities-validation.service.ts
import { Logger } from '@nestjs/common';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

interface ServiceEntitiesResult {
  result: boolean;
  detail?: { message: string; state?: TransferState };
}

export class EntitiesValidationService {
  private readonly logger = new Logger('EntitiesValidationService');

  private transfer: TransferEntity;
  private payout: PayoutEntity;
  private provider: ProviderEntity;

  setTransfer(transfer?: TransferEntity): this {
    this.transfer = transfer;
    return this;
  }

  setPayout(payout?: PayoutEntity): this {
    this.payout = payout;
    return this;
  }

  setProvider(provider?: ProviderEntity): this {
    this.provider = provider;
    return this;
  }

  get getTransfer(): TransferEntity {
    return this.transfer;
  }

  get getPayout(): PayoutEntity {
    return this.payout;
  }

  get getProvider(): ProviderEntity {
    return this.provider;
  }

  // private methods
  /**
   * Validate Transfer existence and valid v2 version
   */
  private validateTransferCommon(): void {
    this.validateTransferExistence();
    this.validateTransferVersion();
  }

  /**
   * Validate Payout existence and valid v2 version
   */
  private validatePayoutCommon(): void {
    this.validatePayoutExistence();
    this.validatePayoutVersion();
  }

  /**
   * Validate transfer existence
   */
  private validateTransferExistence(): void {
    if (!this.transfer) {
      this.logger.error(`Transfer not found`);
      throw new Error(`Transferencia no encontrada`);
    }
  }

  /**
   * Validate if a Payout has all its transfers with CANCELED state
   */
  private validatePayoutAllTransfersCanceled(
    transfers: TransferEntity[],
  ): void {
    const allTransfersCanceled = transfers.every(
      (transfer) => transfer.state === TransferState.CANCELED,
    );
    if (!allTransfersCanceled) {
      this.logger.error('Payout transfer statuses are invalid');
      throw new Error(
        'Los estados de las transferencias del pago son inválidos',
      );
    }
  }

  /**
   * Validate if a Transfer has v2 version
   */
  private validateTransferVersion(): void {
    if (this.transfer.version !== EntityVersion.v2) {
      this.logger.error('Transfer version is not v2');
      throw new Error('La versión de la transferencia no es v2');
    }
  }

  /**
   * Validate if a Payout has all its transfers with COMPLETED or CANCELED (Finished) state
   * @param transfers
   */
  private validatePayoutAllTransfersFinished(
    transfers: TransferEntity[],
  ): void {
    const finishedStates = [TransferState.COMPLETED, TransferState.CANCELED];
    const allFinishedTransfers = transfers.every((transfer) =>
      finishedStates.includes(transfer.state),
    );

    if (!allFinishedTransfers) {
      this.logger.error('Not all payout transfers have finished status');
      throw new Error(
        'No todas las transferencias del pago se encuentran en estado finalizado',
      );
    }
  }

  /**
   * Validate if a Payout has a single transfer with COMPLETED state
   * @param transfers
   */
  private validateUniqueTransferCompleted(transfers: TransferEntity[]): void {
    const completedTransfers = transfers.filter(
      (transfer) => transfer.state === TransferState.COMPLETED,
    );

    if (completedTransfers.length === 0) {
      this.logger.error('Could not find completed transfer');
      throw new Error('No se encontró la transferencia completada');
    }

    if (completedTransfers.length > 1) {
      this.logger.error('Found more than one completed transfer');
      throw new Error('Se encontraron múltiples transferencias completadas');
    }
  }

  /**
   * Validate if a Payout has a single transfer with PROCESSING state
   * @param transfers
   */
  private validateUniqueTransferProcessing(transfers: TransferEntity[]): void {
    const processingTransfers = transfers.filter(
      (transfer) => transfer.state === TransferState.PROCESSING,
    );

    if (processingTransfers.length === 0) {
      this.logger.error('Could not find processing transfer');
      throw new Error('No se encontró la transferencia en proceso');
    }

    if (processingTransfers.length > 1) {
      this.logger.error('Found more than one processing transfer');
      throw new Error('Se encontraron múltiples transferencias en proceso');
    }
  }

  private validatePayoutExistence(): void {
    if (!this.payout) {
      this.logger.error('Payout not found');
      throw new Error('Pago no encontrado con dichos parámetro de búsqueda');
    }
  }

  private validatePayoutVersion(): void {
    if (this.payout.version !== EntityVersion.v2) {
      this.logger.error('Payout version is not v2');
      throw new Error('La versión del pago no es v2');
    }
  }

  private validateProviderExistence(): void {
    if (!this.provider) {
      this.logger.error(
        `No capable providers found for transfer ${this.transfer.id}. Cancelling transfer`,
      );
      throw new Error(
        `No se encontraron proveedores capaces de realizar la transferencia ${this.transfer.id}. Se cancelará la transferencia`,
      );
    }
  }

  private validateTransferAssignable(): void {
    if (!this.transfer.assignable) {
      this.logger.error(`Transfer ${this.transfer.id} is not assignable`);
      throw new Error(`La transferencia ${this.transfer.id} no es asignable`);
    }
  }

  private validatePayoutUnfinishedState(): void {
    const finishedStates = [
      PayoutState.COMPLETED,
      PayoutState.CANCELED,
      PayoutState.FAILED,
    ];
    if (finishedStates.includes(this.payout.state)) {
      this.logger.error(`Payout with id ${this.payout.id} is finished`);
      throw new Error(
        `El pago ${this.payout.id} se encuentra en estado inválido`,
      );
    }
  }

  /**
   * Validates that the given transfer id is the only pending transfer for the payout.
   * @param transferId - The id of the transfer to be assigned
   */
  private validateUniquePendingTransfer(transferId: number): void {
    const payoutTransfers = this.payout.transfers;

    const processingTransfers = payoutTransfers.filter(
      (transfer) => transfer.state === TransferState.PROCESSING,
    );

    if (processingTransfers.length >= 1) {
      this.logger.error(
        `Found multiple processing transfers for payout ${this.payout.id}`,
      );
      throw new Error(
        `Se encontraron múltiples transferencias en proceso del pago ${this.payout.id}`,
      );
    }

    const pendingTransfers = payoutTransfers.filter(
      (transfer) => transfer.state === TransferState.PENDING,
    );

    if (pendingTransfers.length === 0) {
      this.logger.error(
        `Pending transfer ${transferId} not found for payout ${this.payout.id}`,
      );
      throw new Error(
        `No se encontró la transferencia  ${transferId} en estado pending para el pago ${this.payout.id}`,
      );
    }

    if (pendingTransfers.length > 1) {
      this.logger.error(
        `Found multiple pending transfers for payout ${this.payout.id}`,
      );
      throw new Error(
        `Se encontraron múltiples transferencias pending para el pago ${this.payout.id}`,
      );
    }

    const uniquePending = pendingTransfers[0];
    if (uniquePending.id !== transferId) {
      this.logger.error('Transfer to assign is not pending transfer');
      throw new Error(
        'La transferencia a asignar no se encuentra en estado pending',
      );
    }
  }

  private validateHasNonCompletedTransfer(): void {
    const payoutTransfers = this.payout.transfers;
    const completedTransfers = payoutTransfers.filter(
      (transfer) => transfer.state === TransferState.COMPLETED,
    );

    if (completedTransfers.length > 0) {
      this.logger.error(
        `Found multiple completed transfer for payout ${this.payout.id}`,
      );
      throw new Error(
        `Se encontraron múltiples transferencias completadas del pago ${this.payout.id}`,
      );
    }
  }

  // public methods

  /**
   * Checks if a transfer is assignable.
   * This method requires both a Payout and Transfer entity to be set prior to invocation.
   * It validates common payout and transfer conditions, checks if there are no completed transfers,
   * validates if the given transfer is the unique pending one, and checks if the transfer is assignable.
   *
   * Example usage:
   * ```typescript
   * const transferIsAssignable = entitiesValidations
   *   .setTransfer(transfer)
   *   .setPayout(payout)
   *   .transferIsAssignable(transfer.id);
   * ```
   *
   * @param transferId - The id of the transfer to be checked
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the transfer is assignable, false otherwise.
   * If false, the detail property will contain a message and a state indicating the reason and the new state of the transfer.
   */
  public transferIsAssignable(transferId: number): ServiceEntitiesResult {
    try {
      this.validatePayoutCommon();
      this.validateTransferCommon();
      this.validateHasNonCompletedTransfer();
      this.validateUniquePendingTransfer(transferId);
      this.validateTransferAssignable();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
          state: TransferState.CANCELED,
        },
      };
    }
  }

  /**
   * Checks if a transfer is valid.
   * This method requires a Transfer entity to be set prior to invocation.
   * It validates common transfer conditions such as existence and version.
   *
   * Example usage:
   * ```typescript
   * const transferIsValid = entitiesValidations
   *   .setTransfer(transfer)
   *   .transferIsValid();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the transfer is valid, false otherwise.
   * If false, the detail property will contain a message indicating the reason for invalidity.
   */
  public transferIsValid(): ServiceEntitiesResult {
    try {
      this.validateTransferCommon();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }

  /**
   * Checks if a payout is completable.
   * This method requires a Payout entity to be set prior to invocation.
   * It validates common payout conditions and checks if the payout is in an unfinished state.
   *
   * Example usage:
   * ```typescript
   * const payoutIsCompletable = entitiesValidations
   *   .setPayout(payout)
   *   .payoutIsCompletable();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the payout is completable, false otherwise.
   * If false, the detail property will contain a message indicating the reason for incompletion.
   */
  public payoutIsCompletable(): ServiceEntitiesResult {
    try {
      this.validatePayoutCommon();
      this.validatePayoutUnfinishedState();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }

  /**
   * Checks if a payout is processable.
   * This method requires a Payout entity to be set prior to invocation.
   */
  public payoutIsProcessable(): ServiceEntitiesResult {
    try {
      this.validatePayoutCommon();
      this.validatePayoutUnfinishedState();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }
  /**
   * Checks if a payout is cancelable.
   * This method requires a Payout entity to be set prior to invocation.
   * 
   * It validates common payout conditions, checks if all transfers are in the canceled state, and checks if the payout is in an unfinished state.
   *
   * Example usage:
   * ```typescript
   * const payoutIsCancelable = entitiesValidations
   *   .setPayout(payout)
   *   .payoutIsCancelable();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the payout is cancelable, false otherwise.
   * If false, the detail property will contain a message indicating the reason for incompletion.
   */
  public payoutIsCancelable(
    transfers: TransferEntity[],
  ): ServiceEntitiesResult {
    try {
      this.validatePayoutCommon();
      this.validatePayoutAllTransfersCanceled(transfers);
      this.validatePayoutUnfinishedState();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }

  /**
   * Checks if a payout is unfinished.
   * This method requires a Payout entity to be set prior to invocation.
   * It checks if the payout is not in any finished state [FAILED, CANCELED, COMPLETED].
   *
   * Example usage:
   * ```typescript
   * const payoutIsUnfinished = entitiesValidations
   *   .setPayout(payout)
   *   .payoutIsUnfinished();
   * ```
   */
  public payoutIsUnfinished(): ServiceEntitiesResult {
    try {
      this.validatePayoutUnfinishedState();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
          state: TransferState.CANCELED,
        },
      };
    }
  }

  /**
   * Checks if a payout is valid.
   * This method requires a Payoyt entity to be set prior to invocation.
   * It validates common payout conditions such as existence and version.
   *
   * Example usage:
   * ```typescript
   * const payoutIsValid = entitiesValidations
   *   .setPayout(payout)
   *   .payoutIsValid();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the payout is valid, false otherwise.
   * If false, the detail property will contain a message indicating the reason for invalidity.
   */
  public payoutIsValid(): ServiceEntitiesResult {
    try {
      this.validatePayoutCommon();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }
  /**
   * Checks if a payout has a unique completed transfer and all its transfers are finished.
   * This method requires a Payout entity with its transfers to be set prior to invocation.
   *
   * Example usage:
   * ```typescript
   * const payoutUniqueTransferCompleted = entitiesValidations
   *   .setPayout(payout)
   *   .payoutUniqueTransferCompleted();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the payout has a unique completed transfer and all its transfers are finished, false otherwise.
   * If false, the detail property will contain a message indicating the reason.
   */
  public payoutUniqueTransferCompleted(
    transfers: TransferEntity[],
  ): ServiceEntitiesResult {
    try {
      this.validateUniqueTransferCompleted(transfers);
      this.validatePayoutAllTransfersFinished(transfers);
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }

  /**
   * Checks if a payout has a unique transfer in processing state.
   * This method requires transfers to be set prior to invocation.
   *
   * Example usage:
   * ```typescript
   * const payoutUniqueTransferProcessing = entitiesValidations
   *   .setPayout(payout)
   *   .payoutUniqueTransferProcessing();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the payout has a unique transfer in processing state, false otherwise.
   * If false, the detail property will contain a message indicating the reason.
   */
  public payoutUniqueTransferProcessing(transfers: TransferEntity[]): ServiceEntitiesResult {
    try {
      this.validateUniqueTransferProcessing(transfers);
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
        },
      };
    }
  }

  /**
   * Checks if a provider is valid.
   * This method requires a Provider entity to be set prior to invocation.
   * It validates the existence of the provider.
   *
   * Example usage:
   * ```typescript
   * const providerIsValid = entitiesValidations
   *   .setProvider(provider)
   *   .providerIsValid();
   * ```
   *
   * @returns {ServiceEntitiesResult} - Returns an object with a result property set to true if the provider is valid, false otherwise.
   * If false, the detail property will contain a message and a state indicating the reason and the new state of the transfer.
   */
  public providerIsValid(): ServiceEntitiesResult {
    try {
      this.validateProviderExistence();
      return { result: true };
    } catch (error) {
      return {
        result: false,
        detail: {
          message: error.message,
          state: TransferState.CANCELED,
        },
      };
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/entities-validation/entities-validation.service.spec.ts
import { EntitiesValidationService } from './entities-validation.service';
import { Logger } from '@nestjs/common';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';

describe('EntitiesValidationService', () => {
  let service = new EntitiesValidationService();
  const payout = new PayoutEntity();
  const transfer = new TransferEntity();
  const provider = new ProviderEntity();

  beforeEach(async () => {
    service = new EntitiesValidationService();
  });

  it('service should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('set instance context related', () => {
    it('should set transfer, transfer provider and transfer payout to instance', () => {
      payout.id = 1;
      transfer.id = 2;
      provider.id = 3;

      transfer.provider = provider;
      transfer.payout = payout;
      service.setPayout(payout).setProvider(provider).setTransfer(transfer);

      expect(service.getPayout).toBeDefined();
      expect(service.getTransfer).toBeDefined();
      expect(service.getProvider).toBeDefined();
    });

    it('should reset new entities to instance', () => {
      payout.id = 4;
      transfer.id = 5;
      provider.id = 6;
      service.setPayout(payout).setProvider(provider).setTransfer(transfer);

      expect(service.getPayout.id).toBe(4);
      expect(service.getTransfer.id).toBe(5);
      expect(service.getProvider.id).toBe(6);
    });
  });

  describe('when some code executes transferIsAssignable', () => {
    it('should return true if transfer is assignable', () => {
      payout.id = 7;
      payout.version = EntityVersion.v2;

      transfer.id = 8;
      transfer.version = EntityVersion.v2;
      transfer.provider = provider;
      transfer.state = TransferState.PENDING;

      provider.id = 9;

      payout.transfers = [transfer];

      service.setPayout(payout).setProvider(provider).setTransfer(transfer);
      const { result } = service.transferIsAssignable(transfer.id);

      expect(result).toBeTruthy();
    });
    describe('validation cases', () => {
      const cases = [
        {
          description:
            'should return false if transfer is not assignable because of payout validation',
          expectedErrorMessage: 'Payout version is not v2',
          payoutId: 7,
          payoutVersion: EntityVersion.v1,
          transferId: 8,
          transferVersion: EntityVersion.v2,
          transferState: TransferState.PENDING,
          providerId: 9,
        },
        {
          description:
            'should return false if transfer is not assignable because of transfer state validation (transfer already completed)',
          payoutId: 10,
          payoutVersion: EntityVersion.v2,
          transferId: 11,
          transferVersion: EntityVersion.v2,
          transferState: TransferState.COMPLETED,
          providerId: 12,
          expectedErrorMessage: `Found multiple completed transfer for payout 10`,
        },
        {
          description:
            'should return false if transfer is not assignable because of transfer state validation (not unique pending)',
          payoutId: 11,
          payoutVersion: EntityVersion.v2,
          transferId: 12,
          transferVersion: EntityVersion.v2,
          transferState: TransferState.PENDING,
          providerId: 13,
          expectedErrorMessage:
            'Found multiple pending transfers for payout 11',
          otherTransfer: {
            state: TransferState.PENDING,
          } as TransferEntity,
        },
        {
          description:
            'should return false if transfer is not assignable because of transfer version validation',
          payoutId: 14,
          payoutVersion: EntityVersion.v2,
          transferId: 15,
          transferVersion: EntityVersion.v1,
          transferState: TransferState.COMPLETED,
          providerId: 16,
          expectedErrorMessage: `Transfer version is not v2`,
        },
      ];

      it.each(cases)(
        '$description',
        async ({
          payoutId,
          payoutVersion,
          transferId,
          transferVersion,
          transferState,
          providerId,
          expectedErrorMessage,
          otherTransfer,
        }) => {
          const validatePayoutExistenceSpy = jest.spyOn(
            service as any,
            'validatePayoutExistence',
          );
          const loggerSpy = jest.spyOn(Logger.prototype, 'error');

          payout.id = payoutId;
          payout.version = payoutVersion;

          transfer.id = transferId;
          transfer.version = transferVersion;
          transfer.provider = provider;
          transfer.state = transferState;

          provider.id = providerId;

          const payoutTransfers = [transfer];
          if (otherTransfer) {
            payoutTransfers.push(otherTransfer);
          }
          payout.transfers = payoutTransfers;

          service.setPayout(payout).setProvider(provider).setTransfer(transfer);

          const { result } = service.transferIsAssignable(transfer.id);

          expect(result).toBeFalsy();
          expect(validatePayoutExistenceSpy).toHaveBeenCalled();
          expect(loggerSpy).toHaveBeenCalledWith(expectedErrorMessage);
        },
      );
    });
  });

  describe('when some code executes transferIsValid', () => {
    it('should return true if transfer complies validations', () => {
      transfer.version = EntityVersion.v2;

      service.setTransfer(transfer);
      const { result } = service.transferIsValid();

      expect(result).toBeTruthy();
    });
    const cases = [
      { transfer: null, description: 'Transfer not found' },
      {
        transfer: { version: EntityVersion.v1 },
        description: 'Transfer version is not v2',
      },
    ];
    it.each(cases)(
      'should return false if transfer does not exist or has invalid version',
      ({ transfer, description }) => {
        const loggerSpy = jest.spyOn(Logger.prototype, 'error');

        service.setTransfer(transfer as TransferEntity);
        const { result } = service.transferIsValid();

        expect(result).toBeFalsy();
        expect(loggerSpy).toHaveBeenCalledWith(description);
      },
    );
  });

  describe('when some code executes payoutIsValid', () => {
    it('should return true if transfer complies validations', () => {
      payout.version = EntityVersion.v2;

      service.setPayout(payout);
      const { result } = service.payoutIsValid();

      expect(result).toBeTruthy();
    });
    const cases = [
      { payout: null, description: 'Payout not found' },
      {
        payout: { version: EntityVersion.v1 },
        description: 'Payout version is not v2',
      },
    ];
    it.each(cases)(
      'should return false if payout does not exist or has invalid version',
      ({ payout, description }) => {
        const loggerSpy = jest.spyOn(Logger.prototype, 'error');

        service.setPayout(payout as PayoutEntity);
        const { result } = service.payoutIsValid();

        expect(result).toBeFalsy();
        expect(loggerSpy).toHaveBeenCalledWith(description);
      },
    );
  });

  describe('when some code executes payoutIsCompletable', () => {
    it('should return true if payout has only one transfer completed', () => {
      payout.transfers = [{ state: TransferState.COMPLETED } as TransferEntity];

      service.setPayout(payout);
      const { result } = service.payoutIsCompletable();
      expect(result).toBeTruthy();
    });
    it('should return false if payout is not completable', () => {
      payout.state = PayoutState.COMPLETED;
      const validatePayoutUnfinishedStateSpy = jest.spyOn(
        service as any,
        'validatePayoutUnfinishedState',
      );

      const loggerSpy = jest.spyOn(Logger.prototype, 'error');

      service.setPayout(payout);
      const { result } = service.payoutIsCompletable();

      expect(result).toBeFalsy();
      expect(validatePayoutUnfinishedStateSpy).toHaveBeenCalled();
      expect(loggerSpy).toHaveBeenCalledWith(
        `Payout with id ${payout.id} is finished`,
      );
    });
  });

  describe('when some code executes payoutIsProcessable', () => {
    it('should return true if payout is processable', () => {
      payout.state = PayoutState.PROCESSING;

      service.setPayout(payout);
      const { result } = service.payoutIsProcessable();
      expect(result).toBeTruthy();
    });

    it('should return false if payout is not processable', () => {
      payout.state = PayoutState.FAILED;
      const validatePayoutUnfinishedStateSpy = jest.spyOn(
        service as any,
        'validatePayoutUnfinishedState',
      );

      const loggerSpy = jest.spyOn(Logger.prototype, 'error');

      service.setPayout(payout);
      const { result } = service.payoutIsProcessable();

      expect(result).toBeFalsy();
      expect(validatePayoutUnfinishedStateSpy).toHaveBeenCalled();
      expect(loggerSpy).toHaveBeenCalledWith(
        `Payout with id ${payout.id} is finished`,
      );
    });
  });

  describe('when some code executes payoutIsCancelable', () => {
    it('should return true if payout is cancelable', () => {
      payout.state = PayoutState.PROCESSING;
      payout.version = EntityVersion.v2;
      payout.id = 1;
      payout.transfers = [{ state: TransferState.CANCELED } as TransferEntity];

      service.setPayout(payout);
      const { result } = service.payoutIsCancelable();

      expect(result).toBeTruthy();
    });
    const cases = [
      PayoutState.COMPLETED,
      PayoutState.FAILED,
      PayoutState.CANCELED,
    ];
    it.each(cases)(
      'should return false if payout is not cancelable base on actual finished state',
      (state) => {
        const loggerSpy = jest.spyOn(Logger.prototype, 'error');

        payout.state = state;
        payout.version = EntityVersion.v2;
        payout.id = 1;

        service.setPayout(payout);
        const { result } = service.payoutIsCancelable();

        expect(result).toBeFalsy();
        expect(loggerSpy).toHaveBeenCalledWith(
          `Payout with id ${payout.id} is finished`,
        );
      },
    );
    it('should fail if all payout transfers do not have a canceled status', () => {
      const loggerSpy = jest.spyOn(Logger.prototype, 'error');

      payout.state = PayoutState.PROCESSING;
      payout.version = EntityVersion.v2;
      payout.id = 1;
      payout.transfers = [
        { state: TransferState.CANCELED } as TransferEntity,
        { state: TransferState.COMPLETED } as TransferEntity,
      ];

      service.setPayout(payout);
      const { result } = service.payoutIsCancelable();

      expect(result).toBeFalsy();
      expect(loggerSpy).toHaveBeenCalledWith(
        'Payout transfer statuses are invalid',
      );
    });
  });

  describe('when some code executes payoutIsUnfinished', () => {
    it('should return true if payout its not finished', () => {
      payout.state = PayoutState.PROCESSING;
      service.setPayout(payout);
      const { result } = service.payoutIsUnfinished();
      expect(result).toBeTruthy();
    });
    it('should return false if payout has any finished state', () => {
      const loggerSpy = jest.spyOn(Logger.prototype, 'error');

      payout.state = PayoutState.COMPLETED;
      service.setPayout(payout);
      const { result } = service.payoutIsUnfinished();
      expect(result).toBeFalsy();
      expect(loggerSpy).toHaveBeenCalledWith(
        `Payout with id ${payout.id} is finished`,
      );
    });
  });

  describe('when some code executes payoutUniqueTransferCompleted', () => {
    it('should return true if payout has only one transfer completed', () => {
      payout.transfers = [
        { state: TransferState.COMPLETED } as TransferEntity,
        { state: TransferState.CANCELED } as TransferEntity,
      ];

      service.setPayout(payout);
      const { result } = service.payoutUniqueTransferCompleted();
      expect(result).toBeTruthy();
    });

    describe('validation cases', () => {
      const cases = [
        {
          description:
            'should return false if payout has more than one transfer completed',
          transfers: [
            { state: TransferState.COMPLETED },
            { state: TransferState.COMPLETED },
          ] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Found more than one completed transfer',
        },
        {
          description:
            'should return false if payout has not only one transfer completed',
          transfers: [] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Could not find completed transfer',
        },
        {
          description:
            'should return false if payout has not completed transfer',
          transfers: [{ state: TransferState.PROCESSING }] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Could not find completed transfer',
        },
        {
          description:
            'should return false if payout has any unfinished transfer',
          transfers: [
            { state: TransferState.COMPLETED },
            { state: TransferState.PROCESSING },
          ] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Not all payout transfers have finished status',
        },
      ];

      it.each(cases)(
        '$description',
        ({ transfers, expectedResult, expectedErrorMessage }) => {
          const validateUniqueTransferCompletedSpy = jest.spyOn(
            service as any,
            'validateUniqueTransferCompleted',
          );

          payout.transfers = transfers;
          const loggerSpy = jest.spyOn(Logger.prototype, 'error');

          service.setPayout(payout);
          const { result } = service.payoutUniqueTransferCompleted();
          expect(result).toEqual(expectedResult);
          expect(validateUniqueTransferCompletedSpy).toHaveBeenCalled();
          expect(loggerSpy).toHaveBeenCalledWith(expectedErrorMessage);
        },
      );
    });
  });

  describe('when some code executes payoutUniqueTransferProcessing', () => {
    it('should return true if payout has only one transfer in processing state', () => {
      payout.transfers = [
        { state: TransferState.PROCESSING } as TransferEntity,
        { state: TransferState.CANCELED } as TransferEntity,
      ];

      service.setPayout(payout);
      const { result } = service.payoutUniqueTransferProcessing();
      expect(result).toBeTruthy();
    });

    describe('validation cases', () => {
      const cases = [
        {
          description:
            'should return false if payout has more than one transfer processing',
          transfers: [
            { state: TransferState.PROCESSING },
            { state: TransferState.PROCESSING },
          ] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Found more than one processing transfer',
        },
        {
          description:
            'should return false if payout does not have any transfer',
          transfers: [] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Could not find processing transfer',
        },
        {
          description:
            'should return false if payout has no processing transfer',
          transfers: [{ state: TransferState.COMPLETED }] as TransferEntity[],
          expectedResult: false,
          expectedErrorMessage: 'Could not find processing transfer',
        },
      ];

      it.each(cases)(
        '$description',
        ({ transfers, expectedResult, expectedErrorMessage }) => {
          const validateUniqueTransferProcessingSpy = jest.spyOn(
            service as any,
            'validateUniqueTransferProcessing',
          );

          payout.transfers = transfers;
          const loggerSpy = jest.spyOn(Logger.prototype, 'error');

          service.setPayout(payout);
          const { result } = service.payoutUniqueTransferProcessing();
          expect(result).toEqual(expectedResult);
          expect(validateUniqueTransferProcessingSpy).toHaveBeenCalled();
          expect(loggerSpy).toHaveBeenCalledWith(expectedErrorMessage);
        },
      );
    });
  });

  describe('when some code executes providerIsValid', () => {
    it('should return true if provider exist', () => {
      service.setProvider(provider);
      const { result } = service.providerIsValid();
      expect(result).toBeTruthy();
    });
    it('should return false if provider does not exist', () => {
      const loggerSpy = jest.spyOn(Logger.prototype, 'error');

      service.setTransfer(transfer).setProvider();
      const { result } = service.providerIsValid();

      expect(result).toBeFalsy();
      expect(loggerSpy).toHaveBeenCalledWith(
        `No capable providers found for transfer ${transfer.id}. Cancelling transfer`,
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/mail/mail.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import mailConfig from 'src/config/mail.config';
import { MailService } from './mail.service';
import { SentryModule } from '../sentry/sentry.module';

@Module({
  imports: [ConfigModule.forFeature(mailConfig), SentryModule],
  providers: [MailService],
  exports: [MailService],
})
export class MailModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/mail/mail.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import {
  MailDataRequired,
  MailService as SendgridMailService,
} from '@sendgrid/mail';
import { SentryService } from '../sentry/sentry.service';
import mailConfig from 'src/config/mail.config';
import { ConfigType } from '@nestjs/config';
import { Environment } from 'src/common/enums/environment.enum';
import { MockMailService } from 'src/services/mocks/MockMailService';

@Injectable()
export class MailService {
  private readonly logger = new Logger('MailService');
  private sentryService: SentryService;
  private mailService: SendgridMailService | MockMailService;
  private environment: Environment = process.env.NODE_ENV as Environment;
  constructor(
    @Inject(mailConfig.KEY) private config: ConfigType<typeof mailConfig>,
    sentryService: SentryService,
  ) {
    this.sentryService = sentryService;
    try {
      if (this.environment === 'test') {
        this.mailService = new MockMailService();
      } else {
        this.mailService = new SendgridMailService();
      }
      this.mailService.setApiKey(this.config.sendGridApiKey);
    } catch (error) {
      this.logger.error('Error setting SendGrid API key', error);
      this.sentryService.captureException(error);
    }
  }

  async sendEmail(to: string, subject: string, text: string): Promise<void> {
    const msg: MailDataRequired = {
      to: to,
      from: this.config.senderEmail,
      subject: subject,
      text: text,
    };

    try {
      await this.mailService.send(msg);
      this.logger.log(`Email sent to ${to}`);
    } catch (error) {
      this.logger.error('Error sending email', error);
      this.sentryService.captureException(error);
      if (error.response) {
        this.logger.error('Error response body', error.response.body);
      }
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/dtos/transfer-updated-dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';

export class TransferUpdatedDto {
  @IsNumber()
  @IsPositive()
  id: number;

  @IsNumber()
  @IsPositive()
  payoutId: number;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  message?: string;

  @IsEnum(TransferState)
  state: TransferState;

  @IsEnum(TransferErrorCode)
  @IsOptional()
  errorCode?: TransferErrorCode;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/dtos/get-transactions-update-dto.ts
import { IsEnum } from 'class-validator';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { FindOperator } from 'typeorm';

export class GetTransactionsUpdateDto {
  @IsEnum(ProviderType)
  providerType: ProviderType;

  lookupTime?: FindOperator<Date>;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/dtos/transaction-updated-dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class TransactionUpdatedDto {
  @IsNumber()
  @IsPositive()
  transferId: number;

  @IsString()
  @IsNotEmpty()
  externalId: string;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  message?: string;

  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/transfer-provider.service.spec.ts
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutService } from 'src/models/payout/payout.service';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { MockProviderService } from 'src/providers/mock/mock-provider.service';
import { TransferProviderService } from './transfer-provider.service';
import { SentryService } from '../sentry/sentry.service';
import { MockFeatureFlagService } from '../mocks/MockFeatureFlagService';
import { PayoutActionsService } from 'src/models/payout-actions/payout-actions.service';
import { PayoutActionEntity } from 'src/models/payout-actions/entities/payout-action.entity';
import { NotFoundException } from '@nestjs/common';
import { ProviderService } from 'src/models/provider/provider.service';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';

describe('Given a TransferProviderService', () => {
  let service: TransferProviderService;

  let mockEventEmitter = {};
  let mockProviderService = {};
  let mockPayoutService: Partial<PayoutService> = {};
  const mockPayoutNewService = {
    findOneOrFail: jest.fn(),
  };
  let mockTransferService: Partial<TransferService> = {};
  let mockPayoutActionsService: Partial<PayoutActionsService>;

  const mockSentryService: Partial<SentryService> = {
    captureException: (_exception, _level, _tags) => Promise.resolve(),
  };
  const mockFeatureFlagService = {
    getFeatureStatus: jest.fn().mockResolvedValue(false),
  };

  const providerDto = {
    id: 1,
    providerType: ProviderType.ScraperCG,
    accountId: 1,
  };

  const payoutDto = {
    id: 1,
    amount: 1000,
    merchantId: 1,
    state: PayoutState.PENDING,
    message: '',
    version: EntityVersion.v2,
  };

  const transferDto = {
    id: 1,
    payoutId: payoutDto.id,
    amount: payoutDto.amount,
    providerId: providerDto.id,
    state: TransferState.ASSIGNED,
    version: EntityVersion.v2,
  };

  let payout;
  let provider;
  let transfer;

  beforeEach(async () => {
    payout = { ...payoutDto } as PayoutEntity;
    provider = { ...providerDto } as ProviderEntity;
    transfer = { ...transferDto, provider } as TransferEntity;

    mockEventEmitter = {
      emit: () => Promise.resolve(),
    };

    mockPayoutService = {
      updateState(_payoutId: number, state: PayoutState, _metadata?: any) {
        payout.state = state;
        return Promise.resolve(payout);
      },
    };

    mockTransferService = {
      findOneOrFail: async (id: number) =>
        Promise.resolve({ ...transfer, id } as TransferEntity),
      findOneByConditions: async (options) => {
        const validVersion =
          options.where['version'] &&
          options.where['version'] === transfer.version;
        const validState =
          options.where['state'] && options.where['state'] === transfer.state;
        const validId =
          options.where['id'] && options.where['id'] === transfer.id;
        const validConditions = validVersion && validState && validId;
        if (validConditions) {
          return Promise.resolve(transfer);
        }
        throw new NotFoundException(
          'Transfer not found for the provided conditions',
        );
      },
      async update(id, updateTransferDto) {
        transfer = {
          id,
          ...transfer,
          ...updateTransferDto,
        };
        return Promise.resolve(transfer);
      },
      findManyByConditions: async (_options) => Promise.resolve([]),
    };
    mockProviderService = {
      findOne: async (id: number) =>
        Promise.resolve({ ...provider, id } as ProviderEntity),
      getProviderAdapter: () => new MockProviderService(),
    };
    mockPayoutActionsService = {
      getAutomatedPayoutAction: async () => {
        return { errorCode: 'ERROR_0004' } as PayoutActionEntity;
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferProviderService,
        { provide: EventEmitter2, useValue: mockEventEmitter },
        { provide: PayoutService, useValue: mockPayoutService },
        { provide: PayoutNewService, useValue: mockPayoutNewService },
        { provide: TransferService, useValue: mockTransferService },
        { provide: ProviderService, useValue: mockProviderService },
        { provide: SentryService, useValue: mockSentryService },
        { provide: PayoutActionsService, useValue: mockPayoutActionsService },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    service = module.get<TransferProviderService>(TransferProviderService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('when some code executes createTransaction method', () => {
    beforeEach(() => {
      jest
        .spyOn(MockFeatureFlagService.prototype, 'getValueAsync')
        .mockReturnValue(Promise.resolve(false)); // FEATURE FLAG CAN USE NEW PAYOUT CREATION
    });

    it("then shouldn't create the transaction if the transfer state is not 'assigned'", async () => {
      const states = [
        TransferState.PENDING,
        TransferState.COMPLETED,
        TransferState.FAILED,
      ];

      for (const state of states) {
        const spiedMethod = jest.spyOn(mockTransferService, 'update');
        const spiedProcessTransferAndPayout = jest.spyOn(
          PayoutNewService.prototype,
          'processTransferAndPayout',
        );

        transfer.state = state;
        await service.createTransaction(transfer);

        expect(spiedMethod).toHaveBeenCalledTimes(0);
        expect(spiedProcessTransferAndPayout).toHaveBeenCalledTimes(0);
        expect(transfer.state).toEqual(state);
      }
    });

    it("then should not call the provider if the transfer version isn't v2", async () => {
      const spiedMethod = jest.spyOn(mockTransferService, 'update');
      const spiedProcessTransferAndPayout = jest.spyOn(
        PayoutNewService.prototype,
        'processTransferAndPayout',
      );
      transfer.version = EntityVersion.v1;

      await service.createTransaction(transfer);

      expect(spiedMethod).toHaveBeenCalledTimes(0);
      expect(spiedProcessTransferAndPayout).toHaveBeenCalledTimes(0);
      expect(transfer.state).toEqual(TransferState.ASSIGNED);
    });

    it('then should set the transfer as failed if the transaction creation fails', async () => {
      const spiedMethod = jest.spyOn(mockTransferService, 'update');
      const spiedProcessTransferAndPayout = jest.spyOn(
        PayoutNewService.prototype,
        'processTransferAndPayout',
      );
      transfer.amount = -1;

      await service.createTransaction(transfer);

      expect(transfer.state).toEqual(TransferState.FAILED);
      expect(transfer.message).toEqual(
        'El monto de la transferencia debe ser mayor que cero',
      );

      expect(spiedMethod).toHaveBeenCalledTimes(1);
      expect(spiedProcessTransferAndPayout).toHaveBeenCalledTimes(0);
      expect(spiedMethod).toHaveBeenCalledWith(transfer.id, {
        message: 'El monto de la transferencia debe ser mayor que cero',
        state: TransferState.FAILED,
      });
    });

    it('then should create the transaction and return the externalId', async () => {
      const spiedMethod = jest.spyOn(mockTransferService, 'update');
      const spiedProcessTransferAndPayout = jest.spyOn(
        PayoutNewService.prototype,
        'processTransferAndPayout',
      );
      transfer.metadata = null;
      transfer.externalId = null;

      await service.createTransaction(transfer);

      expect(spiedMethod).toHaveBeenCalledTimes(1);
      expect(spiedProcessTransferAndPayout).toHaveBeenCalledTimes(0);
      expect(transfer.externalId).toBeDefined();
      expect(spiedMethod).toHaveBeenCalledWith(transfer.id, {
        externalId: transfer.externalId,
        state: transfer.state,
      });
    });
  });

  describe('when some code executes updatePayout method', () => {
    let payoutUpdateStateSpy: jest.SpyInstance;

    beforeEach(() => {
      payoutUpdateStateSpy = jest.spyOn(mockPayoutService, 'updateState');
    });

    it('then should return undefined if an error is thrown', async () => {
      mockPayoutNewService.findOneOrFail.mockImplementation(async () =>
        Promise.reject('Error'),
      );

      const result = await service.updatePayoutState(transfer);

      expect(payoutUpdateStateSpy).toHaveBeenCalledTimes(0);
      expect(result).toBeUndefined();
    });

    it('then should update the payout state', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      transfer.state = TransferState.PROCESSING;

      const result = await service.updatePayoutState(transfer);
      expect(result).toBeDefined();
      expect(payoutUpdateStateSpy).toHaveBeenCalledTimes(1);
      expect(result.state).toEqual(PayoutState.PROCESSING);
    });
  });

  describe('when some code executes getTransactionsUpdate method', () => {
    it('then should update the transfers with processing state for the specified providerType', async () => {
      const minkaProviderTransfer = {
        ...transfer,
        provider,
        externalId: '12121',
        metadata: { externalId: '12121' },
      };

      mockTransferService.findManyByConditions = async (_options) =>
        Promise.resolve([
          minkaProviderTransfer,
          minkaProviderTransfer,
          minkaProviderTransfer,
        ] as TransferEntity[]);

      const result = await service.getTransactionsUpdate({
        providerType: ProviderType.Minka,
      });

      expect(result).toHaveLength(3);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/transfer-provider.module.ts
import { Module } from '@nestjs/common';
import { PayoutModule } from 'src/models/payout/payout.module';
import { PayoutNewModule } from 'src/models/payout/payout.new.module';
import { ProviderModule } from 'src/models/provider/provider.module';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { TransferProviderService } from './transfer-provider.service';
import { SentryModule } from '../sentry/sentry.module';
import { FeatureFlagModule } from '../feature-flag/feature-flag.module';

@Module({
  imports: [
    SentryModule,
    ProviderModule,
    PayoutModule,
    PayoutNewModule,
    TransferModule,
    FeatureFlagModule,
  ],
  providers: [TransferProviderService],
  exports: [TransferProviderService],
})
export class TransferProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-provider/transfer-provider.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { plainToClass } from 'class-transformer';
import { UpdateTransferDto } from 'src/api/v2/transfer/dto/update-transfer.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutService } from 'src/models/payout/payout.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { ProviderService } from 'src/models/provider/provider.service';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { SortOrder, filterUndefined } from 'src/utils/array-methods.util';
import { FindManyOptions } from 'typeorm';
import { TransactionDto } from '../../providers/common/dtos/transaction.dto';
import { GetTransactionsUpdateDto } from './dtos/get-transactions-update-dto';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { UpdateTransactionDto } from 'src/providers/common/dtos/update-transaction.dto';
import { SentryService } from '../sentry/sentry.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';

@Injectable()
export class TransferProviderService {
  private readonly logger = new Logger('TransferProviderService');
  constructor(
    private sentryService: SentryService,
    private payoutService: PayoutService,
    private payoutNewService: PayoutNewService,
    private transferService: TransferService, // QUITAR DE ACÁ! NO USAR! WARNING DANGER DANGER
    private featureFlagService: FeatureFlagService,
    private providerService: ProviderService,
  ) {}

  private async applyTransactionUpdate(transfer: TransferEntity) {
    try {
      const { externalId } = transfer;
      const provider = this.providerService.getProviderAdapter(
        transfer?.provider?.providerType,
      );

      const transferUpdate = await provider.getTransactionState(
        transfer.provider,
        externalId,
      );

      const updateTransferDto = plainToClass(UpdateTransferDto, transferUpdate);

      const updatedTransfer = await this.transferService.update(
        transfer.id,
        updateTransferDto,
      );

      return updatedTransfer;
    } catch (error) {
      this.logger.error(
        `Can't update transfer with Id ${transfer.id}: ${error.message}`,
      );
      this.sentryService.captureException(error);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  private async setTransferAsFailed(id: number, message?: string) {
    const updatedTransfer = await this.transferService.update(id, {
      state: TransferState.FAILED,
      message,
    });

    return updatedTransfer;
  }

  @OnEvent(TransferEvent.ASSIGNED)
  @OnEvent(TransferEvent.UPDATED_STATE) // TODO: To be deprecated
  async createTransaction(transfer: TransferEntity): Promise<void> {
    const { state, version, providerId } = transfer;

    if (!providerId) return;
    if (version !== EntityVersion.v2) return;

    if (state !== TransferState.ASSIGNED) return;

    const provider = await this.providerService.findOne(providerId);
    if (!provider) return;

    try {
      const providerAdapter = this.providerService.getProviderAdapter(
        provider.providerType,
      );
      const transactionDto = plainToClass(TransactionDto, transfer);

      const transactionResult = await providerAdapter.createTransaction(
        provider,
        transactionDto,
      );

      const {
        externalId,
        state: transactionState,
        message,
        jobId,
      } = transactionResult ?? {};

      const updateTransferDto: UpdateTransferDto = {
        ...(transactionState && { state: transactionState }),
        ...(message && { message }),
        ...(externalId && { externalId }),
        ...(jobId && { metadata: { jobId } }),
      };

      // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
      const canUseNewPayoutCreation =
        await this.featureFlagService.getFeatureStatus(
          FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
        );
      // TODO: Implement this in feature PYT-884
      // if (canUseNewPayoutCreation && transactionState === TransferState.PROCESSING ) { return; }
      if (
        canUseNewPayoutCreation &&
        transactionState === TransferState.PROCESSING
      ) {
        this.logger.log('Processing payout with new service');
        await this.payoutNewService.processPayoutAndTransfer(
          transfer.payoutId,
          transfer.id,
          {
            ...(message && { message }),
            ...(externalId && { externalId }),
          },
        );
        return;
      }
      this.logger.log('Updating transfer with old update method');
      await this.transferService.update(transfer.id, updateTransferDto);
    } catch (error) {
      const message = `Error al crear la transacción: ${error?.message}`;
      await this.setTransferAsFailed(transfer.id, message);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  @OnEvent(TransferEvent.UPDATED_STATE)
  async updatePayoutState(transfer: TransferEntity): Promise<PayoutEntity> {
    try {
      const { payoutId, state } = transfer;

      const reflectableStates = [
        TransferState.PROCESSING,
        TransferState.COMPLETED,
        TransferState.FAILED,
      ];

      if (!reflectableStates.includes(state)) return;

      const payout = await this.payoutNewService.findOneOrFail(payoutId);

      if (!payout) {
        const error = `Payout with Id ${payoutId} does not exist`;
        throw new Error(error);
      }

      if (state === TransferState.PROCESSING) {
        await this.payoutService.updateState(payoutId, PayoutState.PROCESSING);
      }

      if (state === TransferState.COMPLETED) {
        await this.payoutService.updateState(payoutId, PayoutState.COMPLETED);
      }

      const updatedPayout = await this.payoutNewService.findOneOrFail(payoutId);
      return updatedPayout;
    } catch (error) {
      this.logger.error(error);
      const { id } = transfer;
      const message = `Could not apply transfer ${id} changes to payout: ${error?.message}`;
      this.logger.error(message);
    }
  }

  async getTransactionsUpdate(
    getTransactionsUpdateDto: GetTransactionsUpdateDto,
  ) {
    try {
      const { providerType, lookupTime } = getTransactionsUpdateDto;
      const findTransferOptions: FindManyOptions<TransferEntity> = {
        where: {
          provider: { providerType },
          state: TransferState.PROCESSING,
          version: EntityVersion.v2,
          ...(lookupTime && { createdAt: lookupTime }),
        },
        relations: ['provider'],
        order: { createdAt: SortOrder.ASCENDING },
      };
      const transfers = await this.transferService.findManyByConditions(
        findTransferOptions,
      );

      this.logger.log(
        `Found ${transfers.length} transfers with 'processing' state for providerType ${providerType}`,
      );

      const result = await Promise.all(
        transfers.map((transfer) => this.applyTransactionUpdate(transfer)),
      ).then((updatedTransfers) => filterUndefined(updatedTransfers));

      return result;
    } catch (error) {
      this.logger.error(
        `Can't get transactions update for providerType ${getTransactionsUpdateDto.providerType}: ${error.message}`,
      );
    }
  }

  async updateTransfer(updateTransactionDto: UpdateTransactionDto) {
    const { transferId, externalId, state, message, metadata } =
      updateTransactionDto;

    if (!transferId && !externalId) {
      throw new Error(
        'updateTransactionDto must have either transferId or externalId',
      );
    }

    const findByExternalId = !transferId && externalId;

    const transfer = await this.transferService.findOneByConditions({
      where: {
        ...(transferId && { id: transferId }),
        ...(findByExternalId && { externalId }),
        version: EntityVersion.v2,
      },
    });

    const updateTransferDto = plainToClass(
      UpdateTransferDto,
      updateTransactionDto,
      { excludeExtraneousValues: true },
    );

    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation && state === TransferState.COMPLETED) {
      this.logger.log('Completing payout with new service');
      return await this.payoutNewService.completePayoutAndTransfer(
        transfer.payoutId,
        transferId,
        { message },
      );
    }
    if (canUseNewPayoutCreation && state === TransferState.PROCESSING) {
      this.logger.log('Processing payout with new service');
      return await this.payoutNewService.processPayoutAndTransfer(
        transfer.payoutId,
        transferId,
        { message },
      );
    }
    if (canUseNewPayoutCreation && state === TransferState.FAILED) {
      this.logger.log('Failing transfer with new service');
      return await this.payoutNewService.failTransfer(transfer.id, {
        metadata,
        message,
      });
    }

    const updatedTransfer = await this.transferService.update(
      transfer.id,
      updateTransferDto,
    );

    return updatedTransfer;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/metrics/metrics.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { MetricsService } from './metrics.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

describe('given a MetricsService', () => {
  let service: MetricsService;

  beforeEach(async () => {
    const mockTransferEntity = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MetricsService,
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferEntity,
        },
      ],
    }).compile();

    service = module.get<MetricsService>(MetricsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/metrics/metrics.module.ts
import { Module } from '@nestjs/common';
import { MetricsService } from './metrics.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [TypeOrmModule.forFeature([TransferEntity])],
  providers: [MetricsService],
  exports: [MetricsService],
})
export class MetricsModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/metrics/metrics.service.ts
import moment = require('moment');

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { Repository, SelectQueryBuilder } from 'typeorm';

export interface ProviderCountStats {
  [TransferState.PENDING]: number;
  [TransferState.ASSIGNED]: number;
  [TransferState.PROCESSING]: number;
  [TransferState.COMPLETED]: number;
  [TransferState.CANCELED]: number;
  [TransferState.FAILED]: number;
}

export interface ProviderAmountStats {
  avg: number;
  min: number;
  max: number;
  sum: number;
}

export interface ProviderTimeStats {
  avg: number;
  min: number;
  max: number;
}

export interface ProviderManagementStats {
  retry: number;
  reassign: number;
  cancel: number;
  complete: number;
}

export interface MetricsFilters {
  startDate?: Date;
  endDate?: Date;
}

function applyQueryFilters(
  query: SelectQueryBuilder<TransferEntity>,
  filters?: MetricsFilters,
) {
  const { startDate, endDate } = filters || {};

  if (startDate) {
    const start = moment(startDate).format('YYYY-MM-DD HH:mm:ss');
    query.andWhere('transfer.createdAt >= :start', { start });
  }

  if (endDate) {
    const end = moment(endDate).format('YYYY-MM-DD HH:mm:ss');
    query.andWhere('transfer.createdAt <= :end', { end });
  }

  return query;
}

@Injectable()
export class MetricsService {
  constructor(
    @InjectRepository(TransferEntity)
    private readonly transferRepository: Repository<TransferEntity>,
  ) {}

  async getStateMetrics(
    providerId: number,
    filters?: MetricsFilters,
  ): Promise<ProviderCountStats> {
    const query = this.transferRepository
      .createQueryBuilder('transfer')
      .select(['transfer.state as state', 'COUNT(transfer.id) as count'])
      .where('transfer.providerId = :providerId', { providerId })
      .groupBy('transfer.state');

    const filteredQuery = applyQueryFilters(query, filters);

    const results = await filteredQuery.getRawMany();

    const transferStates = Object.values(TransferState);

    const transferCountByState = {
      [TransferState.PENDING]: 0,
      [TransferState.ASSIGNED]: 0,
      [TransferState.PROCESSING]: 0,
      [TransferState.COMPLETED]: 0,
      [TransferState.CANCELED]: 0,
      [TransferState.FAILED]: 0,
    };

    transferStates.forEach((state) => {
      const result = results.find((result) => result.state === state);
      transferCountByState[state] = result ? parseInt(result.count) : 0;
    });

    return transferCountByState;
  }

  public async getTimeMetrics(
    providerId: number,
    filters?: MetricsFilters,
  ): Promise<ProviderTimeStats> {
    const query = this.transferRepository
      .createQueryBuilder('transfer')
      .select([
        'AVG(UNIX_TIMESTAMP(transfer.finishedAt) - UNIX_TIMESTAMP(transfer.startedAt)) as avg',
        'MIN(UNIX_TIMESTAMP(transfer.finishedAt) - UNIX_TIMESTAMP(transfer.startedAt)) as min',
        'MAX(UNIX_TIMESTAMP(transfer.finishedAt) - UNIX_TIMESTAMP(transfer.startedAt)) as max',
      ])
      .where('transfer.providerId = :providerId', { providerId })
      .andWhere('transfer.state = :state', { state: TransferState.COMPLETED });

    const filteredQuery = applyQueryFilters(query, filters);

    const result = await filteredQuery.getRawOne();

    const avg = parseInt(result.avg) || 0;
    const min = parseInt(result.min) || 0;
    const max = parseInt(result.max) || 0;

    return { avg, min, max };
  }

  public async getAmountMetrics(
    providerId: number,
    filters?: MetricsFilters,
  ): Promise<ProviderAmountStats> {
    const query = this.transferRepository
      .createQueryBuilder('transfer')
      .select([
        'AVG(transfer.amount) as avg',
        'MIN(transfer.amount) as min',
        'MAX(transfer.amount) as max',
        'SUM(transfer.amount) as sum',
      ])
      .where('transfer.providerId = :providerId', { providerId })
      .andWhere('transfer.state = :state', { state: TransferState.COMPLETED });

    const filteredQuery = applyQueryFilters(query, filters);

    const result = await filteredQuery.getRawOne();

    const avg = parseInt(result.avg) || 0;
    const min = parseInt(result.min) || 0;
    const max = parseInt(result.max) || 0;
    const sum = parseInt(result.sum) || 0;

    return { avg, min, max, sum };
  }

  async getManagementMetrics(
    providerId: number,
    filters?: MetricsFilters,
  ): Promise<ProviderManagementStats> {
    const subquery = this.transferRepository
      .createQueryBuilder()
      .select([
        'id AS transferId',
        'LEAD(providerId) OVER (PARTITION BY payoutId ORDER BY createdAt) AS nextProvider',
      ]);

    const query = this.transferRepository
      .createQueryBuilder('transfer')
      .select(
        'COUNT(CASE WHEN aux.nextProvider IS NOT NULL AND transfer.providerId = aux.nextProvider THEN 1 END) AS retry',
      )
      .addSelect(
        'COUNT(CASE WHEN aux.nextProvider IS NOT NULL AND transfer.providerId != aux.nextProvider THEN 1 END) AS reassign',
      )
      .addSelect(
        'COUNT(CASE WHEN aux.nextProvider IS NULL AND transfer.state IN (:failed, :canceled) AND payout.state = :canceled THEN 1 END) AS cancel',
      )
      .addSelect(
        'COUNT(CASE WHEN transfer.state = :completed AND payout.state = :completed AND transfer.errorCode IS NOT NULL THEN 1 END) AS complete',
      )
      .leftJoin(
        `(${subquery.getQuery()})`,
        'aux',
        'aux.transferId = transfer.id',
      )
      .leftJoin('transfer.payout', 'payout')
      .where('transfer.providerId = :providerId')
      .setParameters({
        providerId,
        failed: TransferState.FAILED,
        canceled: TransferState.CANCELED,
        completed: TransferState.COMPLETED,
      });

    const filteredQuery = applyQueryFilters(query, filters);

    const result = await filteredQuery.getRawOne();

    return {
      retry: parseInt(result.retry, 10) || 0,
      reassign: parseInt(result.reassign, 10) || 0,
      cancel: parseInt(result.cancel, 10) || 0,
      complete: parseInt(result.complete, 10) || 0,
    };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-reconciliation/transfer-reconciliation.service.ts
import { Injectable, UnprocessableEntityException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferReconciliationDto } from 'src/api/v2/transfer/dto/transfer-reconciliation.dto';
import { TransferMismatchDto } from 'src/api/v2/transfer/dto/transfer-mismatch.dto';
import { BankCode } from 'src/common/enums/bank-code.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import {
  In,
  LessThanOrEqual,
  MoreThan,
  MoreThanOrEqual,
  Repository,
} from 'typeorm';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { AccountService } from 'src/models/account/account.service';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { Errors } from 'src/common/enums/errors.enum';
import { buildTimeQuery } from 'src/common/queries/time.query';

interface ReconciliationParams {
  startDate: string;
  endDate: string;
}

export const RECONCILIATION_SUPPORTED_BANKS = [
  BankCode.BANCO_SANTANDER,
  BankCode.BANCO_ITAU,
  BankCode.BANCO_SECURITY,
];

// TODO: Must change this and get the enable accounts for conciliation from another source, maybe a merchant setting (?)
// IDEA: Add flag to account -> reconciliate: boolean
export const ENABLE_RECONCILIATION_ACCOUNTS = ['77632115'];

@Injectable()
export class TransferReconciliationService {
  constructor(
    @InjectRepository(TransferEntity)
    private transferRepository: Repository<TransferEntity>,
    @InjectRepository(AccountStatementEntity)
    private accountStatementRepository: Repository<AccountStatementEntity>,
    private accountService: AccountService,
    private accountStatementJobService: AccountStatementJobService,
  ) {}

  private async setTransfers(
    reconciliation: TransferMismatchDto,
    params: ReconciliationParams,
  ): Promise<void> {
    const finishedAtRange = buildTimeQuery({
      from: params.startDate,
      to: params.endDate,
    });

    reconciliation.transfers = await this.transferRepository.find({
      relations: ['provider', 'provider.account'],
      where: {
        provider: {
          account: {
            bankCode: In(RECONCILIATION_SUPPORTED_BANKS),
            identifier: In(ENABLE_RECONCILIATION_ACCOUNTS),
          },
        },
        version: EntityVersion.v2,
        state: TransferState.COMPLETED,
        finishedAt: finishedAtRange,
        destinationHolderId: reconciliation.destinationHolderId,
      },
    });
  }

  private async setAccountStatements(
    reconciliation: TransferMismatchDto,
    params: ReconciliationParams,
  ): Promise<void> {
    const dateRange = buildTimeQuery({
      from: params.startDate,
      to: params.endDate,
    });

    reconciliation.accountStatements =
      await this.accountStatementRepository.find({
        where: {
          originBankAccountIdentifier: In(ENABLE_RECONCILIATION_ACCOUNTS),
          state: TransferState.COMPLETED,
          date: dateRange,
          destinationHolderId: reconciliation.destinationHolderId,
          originBankCode: In(RECONCILIATION_SUPPORTED_BANKS),
        },
      });
  }

  private async checkAccountStatementExistence(
    startDate: string,
    endDate: string,
  ): Promise<void> {
    const accounts = await this.accountService.findAll({
      where: {
        bankCode: In(RECONCILIATION_SUPPORTED_BANKS),
        identifier: In(ENABLE_RECONCILIATION_ACCOUNTS),
      },
    });

    const missingAccounts = [];
    for (const account of accounts) {
      const accountStatementJob =
        await this.accountStatementJobService.findOneByConditions({
          where: {
            startDate: LessThanOrEqual(new Date(startDate)),
            endDate: MoreThanOrEqual(new Date(endDate)),
            accountId: account.id,
            state: AccountStatementJobState.FINISHED,
            createdAt: MoreThan(new Date(endDate)),
          },
        });

      if (!accountStatementJob) missingAccounts.push(account.name);
    }

    if (missingAccounts.length > 0) {
      throw new UnprocessableEntityException({
        statusCode: 422,
        message: `${missingAccounts.toString()}`,
        error: Errors.MISSING_ACCOUNT_STATEMENT,
      });
    }
  }

  public async reconciliate(
    transferReConciliationDto: TransferReconciliationDto,
  ): Promise<TransferMismatchDto[]> {
    const { startDate, endDate } = transferReConciliationDto;

    await this.checkAccountStatementExistence(startDate, endDate);

    const reconciliations = await this.transferRepository.query(
      `
        SELECT destinationHolderId, ABS(SUM(diff)) diffCount, ABS(SUM(amount)) amountMismatch
        FROM 
        (
          SELECT t.destinationHolderId, t.amount, DATE_FORMAT(t.finishedAt, '%Y-%m-%d') as date, 1 as diff
          FROM transfer t
          JOIN provider p ON t.providerId = p.id 
          JOIN account a ON p.accountId = a.id
          WHERE a.bankCode IN (?) 
          AND a.identifier IN (?)
          AND version = 'v2' AND t.state = 'completed'
          AND t.finishedAt BETWEEN ? AND ?
          UNION ALL
          SELECT acs.destinationHolderId, (acs.amount*-1) as amount, DATE_FORMAT(acs.date, '%Y-%m-%d') as date, -1 as diff
          FROM account_statement acs        
          WHERE originBankCode IN (?)
          AND originBankAccountIdentifier IN (?)
          AND state = 'completed'
          AND date BETWEEN ? AND ? 
        ) reconciliations
        GROUP BY destinationHolderId
        HAVING (SUM(amount) = 0 AND SUM(diff) <> 0) OR
               (SUM(amount) <> 0 AND SUM(diff) = 0) OR
               (SUM(amount) <> 0 AND SUM(diff) <> 0)
      `,
      [
        RECONCILIATION_SUPPORTED_BANKS,
        ENABLE_RECONCILIATION_ACCOUNTS,
        startDate,
        endDate, // First subquery params
        RECONCILIATION_SUPPORTED_BANKS,
        ENABLE_RECONCILIATION_ACCOUNTS,
        startDate,
        endDate,
      ], // IMPORTANT: Should provide the parameters in the correct order
    );

    for (const reconciliation of reconciliations) {
      await this.setTransfers(reconciliation, transferReConciliationDto);
      await this.setAccountStatements(
        reconciliation,
        transferReConciliationDto,
      );
    }

    return reconciliations as TransferMismatchDto[];
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-reconciliation/transfer-reconciliation.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AccountStatementJobModule } from 'src/models/account-statement-job/account-statement-job.module';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountModule } from 'src/models/account/account.module';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferReconciliationService } from './transfer-reconciliation.service';

@Module({
  imports: [
    TypeOrmModule.forFeature([TransferEntity]),
    TypeOrmModule.forFeature([AccountStatementEntity]),
    AccountModule,
    AccountStatementJobModule,
  ],
  providers: [TransferReconciliationService],
  exports: [TransferReconciliationService],
})
export class TransferReconciliationModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-reconciliation/transfer-reconciliation.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountService } from 'src/models/account/account.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferReconciliationService } from './transfer-reconciliation.service';

describe('TransferConciliationService', () => {
  let service: TransferReconciliationService;
  const mockTransferRepo = {};
  const mockAccountStatementRepo = {};
  const mockAccountStatementJobService = {};
  const mockAccountService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferReconciliationService,
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferRepo,
        },
        {
          provide: getRepositoryToken(AccountStatementEntity),
          useValue: mockAccountStatementRepo,
        },
        {
          provide: AccountStatementJobService,
          useValue: mockAccountStatementJobService,
        },
        {
          provide: AccountService,
          useValue: mockAccountService,
        },
      ],
    }).compile();

    service = module.get<TransferReconciliationService>(
      TransferReconciliationService,
    );
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/aws.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import awsConfig from 'src/config/aws.config';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { AwsSnsService } from './sns.service';

@Module({
  imports: [ConfigModule.forFeature(awsConfig)],
  providers: [AwsBatchService, AwsSnsService],
  exports: [AwsBatchService, AwsSnsService],
})
export class AwsModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/sns.service.ts
import { Inject, Injectable } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import {
  SNSClient,
  MessageAttributeValue,
  SNSClientConfig,
  PublishCommand,
  PublishCommandInput,
} from '@aws-sdk/client-sns';

import AwsConfig from 'src/config/aws.config';

export type MessageAttributes = Record<string, MessageAttributeValue>;
export type PublishMessageResult = {
  messageId: string | undefined;
};

@Injectable()
export class AwsSnsService {
  private client: SNSClient;

  constructor(
    @Inject(AwsConfig.KEY)
    private awsConfig: ConfigType<typeof AwsConfig>,
  ) {
    this.client = new SNSClient(this.config);
  }

  private get config(): SNSClientConfig {
    return {
      region: this.awsConfig.region,
      credentials: {
        accessKeyId: this.awsConfig.accessKeyId,
        secretAccessKey: this.awsConfig.secretAccessKey,
      },
    };
  }

  private buildAttributes(
    attributes: Record<string, string>,
  ): MessageAttributes {
    return Object.entries(attributes).reduce((acc, [key, value]) => {
      acc[key] = {
        DataType: 'String',
        StringValue: value,
      };
      return acc;
    }, {} as MessageAttributes);
  }

  private buildMessage(message: unknown): string {
    return JSON.stringify(message);
  }

  public async publishMessage(
    topicArn: string,
    payload: unknown,
    attributes: Record<string, string> = {},
  ): Promise<PublishMessageResult> {
    const message = this.buildMessage(payload);
    const messageAttributes = this.buildAttributes(attributes);

    const params: PublishCommandInput = {
      TopicArn: topicArn,
      Message: message,
      MessageAttributes: messageAttributes,
    };
    const commandOutput = await this.client.send(new PublishCommand(params));
    const result = { messageId: commandOutput.MessageId };
    return result;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/sns.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AwsSnsService } from './sns.service';
import AwsConfig from 'src/config/aws.config';

describe('given a AwsSnsService', () => {
  let service: AwsSnsService;

  beforeEach(async () => {
    const mockAwsSnsService = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AwsSnsService,
        {
          provide: AwsConfig.KEY,
          useValue: mockAwsSnsService,
        },
      ],
    }).compile();

    service = module.get<AwsSnsService>(AwsSnsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/batch.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import {
  Batch,
  JobSummary,
  BatchClientConfig,
  ListJobsRequest,
  JobStatus,
  SubmitJobCommandOutput,
  SubmitJobCommandInput,
  SubmitJobCommand,
} from '@aws-sdk/client-batch';
import AwsConfig from 'src/config/aws.config';
import { ConfigType } from '@nestjs/config';
import { SubmitBatchJobDto } from './dto/submit-batch-job.dto';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';

@Injectable()
export class AwsBatchService {
  private readonly logger = new Logger('AwsBatchClient');
  private client: Batch;

  constructor(
    @Inject(AwsConfig.KEY)
    private awsConfig: ConfigType<typeof AwsConfig>,
  ) {
    this.client = new Batch(this.config);
  }

  private get config(): BatchClientConfig {
    return {
      region: this.awsConfig.region,
      credentials: {
        accessKeyId: this.awsConfig.accessKeyId,
        secretAccessKey: this.awsConfig.secretAccessKey,
      },
    };
  }

  public async submitBatchJob({
    job,
    jobName,
    environmentVariables,
  }: SubmitBatchJobDto): Promise<SubmitJobCommandOutput> {
    const input: SubmitJobCommandInput = {
      ...this.awsConfig.jobs[job],
      jobName: `${Date.now()}-${jobName}`,
      containerOverrides: {
        environment: environmentVariables,
      },
    };

    const command = new SubmitJobCommand(input);

    try {
      return this.client.send(command);
    } catch (error) {
      this.logger.error(error);

      return { jobName: undefined, jobId: undefined, $metadata: undefined };
    }
  }

  public async getBatchJobQueue(
    job: AwsBatchJob,
    jobStatus: string[] = ['RUNNING'],
  ) {
    const queue: Array<JobSummary> = [];

    for (const jobState of jobStatus) {
      const params: ListJobsRequest = {
        jobQueue: this.awsConfig.jobs[job].jobQueue,
        jobStatus: jobState as JobStatus,
      };
      const results = await this.client.listJobs(params);

      queue.push(...results.jobSummaryList);
    }

    return queue;
  }

  public async findUnfinishedJobByName(
    jobName: string,
    jobQueue: AwsBatchJob,
  ): Promise<JobSummary> {
    const unFinishedState = [
      'SUBMITTED',
      'PENDING',
      'RUNNABLE',
      'STARTING',
      'RUNNING',
    ];
    const jobsQueue = await this.getBatchJobQueue(jobQueue, unFinishedState);

    return jobsQueue.find((job) => job.jobName.includes(jobName));
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/dto/submit-batch-job.dto.ts
import { KeyValuePair } from '@aws-sdk/client-batch';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';
export class SubmitBatchJobDto {
  job: AwsBatchJob;
  jobName: string;
  environmentVariables: KeyValuePair[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/aws/batch.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AwsBatchService } from './batch.service';
import AwsConfig from 'src/config/aws.config';

describe('given a AwsBatchService', () => {
  let service: AwsBatchService;

  beforeEach(async () => {
    const mockAwsService = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AwsBatchService,
        {
          provide: AwsConfig.KEY,
          useValue: mockAwsService,
        },
      ],
    }).compile();

    service = module.get<AwsBatchService>(AwsBatchService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-firebreak/transfer-firebreak.service.ts
import { Injectable } from '@nestjs/common';
import { State } from 'src/common/enums/state.enum';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { TransferFirebreakValidationDto } from './dto/transfer-firebreak-validation.dto';

@Injectable()
export class TransferFirebreakService {
  constructor(
    private transferService: TransferService,
    private providerService: ProviderService,
  ) {}

  async validate(
    transactionDto: TransactionDto,
  ): Promise<TransferFirebreakValidationDto> {
    const { providerId, id: transferId } = transactionDto;

    const provider = await this.providerService.findOne(providerId);

    if (!provider) {
      return {
        message: 'No se encontró el proveedor especificado',
        valid: false,
      };
    }

    const { account } = provider;

    if (provider.state !== State.ACTIVE) {
      return {
        message: `El proveedor ${provider.id} se encuentra inactivo`,
        valid: false,
      };
    }

    if (account.state !== State.ACTIVE) {
      return {
        message: `La cuenta ${account.id} se encuentra inactiva`,
        valid: false,
      };
    }

    const updatedTransfer = await this.transferService
      .findOneOrFail(transferId)
      .catch((_e) => null);

    if (!updatedTransfer) {
      return {
        message:
          'No se pudo obtener la información actualizada de la transferencia',
        valid: false,
      };
    }

    if (updatedTransfer.providerId !== providerId) {
      return {
        message: `El proveedor de la transferencia no coincide con el esperado. Esperado '${providerId}', Recibido: '${updatedTransfer.providerId}'`,
        valid: false,
      };
    }

    if (updatedTransfer.state !== transactionDto.state) {
      return {
        message: `El estado de la transferencia no coincide con el estado esperado. Esperado: '${transactionDto.state}', Recibido: '${updatedTransfer.state}'`,
        valid: false,
      };
    }
    if (updatedTransfer.currency !== account.currency) {
      return {
        message: `No se puede procesar la transferencia, moneda inválida. Esperado: '${account.currency}', Recibdo: '${transactionDto.currency}'`,
        valid: false,
      };
    }

    return {
      message: 'La transferencia se ha validado exitosamente!',
      valid: true,
    };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-firebreak/transfer-firebreak.module.ts
import { Module } from '@nestjs/common';
import { ProviderModule } from 'src/models/provider/provider.module';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { TransferFirebreakService } from './transfer-firebreak.service';

@Module({
  imports: [TransferModule, ProviderModule],
  providers: [TransferFirebreakService],
  exports: [TransferFirebreakService],
})
export class TransferFirebreakModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-firebreak/dto/transfer-firebreak-validation.dto.ts
export interface TransferFirebreakValidationDto {
  message?: string;
  valid: boolean;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-firebreak/transfer-firebreak.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransferFirebreakService } from './transfer-firebreak.service';

describe('TransferFirebreakService', () => {
  let service: TransferFirebreakService;
  const mockTransferService: Partial<TransferService> = {};
  const mockProviderService: Partial<ProviderService> = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferFirebreakService,
        {
          provide: ProviderService,
          useValue: mockProviderService,
        },
        { provide: TransferService, useValue: mockTransferService },
      ],
    }).compile();

    service = module.get<TransferFirebreakService>(TransferFirebreakService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/automated-payout-action/automated-payout-action.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { PayoutManagementService } from '../payout-management/payout-management.service';
import { PayoutActionsService } from 'src/models/payout-actions/payout-actions.service';
import { OnEvent } from '@nestjs/event-emitter';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferErrorCode } from '../../models/transfer-error/error.definition.type';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { PayoutAction } from 'src/common/enums/payout-action.enum';
import { PayoutActionSuggestion } from 'src/common/enums/payout-action-suggestion.enum';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';

@Injectable()
export class AutomatedPayoutActionService {
  private readonly logger = new Logger('AutomatedPayoutActionService');
  @Inject()
  private managementService: PayoutManagementService;
  @Inject()
  private payoutActionsService: PayoutActionsService;
  @Inject()
  private payoutNewService: PayoutNewService;
  @Inject()
  private featureFlagService: FeatureFlagService;

  @OnEvent(TransferEvent.FAILED)
  @OnEvent(TransferEvent.CANCELED)
  @OnEvent(TransferEvent.UPDATED_STATE) // TODO: To be deprecated when PYT-884 is implemented
  async applyAutomatedAction(transfer: TransferEntity): Promise<PayoutEntity> {
    const automatedValidStates = [TransferState.FAILED, TransferState.CANCELED];

    // TODO: Must remove this after delete the feature flag "CAN_APPLY_AUTOMATED_ACTION"
    const canApplyAutomatedAction =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_APPLY_AUTOMATED_ACTION,
      );
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );

    if (!canApplyAutomatedAction) return;
    if (!automatedValidStates.includes(transfer.state)) return;
    if (!transfer.errorCode) return;
    if (transfer.errorCode === TransferErrorCode.UNKNOWN_ERROR) return;

    const automatedAction =
      await this.payoutActionsService.getAutomatedPayoutAction(
        transfer.errorCode,
      );

    if (!automatedAction) {
      this.logger.debug('No automated action found for this error code');
      return;
    }

    const { action, suggestion } = automatedAction;

    if (transfer.state === TransferState.FAILED) {
      const metadata = {
        action: PayoutAction.AUTO_CANCEL,
      };
      if (action === PayoutAction.AUTO_CANCEL && !canUseNewPayoutCreation) {
        return this.managementService.cancelPayout(transfer.payoutId, metadata);
      }
      if (action === PayoutAction.AUTO_CANCEL && canUseNewPayoutCreation) {
        this.logger.log('Cancelling transfer due AUTO_CANCEL');
        return this.managementService.cancelPayoutAndTransfer(
          transfer.payoutId,
          transfer.id,
          { metadata },
        );
      }

      if (action === PayoutAction.AUTO_RETRY) {
        const [retriedPayout] = await this.managementService.autoRetryPayout(
          transfer.payoutId,
        );

        return retriedPayout;
      }

      if (suggestion === PayoutActionSuggestion.AUTO_RETRY) {
        const metadata = { action: PayoutActionSuggestion.AUTO_RETRY };
        return this.payoutNewService.updatePayoutMetadata(
          transfer.payoutId,
          metadata,
        );
      }
    }

    if (transfer.state === TransferState.CANCELED) {
      const metadata = { action: null };
      return this.payoutNewService.updatePayoutMetadata(
        transfer.payoutId,
        metadata,
      );
    }

    this.logger.debug(
      `Unhandled action: ${action} for transfer ${transfer.id}`,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/automated-payout-action/automated-payout-action.module.ts
import { Module } from '@nestjs/common';
import { AutomatedPayoutActionService } from './automated-payout-action.service';
import { PayoutManagementModule } from '../payout-management/payout-management.module';
import { PayoutActionsModule } from 'src/models/payout-actions/payout-actions.module';
import { FeatureFlagModule } from '../feature-flag/feature-flag.module';
import { PayoutNewModule } from 'src/models/payout/payout.new.module';

@Module({
  imports: [
    PayoutManagementModule,
    PayoutActionsModule,
    PayoutNewModule,
    FeatureFlagModule,
  ],
  providers: [AutomatedPayoutActionService],
  exports: [AutomatedPayoutActionService],
})
export class AutomatedPayoutActionModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/automated-payout-action/automated-payout-action.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AutomatedPayoutActionService } from './automated-payout-action.service';
import { PayoutManagementService } from '../payout-management/payout-management.service';
import { PayoutActionsService } from 'src/models/payout-actions/payout-actions.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { PayoutNewService } from 'src/models/payout/payout.new.service';

describe('AutomatedPayoutActionService', () => {
  let service: AutomatedPayoutActionService;
  let mockFeatureFlagService: Partial<FeatureFlagService> = {};
  let mockPayoutActionsService: Partial<PayoutActionsService> = {};
  let mockManagementService: Partial<PayoutManagementService> = {};
  let mockPayoutNewService: Partial<PayoutNewService> = {};

  beforeEach(async () => {
    mockPayoutNewService = {
      updatePayoutMetadata: jest.fn(),
    };
    mockManagementService = {
      cancelPayout: jest.fn(),
      autoRetryPayout: jest.fn(),
    };
    mockPayoutActionsService = {
      getAutomatedPayoutAction: jest.fn(),
    };

    mockFeatureFlagService = {
      getFeatureStatus: jest.fn().mockResolvedValue(false),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AutomatedPayoutActionService,
        { provide: PayoutNewService, useValue: mockPayoutNewService },
        { provide: PayoutManagementService, useValue: mockManagementService },
        { provide: PayoutActionsService, useValue: mockPayoutActionsService },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    service = module.get<AutomatedPayoutActionService>(
      AutomatedPayoutActionService,
    );
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  // TODO: Must remove this after delete the feature flag "CAN_APPLY_AUTOMATED_ACTION"
  describe('when applyAutomatedAction is called', () => {
    it('should check the feature flag and not perform any action if the flag is off', async () => {
      expect(
        await service.applyAutomatedAction({} as TransferEntity),
      ).toBeUndefined();

      expect(mockFeatureFlagService.getFeatureStatus).toHaveBeenCalledWith(
        FEATURE_FLAG.CAN_APPLY_AUTOMATED_ACTION,
      );

      expect(
        mockPayoutActionsService.getAutomatedPayoutAction,
      ).not.toHaveBeenCalled();
      expect(mockManagementService.cancelPayout).not.toHaveBeenCalled();
      expect(mockManagementService.autoRetryPayout).not.toHaveBeenCalled();
      expect(mockPayoutNewService.updatePayoutMetadata).not.toHaveBeenCalled();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/slack/slack.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import slackConfig from 'src/config/slack.config';
import { SlackService } from './slack.service';

@Module({
  imports: [ConfigModule.forFeature(slackConfig)],
  providers: [SlackService],
  exports: [SlackService],
})
export class SlackModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/slack/slack.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import slackConfig from 'src/config/slack.config';
import { SlackService } from './slack.service';

describe('given a SlackService', () => {
  let service: SlackService;

  beforeEach(async () => {
    const mockSlackConfig = {
      webhookUrl: '',
    };
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SlackService,
        {
          provide: slackConfig.KEY,
          useValue: mockSlackConfig,
        },
      ],
    }).compile();

    service = module.get<SlackService>(SlackService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/slack/slack.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import {
  ChatMeMessageResponse,
  KnownBlock,
  MessageAttachment,
} from '@slack/web-api';
import { IncomingWebhook, IncomingWebhookResult } from '@slack/webhook';
import slackConfig, { SlackChannelName } from 'src/config/slack.config';

type PostMessageResponse = {
  success: boolean;
  response: IncomingWebhookResult | ChatMeMessageResponse;
};

export type SlackMessage = {
  channelName: SlackChannelName;
  text: string;
  blocks?: KnownBlock[];
  attachments?: MessageAttachment[];
};
@Injectable()
export class SlackService {
  private readonly logger = new Logger('SlackService');
  constructor(
    @Inject(slackConfig.KEY) private config: ConfigType<typeof slackConfig>,
  ) {}

  async postMessage(message: SlackMessage): Promise<PostMessageResponse> {
    const { channelName, text, blocks, attachments } = message;
    const webhookUrl = this.config.channels[channelName].webhookUrl;
    try {
      const webhookClient = new IncomingWebhook(webhookUrl);
      const response = await webhookClient.send({ text, blocks, attachments });

      return { success: true, response };
    } catch (error) {
      this.logger.error(
        `Error on post slack message to '${webhookUrl}', message: ${error.message}`,
      );

      return { success: false, response: null };
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/excel/excel.module.ts
import { Module } from '@nestjs/common';
import { ExcelService } from './excel.service';

@Module({
  providers: [ExcelService],
  exports: [ExcelService],
})
export class ExcelModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/excel/excel.service.ts
import { BadRequestException, Injectable } from '@nestjs/common';
import * as XLSX from 'xlsx';

// TODO: Must implement generic type for sheet
export interface ExcelSheet {
  name: string;
  data: any[];
  headers: Record<string, string>;
}

@Injectable()
export class ExcelService {
  createXlsx(sheets: ExcelSheet[]): Buffer {
    if (sheets.length === 0) {
      throw new BadRequestException('No sheets provided');
    }

    const workbook = XLSX.utils.book_new();

    for (const sheet of sheets) {
      const worksheet = this.generateSheet(sheet.data, sheet.headers);

      XLSX.utils.book_append_sheet(workbook, worksheet, sheet.name);
    }

    const buffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'buffer' });

    return buffer;
  }

  private generateSheet(
    data: any[],
    columnNames: Record<string, string>,
  ): XLSX.WorkSheet {
    const worksheet = XLSX.utils.json_to_sheet([]);

    const headers = Object.values(columnNames);

    XLSX.utils.sheet_add_aoa(worksheet, [headers], { origin: 'A1' });

    const values = data.map((row) =>
      Object.keys(columnNames).map((key) => {
        const value = key.split('.').reduce((obj, key) => obj?.[key], row);

        return value;
      }),
    );

    XLSX.utils.sheet_add_aoa(worksheet, values, { origin: 'A2' });

    return worksheet;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/excel/excel.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ExcelService } from './excel.service';
import * as XLSX from 'xlsx';

describe('ExcelService', () => {
  let service: ExcelService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ExcelService],
    }).compile();

    service = module.get<ExcelService>(ExcelService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should generate an Excel file with one sheet', () => {
    const sheets = [
      {
        name: 'Sheet1',
        data: [
          { name: 'John Doe', age: 30 },
          { name: 'Jane Doe', age: 25 },
          { name: 'Bob Smith', age: 40 },
        ],
        headers: {
          name: 'Nombre',
          age: 'Edad',
        },
      },
    ];

    const excelBuffer = service.createXlsx(sheets);

    const workbook = XLSX.read(excelBuffer, { type: 'buffer' });
    expect(workbook.SheetNames).toEqual(['Sheet1']);
    const sheet1 = workbook.Sheets['Sheet1'];
    expect(sheet1['A1'].v).toEqual('Nombre');
    expect(sheet1['B1'].v).toEqual('Edad');
    expect(sheet1['A2'].v).toEqual('John Doe');
    expect(sheet1['B2'].v).toEqual(30);
    expect(sheet1['A3'].v).toEqual('Jane Doe');
    expect(sheet1['B3'].v).toEqual(25);
    expect(sheet1['A4'].v).toEqual('Bob Smith');
    expect(sheet1['B4'].v).toEqual(40);
  });

  it('should generate an Excel file with multiple sheets', () => {
    const sheets = [
      {
        name: 'Pagos',
        data: [
          { amount: 100, destinationName: 'Jon Doe' },
          { amount: 150, destinationName: 'Bob Smith' },
          { amount: 200, destinationName: 'Mart Doe' },
        ],
        headers: {
          amount: 'Monto',
          destinationName: 'Nombre',
        },
      },
      {
        name: 'Transferencias',
        data: [
          {
            destinationBankCode: 'cl_banco_santander',
            createdAt: '2020-01-01T00:00:00.000Z',
          },
          {
            destinationBankCode: 'cl_banco_itau_chile',
            createdAt: '2020-01-22T00:00:00.000Z',
          },
          {
            destinationBankCode: 'cl_banco_fallabella',
            createdAt: '2020-02-01T00:00:00.000Z',
          },
        ],
        headers: {
          destinationBankCode: 'Banco Destino',
          createdAt: 'Fecha Creación',
        },
      },
    ];

    const excelBuffer = service.createXlsx(sheets);

    const workbook = XLSX.read(excelBuffer, { type: 'buffer' });

    expect(workbook.SheetNames).toEqual(['Pagos', 'Transferencias']);

    const sheet1 = workbook.Sheets['Pagos'];
    expect(sheet1['A1'].v).toEqual('Monto');
    expect(sheet1['B1'].v).toEqual('Nombre');
    expect(sheet1['A2'].v).toEqual(100);
    expect(sheet1['B2'].v).toEqual('Jon Doe');
    expect(sheet1['A3'].v).toEqual(150);
    expect(sheet1['B3'].v).toEqual('Bob Smith');
    expect(sheet1['A4'].v).toEqual(200);
    expect(sheet1['B4'].v).toEqual('Mart Doe');

    const sheet2 = workbook.Sheets['Transferencias'];
    expect(sheet2['A1'].v).toEqual('Banco Destino');
    expect(sheet2['B1'].v).toEqual('Fecha Creación');
    expect(sheet2['A2'].v).toEqual('cl_banco_santander');
    expect(sheet2['B2'].v).toEqual('2020-01-01T00:00:00.000Z');
    expect(sheet2['A3'].v).toEqual('cl_banco_itau_chile');
    expect(sheet2['B3'].v).toEqual('2020-01-22T00:00:00.000Z');
    expect(sheet2['A4'].v).toEqual('cl_banco_fallabella');
    expect(sheet2['B4'].v).toEqual('2020-02-01T00:00:00.000Z');
  });

  it('should throw an error when no sheets are provided', () => {
    const sheets = [];
    expect(() => service.createXlsx(sheets)).toThrow('No sheets provided');
  });

  it('should allow to send nested object notation in header', () => {
    const sheets = [
      {
        name: 'Sheet1',
        data: [
          {
            name: 'John Doe',
            age: {
              value: 30,
            },
          },
        ],
        headers: {
          name: 'Nombre',
          'age.value': 'Edad',
        },
      },
    ];

    const excelBuffer = service.createXlsx(sheets);

    const workbook = XLSX.read(excelBuffer, { type: 'buffer' });
    const sheet1 = workbook.Sheets['Sheet1'];
    expect(sheet1['A1'].v).toEqual('Nombre');
    expect(sheet1['B1'].v).toEqual('Edad');
    expect(sheet1['A2'].v).toEqual('John Doe');
    expect(sheet1['B2'].v).toEqual(30);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/payout-management/payout-management.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import generalConfig from 'src/config/general.config';
import { PayoutModule } from 'src/models/payout/payout.module';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { TransferAssignmentModule } from '../transfer-assignment/transfer-assignment.module';
import { TransferProviderModule } from '../transfer-provider/transfer-provider.module';
import { PayoutManagementService } from './payout-management.service';
import { FeatureFlagModule } from '../feature-flag/feature-flag.module';
import { PayoutNewModule } from 'src/models/payout/payout.new.module';
import { ProviderModule } from 'src/models/provider/provider.module';

@Module({
  imports: [
    ConfigModule.forFeature(generalConfig),
    PayoutModule,
    PayoutNewModule,
    TransferModule,
    ProviderModule,
    TransferAssignmentModule,
    TransferProviderModule,
    FeatureFlagModule,
  ],
  providers: [PayoutManagementService],
  exports: [PayoutManagementService],
})
export class PayoutManagementModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/payout-management/payout-management.service.ts
import {
  Inject,
  Injectable,
  Logger,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { plainToClass } from 'class-transformer';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import generalConfig from 'src/config/general.config';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutService } from 'src/models/payout/payout.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransactionDto } from 'src/providers/common/dtos/transaction.dto';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { CancelPayoutDto } from 'src/api/v2/management/dto/cancel-payout.dto';
import { ProviderService } from 'src/models/provider/provider.service';

export enum PayoutManagementOperation {
  COMPLETE = 'complete',
  CANCEL = 'cancel',
  REASSIGN = 'reassign',
}

@Injectable()
export class PayoutManagementService {
  private readonly logger = new Logger('PayoutManagementService');

  constructor(
    private payoutService: PayoutService, // MIGRAR LOS MÉTODOS USADOS AL NEW PAYOUT SERVICE
    private payoutNewService: PayoutNewService,
    private transferService: TransferService, // QUITAR DE ACÁ! NO USAR! WARNING DANGER DANGER
    private providerService: ProviderService,
    private featureFlagService: FeatureFlagService,
    @Inject(generalConfig.KEY)
    private config: ConfigType<typeof generalConfig>,
  ) {}

  get autoRetryLimit(): number {
    return this.config.payouts.autoRetryLimit;
  }

  private async canAutoRetryPayout(payoutId: number): Promise<boolean> {
    const payout = await this.payoutNewService.findOneOrFail(payoutId);

    const totalRetries = payout.transfers.reduce((counter, transfer) => {
      if (transfer?.autoRetried) {
        return counter + 1;
      }
      return counter;
    }, 0);

    return totalRetries < this.autoRetryLimit;
  }

  async autoRetryPayout(
    payoutId: number,
  ): Promise<[PayoutEntity?, TransferEntity?]> {
    const canAutoRetryPayout = await this.canAutoRetryPayout(payoutId);

    if (!canAutoRetryPayout) {
      Logger.log(
        `Auto retry limit exceed. Payout with id ${payoutId} cannot be auto-retried`,
      );
      return [];
    }

    const [, createdTransfer] = await this.reassignPayout(payoutId);

    await this.payoutNewService.updateAutoRetried(createdTransfer.id, true);

    const retriedPayout = await this.payoutNewService.findOneOrFail(payoutId);

    return [retriedPayout, createdTransfer];
  }

  async newReassignPayout(
    payoutId: number,
    providerId?: number,
  ): Promise<[PayoutEntity, TransferEntity]> {
    this.logger.log('Reassign Payout from new method');
    try {
      return await this.payoutNewService.reassignPayout(payoutId, providerId);
    } catch (error) {
      // TODO: AGARRAR EL ERROR QUE ENCONTRO Y MAPEARLO AL QUE DEVOLVEREMOS AL CONTROLLER
      // SEND ALERT ???
      throw new UnprocessableEntityException('hola');
    }
  }

  /**
   * @deprecated
   * @param payoutId
   * @param providerId
   * @returns
   */
  async reassignPayout(
    payoutId: number,
    providerId?: number,
  ): Promise<[PayoutEntity, TransferEntity]> {
    this.logger.log('Reassign Payout from old method');

    const payout = await this.payoutNewService.findOneOrFail(payoutId);

    if (!payout) {
      throw new NotFoundException(`Payout not found`);
    }

    if (payout.finished) {
      throw new UnprocessableEntityException(
        `Cannot reassign a payout with a finished state`,
      );
    }

    if (payout.version !== EntityVersion.v2) {
      throw new UnprocessableEntityException(
        `Cannot reassign a payout with a version different from v2`,
      );
    }
    if (
      payout.metadata?.message === 'Account Funding Payout' ||
      payout.concept.startsWith('Payout Funding')
    ) {
      throw new UnprocessableEntityException(
        `Cannot reassign a account funding payout`,
      );
    }

    const lastTransfer = await this.payoutNewService.findLastTransfer(payoutId);

    if (!lastTransfer) {
      throw new UnprocessableEntityException(
        `Payout with id ${payoutId} does not have any transfers`,
      );
    }

    if (lastTransfer.providerId) {
      const provider = this.providerService.getProviderAdapter(
        lastTransfer?.provider?.providerType,
      );

      const transactionDto = plainToClass(TransactionDto, lastTransfer);
      const ability = provider.canRetryTransaction(transactionDto);
      const { capable, error } = ability;

      if (!capable) {
        throw new UnprocessableEntityException(error);
      }
    }

    if (lastTransfer.cancelable) {
      await this.transferService.updateState(
        lastTransfer.id,
        TransferState.CANCELED,
      );
    }

    const createdTransfer = await this.payoutService.createTransfer(
      payout,
      providerId,
    );

    const updatedPayout = await this.payoutNewService.findOneOrFail(payoutId);

    return [updatedPayout, createdTransfer];
  }

  /**
   *  New complete payout and its transfer
   * @param payoutId
   * @param transferId
   * @param metadata
   * @returns
   */
  async completePayoutAndTransfer(
    payoutId: number,
    transferId: number,
    metadata?: CancelPayoutDto,
  ): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    try {
      return this.payoutNewService.completePayoutAndTransfer(
        payoutId,
        transferId,
        metadata,
      );
    } catch (error) {
      this.logger.error(error.message);
      throw new UnprocessableEntityException(error.message);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready, use completePayoutAndTransfer
   */
  async completePayout(payoutId: number) {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation) return;
    const payout = await this.payoutNewService.findOneOrFail(payoutId);

    if (!payout) {
      throw new NotFoundException(`Payout not found`);
    }

    if (payout.finished) {
      throw new UnprocessableEntityException(
        `Cannot complete a payout with a finished state`,
      );
    }

    if (payout.version !== EntityVersion.v2) {
      throw new UnprocessableEntityException(
        `Cannot complete a payout with a version different from v2`,
      );
    }

    const lastTransfer = await this.payoutNewService.findLastTransfer(payoutId);

    if (!lastTransfer) {
      throw new UnprocessableEntityException(
        `Payout with id ${payoutId} does not have any transfers`,
      );
    }

    const provider = this.providerService.getProviderAdapter(
      lastTransfer?.provider?.providerType,
    );

    const transactionDto = plainToClass(TransactionDto, lastTransfer);
    const ability = provider.canCompleteTransaction(transactionDto);
    const { capable, error } = ability;

    if (!capable) {
      throw new UnprocessableEntityException(error);
    }

    if (lastTransfer.completable) {
      await this.transferService.updateState(
        lastTransfer.id,
        TransferState.COMPLETED,
      );
    }

    const updatedPayout = await this.payoutService.updateState(
      payoutId,
      PayoutState.COMPLETED,
    );

    return updatedPayout;
  }

  async cancelPayoutAndTransfer(
    payoutId: number,
    transferId: number,
    cancelPayoutDto: CancelPayoutDto = {},
  ): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    try {
      this.logger.log('Canceling payout from new method');

      await this.payoutNewService.cancelPayoutAndTransfer(
        payoutId,
        +transferId,
        cancelPayoutDto,
      );
    } catch (error) {
      this.logger.error(error.message);
      throw new UnprocessableEntityException(error.message);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready, use cancelPayoutAndTransfer
   */
  async cancelPayout(payoutId: number, metadata?: Record<string, string>) {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation) return;

    this.logger.log('Canceling payout from old method');
    const payout = await this.payoutNewService.findOneOrFail(payoutId);

    if (!payout) {
      throw new NotFoundException(`Payout not found`);
    }

    if (payout.finished) {
      throw new UnprocessableEntityException(
        `Cannot cancel a payout with a finished state`,
      );
    }

    if (payout.version !== EntityVersion.v2) {
      throw new UnprocessableEntityException(
        `Cannot cancel a payout with a version different from v2`,
      );
    }

    const lastTransfer = await this.payoutNewService.findLastTransfer(payoutId);

    if (!lastTransfer) {
      throw new UnprocessableEntityException(
        `Payout with id ${payoutId} does not have any transfers`,
      );
    }

    if (lastTransfer?.provider) {
      const provider = this.providerService.getProviderAdapter(
        lastTransfer.provider?.providerType,
      );

      const transactionDto = plainToClass(TransactionDto, lastTransfer);

      const ability = provider.canCancelTransaction(transactionDto);
      const { capable, error } = ability;

      if (!capable) {
        throw new UnprocessableEntityException(error);
      }
    }

    if (lastTransfer.cancelable) {
      await this.transferService.updateState(
        lastTransfer.id,
        TransferState.CANCELED,
      );
    }

    const updatedPayout = await this.payoutService.updateState(
      payoutId,
      PayoutState.CANCELED,
      metadata,
    );

    return updatedPayout;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/payout-management/payout-management.service.spec.ts
import { ConfigType } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import generalConfig from 'src/config/general.config';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutService } from 'src/models/payout/payout.service';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransferAssignmentService } from '../transfer-assignment/transfer-assignment.service';
import { TransferProviderService } from '../transfer-provider/transfer-provider.service';
import { PayoutManagementService } from './payout-management.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { ProviderService } from 'src/models/provider/provider.service';

describe('PayoutManagementService', () => {
  const AUTO_RETRY_LIMIT = 3;
  let service: PayoutManagementService;

  const mockPayoutNewService = {
    findOneOrFail: jest.fn(),
    updateAutoRetried: jest.fn(),
  };
  const mockPayoutService = {};
  const mockProviderService = {};
  const mockTransferService = {};
  const mockTransferAssignmentService: Partial<TransferAssignmentService> = {};
  const mockTransferProviderService: Partial<TransferProviderService> = {};
  const mockFeatureFlagService = {};

  let mockGeneralConfig: Partial<ConfigType<typeof generalConfig>> = {};

  beforeEach(async () => {
    mockGeneralConfig = { payouts: { autoRetryLimit: AUTO_RETRY_LIMIT } };
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PayoutManagementService,
        { provide: PayoutService, useValue: mockPayoutService },
        { provide: PayoutNewService, useValue: mockPayoutNewService },
        { provide: TransferService, useValue: mockTransferService },
        {
          provide: TransferAssignmentService,
          useValue: mockTransferAssignmentService,
        },
        {
          provide: TransferProviderService,
          useValue: mockTransferProviderService,
        },
        {
          provide: ProviderService,
          useValue: mockProviderService,
        },
        {
          provide: generalConfig.KEY,
          useValue: mockGeneralConfig,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
      ],
    }).compile();

    service = module.get<PayoutManagementService>(PayoutManagementService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('when some code calls autoRetryPayout', () => {
    describe(`and auto retry is attempted and the autoRetryLimit is set to ${AUTO_RETRY_LIMIT}`, () => {
      it('then should retry the payout if the max auto retries are not meet by the payout', async () => {
        const payout: Partial<PayoutEntity> = {
          id: 1,
          state: PayoutState.PROCESSING,
          amount: 100,
          transfers: [
            {
              id: 1,
              state: TransferState.PROCESSING,
              autoRetried: false,
            },
          ] as TransferEntity[],
        };

        mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

        const mockReassign = jest.spyOn(
          PayoutManagementService.prototype,
          'reassignPayout',
        );

        const retriedTransfer = { id: 2, autoRetried: true } as TransferEntity;

        mockReassign.mockImplementation(
          async (_payoutId: number) =>
            [payout, retriedTransfer] as [PayoutEntity, TransferEntity],
        );

        await service.autoRetryPayout(payout.id);

        expect(mockReassign).toHaveBeenCalled();
      });

      it('then should not retry the payout if the max auto retries are meet by the payout', async () => {
        const payout: Partial<PayoutEntity> = {
          id: 1,
          state: PayoutState.PROCESSING,
          amount: 100,
          transfers: [
            {
              id: 1,
              state: TransferState.PROCESSING,
              autoRetried: true,
            },
            {
              id: 1,
              state: TransferState.PROCESSING,
              autoRetried: true,
            },
            {
              id: 1,
              state: TransferState.PROCESSING,
              autoRetried: true,
            },
          ] as TransferEntity[],
        };

        mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

        const mockReassign = jest.spyOn(
          PayoutManagementService.prototype,
          'reassignPayout',
        );

        const retriedTransfer = { id: 2, autoRetried: true } as TransferEntity;

        mockReassign.mockImplementation(
          async (_payoutId: number) =>
            [payout, retriedTransfer] as [PayoutEntity, TransferEntity],
        );

        await service.autoRetryPayout(payout.id);

        expect(mockReassign).not.toHaveBeenCalled();
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/sentry/sentry.service.ts
import * as Sentry from '@sentry/node';
import { Injectable } from '@nestjs/common';
import { rewriteFramesIntegration } from '@sentry/integrations';
import { ProfilingIntegration } from '@sentry/profiling-node';
import { CaptureContext } from '@sentry/types';

// Sentry config
global.__rootdir__ = __dirname || process.cwd();

// This allows TypeScript to detect our global value
declare global {
  // eslint-disable-next-line no-var
  var __rootdir__: string;
}

type Primitive = number | string | boolean | bigint | symbol;
export type SentryTags = Record<string, Primitive>;

@Injectable()
export class SentryService {
  static init(options: Sentry.NodeOptions) {
    Sentry.init({
      ...options,
      integrations: [rewriteFramesIntegration(), new ProfilingIntegration()],
    });
  }

  async captureEvent(
    event: Sentry.Event,
    level: Sentry.SeverityLevel = 'error',
    tags?: SentryTags,
  ) {
    await this.configureScope(level, tags);
    Sentry.captureEvent(event);
  }

  async captureException(
    exception: unknown,
    captureContext?: CaptureContext,
    tags?: SentryTags,
    level: Sentry.SeverityLevel = 'error',
  ) {
    await this.configureScope(level, tags);
    Sentry.captureException(exception, captureContext);
  }

  private async configureScope(level: Sentry.SeverityLevel, tags?: SentryTags) {
    return new Promise<void>((resolve) => {
      Sentry.configureScope((scope) => {
        scope.setLevel(level);

        scope.setTags(tags ?? {});

        resolve();
      });
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/sentry/sentry.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { SentryService } from './sentry.service';

describe('SentryService', () => {
  let service: SentryService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SentryService],
    }).compile();

    service = module.get<SentryService>(SentryService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/sentry/sentry.module.ts
import { Module } from '@nestjs/common';
import { SentryService } from './sentry.service';

@Module({
  providers: [SentryService],
  exports: [SentryService],
})
export class SentryModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/merchant-limit-evaluator/merchant-limit-evaluator.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import * as moment from 'moment';
import { Repository } from 'typeorm';

import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { MerchantLimitDefinition } from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { MerchantLimitService } from 'src/models/merchant-limit/merchant-limit.service';
import { State } from 'src/common/enums/state.enum';

@Injectable()
export class MerchantLimitEvaluatorService {
  logger = new Logger('MerchantLimitEvaluatorService');

  constructor(
    private readonly merchantLimitService: MerchantLimitService,
    @InjectRepository(PayoutEntity)
    private readonly payoutRepository: Repository<PayoutEntity>,
  ) {}

  async evaluate(payout: PayoutEntity): Promise<{
    exceeds: boolean;
    errorMessage?: string;
  }> {
    const merchantLimits = await this.merchantLimitService.findAll({
      where: { merchantId: payout.merchantId, state: State.ACTIVE },
    });

    for (const { limitDefinition: definition, id } of merchantLimits) {
      const isLimitExceeded = await this.isLimitExceeded(definition, payout);
      if (isLimitExceeded) {
        return {
          exceeds: true,
          errorMessage: this.generateErrorMessage(definition.criteria, id),
        };
      }
    }

    return { exceeds: false };
  }

  private async isLimitExceeded(
    definition: MerchantLimitDefinition,
    payout: PayoutEntity,
  ): Promise<boolean> {
    try {
      const { currency, criteria, value } = definition;

      if (currency && currency !== payout.currency) return false;

      const stats = await this.getMerchantStats(payout, definition);

      return criteria === LimitCriteria.AMOUNT
        ? Number(payout.amount) + Number(stats.totalAmount) > value
        : Number(stats.payoutCount) + 1 > value; // LimitCriteria.COUNT
    } catch (error) {
      this.logger.error(error);
      return true;
    }
  }

  private async getMerchantStats(
    payout: PayoutEntity,
    limitDefinition: MerchantLimitDefinition,
  ): Promise<{ totalAmount: string; payoutCount: string }> {
    const { merchantId, destinationHolderId, id } = payout;
    const { aggregation, scope, currency } = limitDefinition;
    const { from, to } = this.buildDateRange(aggregation);

    const payoutsQuery = this.payoutRepository
      .createQueryBuilder('payout')
      .select('SUM(amount)', 'totalAmount')
      .addSelect('COUNT(*)', 'payoutCount')
      .where('merchantId = :merchantId', { merchantId })
      .andWhere('state = :state', { state: PayoutState.COMPLETED })
      .andWhere('createdAt BETWEEN :from AND :to', { from, to })
      .andWhere('id != :currentPayoutId', { currentPayoutId: id });

    if (scope === LimitScope.PERSON) {
      payoutsQuery.andWhere('destinationHolderId = :destinationHolderId', {
        destinationHolderId,
      });
    }

    if (currency) payoutsQuery.andWhere('currency = :currency', { currency });

    return payoutsQuery.getRawOne();
  }

  private buildDateRange(aggregation: LimitAggregation): {
    from: string;
    to: string;
  } {
    const now = this.getUtcDate();
    const to = moment(now).toISOString();

    const from = moment(now).startOf(aggregation).toISOString();
    return { from, to };
  }

  private getUtcDate(): moment.Moment {
    return moment().utc();
  }

  private generateErrorMessage(limitCriteria: LimitCriteria, id: number) {
    let criteria = '';
    if (limitCriteria === LimitCriteria.AMOUNT) criteria = 'monto';
    if (limitCriteria === LimitCriteria.COUNT) criteria = 'cantidad';
    return `La transferencia excede el límite por criterio "${criteria}". Límite ${id} excedido`;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/merchant-limit-evaluator/merchant-limit-evaluator.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';

import { MerchantLimitEvaluatorService } from './merchant-limit-evaluator.service';
import { Currency } from 'src/common/enums/currency.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { MerchantLimitService } from 'src/models/merchant-limit/merchant-limit.service';

const merchantLimitServiceMock = {
  findAll: jest.fn(),
};

describe('given a MerchantLimitEvaluatorService', () => {
  let service: MerchantLimitEvaluatorService;
  let getMerchantStats: jest.SpyInstance;

  const payoutRepositoryMock = {
    createQueryBuilder: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      addSelect: jest.fn().mockReturnThis(),
      where: jest.fn().mockReturnThis(),
      andWhere: jest.fn().mockReturnThis(),
      getRawOne: jest.fn(),
    })),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MerchantLimitEvaluatorService,
        {
          provide: getRepositoryToken(PayoutEntity),
          useValue: payoutRepositoryMock,
        },
        {
          provide: MerchantLimitService,
          useValue: merchantLimitServiceMock,
        },
      ],
    }).compile();

    service = module.get<MerchantLimitEvaluatorService>(
      MerchantLimitEvaluatorService,
    );

    getMerchantStats = jest.spyOn(
      service as unknown as {
        getMerchantStats: MerchantLimitEvaluatorService['getMerchantStats'];
      },
      'getMerchantStats',
    );
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('Single limit with a specific currency and amount criteria', () => {
    it('should return exceeds=true if the single limit is exceeded for amount criteria', async () => {
      const value = 2000; // Specific limit value

      const mockLimit = {
        limitDefinition: {
          currency: Currency.CHILE,
          criteria: LimitCriteria.AMOUNT,
          value,
        },
        id: 1,
      };

      const mockPayout = {
        merchantId: 123,
        currency: Currency.CHILE,
        amount: 1201, // Exceeds the amount criteria of the limit
      };

      merchantLimitServiceMock.findAll.mockResolvedValue([mockLimit]);
      getMerchantStats.mockReturnValue({
        totalAmount: 800, // Total amount for the merchant
        payoutCount: 2, // Total payout count for the merchant
      });

      const result = await service.evaluate(mockPayout as PayoutEntity);

      expect(result.exceeds).toBeTruthy();
      expect(result.errorMessage).toBeDefined();
    });
    it('should return exceeds=true if the single limit is exceeded for count criteria', async () => {
      const value = 1; // Specific limit value

      const mockLimit = {
        limitDefinition: {
          criteria: LimitCriteria.COUNT,
          value,
        },
        id: 1,
      };

      const mockPayout = {
        merchantId: 123,
        currency: Currency.CHILE,
        amount: 1201, // Exceeds the amount criteria of the limit
      };

      merchantLimitServiceMock.findAll.mockResolvedValue([mockLimit]);
      getMerchantStats.mockReturnValue({
        totalAmount: 800, // Total amount for the merchant
        payoutCount: 1, // Total payout count for the merchant
      });

      const result = await service.evaluate(mockPayout as PayoutEntity);

      expect(result.exceeds).toBeTruthy();
      expect(result.errorMessage).toBeDefined();
    });
    it('should return exceeds=false if the single limit is not exceeded', async () => {
      const value = 2000;

      const mockLimit = {
        limitDefinition: {
          currency: Currency.CHILE,
          criteria: LimitCriteria.AMOUNT,
          value, // Specific limit value
        },
        id: 1,
      };

      const mockPayout = {
        merchantId: 123,
        currency: Currency.CHILE,
        amount: 1200, // Exceeds the amount criteria of the limit
      };

      merchantLimitServiceMock.findAll.mockResolvedValue([mockLimit]);
      getMerchantStats.mockReturnValue({
        totalAmount: 800, // Total amount for the merchant
        payoutCount: 2, // Total payout count for the merchant
      });

      const result = await service.evaluate(mockPayout as PayoutEntity);

      expect(result).toEqual({
        exceeds: false,
      });
    });
  });

  describe('Multiple limits with different criteria (amount, count) and currencies.', () => {
    it('should return exceeds=true if any limit is exceeded', async () => {
      const limitExceeded = {
        limitDefinition: {
          currency: Currency.CHILE,
          criteria: LimitCriteria.AMOUNT,
          value: 1000, // Specific limit value
        },
        id: 1,
      };

      const mockLimits = [
        limitExceeded,
        {
          limitDefinition: {
            currency: Currency.CHILE,
            criteria: LimitCriteria.COUNT,
            value: 5,
          },
          id: 2,
        },
      ];

      const mockPayout = {
        merchantId: 123,
        currency: Currency.CHILE,
        amount: 1200,
      };

      merchantLimitServiceMock.findAll.mockResolvedValue(mockLimits);
      getMerchantStats.mockReturnValue({
        totalAmount: 800,
        payoutCount: 2,
      });

      const result = await service.evaluate(mockPayout as PayoutEntity);

      expect(result.exceeds).toBeTruthy();
      expect(result.errorMessage).toBeDefined();
    });
    it('should return exceeds=false if no limits are exceeded', async () => {
      const mockLimits = [
        {
          limitDefinition: {
            currency: Currency.CHILE,
            criteria: LimitCriteria.AMOUNT,
            value: 1000,
          },
          id: 1,
        },
        {
          limitDefinition: {
            criteria: LimitCriteria.COUNT,
            value: 5,
          },
          id: 2,
        },
      ];

      const mockPayout = {
        merchantId: 123,
        currency: Currency.CHILE,
        amount: 200,
      };

      merchantLimitServiceMock.findAll.mockResolvedValue(mockLimits);
      getMerchantStats.mockImplementation(() => ({
        totalAmount: 800,
        payoutCount: 2,
      }));

      const result = await service.evaluate(mockPayout as PayoutEntity);

      expect(result).toEqual({
        exceeds: false,
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/merchant-limit-evaluator/merchant-limit-evaluator.module.ts
import { Module } from '@nestjs/common';
import { MerchantLimitEvaluatorService } from './merchant-limit-evaluator.service';
import { MerchantLimitModule } from 'src/models/merchant-limit/merchant-limit.module';
import { PayoutModule } from 'src/models/payout/payout.module';

@Module({
  imports: [MerchantLimitModule, PayoutModule],
  providers: [MerchantLimitEvaluatorService],
  exports: [MerchantLimitEvaluatorService],
})
export class MerchantLimitEvaluatorModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/mocks/MockFeatureFlagService.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class MockFeatureFlagService {
  async getValueAsync(_featureFlagKey: string): Promise<boolean> {
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/mocks/MockMailService.ts
import { Injectable } from '@nestjs/common';
import { MailDataRequired } from '@sendgrid/mail';

@Injectable()
export class MockMailService {
  setApiKey(_apiKey: string): void {
    return;
  }

  async send(_data: MailDataRequired | MailDataRequired[]): Promise<void> {
    return;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment.new.module.ts
import { Module } from '@nestjs/common';

import { TransferAssignmentNewService } from './transfer-assignment.new.service';
import { AccountModule } from 'src/models/account/account.module';
import { ProviderModule } from 'src/models/provider/provider.module';

@Module({
  imports: [AccountModule, ProviderModule],
  providers: [TransferAssignmentNewService],
  exports: [TransferAssignmentNewService],
})
export class TransferAssignmentNewModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment.module.ts
import { Module } from '@nestjs/common';
import { PayoutNewModule } from 'src/models/payout/payout.new.module';
import { TransferModule } from 'src/models/transfer/transfer.module';
import { TransferAssignmentService } from './transfer-assignment.service';
import { MerchantLimitEvaluatorModule } from '../merchant-limit-evaluator/merchant-limit-evaluator.module';
import { FeatureFlagModule } from '../feature-flag/feature-flag.module';
import { TransferAssignmentNewModule } from './transfer-assignment.new.module';

@Module({
  imports: [
    PayoutNewModule,
    TransferModule,
    MerchantLimitEvaluatorModule,
    FeatureFlagModule,
    TransferAssignmentNewModule,
  ],
  providers: [TransferAssignmentService],
  exports: [TransferAssignmentService],
})

/**
 * @deprecated will be deprecated when EPIC PYT-797 is ready, use new transfer assingment module
 */
export class TransferAssignmentModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { MerchantLimitEvaluatorService } from '../merchant-limit-evaluator/merchant-limit-evaluator.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { TransferAssignmentNewService } from './transfer-assignment.new.service';

export interface CreatedTransferEventDto {
  transferId: number;
  providerId?: number;
}

/**
 * @deprecated will be deprecated when EPIC PYT-797 is ready, use new payout service
 */
@Injectable()
export class TransferAssignmentService {
  private readonly logger = new Logger('TransferAssignmentService');
  constructor(
    private payoutNewService: PayoutNewService,
    private transferAssignmentNewService: TransferAssignmentNewService,
    private transferService: TransferService,
    private merchantLimitEvaluatorService: MerchantLimitEvaluatorService,
    private featureFlagService: FeatureFlagService,
  ) {}

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  @OnEvent(TransferEvent.CREATED)
  async assignProviderToTransfer(
    transfer: TransferEntity,
    providerId?: number,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation) return;

    if (!transfer) {
      this.logger.error(`Transfer not found`);
      return null;
    }

    if (transfer.version !== EntityVersion.v2) {
      this.logger.error(
        `Cannot assign provider to transfer with version ${transfer.version}`,
      );
      return transfer;
    }

    if (!transfer.assignable) {
      this.logger.error(
        `Cannot assign provider to an already assigned transfer`,
      );
      return transfer;
    }

    const payout = await this.payoutNewService.findOneOrFail(transfer.payoutId);

    if (payout.version !== EntityVersion.v2) {
      this.logger.error(
        `Cannot assign provider to payout with version ${payout.version}`,
      );
      return transfer;
    }

    if (payout.finished) {
      this.logger.error(`Payout with id ${transfer.payoutId} is finished`);
      return await this.transferService.update(transfer.id, {
        message: 'Transferencia cancelada por estado inválido del pago',
        state: TransferState.CANCELED,
      });
    }

    const evaluateResult = await this.merchantLimitEvaluatorService.evaluate(
      payout,
    );

    if (evaluateResult.exceeds) {
      this.logger.error(`Payout with id ${payout.id} exceeds merchant limit`);
      return await this.transferService.update(transfer.id, {
        message: evaluateResult.errorMessage,
        state: TransferState.FAILED, // trigger autocancel
      });
    }

    const provider =
      await this.transferAssignmentNewService.findCapableProvider(
        transfer,
        providerId,
      );

    if (!provider) {
      this.logger.error(
        `No capable providers found for transfer ${transfer.id}. Cancelling transfer`,
      );
      return await this.transferService.update(transfer.id, {
        message: 'No hay proveedores disponibles para la transferencia',
        state: TransferState.CANCELED,
      });
    }

    this.logger.log(
      `Assigning provider Id ${provider.id} to transfer ${transfer.id}`,
    );

    const assignedTransfer = await this.transferService.update(transfer.id, {
      providerId: provider.id,
      state: TransferState.ASSIGNED,
    });

    return assignedTransfer;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment.new.service.ts
import { Inject, Injectable } from '@nestjs/common';
import { In } from 'typeorm';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { State } from 'src/common/enums/state.enum';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { pick, sortByField, SortOrder } from 'src/utils/array-methods.util';
import { InSimpleArray } from 'src/common/queries/inSimpleArray.query';

export interface CreatedTransferEventDto {
  transferId: number;
  providerId?: number;
}

@Injectable()
export class TransferAssignmentNewService {
  @Inject(AccountService)
  private accountService: AccountService;
  @Inject(ProviderService)
  private providerService: ProviderService;

  async findAccountsByMerchantId(merchantId: number): Promise<AccountEntity[]> {
    const accounts = await this.accountService.findAll({
      where: { merchantId, state: State.ACTIVE },
    });
    return accounts;
  }

  async filterCapableAccounts(
    accounts: AccountEntity[],
    transfer: TransferEntity,
  ): Promise<AccountEntity[]> {
    const evaluationPromises = accounts.map(async (account) => {
      const capable = await this.accountService.evaluateRules(
        account,
        transfer,
      );
      return { capable, account };
    });

    const evaluations = await Promise.all(evaluationPromises);

    const capableAccounts = evaluations
      .filter((evaluation) => evaluation.capable)
      .map((evaluation) => evaluation.account);

    return capableAccounts;
  }

  async filterCapableProviders(
    providers: ProviderEntity[],
    transfer: TransferEntity,
  ): Promise<ProviderEntity[]> {
    if (providers.length === 0) return [];

    const evaluationPromises = providers.map(async (provider) => {
      const capable = await this.providerService.evaluateRules(
        provider,
        transfer,
      );
      return { capable, provider };
    });

    const evaluations = await Promise.all(evaluationPromises);

    const capableProviders = evaluations
      .filter((evaluation) => evaluation.capable)
      .map((evaluation) => evaluation.provider);

    return capableProviders;
  }

  async filterHighestPriorityProviders(
    providers: ProviderEntity[],
  ): Promise<ProviderEntity[]> {
    if (providers.length === 0) return [];

    const sortedProviders = sortByField(
      providers,
      'priority',
      SortOrder.ASCENDING,
    );

    const hightestPriority = sortedProviders[0].priority;

    return sortedProviders.filter(
      (provider) => provider?.priority === hightestPriority,
    );
  }

  async findCapableProvider(
    transfer: TransferEntity,
    providerId?: number,
  ): Promise<ProviderEntity> {
    const merchantAccounts = await this.findAccountsByMerchantId(
      transfer.merchantId,
    );
    const capableAccounts = await this.filterCapableAccounts(
      merchantAccounts,
      transfer,
    );
    if (capableAccounts.length === 0) return null;

    const accountIds = capableAccounts.map((account) => account.id);

    const merchantProviders = await this.providerService.findAll({
      where: {
        accountId: In(accountIds),
        state: State.ACTIVE,
        capabilities: InSimpleArray(ProviderCapability.CREATE_TRANSFER),
        ...(providerId && { id: providerId }),
      },
    });

    const capableProviders = await this.filterCapableProviders(
      merchantProviders,
      transfer,
    );

    const highestPriorityProviders = await this.filterHighestPriorityProviders(
      capableProviders,
    );

    const capableAccountIds = highestPriorityProviders
      .map((provider) => provider.accountId)
      .filter((value, index, self) => self.indexOf(value) === index);

    const randomAccountId = pick(capableAccountIds);

    const providers = capableProviders.filter(
      (provider) => provider.accountId === randomAccountId,
    );

    const provider = pick(providers);

    return provider;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment-new.service.spec.ts
import * as moment from 'moment';
import { Test, TestingModule } from '@nestjs/testing';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import RulesEvaluator, { EvaluatorContext } from 'src/common/rules/evaluator';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferAssignmentNewService } from './transfer-assignment.new.service';

describe('Given a TransferAssignmentNewService', () => {
  let service: TransferAssignmentNewService;

  let mockAccountService: Partial<AccountService> = {};
  let mockProviderService: Partial<ProviderService> = {};

  let transfer: TransferEntity;
  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const context = { transfer } as EvaluatorContext;
  const processor = new RulesEvaluator(context);

  beforeEach(async () => {
    payout = new PayoutEntity();

    Object.assign(payout, {
      id: 1,
      amount: 1000,
      destinationName: 'test',
      destinationEmail: 'email@buk.cl',
      destinationHolderId: '192912312',
      destinationAccount: '10299912912',
      destinationBankCode: 'cl_banco_falabella',
      merchantId: 1,
      currency: Currency.CHILE,
      concept: 'adelanto de sueldo',
      trackingCode: '1211231212',
      destinationPhone: '$573770000075',
      transfers: [],
      state: PayoutState.PENDING,
      version: EntityVersion.v2,
    });

    transfer = new TransferEntity();

    Object.assign(transfer, {
      id: 1,
      payoutId: payout.id,
      amount: payout.amount,
      state: TransferState.PENDING,
      providerId: null,
      version: EntityVersion.v2,
    });

    account = new AccountEntity();

    Object.assign(account, {
      id: 1,
      bankCode: 'cl_banco_falabella',
      countryCode: CountryCode.CHILE,
      currency: Currency.CHILE,
      name: 'Base Account',
      identifier: '123912391',
      merchantId: 1,
    });

    provider = new ProviderEntity();

    Object.assign(provider, {
      id: 1,
      providerType: ProviderType.ScraperCG,
      accountId: account.id,
    });

    mockAccountService = {
      findAll: async () => Promise.resolve([account]),
      evaluateRules: async (account, _transfer) =>
        Promise.resolve(processor.process(account.rules)),
    };

    mockProviderService = {
      findAll: async () => Promise.resolve([provider]),
      evaluateRules: async (provider) =>
        Promise.resolve(processor.process(provider.rules)),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferAssignmentNewService,
        {
          provide: AccountService,
          useValue: mockAccountService,
        },
        { provide: ProviderService, useValue: mockProviderService },
      ],
    }).compile();

    service = module.get<TransferAssignmentNewService>(
      TransferAssignmentNewService,
    );
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('Given a provider that have a rule of type BankExcludeRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'bank',
          value: ['cl_banco_falabella'],
          operator: 'exclude',
        },
      });
    });

    it('should return an empty array if no providers met the rule', async () => {
      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_falabella' },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_itau_chile' },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type BankLimitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'bank',
          value: {
            amount: 1000,
            window: 'daily',
            bankCode: 'cl_banco_falabella',
          },
          operator: 'limit',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_falabella' },
        transferred: {
          all: {
            daily: 1000,
          },
          destinationBank: {
            daily: 500,
          },
        },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: {
          amount: 400,
          destinationBankCode: 'cl_banco_itau_chile',
        },
        transferred: {
          all: {
            daily: 500,
          },
          destinationBank: {
            daily: 500,
          },
        },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type CurrencyOnlyRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'currency',
          value: 'cop',
          operator: 'only',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999, currency: 'clp' },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type ProviderLimitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'provider',
          value: {
            amount: 1000,
            count: 10,
          },
          operator: 'limit',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999 },
        transferred: { all: { daily: 1000 }, count: { daily: 1 } },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: { amount: 999 },
        transferred: { all: { daily: 0 }, count: { daily: 0 } },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type RecipientWaitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'recipient',
          value: { hours: 24, transfer: 'first' },
          operator: 'wait',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999 },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(10, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: { amount: 999 },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(25, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  // TODO: must review the rule evaluator
  describe('Given a provider that have a rule of type RequiredFieldsRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'transfer',
          value: ['destinationEmail'],
          operator: 'required',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      Object.assign(transfer, { amount: 999, destinationEmail: null });

      processor.context = { transfer } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      Object.assign(transfer, {
        amount: 999,
        destinationEmail: 'test@buk.cl',
      });

      processor.context = { transfer } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type CompoundAndRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'compound',
          value: [
            {
              type: 'currency',
              value: 'clp',
              operator: 'only',
            },
            {
              type: 'recipient',
              value: {
                hours: 24,
                transfer: 'first',
              },
              operator: 'wait',
            },
            {
              type: 'amount',
              value: {
                lt: 100000,
                gte: 0,
              },
              operator: 'range',
            },
            {
              type: 'bank',
              value: ['cl_banco_estado'],
              operator: 'exclude',
            },
          ],
          operator: 'and',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;
      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });
    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: {
          amount: 99999,
          currency: 'clp',
          destinationBankCode: 'cl_banco_itau_chile',
        },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(25, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });

  describe('Given a provider that have a rule of type CompoundOrRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'compound',
          value: [
            {
              type: 'compound',
              value: [
                {
                  type: 'amount',
                  value: {
                    lt: 35000,
                    gte: 0,
                  },
                  operator: 'range',
                },
                {
                  type: 'compound',
                  value: [
                    {
                      type: 'amount',
                      value: {
                        lt: 98000,
                        gte: 0,
                      },
                      operator: 'range',
                    },
                    {
                      type: 'bank',
                      value: ['cl_banco_estado', 'cl_banco_falabella'],
                      operator: 'include',
                    },
                  ],
                  operator: 'and',
                },
              ],
              operator: 'or',
            },
            {
              type: 'currency',
              value: 'clp',
              operator: 'only',
            },
          ],
          operator: 'and',
        },
      });
    });

    it('should return an empty array if the transfer broke the rule (no providers met the rules)', async () => {
      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;

      const capableProviders = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProviders).toHaveLength(0);
    });

    it("should return a provider if transfer doesn't break the rule", async () => {
      processor.context = {
        transfer: {
          amount: 34999,
          currency: 'clp',
          destinationBankCode: 'cl_banco_itau_chile',
        },
      } as EvaluatorContext;

      const capableProvider = await service.filterCapableProviders(
        [provider],
        transfer,
      );

      expect(capableProvider).toHaveLength(1);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-assignment/transfer-assignment.service.spec.ts
import * as moment from 'moment';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import RulesEvaluator, { EvaluatorContext } from 'src/common/rules/evaluator';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { PayoutNewService } from 'src/models/payout/payout.new.service';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { ProviderService } from 'src/models/provider/provider.service';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { TransferService } from 'src/models/transfer/transfer.service';
import { TransferAssignmentService } from './transfer-assignment.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { MerchantLimitEvaluatorService } from '../merchant-limit-evaluator/merchant-limit-evaluator.service';
import { FeatureFlagService } from '../feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { NotFoundException } from '@nestjs/common';
import { TransferAssignmentNewService } from './transfer-assignment.new.service';

describe('Given a TransferAssignmentService', () => {
  let service: TransferAssignmentService;

  let mockAccountService: Partial<AccountService> = {};
  let mockProviderService: Partial<ProviderService> = {};
  let mockTransferService: Partial<TransferService> = {};
  let mockFeatureFlagService: Partial<FeatureFlagService> = {};
  const mockTransferAssignmentNewService = {
    findCapableProvider: jest.fn(),
  };
  let mockMerchantLimitEvaluatorService: Partial<MerchantLimitEvaluatorService> =
    {};
  const mockPayoutNewService = {
    findOneOrFail: jest.fn(),
  };

  let transfer: TransferEntity;
  let payout: PayoutEntity;
  let account: AccountEntity;
  let provider: ProviderEntity;

  const mockEventEmitter = {
    emit: () => Promise.resolve(),
  };
  const context = { transfer } as EvaluatorContext;
  const processor = new RulesEvaluator(context);

  beforeEach(async () => {
    payout = new PayoutEntity();

    Object.assign(payout, {
      id: 1,
      amount: 1000,
      destinationName: 'test',
      destinationEmail: 'email@buk.cl',
      destinationHolderId: '192912312',
      destinationAccount: '10299912912',
      destinationBankCode: 'cl_banco_falabella',
      merchantId: 1,
      currency: Currency.CHILE,
      concept: 'adelanto de sueldo',
      trackingCode: '1211231212',
      destinationPhone: '$573770000075',
      transfers: [],
      state: PayoutState.PENDING,
      version: EntityVersion.v2,
    });

    transfer = new TransferEntity();

    Object.assign(transfer, {
      id: 1,
      payoutId: payout.id,
      amount: payout.amount,
      state: TransferState.PENDING,
      providerId: null,
      version: EntityVersion.v2,
    });

    account = new AccountEntity();

    Object.assign(account, {
      id: 1,
      bankCode: 'cl_banco_falabella',
      countryCode: CountryCode.CHILE,
      currency: Currency.CHILE,
      name: 'Base Account',
      identifier: '123912391',
      merchantId: 1,
    });

    provider = new ProviderEntity();

    Object.assign(provider, {
      id: 1,
      providerType: ProviderType.ScraperCG,
      accountId: account.id,
    });

    mockAccountService = {
      findAll: async () => Promise.resolve([account]),
      evaluateRules: async (account, _transfer) =>
        Promise.resolve(processor.process(account.rules)),
    };

    mockProviderService = {
      findAll: async () => Promise.resolve([provider]),
      evaluateRules: async (provider) =>
        Promise.resolve(processor.process(provider.rules)),
    };

    mockTransferService = {
      findOneOrFail: async (_id: number) => Promise.resolve(transfer),
      update: async (
        id: number,
        updateTransferDto: Partial<TransferEntity>,
      ) => {
        Object.assign(transfer, updateTransferDto);
        return Promise.resolve(transfer);
      },
    };
    mockFeatureFlagService = {
      getFeatureStatus: async (_feat: FEATURE_FLAG) => Promise.resolve(false),
    };

    mockMerchantLimitEvaluatorService = {
      evaluate: async (_payout: PayoutEntity) =>
        Promise.resolve({ exceeds: false }),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferAssignmentService,
        {
          provide: AccountService,
          useValue: mockAccountService,
        },
        { provide: ProviderService, useValue: mockProviderService },
        {
          provide: PayoutNewService,
          useValue: mockPayoutNewService,
        },
        {
          provide: TransferAssignmentNewService,
          useValue: mockTransferAssignmentNewService,
        },
        {
          provide: TransferService,
          useValue: mockTransferService,
        },
        {
          provide: MerchantLimitEvaluatorService,
          useValue: mockMerchantLimitEvaluatorService,
        },
        {
          provide: EventEmitter2,
          useValue: mockEventEmitter,
        },
        {
          provide: FeatureFlagService,
          useValue: mockFeatureFlagService,
        },
      ],
    }).compile();

    service = module.get<TransferAssignmentService>(TransferAssignmentService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('when some code executes assignProvider method', () => {
    it("then should fail the assingment if the transfer payout doesn't exists", async () => {
      mockPayoutNewService.findOneOrFail.mockImplementation(() =>
        Promise.reject(new NotFoundException('Not found in test')),
      );

      await expect(service.assignProviderToTransfer(transfer)).rejects.toThrow(
        'Not found in test',
      );
    });

    it("then shouldn't assign the transfer if the payout version isn't v2", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(async () =>
        Promise.resolve({ ...payout, version: EntityVersion.v1 }),
      );

      const unchangedTransfer = await service.assignProviderToTransfer(
        transfer,
      );
      expect(unchangedTransfer.state).toEqual(TransferState.PENDING);
    });

    it('should cancel the transfer if the payout has a finished state', async () => {
      const states = [
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];

      mockPayoutNewService.findOneOrFail.mockImplementation(async () =>
        Promise.resolve(payout),
      );

      for (const state of states) {
        Object.assign(payout, { state });

        const assignedTransfer = await service.assignProviderToTransfer(
          transfer,
        );
        expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
      }
    });

    it('then should cancel the transfer if there are no capable accounts', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      Object.assign(account, {
        id: 1,
        rules: {
          type: 'amount',
          value: { lt: 35000, gte: 0 },
          operator: 'range',
        },
      });

      processor.context = { transfer: { amount: 35001 } } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);
      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it('then should cancel the transfer if there are no capable providers', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      Object.assign(provider, {
        rules: { type: 'amount', value: { lt: 1000 }, operator: 'range' },
      });

      processor.context = { transfer: { amount: 1000 } } as EvaluatorContext;
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it('then should assign the transfer', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      Object.assign(account, {
        id: 1,
        rules: { type: 'amount', value: { gte: 1000 }, operator: 'range' },
      });

      Object.assign(provider, {
        rules: { type: 'amount', value: { lt: 2000 }, operator: 'range' },
      });
      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      processor.context = { transfer: { amount: 1999 } } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.ASSIGNED);
      expect(assignedTransfer.providerId).toEqual(1);
    });

    describe('Given a provider that have a rule of type AmountRangeRule', () => {
      beforeEach(() => {
        Object.assign(provider, {
          rules: {
            type: 'amount',
            value: { gte: 1000, lt: 2000 },
            operator: 'range',
          },
        });
      });

      it('should cancel the transfer if no providers met the rule', async () => {
        mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

        processor.context = { transfer: { amount: 999 } } as EvaluatorContext;
        const assignedTransfer = await service.assignProviderToTransfer(
          transfer,
        );

        expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
      });

      it("should assign the transfer if the payout doesn't break the rule", async () => {
        mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

        processor.context = { transfer: { amount: 1000 } } as EvaluatorContext;

        mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
          Promise.resolve(provider),
        );
        const assignedTransfer = await service.assignProviderToTransfer(
          transfer,
        );

        expect(assignedTransfer.state).toEqual(TransferState.ASSIGNED);
        expect(assignedTransfer.providerId).toEqual(1);
      });
    });
  });

  describe('Given a provider that have a rule of type BankExcludeRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'bank',
          value: ['cl_banco_falabella'],
          operator: 'exclude',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_falabella' },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_itau_chile' },
      } as EvaluatorContext;

      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type BankLimitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'bank',
          value: {
            amount: 1000,
            window: 'daily',
            bankCode: 'cl_banco_falabella',
          },
          operator: 'limit',
        },
      });
    });

    it('should cancel the transfer if the transfer broke the rule (no providers met the rules)', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999, destinationBankCode: 'cl_banco_falabella' },
        transferred: {
          all: {
            daily: 1000,
          },
          destinationBank: {
            daily: 500,
          },
        },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 400, destinationBankCode: 'cl_banco_itau_chile' },
        transferred: {
          all: {
            daily: 500,
          },
          destinationBank: {
            daily: 500,
          },
        },
      } as EvaluatorContext;

      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type CurrencyOnlyRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'currency',
          value: 'cop',
          operator: 'only',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999, currency: 'clp' },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;

      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type ProviderLimitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'provider',
          value: {
            amount: 1000,
            count: 10,
          },
          operator: 'limit',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999 },
        transferred: { all: { daily: 1000 }, count: { daily: 1 } },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      processor.context = {
        transfer: { amount: 999 },
        transferred: { all: { daily: 0 }, count: { daily: 0 } },
      } as EvaluatorContext;
      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type RecipientWaitRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'recipient',
          value: { hours: 24, transfer: 'first' },
          operator: 'wait',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999 },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(10, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999 },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(25, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;
      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  // TODO: must review the rule evaluator
  describe('Given a provider that have a rule of type RequiredFieldsRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'transfer',
          value: ['destinationEmail'],
          operator: 'required',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      Object.assign(transfer, { amount: 999, destinationEmail: null });

      processor.context = { transfer } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      Object.assign(transfer, { amount: 999, destinationEmail: 'test@buk.cl' });

      processor.context = { transfer } as EvaluatorContext;

      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type CompoundAndRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'compound',
          value: [
            {
              type: 'currency',
              value: 'clp',
              operator: 'only',
            },
            {
              type: 'recipient',
              value: {
                hours: 24,
                transfer: 'first',
              },
              operator: 'wait',
            },
            {
              type: 'amount',
              value: {
                lt: 100000,
                gte: 0,
              },
              operator: 'range',
            },
            {
              type: 'bank',
              value: ['cl_banco_estado'],
              operator: 'exclude',
            },
          ],
          operator: 'and',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);
      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });
    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: {
          amount: 99999,
          currency: 'clp',
          destinationBankCode: 'cl_banco_itau_chile',
        },
        transfers: {
          recipient: {
            first: {
              finishedAt: moment().subtract(25, 'h').toDate(),
            },
          },
        },
      } as EvaluatorContext;
      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });

  describe('Given a provider that have a rule of type CompoundOrRule', () => {
    beforeEach(() => {
      Object.assign(provider, {
        rules: {
          type: 'compound',
          value: [
            {
              type: 'compound',
              value: [
                {
                  type: 'amount',
                  value: {
                    lt: 35000,
                    gte: 0,
                  },
                  operator: 'range',
                },
                {
                  type: 'compound',
                  value: [
                    {
                      type: 'amount',
                      value: {
                        lt: 98000,
                        gte: 0,
                      },
                      operator: 'range',
                    },
                    {
                      type: 'bank',
                      value: ['cl_banco_estado', 'cl_banco_falabella'],
                      operator: 'include',
                    },
                  ],
                  operator: 'and',
                },
              ],
              operator: 'or',
            },
            {
              type: 'currency',
              value: 'clp',
              operator: 'only',
            },
          ],
          operator: 'and',
        },
      });
    });

    it('should cancel the transfer if no providers met the rule', async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: { amount: 999, currency: 'cop' },
      } as EvaluatorContext;

      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.state).toEqual(TransferState.CANCELED);
    });

    it("should assign the transfer if the payout doesn't break the rule", async () => {
      mockPayoutNewService.findOneOrFail.mockResolvedValue(payout);

      processor.context = {
        transfer: {
          amount: 34999,
          currency: 'clp',
          destinationBankCode: 'cl_banco_itau_chile',
        },
      } as EvaluatorContext;

      mockTransferAssignmentNewService.findCapableProvider.mockReturnValue(
        Promise.resolve(provider),
      );
      const assignedTransfer = await service.assignProviderToTransfer(transfer);

      expect(assignedTransfer.providerId).toEqual(1);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/device/device.service.spec.ts
import { ConfigType } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import deviceConfig from 'src/config/device.config';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { AwsSnsService } from '../aws/sns.service';
import { DeviceService } from './device.service';

let mockAwsSnsService: Partial<AwsSnsService>;

describe('given a DeviceService', () => {
  let service: DeviceService;
  const mockTransferMethodEntity: Partial<TransferMethodEntity> = {
    identifier: 'mockIdentifier',
    methodType: TransferMethodType.MOBILE,
  };
  const config: ConfigType<typeof deviceConfig> = {
    token: '',
    queueUrl: 'queueUrl',
    topicArn: 'topicArn',
  };
  mockAwsSnsService = {
    publishMessage: async () => {
      return Promise.resolve({ messageId: 'fakeId' });
    },
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        DeviceService,
        { provide: AwsSnsService, useValue: mockAwsSnsService },
        { provide: deviceConfig.KEY, useValue: config },
      ],
    }).compile();

    service = module.get<DeviceService>(DeviceService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  it('when call requestDigipassCode then return a boolean', async () => {
    const requestedDigipassResult = await service.requestDeviceCode(
      mockTransferMethodEntity as TransferMethodEntity,
    );
    expect(requestedDigipassResult).not.toBeNull();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/device/device.module.ts
import { AwsModule } from '../aws/aws.module';
import { Module } from '@nestjs/common';
import { DeviceService } from 'src/services/device/device.service';
import { ConfigModule } from '@nestjs/config';
import deviceConfig from 'src/config/device.config';

@Module({
  imports: [ConfigModule.forFeature(deviceConfig), AwsModule],
  providers: [DeviceService],
  exports: [DeviceService],
})
export class DeviceModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/device/device.service.ts
import { DeviceRequestDto } from './dto/device-request.dto';
import { TransferMethodEntity } from '../../models/transfer-method/entities/transfer-method.entity';
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import deviceConfig from 'src/config/device.config';
import { AwsSnsService } from '../aws/sns.service';

@Injectable()
export class DeviceService {
  private logger = new Logger('DeviceService');

  constructor(
    @Inject(deviceConfig.KEY)
    private config: ConfigType<typeof deviceConfig>,
    private readonly snsService: AwsSnsService,
  ) {}
  public async requestDeviceCode(
    transferMethod: TransferMethodEntity,
  ): Promise<boolean> {
    const { identifier, methodType } = transferMethod;
    const payload: Partial<DeviceRequestDto> = { identifier, methodType };
    const attributes = { identifier, methodType };

    const { topicArn } = this.config;

    try {
      const snsRepsonse = await this.snsService.publishMessage(
        topicArn,
        payload,
        attributes,
      );

      return snsRepsonse.messageId != null;
    } catch (error) {
      this.logger.error(`SNS publishMessage method failed. ${error?.message}`);
      return false;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/device/dto/device-request.dto.ts
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';

export class DeviceRequestDto {
  @IsString()
  @IsNotEmpty()
  identifier: string;

  @IsEnum(TransferMethodType)
  @IsNotEmpty()
  methodType: TransferMethodType;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/alerts.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { SlackService } from '../slack/slack.service';
import { SentryService } from '../sentry/sentry.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { SlackTransferStateAlert } from './templates/slack-transfer-state-alert';
import { SlackPayoutStateAlert } from './templates/slack-payout-state-alert';
import { SlackEntityInconsistentAlert } from './templates/slack-entity-inconsistent-state';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';

@Injectable()
export class AlertsService {
  private logger = new Logger('AlertsService');
  constructor(
    private slackService: SlackService,
    private sentryService: SentryService,
  ) {}

  @OnEvent(TransferEvent.UPDATED)
  async notifyFailedTransfer(transfer: TransferEntity) {
    try {
      const { currency, payoutId, state, version } = transfer;

      if (version !== EntityVersion.v2) {
        throw new Error('Invalid entity version');
      }
      if (state !== TransferState.FAILED) return false;

      const message = new SlackTransferStateAlert(currency).stuckTransfers(
        state,
        payoutId.toString(),
      );

      const result = await this.slackService.postMessage(message);

      if (!result.success) throw new Error(result.response.text as string);

      return true;
    } catch (error) {
      this.logger.error(error);
      this.sentryService.captureException(error);

      return false;
    }
  }

  @OnEvent(PayoutEvent.COMPLETED)
  @OnEvent(PayoutEvent.FAILED)
  @OnEvent(PayoutEvent.CANCELED)
  async notifyUpdatedPayout(payout: PayoutEntity) {
    try {
      const { state, version } = payout;

      if (version !== EntityVersion.v2) {
        throw new Error('Invalid entity version');
      }

      const message = new SlackPayoutStateAlert(payout)[state];

      // If the state doesn't have an alert configured this will be undefined
      if (!message) return false;

      const result = await this.slackService.postMessage(message);

      if (!result.success) throw new Error(result.response.text as string);

      return true;
    } catch (error) {
      this.logger.error(error);
      this.sentryService.captureException(error);

      return false;
    }
  }

  /**
   * This method is used to notify when there is an inconsistency in the state of transfers during the payout completion process.

   * @param {PayoutEntity} payout - The payout entity that has inconsistencies.
   * @param {string} errorMessage - The error message describing the inconsistency.
   * @returns {Promise<boolean>} Returns a promise that resolves to a boolean. The promise will resolve to `true` if the Slack message was successfully sent, and `false` otherwise.
   * @throws {Error} Throws an error if the Slack message could not be sent.
   * @async
   */
  async notifyPayoutInconsistent(
    payout: PayoutEntity,
    errorMessage: string,
  ): Promise<boolean> {
    try {
      this.logger.debug('Notify Payout Inconsistent');
      const entityInconsistent = new SlackEntityInconsistentAlert(
        payout.currency,
      );
      const message = entityInconsistent.payoutInconsistent(
        payout,
        errorMessage,
      );

      const result = await this.slackService.postMessage(message);

      if (!result.success) throw new Error(result.response.text as string);

      return true;
    } catch (error) {
      this.logger.error(error);
      this.sentryService.captureException(error);

      return false;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/templates/slack-payout-state-alert.ts
import { KnownBlock, MessageAttachment } from '@slack/web-api';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { SlackMessage } from 'src/services/slack/slack.service';
import { BaseAlert } from './base-alert';

export class SlackPayoutStateAlert extends BaseAlert {
  constructor(private payout: PayoutEntity) {
    super({
      currency: payout.currency,
      amount: payout.amount,
    });
  }

  get completed(): SlackMessage {
    const text = `${this.countryFlag} ${this.localAmount} retirados en ${this.countryName}! :white_check_mark:`;

    const blocks: KnownBlock[] = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text,
        },
      },
    ];
    return { text, blocks, channelName: 'payouts' };
  }

  get failed(): SlackMessage {
    const {
      id: payoutId,
      createdAt,
      destinationBankCode,
      destinationHolderId,
      message,
    } = this.payout;

    //TODO: should add the errorCode from the payout
    const requestedAt = createdAt.toISOString();
    const text = `${this.countryFlag} Payout fallido en ${this.countryName}!`;
    const attachments: MessageAttachment[] = [
      {
        color: '#DE1738',
        blocks: [
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*PayoutId:*\n ${payoutId}`,
              },
              {
                type: 'mrkdwn',
                text: `*Amount:*\n$${this.amount} ${this.currency}`,
              },
              {
                type: 'mrkdwn',
                text: `*Requested At:*\n${requestedAt}`,
              },
              {
                type: 'mrkdwn',
                text: `*BankCode:*\n${destinationBankCode}`,
              },
              {
                type: 'mrkdwn',
                text: `*HolderId:*\n${destinationHolderId}`,
              },
            ],
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Message:* ${message ?? 'Error desconocido'}`,
            },
          },
        ],
      },
    ];

    return { text, attachments, channelName: 'alerts-payouts' };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/templates/slack-entity-inconsistent-state.ts
import { KnownBlock } from '@slack/web-api';
import { SlackMessage } from 'src/services/slack/slack.service';
import { BaseAlert } from './base-alert';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';

export class SlackEntityInconsistentAlert extends BaseAlert {
  constructor(currency: string) {
    super({ currency });
  }

  payoutInconsistent(payout: PayoutEntity, message: string): SlackMessage {
    const text = 'Error de Consistencia';
    const blocks: KnownBlock[] = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${this.countryFlag} Se detectó una inconsistencia de estado para el pago ${payout.id}`,
        },
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${message}`,
        },
      },
      {
        type: 'divider',
      },
    ];

    return { text, blocks, channelName: 'alerts-payouts' };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/templates/base-alert.ts
import { CountryCode } from 'src/common/enums/country-code.enum';
import {
  MapCountryCodeToCountryFlag,
  MapCountryCodeToCountryName,
} from 'src/common/maps/country.map';
import { MapCurrencyToCountryCode } from 'src/common/maps/currency.map';
import { formatAmount } from 'src/utils/currency-methods.util';

interface AlertParams {
  currency: string;
  countryCode?: string;
  amount?: number;
}

export class BaseAlert {
  protected amount: number;
  protected currency: string;

  constructor(params: AlertParams) {
    const { currency, amount } = params;

    this.amount = amount;
    this.currency = currency;
  }

  get localAmount(): string {
    return formatAmount(this.amount, this.countryCode);
  }

  get countryCode(): CountryCode {
    return MapCurrencyToCountryCode[this.currency];
  }

  get countryName(): string {
    return MapCountryCodeToCountryName[this.countryCode];
  }

  get countryFlag(): string {
    return MapCountryCodeToCountryFlag[this.countryCode];
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/templates/slack-transfer-state-alert.ts
import { KnownBlock } from '@slack/web-api';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { SlackMessage } from 'src/services/slack/slack.service';
import { BaseAlert } from './base-alert';

export class SlackTransferStateAlert extends BaseAlert {
  constructor(currency: string, amount?: number) {
    super({ currency, amount });
  }

  stuckTransfers(
    state: TransferState,
    payoutIds: string,
    count = 1,
  ): SlackMessage {
    const text = `Found ${count} transfers with state ${state} in ${this.countryName}.\nPayout IDs: ${payoutIds}`;
    const blocks: KnownBlock[] = [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${this.countryFlag} Found ${count} transfers with \`${state}\` state in ${this.countryName}`,
        },
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `Payout IDs: ${payoutIds}`,
        },
      },
      {
        type: 'divider',
      },
    ];

    return { text, blocks, channelName: 'alerts-payouts' };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/alerts.module.ts
import { Module } from '@nestjs/common';
import { AlertsService } from './alerts.service';
import { SentryModule } from '../sentry/sentry.module';
import { SlackModule } from '../slack/slack.module';

@Module({
  imports: [SentryModule, SlackModule],
  providers: [AlertsService],
  exports: [AlertsService],
})
export class AlertsModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/alerts/alerts.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AlertsService } from './alerts.service';
import { SentryService } from '../sentry/sentry.service';
import { SlackService } from '../slack/slack.service';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { Currency } from 'src/common/enums/currency.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferErrorCode } from '../../models/transfer-error/error.definition.type';

describe('AlertsService', () => {
  let service: AlertsService;
  const mockSentryService: Partial<SentryService> = {
    captureException: (_exception, _level?, _tags?) => Promise.resolve(),
  };
  let mockSlackService: Partial<SlackService> = {};

  beforeEach(async () => {
    mockSlackService = {
      postMessage: (_message) =>
        Promise.resolve({ success: true, response: undefined }),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AlertsService,
        {
          provide: SentryService,
          useValue: mockSentryService,
        },
        {
          provide: SlackService,
          useValue: mockSlackService,
        },
      ],
    }).compile();

    service = module.get<AlertsService>(AlertsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('When some code executes notifyFailedTransfer', () => {
    it('then should return false if the transfer version is not v2', async () => {
      const result = await service.notifyFailedTransfer({
        version: EntityVersion.v1,
        state: TransferState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        payoutId: 1,
      } as TransferEntity);

      expect(result).toEqual(false);
    });

    it('then should return false if the transfer state is not "failed"', async () => {
      const result = await service.notifyFailedTransfer({
        version: EntityVersion.v2,
        state: TransferState.ASSIGNED,
        currency: Currency.CHILE,
        amount: 100,
        payoutId: 1,
      } as TransferEntity);

      expect(result).toEqual(false);
    });

    it('then should return false if the transfer state is not "failed"', async () => {
      const result = await service.notifyFailedTransfer({
        version: EntityVersion.v2,
        state: TransferState.ASSIGNED,
        currency: Currency.CHILE,
        amount: 100,
        payoutId: 1,
      } as TransferEntity);

      expect(result).toEqual(false);
    });

    it('then should return false if the alert was not sent', async () => {
      mockSlackService.postMessage = (_message) =>
        Promise.resolve({ success: false, response: { text: 'Error' } });

      const result = await service.notifyFailedTransfer({
        version: EntityVersion.v2,
        state: TransferState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        payoutId: 1,
      } as TransferEntity);

      expect(result).toEqual(false);
    });

    it('then should return true if the alert was sent', async () => {
      const result = await service.notifyFailedTransfer({
        version: EntityVersion.v2,
        state: TransferState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        payoutId: 1,
      } as TransferEntity);

      expect(result).toEqual(true);
    });
  });

  describe('When some code executes notifyPayoutUpdate', () => {
    it('then should return false if the payout version is not v2', async () => {
      const result = await service.notifyUpdatedPayout({
        version: EntityVersion.v1,
        state: PayoutState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        transfers: [
          {
            message: 'Failed',
            errorCode: TransferErrorCode.UNKNOWN_ERROR,
          } as TransferEntity,
        ],
      } as PayoutEntity);

      expect(result).toEqual(false);
    });

    it('then should return false if the payout state is not in ("failed", "completed")', async () => {
      const result = await service.notifyUpdatedPayout({
        version: EntityVersion.v2,
        state: PayoutState.PROCESSING,
        currency: Currency.CHILE,
        amount: 100,
        transfers: [
          {
            message: 'Failed',
            errorCode: TransferErrorCode.UNKNOWN_ERROR,
          } as TransferEntity,
        ],
      } as PayoutEntity);

      expect(result).toEqual(false);
    });

    it('then should return false if the alert was not sent', async () => {
      mockSlackService.postMessage = (_message) =>
        Promise.resolve({ success: false, response: { text: 'Error' } });
      const result = await service.notifyUpdatedPayout({
        version: EntityVersion.v2,
        state: PayoutState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        transfers: [
          {
            message: 'Failed',
            errorCode: TransferErrorCode.UNKNOWN_ERROR,
          } as TransferEntity,
        ],
      } as PayoutEntity);

      expect(result).toEqual(false);
    });

    it('then should return true if the alert was sent', async () => {
      const result = await service.notifyUpdatedPayout({
        version: EntityVersion.v2,
        state: PayoutState.FAILED,
        currency: Currency.CHILE,
        amount: 100,
        createdAt: new Date(),
        transfers: [
          {
            message: 'Failed',
            errorCode: TransferErrorCode.UNKNOWN_ERROR,
          } as TransferEntity,
        ],
      } as PayoutEntity);

      expect(result).toEqual(true);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/webhook/webhook.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';
import { OnEvent } from '@nestjs/event-emitter';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { generatePayloadSignature } from 'src/utils/secrets.util';
import axios from 'axios';
import { plainToClass } from 'class-transformer';
import { WebhookPayloadDto } from './dto/webhook-payload.dto';
import { sortByField } from 'src/utils/array-methods.util';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { SentryService } from '../sentry/sentry.service';

const webhookEventMap: Record<PayoutEvent, WebhookEvent> = {
  [PayoutEvent.CREATED]: WebhookEvent.PAYOUT_CREATED,
  [PayoutEvent.PROCESSING]: WebhookEvent.PAYOUT_PROCESSING,
  [PayoutEvent.COMPLETED]: WebhookEvent.PAYOUT_COMPLETED,
  [PayoutEvent.FAILED]: WebhookEvent.PAYOUT_FAILED,
  [PayoutEvent.CANCELED]: WebhookEvent.PAYOUT_CANCELED,
};

export interface WebhookPayload {
  timestamp: number;
  type: string;
  data: WebhookData;
}

export interface WebhookData {
  object?: WebhookPayloadDto;
  error?: string;
}

export type WebhookHeaders = {
  'Payouts-Signature': string;
  'Content-Type': string;
};

@Injectable()
export class WebhookService {
  @Inject()
  private readonly sentryService: SentryService;
  @Inject()
  private readonly webhookEndpointService: WebhookEndpointService;
  private readonly logger = new Logger('WebhookServiceLogger');

  @OnEvent(PayoutEvent.PROCESSING)
  private async handlePayoutProcessingEvent(
    payout: PayoutEntity,
  ): Promise<void> {
    return this.handlePayoutEvent(PayoutEvent.PROCESSING, payout);
  }

  @OnEvent(PayoutEvent.COMPLETED)
  private async handlePayoutCompletedEvent(
    payout: PayoutEntity,
  ): Promise<void> {
    return this.handlePayoutEvent(PayoutEvent.COMPLETED, payout);
  }

  @OnEvent(PayoutEvent.CANCELED)
  private async handlePayoutCanceledEvent(payout: PayoutEntity): Promise<void> {
    return this.handlePayoutEvent(PayoutEvent.CANCELED, payout);
  }

  @OnEvent(PayoutEvent.FAILED)
  private async handlePayoutFailedEvent(payout: PayoutEntity): Promise<void> {
    return this.handlePayoutEvent(PayoutEvent.FAILED, payout);
  }

  private prepareHeaders(
    payload: WebhookPayload,
    secret: string,
  ): WebhookHeaders {
    const hmacSignature = generatePayloadSignature(payload, secret);
    return {
      'Payouts-Signature': hmacSignature,
      'Content-Type': 'application/json',
    };
  }

  private async preparePayload(
    payout: PayoutEntity,
    eventName: PayoutEvent,
  ): Promise<WebhookPayload> {
    const timestamp = Date.now();

    const payload = plainToClass(WebhookPayloadDto, payout, {
      excludeExtraneousValues: true,
    });

    const lastTransfer = sortByField<TransferEntity>(
      payout?.transfers ?? [],
      'createdAt',
    ).at(-1);

    payload.errorCode = lastTransfer?.errorCode;
    payload.message = lastTransfer?.message;

    // TODO: evaluate if should return the unwrapped payload or include an error field
    const data = {
      object: payload,
    };

    return {
      data,
      timestamp,
      type: eventName,
    };
  }

  private async postWebhook(
    url: string,
    payload: WebhookPayload,
    headers: WebhookHeaders,
  ) {
    const objectId = payload?.data?.object?.id ?? 'missing_object_id';
    const eventName = payload?.type ?? 'missing_event_name';

    try {
      await axios.post(url, payload, { headers });
      this.logger.log(
        `Webhook posting succeed to URL '${url}'. Event name: ${eventName}. Object ID: ${objectId}.`,
      );
    } catch (err) {
      this.logger.debug(
        `Webhook posting failed to URL '${url}'. Event name: ${eventName}. Object ID: ${objectId}.`,
      );
      this.logger.error(err);
      this.sentryService.captureException(err);
    }
  }

  async handlePayoutEvent(event: PayoutEvent, payout: PayoutEntity) {
    const merchantId = payout.merchantId;
    const webhookEndpoints = await this.webhookEndpointService.findByEventName(
      webhookEventMap[event],
      merchantId,
    );

    for (const { secret, url } of webhookEndpoints) {
      const payload = await this.preparePayload(payout, event);

      const headers = this.prepareHeaders(payload, secret);

      this.postWebhook(url, payload, headers);
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/webhook/webhook.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { WebhookEndpointService } from 'src/models/webhook-endpoint/webhook-endpoint.service';
import { WebhookService } from './webhook.service';
import { SentryService } from '../sentry/sentry.service';

describe('WebhookService', () => {
  let service: WebhookService;

  beforeEach(async () => {
    const mockWebhookEndpointService = {};

    const mockSentryService: Partial<SentryService> = {
      captureException: (_exception, _level, _tags) => Promise.resolve(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        WebhookService,
        {
          provide: SentryService,
          useValue: mockSentryService,
        },
        {
          provide: WebhookEndpointService,
          useValue: mockWebhookEndpointService,
        },
      ],
    }).compile();

    service = module.get<WebhookService>(WebhookService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/webhook/webhook.module.ts
import { Module } from '@nestjs/common';
import { WebhookEndpointModule } from 'src/models/webhook-endpoint/webhook-endpoint.module';
import { WebhookService } from './webhook.service';
import { SentryModule } from '../sentry/sentry.module';

@Module({
  imports: [WebhookEndpointModule, SentryModule],
  providers: [WebhookService],
  exports: [WebhookService],
})
export class WebhookModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/webhook/dto/webhook-payload.dto.ts
import { Expose } from 'class-transformer';
import {
  IsDateString,
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';

export class WebhookPayloadDto {
  @Expose()
  @IsNumber()
  @IsPositive()
  id: number;

  @Expose()
  @IsNumber()
  @IsPositive()
  amout: number; // Is this amount??

  @Expose()
  @IsEnum(PayoutState)
  state: PayoutState;

  @Expose()
  @IsEnum(Currency)
  currency: Currency;

  @Expose()
  @IsString()
  concept: string;

  @Expose()
  @IsString()
  trackingCode: string;

  @Expose()
  @IsObject()
  metadata: any;

  @Expose()
  @IsString()
  @IsOptional()
  destinationEmail?: string;

  @Expose()
  @IsString()
  destinationName: string;

  @Expose()
  @IsString()
  destinationHolderId: string;

  @Expose()
  @IsString()
  destinationAccount: string;

  @Expose()
  @IsString()
  destinationBankCode: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationPhone?: string;

  @Expose()
  @IsEnum(EntityVersion)
  version: EntityVersion;

  @Expose()
  @IsString()
  @IsOptional()
  errorCode?: string;

  @Expose()
  @IsString()
  @IsOptional()
  message?: string;

  @Expose()
  @IsDateString()
  createdAt: Date;

  @Expose()
  @IsDateString()
  updatedAt: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/twilio/dto/twilio-message.dto.ts
import { IsOptional, IsString } from 'class-validator';
export class TwilioMessageDto {
  @IsString()
  @IsOptional()
  MessageSid?: string;

  @IsString()
  @IsOptional()
  AccountSid?: string;

  @IsString()
  @IsOptional()
  To: string;

  @IsString()
  Body: string;

  @IsString()
  @IsOptional()
  From?: string;

  @IsString()
  @IsOptional()
  ToCountry?: string;

  @IsString()
  @IsOptional()
  ToState?: string;

  @IsString()
  @IsOptional()
  SmsMessageSid?: string;

  @IsString()
  @IsOptional()
  NumMedia?: string;

  @IsString()
  @IsOptional()
  ReferralNumMedia?: string;

  @IsString()
  @IsOptional()
  ToCity?: string;

  @IsString()
  @IsOptional()
  FromZip?: string;

  @IsString()
  @IsOptional()
  SmsSid?: string;

  @IsString()
  @IsOptional()
  FromState?: string;

  @IsString()
  @IsOptional()
  SmsStatus?: string;

  @IsString()
  @IsOptional()
  FromCity?: string;

  @IsString()
  @IsOptional()
  FromCountry?: string;

  @IsString()
  @IsOptional()
  ToZip?: string;

  @IsString()
  @IsOptional()
  NumSegments?: string;

  @IsString()
  @IsOptional()
  ApiVersion?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-auth/transfer-auth.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { TransferAuthService } from './transfer-auth.service';
import { AuthorizationCodeModule } from 'src/models/authorization-code/authorization-code.module';
import { DeviceModule } from '../device/device.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([BankAccessEntity, TransferMethodEntity]),
    AuthorizationCodeModule,
    DeviceModule,
  ],
  providers: [TransferAuthService],
  exports: [TransferAuthService],
})
export class TransferAuthModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-auth/transfer-auth.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { PinoLogger } from 'nestjs-pino';
import { AuthorizationCodeService } from 'src/models/authorization-code/authorization-code.service';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { DeviceService } from '../device/device.service';
import { TransferAuthService } from './transfer-auth.service';

describe('given a TransferAuthService', () => {
  let service: TransferAuthService;

  beforeEach(async () => {
    const mockDeviceService = {};
    const mockAuthorizationCodeService = {};
    const mockBankAccessEntityRepository = {};
    const mockTransferMethodEntityRepository = {};
    const mockPinoLogger = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferAuthService,
        { provide: DeviceService, useValue: mockDeviceService },
        {
          provide: AuthorizationCodeService,
          useValue: mockAuthorizationCodeService,
        },
        {
          provide: getRepositoryToken(BankAccessEntity),
          useValue: mockBankAccessEntityRepository,
        },
        {
          provide: getRepositoryToken(TransferMethodEntity),
          useValue: mockTransferMethodEntityRepository,
        },
        {
          provide: PinoLogger,
          useValue: mockPinoLogger,
        },
      ],
    }).compile();

    service = module.get<TransferAuthService>(TransferAuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/transfer-auth/transfer-auth.service.ts
import moment = require('moment');
import { Repository } from 'typeorm';
import {
  Injectable,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { AuthorizationCodeService } from 'src/models/authorization-code/authorization-code.service';
import { DeviceService } from '../device/device.service';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';
import { State } from 'src/common/enums/state.enum';
import {
  SecurityCardPayload,
  AuthorizeTransferDto,
} from 'src/api/v2/transfer/dto/authorize-transfer.dto';

export interface CodeRequestStatus {
  code: Record<string, string> | string | null;
  wait: boolean;
}

@Injectable()
export class TransferAuthService {
  constructor(
    private readonly deviceService: DeviceService,
    private readonly authorizationCodeService: AuthorizationCodeService,
    @InjectRepository(BankAccessEntity)
    private bankAccessRepository: Repository<BankAccessEntity>,
    @InjectRepository(TransferMethodEntity)
    private transferMethodRepository: Repository<TransferMethodEntity>,
  ) {}

  async findTransferMethodForTransfer(
    transfer: TransferEntity,
    transferMethodType: TransferMethodType,
  ) {
    const bankAccess = await this.bankAccessRepository.findOneBy({
      id: transfer.originBankAccessId,
    });
    const transferMethod = await this.transferMethodRepository.findOne({
      where: {
        methodType: transferMethodType,
        bankAccess: bankAccess,
      },
    });

    if (!transferMethod) {
      throw new NotFoundException(
        `Transfer method for transfer ${transfer.id} not found`,
      );
    }

    return transferMethod;
  }

  async findBankAccessTransferMethod(
    bankAccessId: number,
    transferMethodType: TransferMethodType,
  ): Promise<TransferMethodEntity> {
    const transferMethod = await this.transferMethodRepository.findOne({
      where: {
        bankAccessId,
        methodType: transferMethodType,
        state: State.ACTIVE,
      },
    });

    if (!transferMethod) {
      throw new NotFoundException(
        `Transfer method not found for bankAccess ${bankAccessId}`,
      );
    }

    return transferMethod;
  }

  async authorizeTransfer(
    transferMethod: TransferMethodEntity,
    authorizeTransferDto: AuthorizeTransferDto,
  ): Promise<CodeRequestStatus> {
    const { payload, transferMethodType } = authorizeTransferDto;

    // Handle SecurityCard codes

    if (transferMethodType === TransferMethodType.CARD) {
      const code = this.getCardCoordinates(transferMethod, payload);
      if (code) return { code, wait: false };
      throw new NotFoundException(
        `Coordinates not found for Transfer Method ${transferMethod.id}`,
      );
    }

    // Handle SMS codes

    if (transferMethodType === TransferMethodType.SMS) {
      const activeAuthorizationCode =
        await this.authorizationCodeService.findActiveForTransferMethod(
          transferMethod,
        );

      if (activeAuthorizationCode) {
        return { code: activeAuthorizationCode.code, wait: false };
      } else {
        return { code: null, wait: true };
      }
    }

    // Handle Device codes

    const deviceTypes = [
      TransferMethodType.DIGIPASS,
      TransferMethodType.MOBILE,
    ];

    if (deviceTypes.includes(transferMethodType)) {
      const activeAuthorizationCode =
        await this.authorizationCodeService.findActiveForTransferMethod(
          transferMethod,
        );

      if (activeAuthorizationCode) {
        const authCodeId = activeAuthorizationCode.id;
        await this.authorizationCodeService.findOneAndClaim(authCodeId);

        return { code: activeAuthorizationCode.code, wait: false };
      }

      const pendingAuthorizationCode =
        await this.authorizationCodeService.findPendingForTransferMethod(
          transferMethod,
        );

      if (pendingAuthorizationCode) {
        const { createdAt } = pendingAuthorizationCode;
        const maxAge = moment().subtract(2, 'minutes');
        const codeAge = moment(createdAt);

        const shouldWait = codeAge.isAfter(maxAge);
        if (shouldWait) return { code: null, wait: true };
      }

      await this.authorizationCodeService.create({
        transferMethodId: transferMethod.id,
        state: AuthorizationCodeState.PENDING,
      });

      const codeRequested = await this.deviceService.requestDeviceCode(
        transferMethod,
      );

      if (codeRequested) return { code: null, wait: true };

      throw new UnprocessableEntityException(
        `Cannot request a new device code for transferMethod ${transferMethod.id}`,
      );
    }
  }

  private getCardCoordinates(
    transferMethod: TransferMethodEntity,
    payload: SecurityCardPayload,
  ): Record<string, string> {
    const { coordinates = [] } = payload;
    const { card } = transferMethod.signingKeys;

    const mapping = {};

    coordinates.forEach((coordinate) => {
      const cardKey = coordinate.toUpperCase();
      const code = card[cardKey];
      mapping[coordinate] = code;
    });

    const invalidCodes = Object.values(mapping).some((code) => code == null);
    if (invalidCodes) return null;

    return mapping;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/feature-flag/feature-flag.service.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import * as configcat from 'configcat-node';
import { ConfigType } from '@nestjs/config';
import configCatConfig from 'src/config/configcat.config';
import { MockFeatureFlagService } from '../mocks/MockFeatureFlagService';
import { Environment } from 'src/common/enums/environment.enum';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';

@Injectable()
export class FeatureFlagService {
  private readonly logger = new Logger('FeatureFlagService');
  private service: configcat.IConfigCatClient | MockFeatureFlagService;
  private environment: Environment = process.env.NODE_ENV as Environment;

  constructor(
    @Inject(configCatConfig.KEY)
    private config: ConfigType<typeof configCatConfig>,
  ) {
    if (this.environment === 'test') {
      this.service = new MockFeatureFlagService();
    } else {
      this.service = this.getClient();
    }
  }

  private getClient(): configcat.IConfigCatClient {
    const { key } = this.config;
    return configcat.getClient(key);
  }

  async getFeatureStatus(featureFlagKey: FEATURE_FLAG): Promise<boolean> {
    const value = await this.service.getValueAsync(featureFlagKey, false);
    if (!value) this.logger.debug(`Feature ${featureFlagKey} disabled`);
    return value;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/feature-flag/feature-flag.module.ts
import { Module } from '@nestjs/common';

import { ConfigModule } from '@nestjs/config';
import configCatConfig from 'src/config/configcat.config';
import { FeatureFlagService } from './feature-flag.service';

@Module({
  imports: [ConfigModule.forFeature(configCatConfig)],
  providers: [FeatureFlagService],
  exports: [FeatureFlagService],
})
export class FeatureFlagModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/services/feature-flag/feature-flag.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { FeatureFlagService } from './feature-flag.service';
import ConfigCatConfig from 'src/config/configcat.config';

describe('given a FeatureFlagService', () => {
  let service: FeatureFlagService;

  beforeEach(async () => {
    const mockFeatureFlagService: Partial<FeatureFlagService> = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        FeatureFlagService,
        {
          provide: ConfigCatConfig.KEY,
          useValue: mockFeatureFlagService,
        },
      ],
    }).compile();

    service = module.get<FeatureFlagService>(FeatureFlagService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/middlewares/api-version.middleware.ts
import {
  Inject,
  Injectable,
  NestMiddleware,
  NotFoundException,
} from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import { NextFunction, Request, Response } from 'express';
import generalConfig from 'src/config/general.config';
import { Environment } from '../enums/environment.enum';

const API_VERSION_REGEX = /\/(?<version>v\d(?:-\w+)?)\//;

@Injectable()
export class ApiVersionMiddleware implements NestMiddleware {
  constructor(
    @Inject(generalConfig.KEY) private config: ConfigType<typeof generalConfig>,
  ) {}

  use(req: Request, res: Response, next: NextFunction) {
    if (this.config.api.env !== Environment.PRODUCTION) return next();

    const match = req.originalUrl.match(API_VERSION_REGEX);

    if (match && match.groups) {
      const version = match.groups.version;

      if (!this.config.api.version.includes(version)) {
        throw new NotFoundException(`api version ${version} was not found`);
      }
    }

    next();
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/middlewares/authorization-code.middleware.ts
import { Injectable, Inject, NestMiddleware } from '@nestjs/common';
import { AuthorizationCodeService } from 'src/models/authorization-code/authorization-code.service';
import { NextFunction, Request, Response } from 'express';

@Injectable()
export class AuthorizationCodeMiddleware implements NestMiddleware {
  @Inject(AuthorizationCodeService)
  private authorizationCodeService: AuthorizationCodeService;

  async use(req: Request, res: Response, next: NextFunction) {
    await this.authorizationCodeService.updateExpiredCodes();

    next();
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/secret.transformer.ts
import { ValueTransformer } from 'typeorm';
import { Logger } from '@nestjs/common';
import generalConfig from 'src/config/general.config';
import { EncryptionService } from 'src/utils/encryption.util';

const logger = new Logger('SecretTransformer');

export class SecretTransformer implements ValueTransformer {
  private encryptionService: EncryptionService;
  constructor(encryptionKey: string) {
    this.encryptionService = new EncryptionService(encryptionKey);
  }

  public static default(): SecretTransformer {
    const config = generalConfig();
    const encryptionKey = config.security.securityKey;

    return new SecretTransformer(encryptionKey);
  }

  public from(encryptedData?: string): string {
    if (!encryptedData) {
      return null;
    }

    try {
      const decryptedData = this.encryptionService.decryptString(encryptedData);

      return decryptedData;
    } catch (error) {
      logger.error(error);
      return null;
    }
  }

  public to(data?: string): string {
    if (!data) {
      return null;
    }
    try {
      const encryptedData = this.encryptionService.encryptString(data);
      return encryptedData;
    } catch (error) {
      logger.error(error);
      return null;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/encryption.transformer.ts
import { ValueTransformer } from 'typeorm';
import { Logger } from '@nestjs/common';
import generalConfig from 'src/config/general.config';
import { EncryptionService } from 'src/utils/encryption.util';

const logger = new Logger('EncryptionTransformer');

export default class EncryptionTransformer implements ValueTransformer {
  private encryptionService: EncryptionService;

  constructor(encryptionKey: string) {
    this.encryptionService = new EncryptionService(encryptionKey);
  }

  public static default(): EncryptionTransformer {
    const config = generalConfig();
    const encryptionKey = config.security.securityKey;

    return new EncryptionTransformer(encryptionKey);
  }

  public to(data?: any): string {
    if (data === null || data === undefined) return null;

    try {
      const dataString = JSON.stringify(data);
      const encryptedData = this.encryptionService.encrypt(dataString);
      return encryptedData;
    } catch (err) {
      logger.error('EncryptionTransformer encrypt error', err.message);
      return null;
    }
  }

  public from(encryptedData?: any): any {
    if (encryptedData === null || encryptedData === undefined) return null;

    try {
      const dataString = this.encryptionService.decrypt(encryptedData);
      const data = JSON.parse(dataString);
      return data;
    } catch (err) {
      logger.error('EncryptionTransformer decrypt error', err.message);
      return null;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/encrypt.transformer.ts
import { ValueTransformer } from 'typeorm';
import { Logger } from '@nestjs/common';
import generalConfig from 'src/config/general.config';
import { EncryptionService } from 'src/utils/encryption.util';

const logger = new Logger('EncryptTransformer');

export class EncryptTransformer implements ValueTransformer {
  private encryptionService: EncryptionService;

  constructor(encryptionKey: string) {
    this.encryptionService = new EncryptionService(encryptionKey);
  }
  public static default(): EncryptTransformer {
    const config = generalConfig();
    const encryptionKey = config.security.securityKey;

    return new EncryptTransformer(encryptionKey);
  }

  public to(data?: any): string {
    if (data === null || data === undefined) return null;
    try {
      const dataString = JSON.stringify(data);
      const encryptedData = this.encryptionService.encryptString(dataString);
      return encryptedData;
    } catch (err) {
      logger.log(`EncryptTransformer encrypt error: ${err.message}`);
      return null;
    }
  }

  public from(encryptedData?: any): any {
    if (encryptedData === null || encryptedData === undefined) return null;
    try {
      const dataString = this.encryptionService.decryptString(encryptedData);
      const data = JSON.parse(dataString);
      return data;
    } catch (err) {
      logger.log(`EncryptTransformer decrypt error: ${err.message}`);
      return null;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/encrypt.transformer.spec.ts
import { EncryptTransformer } from './encrypt.transformer';

describe('EncryptTransformer', () => {
  let encryptTransformer: EncryptTransformer;

  beforeAll(() => {
    encryptTransformer = EncryptTransformer.default();
  });

  it('should be defined', () => {
    expect(encryptTransformer).toBeDefined();
  });

  describe('to', () => {
    it('should encrypt data and return the encrypted string', () => {
      const data = { example: 'data' };
      const encryptedResult = encryptTransformer.to(data);

      expect(encryptedResult).not.toEqual(data);
    });

    it('should return null if data is null or undefined', () => {
      expect(encryptTransformer.to(null)).toBeNull();
      expect(encryptTransformer.to(undefined)).toBeNull();
    });
  });

  describe('from', () => {
    it('should decrypt data and return the parsed object', () => {
      const encryptedData = encryptTransformer.to({ example: 'data' });
      const decryptedResult = encryptTransformer.from(encryptedData);

      expect(decryptedResult).toEqual({ example: 'data' });
    });

    it('should return null if encryptedData is null or undefined', () => {
      expect(encryptTransformer.from(null)).toBeNull();
      expect(encryptTransformer.from(undefined)).toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/nanoid.transformer.ts
import { nanoid } from 'nanoid';

export class ColumnNanoidTransformer {
  to(): string {
    return nanoid();
  }
  from(data: string): string {
    return data;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/secret.transformer.spec.ts
import { SecretTransformer } from './secret.transformer';

describe('SecretTransformer', () => {
  let secretTransformer: SecretTransformer;

  beforeAll(async () => {
    secretTransformer = SecretTransformer.default();
  });

  it('should be defined', () => {
    expect(secretTransformer).toBeDefined();
  });

  describe('to', () => {
    it('should encrypt data and return the encrypted string', () => {
      const data = 'data';
      const encryptedResult = secretTransformer.to(data);

      expect(encryptedResult).not.toEqual(data);
    });

    it('should return null if data is null or undefined', () => {
      expect(secretTransformer.to(null)).toBeNull();
      expect(secretTransformer.to(undefined)).toBeNull();
    });
  });

  describe('from', () => {
    it('should decrypt data and return the decrypted string', () => {
      const encryptedData = secretTransformer.to('secret');
      const decryptedResult = secretTransformer.from(encryptedData);

      expect(decryptedResult).toEqual('secret');
    });

    it('should return null if encryptedData is null or undefined', () => {
      expect(secretTransformer.from(null)).toBeNull();
      expect(secretTransformer.from(undefined)).toBeNull();
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/decimal.transformer.spec.ts
import { ColumnNumericTransformer } from './decimal.transformer';

let columnNumericTransformer: ColumnNumericTransformer;
beforeAll(() => {
  columnNumericTransformer = new ColumnNumericTransformer();
});
describe('Common transformer decimal-method related', () => {
  it('should return a decimal from a decimal', () => {
    const a = 5.344456;

    const result = columnNumericTransformer.to(a);
    expect(result).toBe(5.344456);
  });
  it('should return a decimal from a string decimal', () => {
    const b = '5.9877';

    const resultB = columnNumericTransformer.from(b);
    expect(resultB).toBe(5.9877);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/decimal.transformer.ts
export class ColumnNumericTransformer {
  to(data: number): number {
    return data;
  }
  from(data: string): number {
    return parseFloat(data);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/transformers/credential.transformer.ts
import { Logger } from '@nestjs/common';
import generalConfig from 'src/config/general.config';
import { Credential, EncryptionService } from 'src/utils/encryption.util';

const config = generalConfig();
const encryptionKey = config.security.securityKey;

const logger = new Logger('CredentialTransformer');

export default class CredentialTransformer {
  private static encryptionService = new EncryptionService(encryptionKey);

  public static encrypt(credential: Credential): Credential {
    if (!credential) return null;

    return this.encryptionService.encryptCredential(credential);
  }

  public static decrypt(credential: Credential): Credential {
    if (!credential) return credential;

    try {
      return this.encryptionService.decryptCredential(credential);
    } catch (error) {
      logger.debug(`decryption failed: ${error}`);
      return credential;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/queries/payout.query.ts
import { QueryPayoutDto } from 'src/api/v2/payout/dto/query-payout.dto';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import {
  FindOptionsWhere,
  FindManyOptions,
  FindOperator,
  In,
  Raw,
  SelectQueryBuilder,
} from 'typeorm';
import { MysqlFullTextSearchMode } from '../enums/full-text-search.enum';
import { buildTimeQuery } from './time.query';
import { PayoutState } from '../enums/payout-state.enum';
import { TransferState } from '../enums/transfer-state.enum';

const FULLTEXTCOLUMN = {
  destinationEmail: {
    field: 'destinationEmail',
  },
  destinationAccount: {
    field: 'destinationAccount',
    mode: MysqlFullTextSearchMode.BOOLEAN_MODE,
  },
  destinationName: {
    field: 'destinationName',
    mode: MysqlFullTextSearchMode.BOOLEAN_MODE,
  },
};

const IGNORED_FILTERS = ['page', 'limit', 'sort', 'from', 'to', 'search'];

export const buildPayoutQuery = (
  query: QueryPayoutDto,
): FindManyOptions<PayoutEntity> => {
  const { sort } = query || {};

  const options: FindManyOptions<PayoutEntity> = {
    order: {
      createdAt: sort,
    },
    where: {},
  };

  const alias = PayoutEntity.name;

  options.where = {
    ...buildCompoundFindConditions(query),
    ...(query.search && {
      destinationName: Raw(
        () =>
          `(
            MATCH(${alias}.destinationName) AGAINST (:search)
            OR MATCH(${alias}.destinationEmail) AGAINST (:search)
            OR MATCH(${alias}.destinationAccount) AGAINST (:search)
            OR ${alias}.id = CAST(:search AS UNSIGNED) 
            OR ${alias}.amount = CAST(:search AS DECIMAL(18,2))
            OR ${alias}.destinationHolderId = :search
            OR JSON_EXTRACT(${alias}.metadata, "$.paymentId") = CAST(:search AS UNSIGNED)
            )`,
        {
          search: query.search,
        },
      ),
    }),
  };

  return options;
};

function buildCompoundFindConditions(
  query: QueryPayoutDto,
): FindOptionsWhere<PayoutEntity> {
  const condition: FindOptionsWhere<PayoutEntity> = {};

  // TODO: Remove the loop and add filter case by case
  for (const key in query) {
    if (key === 'metadata' || !query[key]) continue;

    if (IGNORED_FILTERS.includes(key)) continue;

    if (key in FULLTEXTCOLUMN) {
      condition[key] = getFullTextQuery(query[key], FULLTEXTCOLUMN[key].mode);
    } else if (Array.isArray(query[key])) {
      if (key === 'states') condition['state'] = In(query[key]);
      // else if query[key] is an object
    } else if (typeof query[key] === 'object') {
      if (key === 'transfer') {
        if (query.transfer.originBankCode) {
          condition['transfers.originBankCode'] = query.transfer.originBankCode;
        }
        if (query.transfer.providerId) {
          condition['transfers.providerId'] = query.transfer.providerId;
        }
      }
    } else {
      condition[key] = query[key];
    }
  }

  const filterByCreatedAt = buildTimeQuery({ from: query.from, to: query.to });

  if (filterByCreatedAt) {
    condition['createdAt'] = filterByCreatedAt;
  }

  return condition;
}

export function filterPayoutByState(
  states: PayoutState[],
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (states) {
    qb.andWhere('payout.state IN (:...states)', { states });
  }
}

export function filterPayoutByTrasferState(
  states: TransferState[],
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (states) {
    qb.andWhere('transfer.state IN (:...states)', {
      states,
    });
  }
}

export function filterPayoutByRangeDate(
  { from, to }: { from?: string; to?: string },
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (from && to) {
    qb.andWhere('payout.createdAt BETWEEN :from AND :to', { from, to });
  } else if (from && !to) {
    qb.andWhere('payout.createdAt >= :from', { from });
  } else if (!from && to) {
    qb.andWhere('payout.createdAt <= :to', { to });
  }
}

export function filterPayoutByOriginBankCode(
  originBankCode: string,
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (originBankCode) {
    qb.andWhere('transfer.originBankCode = :originBankCode', {
      originBankCode,
    });
  }
}

export function filterPayoutByCurrency(
  currency: string,
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (currency) {
    qb.andWhere('payout.currency = :currency', { currency });
  }
}

export function filterPayoutByDestinationBank(
  destinationBankCode: string,
  qb: SelectQueryBuilder<PayoutEntity>,
) {
  if (destinationBankCode) {
    qb.andWhere('transfer.destinationBankCode = :destinationBankCode', {
      destinationBankCode,
    });
  }
}

function getFullTextQuery(
  field: string,
  searchValue: string,
  mode = '',
): FindOperator<any> {
  if (mode === MysqlFullTextSearchMode.BOOLEAN_MODE)
    /*The @ is an operator used in boolean mode*/
    searchValue = searchValue.replace('@', '');

  return Raw(() => `MATCH(${field}) AGAINST ('${searchValue}*' ${mode || ''})`);
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/queries/inSimpleArray.query.ts
import { Raw } from 'typeorm';

/**
 * InSimpleArray Function
 *
 * This function generates a TypeORM query to find the position of a value in a simple array using FIND_IN_SET.
 *
 * @param value - The value to search for in the array.
 * @returns TypeORM raw query using FIND_IN_SET.
 *
 * @example
 * InSimpleArray('exampleValue');
 * // Output: Raw((alias) => `FIND_IN_SET('exampleValue', ${alias})`);
 */
export function InSimpleArray(value: string) {
  return Raw((alias) => `FIND_IN_SET('${value}', ${alias})`);
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/queries/inSimpleArray.query.spec.ts
import { InSimpleArray } from './inSimpleArray.query';

describe('InSimpleArray Function', () => {
  it('should generate a TypeORM raw query using FIND_IN_SET', () => {
    const value = 'exampleValue';
    const result = InSimpleArray(value);

    expect(result.getSql('alias')).toContain(`FIND_IN_SET('${value}', alias)`);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/queries/accountStatement.query.ts
import { FindManyOptions, FindOneOptions } from 'typeorm';

import { QueryAccountStatementQueryDto } from 'src/api/v2/account-statement/dto/query-account-statement.dto';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { buildTimeQuery } from './time.query';

export const buildAccountStatementQuery = (
  query: QueryAccountStatementQueryDto,
): FindOneOptions<AccountStatementEntity> => {
  const {
    originBankAccountIdentifier,
    from,
    to,
    amount,
    destinationBankCode,
    destinationHolderId,
  } = query;
  const filterByDate = buildTimeQuery({ from, to });

  const options: FindManyOptions<AccountStatementEntity> = {
    relations: ['accountStatementJob'],
    order: {
      date: DESCENDING_ORDER,
    },
    where: {
      ...(originBankAccountIdentifier && { originBankAccountIdentifier }),
    },
  };

  if (amount) options.where['amount'] = amount;
  if (destinationBankCode)
    options.where['destinationBankCode'] = destinationBankCode;
  if (destinationHolderId)
    options.where['destinationHolderId'] = destinationHolderId;
  if (filterByDate) options.where['date'] = filterByDate;

  return options;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/queries/time.query.ts
import {
  LessThanOrEqual,
  MoreThanOrEqual,
  Between,
  FindOperator,
} from 'typeorm';

type TimeRange = {
  from?: string;
  to?: string;
};

export const buildTimeQuery = (range?: TimeRange): FindOperator<Date> => {
  const { from, to } = range;
  const startDate = from && new Date(from);
  const endDate = to && new Date(to);

  if (from && to) return Between(startDate, endDate);
  if (from) return MoreThanOrEqual(startDate);
  if (to) return LessThanOrEqual(endDate);
  return;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/state-machine/base-transition.ts
import { Transition } from './state-machine.interfaces';

export default class BaseTransition<S> implements Transition<S> {
  public name: string;
  public from: S[];
  public to: S;

  constructor(name: string, from: S[], to: S) {
    this.name = name;
    this.from = from;
    this.to = to;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/state-machine/state-machine-errors.ts
import { Entity } from './state-machine.interfaces';

export class TransitionNotAllowedError<S> extends Error {
  constructor(entity: Entity<S>, destinationState: S) {
    const entityName = entity.constructor.name;
    const originState = entity.state;
    const message = `${entityName} transition from '${originState}' to '${destinationState}' is not allowed`;
    super(message);
    this.name = 'TransitionNotAllowedError';
  }
}

export class TransitionMissingError<S> extends Error {
  constructor(destinationState: S) {
    const message = `transition to '${destinationState}' does not exist`;
    super(message);
    this.name = 'TransitionMissingError';
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/state-machine/state-machine.interfaces.ts
export interface Transition<S> {
  name: string;
  from: S[];
  to: S;
}

export interface Entity<S> {
  state: S;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/state-machine/base-state-machine.ts
import { TransitionNotAllowedError } from './state-machine-errors';
import { Entity, Transition } from './state-machine.interfaces';

export default class BaseStateMachine<E extends Entity<S>, S> {
  transitions: Transition<S>[];

  constructor(transitions: Transition<S>[]) {
    this.transitions = transitions;
  }

  canTransit(entity: E, destinationState: S): boolean {
    const transition = this.findTransitionForEntity(entity, destinationState);
    return transition != null;
  }

  updateState(entity: E, destinationState: S): E {
    entity.state = destinationState;
    return entity;
  }

  transitTo(entity: E, destinationState: S): E {
    const canTransit = this.canTransit(entity, destinationState);
    if (!canTransit) {
      throw new TransitionNotAllowedError(entity, destinationState);
    }

    const result = this.updateState(entity, destinationState);
    return result;
  }

  applyTransition(entity: E, transition: Transition<S>): E {
    const updatedEntity = this.transitTo(entity, transition.to);
    return updatedEntity;
  }

  transitionsFrom(state: S): Transition<S>[] {
    return this.transitions.filter((transition) => {
      return transition.from.includes(state);
    });
  }

  transitionsTo(state: S): Transition<S>[] {
    return this.transitions.filter((transition) => {
      return transition.to === state;
    });
  }

  findTransition(originState: S, destinationState: S): Transition<S> {
    return this.transitions.find((transition) => {
      const from = transition.from.includes(originState);
      const to = transition.to === destinationState;
      return from && to;
    });
  }

  findTransitionByName(name: string): Transition<S> {
    return this.transitions.find((transition) => {
      return transition.name === name;
    });
  }

  findTransitionForEntity(entity: E, destinationState: S): Transition<S> {
    const originState = entity.state;
    const transition = this.findTransition(originState, destinationState);
    return transition;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/state-machine/base-state-machine.spec.ts
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import PayoutTransitions from 'src/models/payout/payout.transitions';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import TransferTransitions from 'src/models/transfer/transfer.transitions';
import { PayoutState } from '../enums/payout-state.enum';
import { TransferState } from '../enums/transfer-state.enum';
import BaseStateMachine from './base-state-machine';

describe('given a BaseEstateMachine for payout', () => {
  const payoutStateMachine = new BaseStateMachine(PayoutTransitions);
  const payout = new PayoutEntity();
  describe('when a user use canTransit', () => {
    it('should return true if payout state is PENDING to CANCELED', () => {
      payout.state = PayoutState.PENDING;
      const result = payoutStateMachine.canTransit(
        payout,
        PayoutState.CANCELED,
      );
      expect(result).toBe(true);
    });
    it('should return true if payout state is PENDING to PROCESSING', () => {
      payout.state = PayoutState.PENDING;
      const result = payoutStateMachine.canTransit(
        payout,
        PayoutState.PROCESSING,
      );
      expect(result).toBe(true);
    });
    it('should return true if payout state is PENDING to FAILED', () => {
      payout.state = PayoutState.PENDING;
      const result = payoutStateMachine.canTransit(payout, PayoutState.FAILED);
      expect(result).toBe(true);
    });
    it('should return true if payout state is PROCESSING to FAILED', () => {
      payout.state = PayoutState.PROCESSING;
      const result = payoutStateMachine.canTransit(payout, PayoutState.FAILED);
      expect(result).toBe(true);
    });
    it('should return true if payout state is PROCESSING to CANCELED', () => {
      payout.state = PayoutState.PROCESSING;
      const result = payoutStateMachine.canTransit(
        payout,
        PayoutState.CANCELED,
      );
      expect(result).toBe(true);
    });
    it('should return true if payout state is PROCESSING to COMPLETED', () => {
      payout.state = PayoutState.PROCESSING;
      const result = payoutStateMachine.canTransit(
        payout,
        PayoutState.COMPLETED,
      );
      expect(result).toBe(true);
    });
    it('should return false if payout state is COMPLETED any other state', () => {
      payout.state = PayoutState.COMPLETED;
      const resultCOMPLETED = payoutStateMachine.canTransit(
        payout,
        PayoutState.COMPLETED,
      );
      expect(resultCOMPLETED).toBe(false);
      const resultPENDING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PENDING,
      );
      expect(resultPENDING).toBe(false);
      const resultPROCESSING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PROCESSING,
      );
      expect(resultPROCESSING).toBe(false);
      const resultCANCELED = payoutStateMachine.canTransit(
        payout,
        PayoutState.CANCELED,
      );
      expect(resultCANCELED).toBe(false);
      const resultFAILED = payoutStateMachine.canTransit(
        payout,
        PayoutState.FAILED,
      );
      expect(resultFAILED).toBe(false);
    });
    it('should return false if payout state is CANCELED any other state', () => {
      payout.state = PayoutState.CANCELED;
      const resultCOMPLETED = payoutStateMachine.canTransit(
        payout,
        PayoutState.COMPLETED,
      );
      expect(resultCOMPLETED).toBe(false);
      const resultPENDING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PENDING,
      );
      expect(resultPENDING).toBe(false);
      const resultPROCESSING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PROCESSING,
      );
      expect(resultPROCESSING).toBe(false);
      const resultCANCELED = payoutStateMachine.canTransit(
        payout,
        PayoutState.CANCELED,
      );
      expect(resultCANCELED).toBe(false);
      const resultFAILED = payoutStateMachine.canTransit(
        payout,
        PayoutState.FAILED,
      );
      expect(resultFAILED).toBe(false);
    });
    it('should return false if payout state is FAILED any other state', () => {
      payout.state = PayoutState.FAILED;
      const resultCOMPLETED = payoutStateMachine.canTransit(
        payout,
        PayoutState.COMPLETED,
      );
      expect(resultCOMPLETED).toBe(false);
      const resultPENDING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PENDING,
      );
      expect(resultPENDING).toBe(false);
      const resultPROCESSING = payoutStateMachine.canTransit(
        payout,
        PayoutState.PROCESSING,
      );
      expect(resultPROCESSING).toBe(false);
      const resultCANCELED = payoutStateMachine.canTransit(
        payout,
        PayoutState.CANCELED,
      );
      expect(resultCANCELED).toBe(true);
      const resultFAILED = payoutStateMachine.canTransit(
        payout,
        PayoutState.FAILED,
      );
      expect(resultFAILED).toBe(false);
    });
  });
  describe('when a user use transitTo', () => {
    it('should return an updated payout state from PENDING to PROCESSING|CANCELED|FAILED', () => {
      payout.state = PayoutState.PENDING;
      const statesArray = [
        //PayoutState.PENDING,
        PayoutState.PROCESSING,
        //PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        const result = payoutStateMachine.transitTo(payout, state);
        expect(result.state).toBe(state);
        payout.state = PayoutState.PENDING;
      }
    });
    it('should return an updated payout state from PROCESSING to COMPLETED|CANCELED|FAILED', () => {
      payout.state = PayoutState.PROCESSING;
      const statesArray = [
        //PayoutState.PENDING,
        //PayoutState.PROCESSING,
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        const result = payoutStateMachine.transitTo(payout, state);
        expect(result.state).toBe(state);
        payout.state = PayoutState.PROCESSING;
      }
    });
    it('should return fail if transitTo is not permitted', () => {
      //from COMPLETED|FAILED|CANCELED
      payout.state = PayoutState.COMPLETED;
      const statesArray = [
        PayoutState.PENDING,
        PayoutState.PROCESSING,
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        // PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        try {
          payoutStateMachine.transitTo(payout, state);
        } catch (error) {
          expect(error.message).toBe(
            `PayoutEntity transition from 'completed' to '${state.toLowerCase()}' is not allowed`,
          );
        }
      }
      payout.state = PayoutState.FAILED;
      for (const state of statesArray) {
        try {
          payoutStateMachine.transitTo(payout, state);
        } catch (error) {
          expect(error.message).toBe(
            `PayoutEntity transition from 'failed' to '${state.toLowerCase()}' is not allowed`,
          );
        }
      }
      payout.state = PayoutState.CANCELED;
      for (const state of statesArray) {
        try {
          payoutStateMachine.transitTo(payout, state);
        } catch (error) {
          expect(error.message).toBe(
            `PayoutEntity transition from 'canceled' to '${state.toLowerCase()}' is not allowed`,
          );
        }
      }
    });
  });
  describe('when a user use findTransitionForEntity', () => {
    it('should return a Transition starting in PENDING', () => {
      payout.state = PayoutState.PENDING;
      const statesArray = [
        //PayoutState.PENDING,
        PayoutState.PROCESSING,
        //PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        const result = payoutStateMachine.findTransitionForEntity(
          payout,
          state,
        );
        expect(result).toStrictEqual(expect.any(Object));
      }
    });
    it('should return a Transition starting in PROCESSING', () => {
      payout.state = PayoutState.PROCESSING;
      const statesArray = [
        //PayoutState.PENDING,
        //PayoutState.PROCESSING,
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        const result = payoutStateMachine.findTransitionForEntity(
          payout,
          state,
        );
        expect(result).toStrictEqual(expect.any(Object));
      }
    });
    it('should return a undefined if cant`t do transition', () => {
      //start COMPLETED
      payout.state = PayoutState.COMPLETED;
      const statesArray = [
        PayoutState.PENDING,
        PayoutState.PROCESSING,
        PayoutState.COMPLETED,
        PayoutState.CANCELED,
        PayoutState.FAILED,
      ];
      for (const state of statesArray) {
        const result = payoutStateMachine.findTransitionForEntity(
          payout,
          state,
        );
        expect(result).toStrictEqual(undefined);
      }
      //change to CANCELED
      payout.state = PayoutState.CANCELED;
      for (const state of statesArray) {
        const result = payoutStateMachine.findTransitionForEntity(
          payout,
          state,
        );
        expect(result).toStrictEqual(undefined);
      }
    });
  });
});

describe('given a BaseEstateMachine for transfer', () => {
  const transferStateMachine = new BaseStateMachine(TransferTransitions);
  const transfer = new TransferEntity();
  describe('when a user use canTransit', () => {
    it('should return true if transfer state is ASSIGNED to PROCESSING', () => {
      transfer.state = TransferState.ASSIGNED;
      const result = transferStateMachine.canTransit(
        transfer,
        TransferState.PROCESSING,
      );
      expect(result).toBe(true);
    });
    it('should return false if transfer state is ASSIGNED to non permitted state', () => {
      transfer.state = TransferState.ASSIGNED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.COMPLETED,
        TransferState.ASSIGNED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(false);
      }
    });
    it('should return false if transfer state is PENDING to non permitted state', () => {
      transfer.state = TransferState.PENDING;
      const transferStates = [
        TransferState.PENDING,
        TransferState.PROCESSING,
        TransferState.COMPLETED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(false);
      }
    });
    it('should return true if transfer state is PENDING to ASSIGNED|CANCELED', () => {
      transfer.state = TransferState.PENDING;
      const transferStates = [TransferState.ASSIGNED, TransferState.CANCELED];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(true);
      }
    });
    it('should return true if transfer state is ASSIGNED to PROCESSING|FAILED|CANCELED', () => {
      transfer.state = TransferState.ASSIGNED;
      const transferStates = [
        TransferState.PROCESSING,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(true);
      }
    });
    it('should return true if transfer state is PROCESSING to COMPLETED|FAILED|CANCELED', () => {
      transfer.state = TransferState.PROCESSING;
      const transferStates = [
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(true);
      }
    });
    it('should return false if transfer state is COMPLETED to any other state', () => {
      transfer.state = TransferState.COMPLETED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(false);
      }
    });
    it('should return false if transfer state is FAILED to any other state except COMPLETED', () => {
      transfer.state = TransferState.FAILED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(false);
      }
    });
    it('should return false if transfer state is CANCELED to any other state', () => {
      transfer.state = TransferState.CANCELED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.canTransit(transfer, state);
        expect(result).toBe(false);
      }
    });
  });
  describe('when a user use transitTo', () => {
    it('should return an updated transfer state from PENDING to ASSIGNED|CANCELED', () => {
      transfer.state = TransferState.PENDING;
      const transferStates = [TransferState.ASSIGNED, TransferState.CANCELED];
      for (const state of transferStates) {
        const result = transferStateMachine.transitTo(transfer, state);
        expect(result.state).toBe(state);
        transfer.state = TransferState.PENDING;
      }
    });
    it('should return an updated transfer state from ASSIGNED to FAILED|CANCELED|PROCESSING', () => {
      transfer.state = TransferState.ASSIGNED;
      const transferStates = [
        TransferState.FAILED,
        TransferState.CANCELED,
        TransferState.PROCESSING,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.transitTo(transfer, state);
        expect(result.state).toBe(state);
        transfer.state = TransferState.ASSIGNED;
      }
    });
    it('should return an updated transfer state from ASSIGNED to PROCESSING', () => {
      transfer.state = TransferState.ASSIGNED;
      const transferStates = [TransferState.PROCESSING];
      for (const state of transferStates) {
        const result = transferStateMachine.transitTo(transfer, state);
        expect(result.state).toBe(state);
        transfer.state = TransferState.ASSIGNED;
      }
    });
    it('should return an updated transfer state from PROCESSING to COMPLETED', () => {
      transfer.state = TransferState.PROCESSING;
      const transferStates = [TransferState.COMPLETED];
      for (const state of transferStates) {
        const result = transferStateMachine.transitTo(transfer, state);
        expect(result.state).toBe(state);
        transfer.state = TransferState.PROCESSING;
      }
    });
    it('should return an updated transfer state from PROCESSING to COMPLETED|FAILED|CANCELED', () => {
      transfer.state = TransferState.PROCESSING;
      const transferStates = [
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        const result = transferStateMachine.transitTo(transfer, state);
        expect(result.state).toBe(state);
        transfer.state = TransferState.PROCESSING;
      }
    });
    it('should return a TransitionNotAllowedError from COMPLETED to any state', () => {
      transfer.state = TransferState.COMPLETED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        try {
          transferStateMachine.transitTo(transfer, state);
        } catch (error) {
          expect(error.message).toBe(
            `TransferEntity transition from 'completed' to '${state}' is not allowed`,
          );
        }
      }
    });
    it('should return a TransitionNotAllowedError from FAILED to any state except COMPLETED', () => {
      transfer.state = TransferState.FAILED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
      ];
      for (const state of transferStates) {
        try {
          transferStateMachine.transitTo(transfer, state);
        } catch (error) {
          expect(error.message).toBe(
            `TransferEntity transition from 'failed' to '${state}' is not allowed`,
          );
        }
      }
    });
    it('should return a TransitionNotAllowedError from CANCELED to any state', () => {
      transfer.state = TransferState.CANCELED;
      const transferStates = [
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.COMPLETED,
        TransferState.FAILED,
        TransferState.CANCELED,
      ];
      for (const state of transferStates) {
        try {
          transferStateMachine.transitTo(transfer, state);
        } catch (error) {
          expect(error.message).toBe(
            `TransferEntity transition from 'canceled' to '${state}' is not allowed`,
          );
        }
      }
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../enums/user-role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import RequestWithUser from 'src/services/auth/requestWithUser.interface';

export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request: RequestWithUser = ctx.switchToHttp().getRequest();
    const user = request.user;
    return data ? user?.[data] : user;
  },
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/exclude-from-logs.decorator.ts
import 'reflect-metadata';

export const OBFUSCATE_KEY = 'obfuscate';
export const OBFUSCATE_VALUE = '[OBFUSCATED]';
export const ExcludeFromLogs = () => {
  return function (target: any, propertyName: string) {
    Reflect.defineMetadata(OBFUSCATE_KEY, true, target, propertyName);
  };
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/is-not-thomas-provider.validator.ts
import { registerDecorator, ValidationOptions } from 'class-validator';
import { ProviderType } from 'src/common/enums/provider-type.enum';

/**
 * Decorator that validates whether the provided value is Thomas provider
 * and disallows it in a production environment.
 *
 * @param {ValidationOptions} [validationOptions] - Options for the validation decorator.
 * @returns {PropertyDecorator} Property decorator function.
 *
 * @example
 * class ExampleDto {
 *   @IsNotThomasProvider()
 *   providerType: ProviderType;
 * }
 */
export function IsNotThomasProvider(validationOptions?: ValidationOptions) {
  return function (object: unknown, propertyName: string) {
    registerDecorator({
      name: 'isNotThomasProvider',
      target: object.constructor,
      propertyName: propertyName,
      options: {
        message: `Thomas provider is not allowed for production environment`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const isProduction = process.env.NODE_ENV === 'production';

          return !(isProduction && value === ProviderType.Thomas);
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/isUTCDateString.validator.spec.ts
import { IsUTCDateString } from './isUTCDateString.validator';
import { validate } from 'class-validator';

class TestClass {
  @IsUTCDateString()
  date: string;
}

describe('IsUTCDateString Decorator', () => {
  it('should validate a valid UTC date string', async () => {
    const instance = new TestClass();
    instance.date = '2023-08-14T12:34:56.000Z';

    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });

  it('should not validate an invalid UTC date string', async () => {
    const instance = new TestClass();
    instance.date = '2023-08-14T12:34:56.000+05:00';

    const errors = await validate(instance);

    expect(errors.length).toBe(1);
    expect(errors[0].constraints).toEqual({
      isUTCDateString:
        'date must be a UTC date with the ISO 8601 format: YYYY-MM-DDTHH:mm:ss.sssZ',
    });
  });

  it('should not validate if date does not match the UTC ISO 8601 format', async () => {
    const instance = new TestClass();
    instance.date = '2023-08-14';

    const errors = await validate(instance);

    expect(errors.length).toBe(1);
    expect(errors[0].constraints).toEqual({
      isUTCDateString:
        'date must be a UTC date with the ISO 8601 format: YYYY-MM-DDTHH:mm:ss.sssZ',
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/isUTCDateString.validator.ts
import { registerDecorator, ValidationOptions } from 'class-validator';

export function IsUTCDateString(validationOptions?: ValidationOptions) {
  return function (object: unknown, propertyName: string) {
    registerDecorator({
      name: 'isUTCDateString',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be a UTC date with the ISO 8601 format: YYYY-MM-DDTHH:mm:ss.sssZ`,
        ...validationOptions,
      },
      validator: {
        validate(date: string) {
          const regex = new RegExp(
            /^(19|20)\d\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01]\d|2[0-3]):[0-5]\d:[0-5]\d\.(\d{3}Z)$/,
          );

          return typeof date === 'string' && regex.test(date);
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/index.ts
export * from './days-between-range.validator';
export * from './greater-than-or-equal-date.validator';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/exclude-deleted-state.decorator.ts
import {
  registerDecorator,
  ValidationOptions,
  ValidationArguments,
} from 'class-validator';
import { State } from 'src/common/enums/state.enum';

export function ExcludeDeletedState(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'excludeDeletedState',
      target: object.constructor,
      propertyName: propertyName,
      options: {
        ...validationOptions,
        message: `${propertyName} cannot be '${State.DELETED}'`,
      },
      validator: {
        validate(value: any, _args: ValidationArguments) {
          return value !== State.DELETED;
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/exclude-deleted-state.decorator.spec.ts
import { ExcludeDeletedState } from './exclude-deleted-state.decorator';
import { validate } from 'class-validator';
import { State } from 'src/common/enums/state.enum';

class TestClass {
  @ExcludeDeletedState()
  state: State;
}

describe('Given an ExcludeDeletedState decorator', () => {
  describe('When a class has a property decorated with it', () => {
    it('should not fail if state is not "DELETED"', async () => {
      const testInstance = new TestClass();
      testInstance.state = State.ACTIVE;

      const errors = await validate(testInstance);

      expect(errors.length).toBe(0);
    });

    it('should fail if state is "DELETED"', async () => {
      const testInstance = new TestClass();
      testInstance.state = State.DELETED;

      const errors = await validate(testInstance);

      expect(errors.length).toBe(1);
      expect(errors[0].constraints).toEqual({
        excludeDeletedState: `state cannot be '${State.DELETED}'`,
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/days-between-range.validator.spec.ts
import { DaysBetweenRange } from './days-between-range.validator'; // Importa tu decorador
import { validate } from 'class-validator';

class DateRange {
  @DaysBetweenRange(30, 'endDate')
  startDate: Date;

  endDate: Date;
}

class StringDateRange {
  @DaysBetweenRange(30, 'endDate')
  startDate: string;

  endDate: string;
}

describe('Given a DaysBetweenRange decorator', () => {
  describe('When there is a class with two date properties used to represent a range', () => {
    describe('And the properties are instances of the Date class', () => {
      it('should not fail if the days between the date range does not exceed the limit', async () => {
        const dateRange = new DateRange();
        dateRange.startDate = new Date('2023-08-01');
        dateRange.endDate = new Date('2023-08-15');

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should fail if the days between the date range exceed the limit', async () => {
        const dateRange = new DateRange();
        dateRange.startDate = new Date('2023-06-15');
        dateRange.endDate = new Date('2023-08-08');

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          daysBetweenRange:
            'startDate must have a maximum difference of 30 days from endDate',
        });
      });
    });

    describe('And the type of the properties are strings', () => {
      it('should not fail if the days between the date range does not exceed the limit', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = '2023-08-01';
        dateRange.endDate = '2023-08-15';

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should fail if the days between the date range exceed the limit', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = '2023-06-15';
        dateRange.endDate = '2023-08-08';

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          daysBetweenRange:
            'startDate must have a maximum difference of 30 days from endDate',
        });
      });

      it('should fail if the days between the date range exceed the limit for ISO Date string properties', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = new Date(
          '2023-06-08T12:48:00.000Z',
        ).toISOString();
        dateRange.endDate = new Date('2023-08-08T14:48:00.000Z').toISOString();

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          daysBetweenRange:
            'startDate must have a maximum difference of 30 days from endDate',
        });
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/greater-than-or-equal.validator.spec.ts
import { IsGreaterThanOrEqualDate } from './greater-than-or-equal-date.validator';
import { validate } from 'class-validator';

class DateRange {
  startDate: Date;

  @IsGreaterThanOrEqualDate('startDate')
  endDate: Date;
}

class StringDateRange {
  startDate: string;

  @IsGreaterThanOrEqualDate('startDate')
  endDate: string;
}

describe('Given a IsGreaterThanOrEqualDate decorator', () => {
  describe('When there is a class with two date properties used for represent a range ', () => {
    describe('And the properties are instance of the Date class', () => {
      it('should not fail if startDate is less than endDate', async () => {
        const dateRange = new DateRange();
        dateRange.startDate = new Date('2023-08-01');
        dateRange.endDate = new Date('2023-08-15');

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should not fail if startDate is equal than endDate', async () => {
        const dateRange = new DateRange();
        dateRange.startDate = new Date('2023-08-15');
        dateRange.endDate = new Date('2023-08-15');

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should fail if startDate is greater than endDate', async () => {
        const dateRange = new DateRange();
        dateRange.startDate = new Date('2023-08-15');
        dateRange.endDate = new Date('2023-08-08');

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          isGreaterOrEqualsDate:
            'endDate must be greater than or equal startDate',
        });
      });
    });
    describe('And the type of the properties are string', () => {
      it('should not fail if startDate is less than endDate', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = '2023-08-01';
        dateRange.endDate = '2023-08-15';

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should fail if startDate is greater than endDate', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = '2023-08-15';
        dateRange.endDate = '2023-08-08';

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          isGreaterOrEqualsDate:
            'endDate must be greater than or equal startDate',
        });
      });
      it('should not fail if startDate is less than endDate for ISO Date string properties', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = new Date(
          '2023-08-08T12:48:00.000Z',
        ).toISOString();
        dateRange.endDate = new Date('2023-08-08T14:48:00.000Z').toISOString();

        const errors = await validate(dateRange);

        expect(errors.length).toBe(0);
      });

      it('should fail if startDate is greater than endDate for ISO Date string properties', async () => {
        const dateRange = new StringDateRange();
        dateRange.startDate = new Date(
          '2023-08-08T18:48:00.000Z',
        ).toISOString();
        dateRange.endDate = new Date('2023-08-08T14:48:00.000Z').toISOString();

        const errors = await validate(dateRange);

        expect(errors.length).toBe(1);
        expect(errors[0].constraints).toEqual({
          isGreaterOrEqualsDate:
            'endDate must be greater than or equal startDate',
        });
      });
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/is-not-thomas-provider.validator.spec.ts
import { IsEnum, validate } from 'class-validator';
import { IsNotThomasProvider } from './is-not-thomas-provider.validator';
import { ProviderType } from 'src/common/enums/provider-type.enum';

describe('IsNotThomasProvider Decorator', () => {
  class TestClass {
    @IsNotThomasProvider()
    @IsEnum(ProviderType)
    providerType: ProviderType;
  }

  it('should allow Thomas provider in non-production environment', async () => {
    const testObject = new TestClass();
    testObject.providerType = ProviderType.Thomas;

    const errors = await validate(testObject);

    expect(errors.length).toBe(0);
  });

  it('should allow any provider different from Thomas provider in production environment', async () => {
    process.env.NODE_ENV = 'production';
    const testObject = new TestClass();
    testObject.providerType = ProviderType.Minka;

    const errors = await validate(testObject);

    expect(errors.length).toBe(0);
    process.env.NODE_ENV = 'test';
  });

  it('should disallow Thomas provider in production environment', async () => {
    process.env.NODE_ENV = 'production';

    const testObject = new TestClass();
    testObject.providerType = ProviderType.Thomas;

    const errors = await validate(testObject);

    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0]).toHaveProperty('constraints.isNotThomasProvider');
    expect(errors[0].constraints).toEqual({
      isNotThomasProvider: `Thomas provider is not allowed for production environment`,
    });
    process.env.NODE_ENV = 'test';
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/days-between-range.validator.ts
import {
  registerDecorator,
  ValidationArguments,
  ValidationOptions,
} from 'class-validator';
import moment = require('moment');

export function DaysBetweenRange(
  days: number,
  property = 'startDate',
  validationOptions?: ValidationOptions,
) {
  return function (object: unknown, propertyName: string) {
    registerDecorator({
      name: 'daysBetweenRange',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [property],
      options: {
        ...validationOptions,
        message: `${propertyName} must have a maximum difference of ${days} days from ${property}`,
      },
      validator: {
        validate(date: Date | string, args: ValidationArguments) {
          const comparisonDate = args.object[property];
          const diff = moment(date).diff(moment(comparisonDate), 'days');
          return Math.abs(diff) <= days;
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/has-date-format.ts
import { registerDecorator, ValidationOptions } from 'class-validator';
import moment = require('moment');

export function HasDateFormat(
  format = 'YYYY-MM-DD',
  validationOptions?: ValidationOptions,
) {
  return function (object: unknown, propertyName: string) {
    registerDecorator({
      name: 'hasDateFormat',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must follow the format: ${format}`,
        ...validationOptions,
      },
      validator: {
        validate(date: string) {
          return moment(date, format, true).isValid();
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/greater-than-or-equal-date.validator.ts
import {
  registerDecorator,
  ValidationArguments,
  ValidationOptions,
} from 'class-validator';

export function IsGreaterThanOrEqualDate(
  property: string,
  validationOptions?: ValidationOptions,
) {
  return function (object: unknown, propertyName: string) {
    registerDecorator({
      name: 'isGreaterOrEqualsDate',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [property],
      options: {
        ...validationOptions,
        message: `${propertyName} must be greater than or equal ${property}`,
      },
      validator: {
        validate(date: Date, args: ValidationArguments) {
          const comparisonDate = new Date(args.object[property]);

          const parsedDate = new Date(date);

          return parsedDate >= comparisonDate;
        },
      },
    });
  };
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/custom-validators/has-date-format.spec.ts
import { validate } from 'class-validator';
import { HasDateFormat } from './has-date-format';

const DATE_FORMAT = 'YYYY-MM-DD';

class TestClass {
  @HasDateFormat(DATE_FORMAT)
  date: string;
}

describe('HasDateFormat custom class-validator Decorator', () => {
  it("shouldn't return any error if date has the correct format", async () => {
    const instance = new TestClass();
    instance.date = '2023-08-14';

    const errors = await validate(instance);

    expect(errors.length).toBe(0);
  });

  it("should return an error if date hasn't the correct format", async () => {
    const instance = new TestClass();
    instance.date = '2023-08-14T12:34:56.000+05:00';

    const errors = await validate(instance);

    expect(errors.length).toBe(1);
    expect(errors[0].constraints).toEqual({
      hasDateFormat: `date must follow the format: ${DATE_FORMAT}`,
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/merchantId.decorator.ts
import {
  BadRequestException,
  createParamDecorator,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import RequestWithUser from 'src/services/auth/requestWithUser.interface';
import { UserRole } from '../enums/user-role.enum';

interface DataOptions {
  required?: boolean;
}

/**
 * A decorator for extracting the merchant ID based on dynamic criteria.
 * If the user as User role Admin, it would return its merchant id
 * If the user as ApiKey role Admin or role Super, it would return its merchant id
 * If merchant ID its given from params, it will return merchant ID from params
 * And finally If merchant ID its given from query params, it will return merchant ID from query params
 * @param {ExecutionContext} ctx - The execution context of the current request.
 * @throws {BadRequestException} if merchant ID its given in params and query params
 * @throws {BadRequestException} if merchant ID its required but not given in params or query params
 * @throws {ForbiddenException} if merchantId should be returned by user type but does not exist
 * @returns {number} The extracted merchant ID.
 */
export const MerchantId = createParamDecorator(
  (data?: DataOptions, ctx?: ExecutionContext) => {
    const { required } = data ?? { required: false };
    const request: RequestWithUser = ctx.switchToHttp().getRequest();
    const user = request.user;
    const { role, merchantId: userMerchantId } = user;

    const filterByApiKey = typeof user['key'] === 'string';
    const filterByAdminRole = role === UserRole.ADMIN;
    const filteredByUserMerchant = filterByAdminRole || filterByApiKey;

    if (filteredByUserMerchant && userMerchantId === null) {
      throw new ForbiddenException('Missing merchant id');
    }
    if (filteredByUserMerchant) return userMerchantId;

    const queryMerchant = request?.query?.merchantId;
    const paramsMerchant = request?.params?.merchantId;

    if (queryMerchant && paramsMerchant) throw new BadRequestException();
    if (paramsMerchant) return Number(paramsMerchant);
    if (queryMerchant) return Number(queryMerchant);
    if (required) throw new BadRequestException('Missing merchant id');
  },
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/account-type.enum.ts
export enum AccountType {
  CURRENT = 'current',
  SAVINGS = 'savings',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/payout-event.enum.ts
export enum PayoutEvent {
  CREATED = 'payout.created',
  PROCESSING = 'payout.processing',
  COMPLETED = 'payout.completed',
  CANCELED = 'payout.canceled',
  FAILED = 'payout.failed',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/country-name.enum.ts
export enum CountryName {
  CHILE = 'Chile',
  COLOMBIA = 'Colombia',
  MEXICO = 'México',
  PERU = 'Perú',
  BRAZIL = 'Brasil',
  ARGENTINA = 'Argentina',
  BOLIVIA = 'Bolivia',
  ECUADOR = 'Ecuador',
  URUGUAY = 'Uruguay',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/feature-flag.enum.ts
export enum FEATURE_FLAG {
  CAN_EVALUATE_MERCHANT_LIMIT = 'merchantLimits',
  CAN_APPLY_AUTOMATED_ACTION = 'automatedActions',
  CAN_USE_NEW_PAYOUT_CREATION = 'newPayoutCreation',
  CAN_USE_NEW_PAYOUT_FLOW = 'newPayoutFlow',
  CAN_USE_NEW_PAYOUT_REASSIGN = 'newPayoutReassign',
  CAN_USE_NEW_PAYOUT_CANCELATION = 'newPayoutCancelation',
  CAN_USE_NEW_PAYOUT_COMPLETION = 'newPayoutCompletion',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/shinkansen-payout-state.enum.ts
export enum ShinkansenPayoutStatus {
  OK = 'ok',
  ERROR = 'error',
  PENDING = 'pending',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/environment.enum.ts
export enum Environment {
  DEVELOPMENT = 'development',
  TEST = 'test',
  STAGING = 'staging',
  PRODUCTION = 'production',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/provider-type.enum.ts
export enum ProviderType {
  ScraperCG = 'scraperCG',
  ScraperPW = 'scraperPW',
  Minka = 'minka',
  Liquido = 'liquido',
  Shinkansen = 'shinkansen',
  Thomas = 'thomas', // This provider is a fakeProvider
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/webhook-endpoint-event.enum.ts
export enum WebhookEvent {
  PAYOUT_CREATED = 'payout.created',
  PAYOUT_PROCESSING = 'payout.processing',
  PAYOUT_COMPLETED = 'payout.completed',
  PAYOUT_CANCELED = 'payout.canceled',
  PAYOUT_FAILED = 'payout.failed',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transfer-state.enum.ts
export enum TransferState {
  PENDING = 'pending',
  ASSIGNED = 'assigned',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELED = 'canceled',
}

export const UNFINISHED_MINKA_STATE = [
  TransferState.ASSIGNED,
  TransferState.PROCESSING,
];


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transaction-event.enum.ts
export enum TransactionEvent {
  UPDATE = 'payout.update',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transfer-event.enum.ts
export enum TransferEvent {
  CREATED = 'transfer.created', // TODO: To be deprecated
  UPDATED = 'transfer.updated', // TODO: To be deprecated
  UPDATED_STATE = 'transfer.updated.state', // TODO: To be deprecated
  ASSIGNED = 'transfer.assigned',
  PROCESSING = 'transfer.processing',
  COMPLETED = 'transfer.completed',
  CANCELED = 'transfer.canceled',
  FAILED = 'transfer.failed',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/audit-log-event.enum.ts
export enum AuditLogEvent {
  INSERT = 'insert',
  UPDATE = 'update',
  REMOVE = 'remove',
  SOFTREMOVE = 'softremove',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/scraper-banks.enum.ts
export enum TransferScraperBanks {
  pe_banco_interbank = 'pe_banco_interbank',
  pe_banco_bcp = 'pe_banco_bcp',
  pe_banco_bbva = 'pe_banco_bbva',
  cl_banco_santander = 'cl_banco_santander',
  cl_banco_security = 'cl_banco_security',
  cl_banco_itau_chile = 'cl_banco_itau_chile',
}

export enum AccountStatementScraperBanks {
  cl_banco_itau_chile = 'cl_banco_itau_chile',
  cl_banco_santander = 'cl_banco_santander',
  cl_banco_security = 'cl_banco_security',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/payout-action.enum.ts
export enum PayoutAction {
  AUTO_CANCEL = 'AUTO_CANCEL',
  AUTO_RETRY = 'AUTO_RETRY',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/user-role.enum.ts
export enum UserRole {
  USER = 'user',
  ADMIN = 'admin',
  SUPER = 'super',
  SUPPORT = 'support',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/minka-transaction-state.enum.ts
export enum MinkaTransactionState {
  CREATED = 'CREATED',
  INITIATED = 'INITIATED',
  PENDING = 'PENDING',
  ACCEPTED = 'ACCEPTED',
  COMPLETED = 'COMPLETED',
  REJECTED = 'REJECTED',
  ERROR = 'ERROR',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transfer-job-state.enum.ts
export enum TransferJobState {
  STARTED = 'started',
  CREATED = 'created',
  FINISHED = 'finished',
  ERROR = 'error',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/timezone.enum.ts
export enum Timezone {
  CHILE = 'America/Santiago',
  COLOMBIA = 'America/Bogota',
  MEXICO = 'America/Mexico_City',
  PERU = 'America/Lima',
  BRAZIL = 'America/Sao_Paulo',
  ARGENTINA = 'America/Buenos_Aires',
  BOLIVIA = 'America/La_Paz',
  ECUADOR = 'America/Guayaquil',
  URUGUAY = 'America/Montevideo',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/liquido-transaction-state.enum.ts
export enum LiquidoTransactionState {
  SETTLED = 'SETTLED',
  IN_PROGRESS = 'IN_PROGRESS',
  FAILED = 'FAILED',
  REJECTED = 'REJECTED',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/provider-capability.enum.ts
export enum ProviderCapability {
  READ_TRANSFER = 'read_transfer',
  CREATE_TRANSFER = 'create_transfer',
  ALL = 'all',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/currency.enum.ts
export enum Currency {
  ARGENTINA = 'ars',
  BOLIVIA = 'bob',
  BRAZIL = 'brl',
  CHILE = 'clp',
  COLOMBIA = 'cop',
  MEXICO = 'mxn',
  ECUADOR = 'usd',
  PERU = 'pen',
  URUGUAY = 'uyu',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/full-text-search.enum.ts
export enum MysqlFullTextSearchMode {
  BOOLEAN_MODE = 'IN BOOLEAN MODE',
  NATURAL_LANGUAGE_MODE = 'IN NATURAL LANGUAGE MODE',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/bank-code.enum.ts
export enum BankCode {
  BANCO_ABN_AMRO = 'cl_abn_amro_bank_chile',
  BANCO_BCI = 'cl_banco_bci',
  BANCO_BICE = 'cl_banco_bice',
  BANCO_CONSORCIO = 'cl_banco_consorcio',
  BANCO_COOPEUCH = 'cl_banco_coopeuch',
  BANCO_CORPBANCA = 'cl_banco_corpbanca',
  BANCO_DE_CHILE = 'cl_banco_de_chile',
  BANCO_DEL_DESARROLLO = 'cl_banco_del_desarrollo',
  BANCO_ESTADO = 'cl_banco_estado',
  BANCO_FALABELLA = 'cl_banco_falabella',
  BANCO_HSBC_CHILE = 'cl_hsbc_bank_chile',
  BANCO_INTERNACIONAL = 'cl_banco_internacional',
  BANCO_ITAU = 'cl_banco_itau_chile',
  BANCO_JP_MORGAN_CHASE = 'cl_jp_morgan_chase_bank',
  BANCO_LOS_HEROES = 'cl_prepago_los_heroes',
  BANCO_RABOBANK = 'cl_rabobank_chile',
  BANCO_PARIS = 'cl_banco_paris',
  BANCO_RIPLEY = 'cl_banco_ripley',
  BANCO_SANTANDER = 'cl_banco_santander',
  BANCO_SCOTIABANK_AZUL = 'cl_scotiabank_azul',
  BANCO_SCOTIABANK_SUDAMERICANO = 'cl_scotiabank_sud_americano',
  BANCO_SECURITY = 'cl_banco_security',
  BANCO_TENPO = 'cl_tenpo_prepago',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/authorization-code.state.enum.ts
export enum AuthorizationCodeState {
  PENDING = 'pending',
  ACTIVE = 'active',
  CLAIMED = 'claimed',
  EXPIRED = 'expired',
  DELETED = 'deleted',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transfer-mode.enum.ts
export enum TransferMode {
  SINGLE = 'single',
  BULK = 'bulk',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/entity-version.enum.ts
export enum EntityVersion {
  v1 = 'v1',
  v2 = 'v2',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/errors.enum.ts
export enum Errors {
  MISSING_MFA_CODE = 'Missing MFA code',
  INVALID_CODE = 'Invalid Code',
  INVALID_CREDENTIALS = 'Invalid credentials',
  DISABLED_MFA = 'Disabled MFA',
  INVALID_PASSWORD = 'Invalid password',
  INVALID_API_KEY = 'Invalid API key',
  INVALID_STEP = 'Invalid Step',
  INVALID_TOKEN = 'Invalid Token',
  NOT_FOUND = 'Not Found',
  BAD_REQUEST = 'Bad Request',
  MISSING_ACCOUNT_STATEMENT = 'Missing Account Statement',
  NO_ACTIVE_ACCOUNTS = 'No active accounts',
  MISSING_READ_TRANSFER_CAPABILITY = "Can't get balance, provider doesn't have the 'read_transfer' capability",
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/country-code.enum.ts
export enum CountryCode {
  CHILE = 'CHL',
  COLOMBIA = 'COL',
  MEXICO = 'MEX',
  PERU = 'PER',
  BRAZIL = 'BRA',
  ARGENTINA = 'ARG',
  BOLIVIA = 'BOL',
  ECUADOR = 'ECU',
  URUGUAY = 'URY',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/access-type.enum.ts
export enum AccessType {
  PERSONAL = 'personal',
  BUSINESS = 'business',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/payout-state.enum.ts
export enum PayoutState {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  CANCELED = 'canceled',
  FAILED = 'failed',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/transfer-method-type.enum.ts
export enum TransferMethodType {
  CARD = 'security_card',
  SMS = 'sms',
  DIGIPASS = 'digipass',
  MOBILE = 'mobile_app',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/account-statement-job.enum.ts
export enum AccountStatementJobState {
  STARTED = 'started',
  CREATED = 'created',
  FINISHED = 'finished',
  ERROR = 'error',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/aws-batch-jobs.enum.ts
export enum AwsBatchJob {
  accountStatements = 'accountStatements',
  transfers = 'transfers',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/payout-action-suggestion.enum.ts
export enum PayoutActionSuggestion {
  AUTO_RETRY = 'AUTO_RETRY',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/locks-mode.enum.ts
export enum LockMode {
  PESSIMISTIC_WRITE = 'pessimistic_write',
  PESSIMISTIC_READ = 'pessimistic_read',
  OPTIMISTIC = 'optimistic',
  PESSIMISTIC_PARTIAL_WRITE = 'pessimistic_partial_write',
  PESSIMISTIC_WRITE_OR_FAIL = 'pessimistic_write_or_fail',
  FOR_NO_KEY_UPDATE = 'for_no_key_update',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/merchant-limit-type.enum.ts
export enum MerchantLimitType {
  RATE = 'rate',
  // ABSOLUTE = 'absolute',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/state.enum.ts
export enum State {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  DELETED = 'deleted',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/country-flag.enum.ts
export enum CountryFlag {
  CHILE = '🇨🇱',
  COLOMBIA = '🇨🇴',
  MEXICO = '🇲🇽',
  PERU = '🇵🇪',
  BRAZIL = '🇧🇷',
  ARGENTINA = '🇦🇷',
  BOLIVIA = '🇧🇴',
  ECUADOR = '🇪🇨',
  URUGUAY = '🇺🇾',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/deposit-state.enum.ts
export enum DepositState {
  CREATED = 'created',
  PROCESSING = 'processing',
  ACCEPTED = 'accepted',
  REJECTED = 'rejected',
  CANCELED = 'canceled',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/bank-access-capability.enum.ts
export enum BankAccessCapability {
  CREATE_TRANSFER = 'create_transfer',
  AUTHORIZE_TRANSFER = 'authorize_transfer',
  READ_TRANSFER = 'read_transfer',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/limit-aggregation.enum.ts
export enum LimitAggregation {
  MINUTE = 'minute',
  HOUR = 'hour',
  DAY = 'day',
  WEEK = 'week',
  MONTH = 'month',
  YEAR = 'year',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/mfa-state.enum.ts
export enum MFAState {
  DISABLED = 'disabled',
  ENROLLED = 'enrolled',
  VERIFIED = 'verified',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/language-tag.enum.ts
export enum LanguageTag {
  CHILE = 'es-CL',
  MEXICO = 'es-MX',
  PERU = 'es-PE',
  COLOMBIA = 'es-CO',
  BRAZIL = 'pt-BR',
  ARGENTINA = 'es-AR',
  BOLIVIA = 'es-BO',
  ECUADOR = 'es-EC',
  URUGUAY = 'es-UY',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/limit-scope.enum.ts
export enum LimitScope {
  MERCHANT = 'merchant',
  PERSON = 'person',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/webhook-endpoint-state.enum.ts
export enum WebhookEndpointState {
  ENABLED = 'enabled',
  DISABLED = 'disabled',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/limit-criteria.enum.ts
export enum LimitCriteria {
  AMOUNT = 'amount', // suma de monto
  COUNT = 'count', // suma de veces
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/enums/pagination-header.enum.ts
export enum PaginationHeader {
  PAGE = 'X-Pagination-Page',
  ITEM_COUNT = 'X-Pagination-ItemCount',
  LIMIT = 'X-Pagination-Limit',
  PAGE_COUNT = 'X-Pagination-PageCount',
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-definitions/rule-definition-types.ts
export type RuleDefinitionType =
  | 'amount'
  | 'bank'
  | 'compound'
  | 'transfer'
  | 'recipient'
  | 'currency'
  | 'provider';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-definitions/rule-definition-params.ts
import { RuleDefinition } from './rule-definition';

export type TimeWindow = 'daily' | 'monthly';

export type BankCode = string;
export type CurrencyCode = string;
export type RequiredFields = string;

export type BankIncludeParams = BankCode[];
export type BankExcludeParams = BankCode[];
export type CompoundOrParams = RuleDefinition[];
export type CompoundAndParams = RuleDefinition[];

export type CurrencyOnlyParams = CurrencyCode;
export type RequiredFieldsParams = RequiredFields[];
export type AmountRangeParams = {
  lt?: number;
  lte?: number;
  gte?: number;
  gt?: number;
};

export type BankLimitParams = {
  amount: number;
  window: TimeWindow;
  bankCode?: string;
};

export type ProviderLimitParams = {
  count: number;
  amount: number;
};

export type RecipientWaitParams = {
  hours?: number;
  transfer?: 'first' | 'last';
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-definitions/rule-definition-operators.ts
export type RuleDefinitionOperator =
  | 'and'
  | 'or'
  | 'wait'
  | 'limit'
  | 'range'
  | 'exclude'
  | 'include'
  | 'only'
  | 'required';


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-definitions/rule-definition.ts
import { RuleDefinitionType } from './rule-definition-types';
import { RuleDefinitionOperator } from './rule-definition-operators';
import {
  BankLimitParams,
  CompoundAndParams,
  CompoundOrParams,
  BankIncludeParams,
  BankExcludeParams,
  AmountRangeParams,
  RecipientWaitParams,
  CurrencyOnlyParams,
  RequiredFieldsParams,
  ProviderLimitParams,
} from './rule-definition-params';

export type RuleDefinitionParams =
  | AmountRangeParams
  | BankLimitParams
  | BankIncludeParams
  | BankExcludeParams
  | RecipientWaitParams
  | CompoundOrParams
  | CompoundAndParams
  | CurrencyOnlyParams
  | RequiredFieldsParams
  | ProviderLimitParams;

export type RuleDefinition = {
  type: RuleDefinitionType;
  value: RuleDefinitionParams;
  operator: RuleDefinitionOperator;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/evaluator.ts
import { RuleDefinition } from './rule-definitions/rule-definition';
import BankLimitRule from './rule-evaluators/bank-limit.rule';
import CompoundOrRule from './rule-evaluators/compound-or.rule';
import AmountRangeRule from './rule-evaluators/amount-range.rule';
import BankExcludeRule from './rule-evaluators/bank-exclude.rule';
import BankIncludeRule from './rule-evaluators/bank-include.rule';
import CompoundAndRule from './rule-evaluators/compound-and.rule';
import RecipientWaitRule from './rule-evaluators/recipient-wait.rule';
import CurrencyOnlyRule from './rule-evaluators/currency-only.rule';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { Logger } from '@nestjs/common';
import BaseRule from './rule-evaluators/base.rule';
import RequiredFieldsRule from './rule-evaluators/required-fields.rule';
import ProviderLimitRule from './rule-evaluators/provider-limit.rule';

export type EvaluatorContext = {
  transfer: TransferEntity;
  transferred: {
    destinationBank?: {
      daily: number;
      monthly: number;
    };
    all: {
      daily: number;
      monthly?: number;
    };
    count?: {
      daily: number;
      monthly?: number;
    };
  };
  transfers?: {
    recipient: {
      first: TransferEntity;
    };
  };
};

export type TotalTransferred = {
  amount: number;
  count: number;
};

export default class RulesEvaluator {
  public context: EvaluatorContext;
  private readonly logger = new Logger('RulesEvaluator');

  constructor(context) {
    this.context = context;
  }

  process(ruleDefinition: RuleDefinition) {
    if (!ruleDefinition || Object.keys(ruleDefinition).length === 0) {
      return true;
    }

    const { type, operator, value } = ruleDefinition;
    let rule: BaseRule;
    if (type === 'compound' && operator === 'and') {
      rule = new CompoundAndRule(this);
    } else if (type === 'compound' && operator === 'or') {
      rule = new CompoundOrRule(this);
    } else if (type === 'amount' && operator === 'range') {
      rule = new AmountRangeRule(this);
    } else if (type === 'bank' && operator === 'include') {
      rule = new BankIncludeRule(this);
    } else if (type === 'bank' && operator === 'exclude') {
      rule = new BankExcludeRule(this);
    } else if (type === 'bank' && operator === 'limit') {
      rule = new BankLimitRule(this);
    } else if (type === 'recipient' && operator === 'wait') {
      rule = new RecipientWaitRule(this);
    } else if (type === 'currency' && operator === 'only') {
      rule = new CurrencyOnlyRule(this);
    } else if (type === 'transfer' && operator === 'required') {
      rule = new RequiredFieldsRule(this);
    } else if (type === 'provider' && operator === 'limit') {
      rule = new ProviderLimitRule(this);
    }

    if (!rule) {
      this.logger.debug(
        'Rule not supported for definition: ',
        JSON.stringify(ruleDefinition),
      );
      return false;
    }
    const valid = rule.evaluate(value);
    return valid;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rules.spec.ts
import moment = require('moment');
import { Currency } from 'src/common/enums/currency.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import RulesEvaluator, { EvaluatorContext } from './evaluator';
import {
  RuleDefinition,
  RuleDefinitionParams,
} from './rule-definitions/rule-definition';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';

describe('given a Rules evaluator', () => {
  describe('when a user process a rule in a empty context', () => {
    const transferRules: RuleDefinition = {} as RuleDefinition;
    it('return true if no rules in context', () => {
      const context = {};
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
  });
  describe('when a user process a rule in a empty context', () => {
    const transferRules: RuleDefinition = {
      type: 'currency',
      value: 'cop',
      operator: 'limit',
    };
    it('return false if rule is not correct or not exist', () => {
      const context = {};
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});
describe('given a Rules evaluator for CurrencyOnlyRule', () => {
  describe('when a user process a rule and its context is Currency.COLOMBIA', () => {
    const transferRules: RuleDefinition = {
      type: 'currency',
      value: 'cop',
      operator: 'only',
    };
    it('return true if transfer is Currency.COLOMBIA', () => {
      const transfer = new TransferEntity();
      transfer.currency = Currency.COLOMBIA;
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer is not Currency.COLOMBIA', () => {
      const currencyArray = [
        Currency.ARGENTINA,
        Currency.BOLIVIA,
        Currency.BRAZIL,
        Currency.CHILE,
        //Currency.COLOMBIA,
        Currency.MEXICO,
        Currency.ECUADOR,
        Currency.PERU,
        Currency.URUGUAY,
      ];
      for (const currency of currencyArray) {
        const transfer = new TransferEntity();
        transfer.currency = currency;
        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(false);
      }
    });
  });
});
describe('given a Rules evaluator for CompoundOrRule', () => {
  describe('when a user process a rule and its context is transfers amount lt 35000 or ', () => {
    const transferRules: RuleDefinition = {
      type: 'compound',
      value: [
        {
          type: 'amount',
          value: { lt: 35000, gte: 0 },
          operator: 'range',
        },
        {
          type: 'compound',
          value: [
            {
              type: 'amount',
              value: { lt: 80000, gte: 0 },
              operator: 'range',
            },
            {
              type: 'bank',
              value: ['cl_banco_estado', 'cl_banco_falabella'],
              operator: 'include',
            },
          ],
          operator: 'and',
        },
      ],
      operator: 'or',
    };
    it('return true if transfer amount is less of 35000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 34000;
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more or equal of 35000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 35000;
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer amount is more of 35000 but cl_banco_estado destination bank', () => {
      const transfer = new TransferEntity();
      transfer.amount = 35000;
      transfer.destinationBankCode = 'cl_banco_estado';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more or equal of 80000 and cl_banco_estado destination bank', () => {
      const transfer = new TransferEntity();
      transfer.amount = 80000;
      transfer.destinationBankCode = 'cl_banco_estado';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer amount is more of 35000 but cl_banco_falabella destination bank', () => {
      const transfer = new TransferEntity();
      transfer.amount = 35000;
      transfer.destinationBankCode = 'cl_banco_falabella';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more or equal of 80000 and cl_banco_falabella destination bank', () => {
      const transfer = new TransferEntity();
      transfer.amount = 80000;
      transfer.destinationBankCode = 'cl_banco_falabella';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});
describe('given a Rules evaluator for CompoundAndRule and RecipientWaitRule', () => {
  describe('when a user process a rule and its context is first transfer 24 delayed', () => {
    const transferRules: RuleDefinition = {
      type: 'compound',
      value: [
        {
          type: 'recipient',
          value: { hours: 24, transfer: 'first' },
          operator: 'wait',
        },
        {
          type: 'compound',
          value: [
            {
              type: 'compound',
              value: [
                {
                  type: 'amount',
                  value: { lt: 150000, gte: 0 },
                  operator: 'range',
                },
                {
                  type: 'bank',
                  value: ['cl_banco_estado'],
                  operator: 'exclude',
                },
              ],
              operator: 'and',
            },
          ],
          operator: 'or',
        },
      ],
      operator: 'and',
    };
    it('return true if first transfer was about 24 or more hours ago', () => {
      const transfer = new TransferEntity();
      const now = moment();
      transfer.finishedAt = now.subtract(25, 'hours').toDate();
      const secondTransfer = new TransferEntity();
      secondTransfer.amount = 140000;

      const context = {
        transfer: secondTransfer,
        transferred: {
          destinationBank: {
            daily: 27,
            monthly: 27,
          },
          all: {
            daily: 27,
            monthly: 27,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if first transfer was less of 24 hours ago', () => {
      const transfer = new TransferEntity();
      transfer.amount = 140000;
      const now = moment();
      transfer.finishedAt = now.subtract(2, 'hours').toDate();
      const secondTransfer = new TransferEntity();
      secondTransfer.amount = 140000;
      const context = {
        transfer: secondTransfer,
        transferred: {
          destinationBank: {
            daily: 27,
            monthly: 27,
          },
          all: {
            daily: 27,
            monthly: 27,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return false if first transfer was less of 24 hours ago and banco estado', () => {
      const transfer = new TransferEntity();
      transfer.amount = 140000;
      const now = moment();
      transfer.finishedAt = now.subtract(22, 'hours').toDate();
      const secondTransfer = new TransferEntity();
      secondTransfer.amount = 130000;
      secondTransfer.destinationBankCode = 'cl_banco_estado';
      const context = {
        transfer: secondTransfer,
        transferred: {
          destinationBank: {
            daily: 27,
            monthly: 27,
          },
          all: {
            daily: 27,
            monthly: 27,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});
describe('given a Rules evaluator for AmountRangeRule', () => {
  describe('when a user process a rule and its context is transfers amount gte: 0', () => {
    const transferRules: RuleDefinition = {
      type: 'amount',
      value: { gte: 0 },
      operator: 'range',
    };
    it('return true if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return true if transfer amount is equal cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 0;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = -10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
  describe('when a user process a rule and its context is transfers amount gt: 0', () => {
    const transferRules: RuleDefinition = {
      type: 'amount',
      value: { gt: 0 },
      operator: 'range',
    };
    it('return true if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = -10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return false if transfer amount is equal cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 0;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
  describe('when a user process a rule and its context is transfers amount lte: 1000000', () => {
    const transferRules: RuleDefinition = {
      type: 'amount',
      value: { lte: 1000000 },
      operator: 'range',
    };
    it('return true if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return true if transfer amount is equal 1000000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 1000000;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is more than 1000000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 2000000;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
  describe('when a user process a rule and its context is transfers amount lt: 1000000', () => {
    const transferRules: RuleDefinition = {
      type: 'amount',
      value: { lt: 1000000 },
      operator: 'range',
    };
    it('return true if transfer amount is more than cero', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer amount is equal 1000000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 1000000;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return false if transfer amount is more than 1000000', () => {
      const transfer = new TransferEntity();
      transfer.amount = 2000000;

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});
describe('given a Rules evaluator for BankExcludeRule', () => {
  describe('when a user process a rule and its context bank exclude cl_banco_estado', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: ['cl_banco_estado', 'cl_banco_del_desarrollo'],

      operator: 'exclude',
    };
    it('return true if destination bank is not excluded', () => {
      const chileanBanksCodes = [
        'cl_abn_amro_bank_chile',
        'cl_banco_bice',
        'cl_banco_de_chile',
        'cl_banco_consorcio',
        'cl_banco_bci',
        'cl_banco_falabella',
        'cl_banco_internacional',
        'cl_banco_itau_chile',
        'cl_banco_paris',
        'cl_banco_ripley',
        'cl_banco_security',
        'cl_banco_coopeuch',
        'cl_banco_corpbanca',
        'cl_hsbc_bank_chile',
        'cl_prepago_los_heroes',
        'cl_rabobank_chile',
        'cl_scotiabank_azul',
        'cl_scotiabank_sud_americano',
        'cl_tenpo_prepago',
        'cl_banco_santander',
        'cl_jp_morgan_chase_bank',
      ];
      for (const bankCode of chileanBanksCodes) {
        const transfer = new TransferEntity();
        transfer.destinationBankCode = bankCode;

        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(true);
      }
    });
    it('return false if destination bank is excluded', () => {
      const transfer = new TransferEntity();
      transfer.destinationBankCode = 'cl_banco_estado';

      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});
describe('given a Rules evaluator for BankIncludeRule', () => {
  describe('when a user process a rule and its context bank exclude cl_banco_estado', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: ['cl_banco_estado', 'cl_banco_bice', 'cl_banco_bci'],
      operator: 'include',
    };
    it('return false if destination bank is not included', () => {
      const chileanBanksCodes = [
        'cl_abn_amro_bank_chile',
        'cl_banco_de_chile',
        'cl_banco_consorcio',
        'cl_banco_del_desarrollo',
        'cl_banco_falabella',
        'cl_banco_internacional',
        'cl_banco_itau_chile',
        'cl_banco_paris',
        'cl_banco_ripley',
        'cl_banco_security',
        'cl_banco_coopeuch',
        'cl_banco_corpbanca',
        'cl_hsbc_bank_chile',
        'cl_prepago_los_heroes',
        'cl_rabobank_chile',
        'cl_scotiabank_azul',
        'cl_scotiabank_sud_americano',
        'cl_tenpo_prepago',
        'cl_banco_santander',
        'cl_jp_morgan_chase_bank',
      ];
      for (const bankCode of chileanBanksCodes) {
        const transfer = new TransferEntity();
        transfer.destinationBankCode = bankCode;

        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(false);
      }
    });
    it('return true if destination bank is included', () => {
      const chileanBanksCodes = [
        'cl_banco_bice',
        'cl_banco_bci',
        'cl_banco_estado',
      ];
      for (const bankCode of chileanBanksCodes) {
        const transfer = new TransferEntity();
        transfer.destinationBankCode = bankCode;

        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(true);
      }
    });
  });
});
describe('given a Rules evaluator for BankLimitRule', () => {
  describe('when a user process a rule and its context BankLimit with monthly window and especific bankCode', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: {
        amount: 2000000,
        window: 'monthly',
        bankCode: 'cl_banco_consorcio',
      },
      operator: 'limit',
    };
    it('return false if transfer exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;
      transfer.destinationBankCode = 'cl_banco_consorcio';

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 2000000,
            monthly: 2000000,
          },
          all: {
            daily: 2000000,
            monthly: 2000000,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer not exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;
      transfer.destinationBankCode = 'cl_banco_consorcio';

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 20000,
            monthly: 20000,
          },
          all: {
            daily: 100,
            monthly: 200,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
  });
  describe('when a user process a rule and its context BankLimit with daily window and especific bankCode', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: {
        amount: 20000,
        window: 'daily',
        bankCode: 'cl_banco_estado',
      },
      operator: 'limit',
    };
    it('return false if transfer exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;
      transfer.destinationBankCode = 'cl_banco_estado';

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 2000000,
            monthly: 2000000,
          },
          all: {
            daily: 2000000,
            monthly: 2000000,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer not exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10000;
      transfer.destinationBankCode = 'cl_banco_estado';

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 10000,
            monthly: 20000,
          },
          all: {
            daily: 100,
            monthly: 200,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
  });
  describe('when a user process a rule and its context BankLimit with monthly window without bankcode', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: {
        amount: 2000000,
        window: 'monthly',
      },
      operator: 'limit',
    };
    it('return false if transfer exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 2000000,
            monthly: 2000000,
          },
          all: {
            daily: 2000000,
            monthly: 2000000,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer not exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 20000,
            monthly: 20000,
          },
          all: {
            daily: 100,
            monthly: 200,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
  });
  describe('when a user process a rule and its context BankLimit with daily window without bankCode', () => {
    const transferRules: RuleDefinition = {
      type: 'bank',
      value: {
        amount: 20000,
        window: 'daily',
      },
      operator: 'limit',
    };
    it('return false if transfer exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 20000;

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 2000000,
            monthly: 2000000,
          },
          all: {
            daily: 2000000,
            monthly: 2000000,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return true if transfer not exceed bank limit amount', () => {
      const transfer = new TransferEntity();
      transfer.amount = 10000;

      const context = {
        transfer: transfer,
        transferred: {
          destinationBank: {
            daily: 20000,
            monthly: 20000,
          },
          all: {
            daily: 100,
            monthly: 200,
          },
        },
        transfers: {
          recipient: {
            first: transfer,
          },
        },
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
  });
});
describe('given a Rules evaluator for RequiredFieldsRule', () => {
  describe('when a user process a rule with a list of required fields in a transfer', () => {
    const transferRules: RuleDefinition = {
      type: 'transfer',
      value: ['destinationPhone', 'amount'],
      operator: 'required',
    };
    it('return true if transfer has non empty null or undefined value on defined properties', () => {
      const transfer = new TransferEntity();
      transfer.amount = 2000;
      transfer.destinationPhone = '345';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer has empty null or undefined value on defined properties', () => {
      const falsyArray = [null, undefined, ''];
      for (const falsy of falsyArray) {
        const transfer = new TransferEntity();
        transfer.amount = 2000;
        transfer.destinationPhone = falsy;
        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(false);
      }
    });
    it('return false if transfer is null', () => {
      const context = {
        transfer: null,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return false if list of properties empty', () => {
      transferRules.value = [];

      const transfer = new TransferEntity();
      transfer.amount = 2000;
      transfer.destinationPhone = '123';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
    it('return false if list of properties null', () => {
      transferRules.value = null;

      const transfer = new TransferEntity();
      transfer.amount = 2000;
      transfer.destinationPhone = '123';
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});

describe('given a Rules evaluator for CompoundAndRule CurrencyOnly + RequiredField', () => {
  const transferRules: RuleDefinition = {
    type: 'compound',
    value: [
      {
        type: 'currency',
        value: 'cop',
        operator: 'only',
      },
      {
        type: 'transfer',
        value: ['destinationPhone'],
        operator: 'required',
      },
    ],
    operator: 'and',
  };

  describe('when a user process a transfer', () => {
    it('return true if transfer has non empty null or undefined value on defined properties and Currency only params', () => {
      const transfer = new TransferEntity();
      transfer.amount = 2000;
      transfer.destinationPhone = 'sdsdsd';
      transfer.currency = Currency.COLOMBIA;
      const context = {
        transfer: transfer,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(true);
    });
    it('return false if transfer has empty null or undefined value on defined properties', () => {
      const falsyArray = [null, undefined, ''];
      for (const falsy of falsyArray) {
        const transfer = new TransferEntity();
        transfer.amount = 2000;
        transfer.destinationPhone = falsy;
        transfer.currency = Currency.COLOMBIA;
        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(false);
      }
    });
    it('return false if transfer has not allowed Currency', () => {
      const currencyArray = [
        Currency.ARGENTINA,
        Currency.BOLIVIA,
        Currency.BRAZIL,
        Currency.CHILE,
        Currency.MEXICO,
        Currency.ECUADOR,
        Currency.PERU,
        Currency.URUGUAY,
      ];
      for (const currency of currencyArray) {
        const transfer = new TransferEntity();
        transfer.amount = 2000;
        transfer.destinationPhone = '2342352345';
        transfer.currency = currency;
        const context = {
          transfer: transfer,
        };
        const evaluator = new RulesEvaluator(context);
        const result = evaluator.process(transferRules);
        expect(result).toBe(false);
      }
    });
    it('return false if transfer is null', () => {
      const context = {
        transfer: null,
      };
      const evaluator = new RulesEvaluator(context);
      const result = evaluator.process(transferRules);
      expect(result).toBe(false);
    });
  });
});

describe('given a Rules evaluator for ProviderLimitRule', () => {
  const provider = new ProviderEntity();
  const transfer = new TransferEntity();
  provider.rules = {
    type: 'provider',
    operator: 'limit',
    value: { amount: 0, count: 0 },
  };

  let context: EvaluatorContext;

  beforeEach(() => {
    transfer.amount = 0;
    context = {
      transfer,
      transferred: {
        all: {
          daily: 0,
          monthly: 0,
        },
        count: {
          daily: 0,
        },
      },
    } as EvaluatorContext;
  });

  it('then should return true if the rule value is not defined', () => {
    context.transferred.count.daily = 1000;
    provider.rules.value = {} as RuleDefinitionParams;

    const evaluator = new RulesEvaluator(context);

    const result = evaluator.process(provider.rules);
    expect(result).toBe(true);
  });

  it('then should return false if the daily transactions count is exceeded', () => {
    context.transferred.count.daily = 1000;
    provider.rules.value = { count: 1000, amount: 0 };

    const evaluator = new RulesEvaluator(context);

    const result = evaluator.process(provider.rules);
    expect(result).toBe(false);
  });

  it('then should return true if the daily transactions count is not exceeded', () => {
    context.transferred.count.daily = 999;
    provider.rules.value = { count: 1000, amount: 0 };
    const evaluator = new RulesEvaluator(context);

    const result = evaluator.process(provider.rules);
    expect(result).toBe(true);
  });

  it('then should return false if the daily amount is exceeded', () => {
    context.transferred.all.daily = 1000;
    provider.rules.value = { count: 0, amount: 700 };
    transfer.amount = 301;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return true if the daily amount is not exceeded', () => {
    context.transferred.all.daily = 1000;
    provider.rules.value = { count: 0, amount: 700 };
    transfer.amount = 300;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return false if both daily count and amount is exceeded', () => {
    context.transferred.all.daily = 1000;
    context.transferred.count.daily = 1000;

    provider.rules.value = { count: 1000, amount: 700 };
    transfer.amount = 300;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });
});

describe('given a Rules evaluator for CompoundAndRule with AmountRangeRule and ProviderLimitRule', () => {
  const provider = new ProviderEntity();
  const transfer = new TransferEntity();
  provider.rules = {
    type: 'compound',
    operator: 'and',
    value: [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 0, amount: 0 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 0 },
      },
    ],
  };

  let context: EvaluatorContext;

  beforeEach(() => {
    transfer.amount = 0;
    context = {
      transfer,
      transferred: {
        all: {
          daily: 0,
          monthly: 0,
        },
        count: {
          daily: 0,
        },
      },
    } as EvaluatorContext;
  });

  it('then should return false if the transfer amount is greater than the specified value', () => {
    provider.rules.value = [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 0, amount: 0 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 1000 },
      },
    ];

    transfer.amount = 1001;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return true if the transfer amount is lower than the specified value', () => {
    provider.rules.value = [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 0, amount: 0 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 1000 },
      },
    ];

    transfer.amount = 999;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return false if the transfer amount is lower than the specified value but provider transaction count is exceeded', () => {
    provider.rules.value = [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 1000, amount: 0 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 1000 },
      },
    ];
    context.transferred.count.daily = 1000;

    transfer.amount = 999;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return false if the transfer amount is lower than the specified value but provider transactions amount is exceeded', () => {
    provider.rules.value = [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 0, amount: 10000 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 1000 },
      },
    ];
    context.transferred.all.daily = 10001;

    transfer.amount = 999;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(false);
  });

  it('then should return true if the transfer amount is lower than the specified value and provider limit is not exceeded', () => {
    provider.rules.value = [
      {
        type: 'provider',
        operator: 'limit',
        value: { count: 1000, amount: 10000 },
      },
      {
        type: 'amount',
        operator: 'range',
        value: { lte: 1000 },
      },
    ];
    context.transferred.count.daily = 999;
    context.transferred.all.daily = 9001;

    transfer.amount = 999;

    const evaluator = new RulesEvaluator(context);
    const result = evaluator.process(provider.rules);

    expect(result).toBe(true);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/currency-only.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { CurrencyOnlyParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class CurrencyOnlyRule extends BaseRule {
  public type: RuleDefinitionType = 'currency';
  public operator: RuleDefinitionOperator = 'only';

  evaluate(params: CurrencyOnlyParams): boolean {
    if (!this.context.transfer) return false;
    const { currency } = this.context.transfer;
    if (currency === params) {
      return true;
    }
    return false;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/base.rule.ts
import RulesEvaluator, { EvaluatorContext } from '../evaluator';
import { RuleDefinitionParams } from '../rule-definitions/rule-definition';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default abstract class BaseRule {
  protected evaluator: RulesEvaluator;
  protected context: EvaluatorContext;
  public type: RuleDefinitionType;
  public operator: RuleDefinitionOperator;

  constructor(evaluator) {
    this.evaluator = evaluator;
    this.context = evaluator.context;
  }

  abstract evaluate(params: RuleDefinitionParams): boolean;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/required-fields.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { RequiredFieldsParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class RequiredFieldsRule extends BaseRule {
  public type: RuleDefinitionType = 'transfer';
  public operator: RuleDefinitionOperator = 'required';

  evaluate(params: RequiredFieldsParams): boolean {
    if (!this.context.transfer || !params || params.length === 0) return false;
    for (const prop of Object.keys(this.context.transfer)) {
      for (const param of params) {
        if (prop === param) {
          if (!this.context.transfer[prop]) {
            return false;
          }
        }
      }
    }
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/bank-include.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { BankIncludeParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class BankIncludeRule extends BaseRule {
  public type: RuleDefinitionType = 'bank';
  public operator: RuleDefinitionOperator = 'include';

  evaluate(params: BankIncludeParams): boolean {
    const { destinationBankCode } = this.context.transfer;
    if (Array.isArray(params)) {
      return params.includes(destinationBankCode);
    }
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/compound-and.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { CompoundAndParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class CompoundAndRule extends BaseRule {
  public type: RuleDefinitionType = 'compound';
  public operator: RuleDefinitionOperator = 'and';

  evaluate(params: CompoundAndParams): boolean {
    return params.every((rule) => this.evaluator.process(rule));
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/recipient-wait.rule.ts
import * as moment from 'moment';
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { RecipientWaitParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class RecipientWaitRule extends BaseRule {
  public type: RuleDefinitionType = 'recipient';
  public operator: RuleDefinitionOperator = 'wait';

  evaluate(params: RecipientWaitParams): boolean {
    const { hours, transfer } = params;
    const { recipient } = this.context.transfers;
    // Should check the first transfer made to the recipient
    if (transfer == 'first') {
      // If no transfers have been made, transfer is allowed
      if (recipient.first == null) return true;
      const firstTransferDate = moment(recipient.first.finishedAt);
      const now = moment();
      // Check hours since first transfer
      return now.isAfter(firstTransferDate.add(hours, 'hours'));
    } else {
      return true;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/compound-or.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { CompoundOrParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class CompoundOrRule extends BaseRule {
  public type: RuleDefinitionType = 'compound';
  public operator: RuleDefinitionOperator = 'or';

  evaluate(rules: CompoundOrParams): boolean {
    return rules.some((rule) => this.evaluator.process(rule));
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/bank-limit.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { BankLimitParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class BankLimitRule extends BaseRule {
  public type: RuleDefinitionType = 'bank';
  public operator: RuleDefinitionOperator = 'limit';

  evaluate(params: BankLimitParams): boolean {
    const { destinationBankCode, amount } = this.context.transfer;
    const { destinationBank, all } = this.context.transferred;
    if (params.bankCode) {
      if (params.bankCode !== destinationBankCode) {
        return true;
      } else if (params.window === 'daily') {
        if (destinationBank.daily + amount > params.amount) return false;
      } else if (params.window === 'monthly') {
        if (destinationBank.monthly + amount > params.amount) return false;
      }
    } else {
      if (params.window === 'daily') {
        if (all.daily + amount > params.amount) return false;
      } else if (params.window === 'monthly') {
        if (all.monthly + amount > params.amount) return false;
      }
    }
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/provider-limit.rule.ts
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { ProviderLimitParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';
import BaseRule from './base.rule';

export default class ProviderLimitRule extends BaseRule {
  public type: RuleDefinitionType = 'provider';
  public operator: RuleDefinitionOperator = 'limit';

  evaluate(params: ProviderLimitParams): boolean {
    const { amount } = this.context.transfer;
    const { all, count } = this.context.transferred;

    const dailyAmountExceeded = all.daily + amount > params.amount;
    const dailyCountExceeded = count.daily >= params.count;

    if (dailyCountExceeded || dailyAmountExceeded) return false;

    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/amount-range.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { AmountRangeParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class AmountRangeRule extends BaseRule {
  public type: RuleDefinitionType = 'amount';
  public operator: RuleDefinitionOperator = 'range';

  evaluate(params: AmountRangeParams): boolean {
    const { amount } = this.context.transfer;
    if ('gte' in params && !(amount >= params.gte)) return false;
    if ('gt' in params && !(amount > params.gt)) return false;
    if ('lte' in params && !(amount <= params.lte)) return false;
    if ('lt' in params && !(amount < params.lt)) return false;
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/rules/rule-evaluators/bank-exclude.rule.ts
import BaseRule from './base.rule';
import { RuleDefinitionOperator } from '../rule-definitions/rule-definition-operators';
import { BankExcludeParams } from '../rule-definitions/rule-definition-params';
import { RuleDefinitionType } from '../rule-definitions/rule-definition-types';

export default class BankExcludeRule extends BaseRule {
  public type: RuleDefinitionType = 'bank';
  public operator: RuleDefinitionOperator = 'exclude';

  evaluate(params: BankExcludeParams): boolean {
    const { destinationBankCode } = this.context.transfer;
    if (Array.isArray(params)) {
      return !params.includes(destinationBankCode);
    }
    return true;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/maps/timezone.map.ts
import { CountryCode } from '../enums/country-code.enum';
import { Timezone } from '../enums/timezone.enum';

export const MapCountryCodeToTimezone: Record<CountryCode, Timezone> = {
  [CountryCode.CHILE]: Timezone.CHILE,
  [CountryCode.COLOMBIA]: Timezone.COLOMBIA,
  [CountryCode.MEXICO]: Timezone.MEXICO,
  [CountryCode.PERU]: Timezone.PERU,
  [CountryCode.BRAZIL]: Timezone.BRAZIL,
  [CountryCode.ARGENTINA]: Timezone.ARGENTINA,
  [CountryCode.BOLIVIA]: Timezone.BOLIVIA,
  [CountryCode.ECUADOR]: Timezone.ECUADOR,
  [CountryCode.URUGUAY]: Timezone.URUGUAY,
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/maps/currency.map.ts
import { CountryCode } from '../enums/country-code.enum';
import { CountryFlag } from '../enums/country-flag.enum';
import { CountryName } from '../enums/country-name.enum';
import { Currency } from '../enums/currency.enum';

export const MapCurrencyToFlag: Record<Currency, CountryFlag> = {
  [Currency.CHILE]: CountryFlag.CHILE,
  [Currency.COLOMBIA]: CountryFlag.COLOMBIA,
  [Currency.MEXICO]: CountryFlag.MEXICO,
  [Currency.PERU]: CountryFlag.PERU,
  [Currency.BRAZIL]: CountryFlag.BRAZIL,
  [Currency.ARGENTINA]: CountryFlag.ARGENTINA,
  [Currency.BOLIVIA]: CountryFlag.BOLIVIA,
  [Currency.ECUADOR]: CountryFlag.ECUADOR,
  [Currency.URUGUAY]: CountryFlag.URUGUAY,
};

export const MapCurrencyToCountryName: Record<Currency, CountryName> = {
  [Currency.CHILE]: CountryName.CHILE,
  [Currency.COLOMBIA]: CountryName.COLOMBIA,
  [Currency.MEXICO]: CountryName.MEXICO,
  [Currency.PERU]: CountryName.PERU,
  [Currency.BRAZIL]: CountryName.BRAZIL,
  [Currency.ARGENTINA]: CountryName.ARGENTINA,
  [Currency.BOLIVIA]: CountryName.BOLIVIA,
  [Currency.ECUADOR]: CountryName.ECUADOR,
  [Currency.URUGUAY]: CountryName.URUGUAY,
};

export const MapCurrencyToCountryCode: Record<Currency, CountryCode> = {
  [Currency.CHILE]: CountryCode.CHILE,
  [Currency.COLOMBIA]: CountryCode.COLOMBIA,
  [Currency.MEXICO]: CountryCode.MEXICO,
  [Currency.PERU]: CountryCode.PERU,
  [Currency.BRAZIL]: CountryCode.BRAZIL,
  [Currency.ARGENTINA]: CountryCode.ARGENTINA,
  [Currency.BOLIVIA]: CountryCode.BOLIVIA,
  [Currency.ECUADOR]: CountryCode.ECUADOR,
  [Currency.URUGUAY]: CountryCode.URUGUAY,
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/maps/country.map.ts
import { CountryCode } from '../enums/country-code.enum';
import { CountryFlag } from '../enums/country-flag.enum';
import { CountryName } from '../enums/country-name.enum';
import { Currency } from '../enums/currency.enum';
import { LanguageTag } from '../enums/language-tag.enum';

export const MapCountryCodeToCurrency = {
  [CountryCode.CHILE]: Currency.CHILE,
  [CountryCode.COLOMBIA]: Currency.COLOMBIA,
  [CountryCode.MEXICO]: Currency.MEXICO,
  [CountryCode.PERU]: Currency.PERU,
};

export const MapCountryCodeToLanguageTag: Record<CountryCode, LanguageTag> = {
  [CountryCode.CHILE]: LanguageTag.CHILE,
  [CountryCode.MEXICO]: LanguageTag.MEXICO,
  [CountryCode.PERU]: LanguageTag.PERU,
  [CountryCode.COLOMBIA]: LanguageTag.COLOMBIA,
  [CountryCode.BRAZIL]: LanguageTag.BRAZIL,
  [CountryCode.ARGENTINA]: LanguageTag.ARGENTINA,
  [CountryCode.BOLIVIA]: LanguageTag.BOLIVIA,
  [CountryCode.ECUADOR]: LanguageTag.ECUADOR,
  [CountryCode.URUGUAY]: LanguageTag.URUGUAY,
};

export const MapCountryCodeToCountryFlag: Record<CountryCode, CountryFlag> = {
  [CountryCode.CHILE]: CountryFlag.CHILE,
  [CountryCode.COLOMBIA]: CountryFlag.COLOMBIA,
  [CountryCode.MEXICO]: CountryFlag.MEXICO,
  [CountryCode.PERU]: CountryFlag.PERU,
  [CountryCode.BRAZIL]: CountryFlag.BRAZIL,
  [CountryCode.ARGENTINA]: CountryFlag.ARGENTINA,
  [CountryCode.BOLIVIA]: CountryFlag.BOLIVIA,
  [CountryCode.ECUADOR]: CountryFlag.ECUADOR,
  [CountryCode.URUGUAY]: CountryFlag.URUGUAY,
};

export const MapCountryCodeToCountryName: Record<CountryCode, CountryName> = {
  [CountryCode.CHILE]: CountryName.CHILE,
  [CountryCode.COLOMBIA]: CountryName.COLOMBIA,
  [CountryCode.MEXICO]: CountryName.MEXICO,
  [CountryCode.PERU]: CountryName.PERU,
  [CountryCode.BRAZIL]: CountryName.BRAZIL,
  [CountryCode.ARGENTINA]: CountryName.ARGENTINA,
  [CountryCode.BOLIVIA]: CountryName.BOLIVIA,
  [CountryCode.ECUADOR]: CountryName.ECUADOR,
  [CountryCode.URUGUAY]: CountryName.URUGUAY,
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/base.entity.ts
import {
  PrimaryGeneratedColumn,
  Column,
  UpdateDateColumn,
  CreateDateColumn,
  Generated,
} from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column('string')
  @Generated('uuid')
  uuid: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/dto/query-paginated.dto.ts
import { IsNumberString, IsOptional } from 'class-validator';

export class QueryPaginatedDto {
  @IsNumberString()
  @IsOptional()
  public page?: number;

  @IsNumberString()
  @IsOptional()
  public limit?: number;

  @IsNumberString()
  @IsOptional()
  merchantId?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/dto/transfer-error.dto.ts
export class TransferErrorDto {
  errorRaw: string;
  errorCode?: string;
  errorType?: string;
  description?: string;
  issuer?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/shinkansen.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
  Logger,
} from '@nestjs/common';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';

@Injectable()
export class ShinkansenGuard implements CanActivate {
  @Inject()
  private shinkansenProvider: ShinkansenProvider;

  private readonly logger = new Logger('ShinkansenGuardLogger');

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const headers = context.switchToHttp().getRequest().headers;
    const updateTransactionDto = context.switchToHttp().getRequest().body;

    if (!headers['shinkansen-jws-signature']) return false;

    const signature = headers['shinkansen-jws-signature'];

    const isValidSignature = await this.shinkansenProvider.validateSignature(
      signature,
      updateTransactionDto,
    );

    return isValidSignature;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/device.guard.ts
import { ConfigType } from '@nestjs/config';
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Inject,
} from '@nestjs/common';
import deviceCodeConfig from 'src/config/device.config';
import { validateSignature } from 'src/utils/secrets.util';

export const PAYOUTS_HEADER = 'x-payouts-signature';

@Injectable()
export class DeviceCodeGuard implements CanActivate {
  constructor(
    @Inject(deviceCodeConfig.KEY)
    private config: ConfigType<typeof deviceCodeConfig>,
  ) {}

  canActivate(context: ExecutionContext): boolean {
    const { token } = this.config;

    const { body, headers } = context.switchToHttp().getRequest();
    const header = String(headers[PAYOUTS_HEADER]);

    const validRequest = validateSignature(token, header, body);
    return validRequest;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/device.guard.spec.ts
import { ExecutionContext } from '@nestjs/common';
import { DeviceCodeGuard } from './device.guard';
import { createMock } from '@golevelup/ts-jest';
import { validateSignature } from 'src/utils/secrets.util';

let deviceCodeGuard: DeviceCodeGuard;
// let executionContext: ExecutionContext;
beforeEach(async () => {
  // const mock_ForceFailGuard: CanActivate = { canActivate: jest.fn(() => true) };
  // const mockConfig = {};
  // const config: ConfigType<typeof deviceConfig> = () => {
  //   return {
  //     queueUrl: 'jjjj',
  //     token: 'token',
  //   };
  // };
  // const app: TestingModule = await Test.createTestingModule({
  //   providers: [
  //     DeviceGuard,
  //     {
  //       provide: config,
  //       useValue: mockConfig,
  //     },
  //   ],
  // })
  //   .overrideGuard(DeviceGuard)
  //   .useValue(mock_ForceFailGuard)
  //   .compile();

  deviceCodeGuard = new DeviceCodeGuard({
    queueUrl: 'queueUrl',
    topicArn: 'topicArn',
    token: 'token',
  });
});

describe('given DeviceGuard', () => {
  it('when we call canActivate then return a Boolean', () => {
    const mockContext = createMock<ExecutionContext>();
    mockContext.switchToHttp().getRequest.mockReturnValue({
      body: 'body',
      headers: 'header',
    });

    const result = deviceCodeGuard.canActivate(mockContext);
    expect(result).toStrictEqual(expect.any(Boolean));
  });
  it('when we call validateSignature then return a Boolean', () => {
    const token = '';
    const header = '';
    const body = '';

    const resultB = validateSignature(token, header, body);
    expect(resultB).toStrictEqual(expect.any(Boolean));
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/scraper.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
} from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import scraperConfig from 'src/config/scraper.config';
import { ProviderService } from 'src/models/provider/provider.service';
import { validateSignature } from 'src/utils/secrets.util';
import { ProviderType } from '../enums/provider-type.enum';
import { State } from '../enums/state.enum';
import { PAYOUTS_HEADER } from './device.guard';

@Injectable()
export class ScraperGuard implements CanActivate {
  constructor(
    private providerService: ProviderService,
    @Inject(scraperConfig.KEY)
    private config: ConfigType<typeof scraperConfig>,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const { params, body, headers } = context.switchToHttp().getRequest();

    const allowedProviderType = [
      ProviderType.ScraperCG,
      ProviderType.ScraperPW,
    ];

    const providerId: number = params.providerId;

    const provider = await this.providerService.findOne(providerId);

    if (!provider || provider.state !== State.ACTIVE) return false;

    if (!allowedProviderType.includes(provider.providerType)) return false;

    const { token } = this.config;
    const header = String(headers[PAYOUTS_HEADER]);
    const validSignature = validateSignature(token, header, body);

    return validSignature;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';
import { UserRole } from '../enums/user-role.enum';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );
    if (!requiredRoles) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.includes(user.role);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/guards/twilio.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  Inject,
  Logger,
} from '@nestjs/common';
import * as client from 'twilio';
import twilioConfig from 'src/config/twilio.config';
import { ConfigType } from '@nestjs/config';

export const TWILIO_HEADER = 'x-twilio-signature';

@Injectable()
export class TwilioGuard implements CanActivate {
  private readonly logger = new Logger('TwilioGuard');

  constructor(
    @Inject(twilioConfig.KEY)
    private config: ConfigType<typeof twilioConfig>,
  ) {}

  canActivate(context: ExecutionContext): boolean {
    const { token, url } = this.config;
    const { body, headers } = context.switchToHttp().getRequest();

    const signature = String(headers[TWILIO_HEADER]);
    const validRequest = client.validateRequest(token, signature, url, body);

    return validRequest;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/interceptors/serialize.interceptor.ts
import {
  UseInterceptors,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { plainToInstance } from 'class-transformer';

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

/** Serialize decorator
 * Takes the response entity and uses the given dto for nest to serialize it.
 * @param dto - The dto used to serialize
 */
export function Serialize(dto: any) {
  return UseInterceptors(new SerializeInterceptor(dto));
}

export class SerializeInterceptor implements NestInterceptor {
  constructor(private dto: any) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        return plainToInstance(this.dto, data, {
          excludeExtraneousValues: true,
        });
      }),
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/interceptors/paginated.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import type { ServerResponse } from 'http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { PaginationHeader } from '../enums/pagination-header.enum';

interface IGenericPageResult {
  data: Array<any>;
  page: number;
  limit: number;
  itemCount: number;
  pageCount: number;
}

@Injectable()
export class PaginatedInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data: IGenericPageResult) => {
        if (!data?.data) return data;

        const res = context.switchToHttp().getResponse<ServerResponse>();

        const headers: Record<PaginationHeader, number> = {
          [PaginationHeader.PAGE]: data.page,
          [PaginationHeader.ITEM_COUNT]: data.itemCount,
          [PaginationHeader.LIMIT]: data.limit,
          [PaginationHeader.PAGE_COUNT]: data.pageCount,
        };

        Object.entries(headers).forEach(([key, value]) => {
          res.setHeader(key, value);
        });

        return data.data;
      }),
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/filters/utils/controller-route/controller-route.ts
import { ControllerRoute } from 'src/api/common';

export function includesControllerRoute(path: string): boolean {
  for (const enumValue in ControllerRoute) {
    if (path.includes(ControllerRoute[enumValue])) {
      return true;
    }
  }
  return false;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/filters/utils/controller-route/controller-route.spec.ts
import { includesControllerRoute } from './controller-route';

describe('includesControllerRoute', () => {
  it('should return true if path is include in controller routes', () => {
    const path = 'http://localhost:5000/api/auth/login';

    const result = includesControllerRoute(path);
    expect(result).toBeTruthy();
  });

  it('should return false if path is not include in controller routes', () => {
    const path = 'http://localhost:5000/api/';

    const result = includesControllerRoute(path);
    expect(result).toBeFalsy();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/common/filters/http-exception.filter.ts
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';

import { SentryService } from 'src/services/sentry/sentry.service';
import { includesControllerRoute } from './utils/controller-route/controller-route';

export const notRequiredSentryCodes = [401, 403];

@Catch()
export class HttpExceptionFilter<T> implements ExceptionFilter {
  constructor(
    private readonly httpAdapterHost: HttpAdapterHost,
    private sentryService: SentryService,
  ) {}
  catch(exception: T, host: ArgumentsHost) {
    // In certain situations `httpAdapter` might not be available in the
    // constructor method, thus we should resolve it here.
    const { httpAdapter } = this.httpAdapterHost;

    const ctx = host.switchToHttp();
    const request = ctx.getRequest();
    const routePath = ctx.getRequest().url;
    const isHttpException = exception instanceof HttpException;
    const pathInControllerRoute = includesControllerRoute(routePath);

    const httpStatusCode = isHttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    const httpCodeInNotRequired =
      notRequiredSentryCodes.includes(httpStatusCode);

    const responseBody = isHttpException
      ? exception.getResponse()
      : {
          httpStatusCode,
          message: 'Internal server error!',
        };

    if (
      (httpStatusCode === 404 && !pathInControllerRoute) ||
      httpCodeInNotRequired
    ) {
      httpAdapter.reply(ctx.getResponse(), responseBody, httpStatusCode);
      return;
    }

    const requestUsername = request?.user?.name ?? request.user?.username;

    const context = {
      user: {
        id: request?.user?.id,
        ip_address: request.ip,
        username: requestUsername,
      },
    };

    const tags = {
      url: request.url,
      method: request.method,
      status_code: httpStatusCode,
      merchant: request?.user?.merchant?.name,
    };

    this.sentryService.captureException(exception, context, tags);

    httpAdapter.reply(ctx.getResponse(), responseBody, httpStatusCode);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/app.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Payments Engine"', () => {
      expect(appController.index()).toBe('Payments Engine API');
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/storage.ts
import { AsyncLocalStorage } from 'async_hooks';

const asyncLocalStorage: AsyncLocalStorage<{ requestId: string }> =
  new AsyncLocalStorage();

export default asyncLocalStorage;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/health/health.controller.ts
import { Controller, Get, Inject, VERSION_NEUTRAL } from '@nestjs/common';
import { ConfigType } from '@nestjs/config';
import {
  HealthCheck,
  HealthCheckService,
  HttpHealthIndicator,
  TypeOrmHealthIndicator,
} from '@nestjs/terminus';
import generalConfig from 'src/config/general.config';
import { RequireAuth } from 'src/api/v2/auth/decorators/requireAuth.decorator';

@Controller({ version: VERSION_NEUTRAL, path: 'health' })
export class HealthController {
  constructor(
    @Inject(generalConfig.KEY)
    private config: ConfigType<typeof generalConfig>,
    private health: HealthCheckService,
    private http: HttpHealthIndicator,
    private db: TypeOrmHealthIndicator,
  ) {}

  @Get()
  @HealthCheck()
  @RequireAuth('none')
  check() {
    const { url } = this.config.api;
    return this.health.check([
      () => this.http.pingCheck('app', url),
      () => this.db.pingCheck('database', { timeout: 5000 }),
    ]);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/health/health.controller.spec.ts
import {
  HealthCheckService,
  HttpHealthIndicator,
  TypeOrmHealthIndicator,
} from '@nestjs/terminus';
import { Test, TestingModule } from '@nestjs/testing';
import generalConfig from 'src/config/general.config';
import { HealthController } from './health.controller';
import { ConfigModule } from '@nestjs/config';
describe('HealthController', () => {
  let controller: HealthController;

  beforeEach(async () => {
    const mockHealthCheckService = {};
    const mockHttpHealthIndicator = {};
    const mockTypeOrmHealthIndicator = {};

    const module: TestingModule = await Test.createTestingModule({
      controllers: [HealthController],
      providers: [
        HealthCheckService,
        {
          provide: HealthCheckService,
          useValue: mockHealthCheckService,
        },
        {
          provide: HttpHealthIndicator,
          useValue: mockHttpHealthIndicator,
        },
        {
          provide: TypeOrmHealthIndicator,
          useValue: mockTypeOrmHealthIndicator,
        },
      ],
      imports: [ConfigModule.forFeature(generalConfig)],
    }).compile();

    controller = module.get<HealthController>(HealthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-job/transfer-job.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TransferJobEntity } from './entities/transfer-job.entity';
import { TransferJobService } from './transfer-job.service';
import { AwsBatchService } from 'src/services/aws/batch.service';

describe('TransferJobService', () => {
  let service: TransferJobService;
  const fakeTransferJobRepository = {};
  const mockBatchService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferJobService,
        {
          provide: getRepositoryToken(TransferJobEntity),
          useValue: fakeTransferJobRepository,
        },
        { provide: AwsBatchService, useValue: mockBatchService },
      ],
    }).compile();

    service = module.get<TransferJobService>(TransferJobService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-job/entities/transfer-job.entity.ts
import { IsEnum } from 'class-validator';
import { BaseEntity } from 'src/common/base.entity';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { Column, Entity, ManyToOne } from 'typeorm';

@Entity({ name: 'transfer_job' })
export class TransferJobEntity extends BaseEntity {
  @Column({ type: 'datetime', precision: 6, nullable: true })
  startedAt: Date;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  endedAt: Date;

  @IsEnum(TransferJobState)
  @Column('enum', {
    enum: TransferJobState,
    nullable: false,
    default: TransferJobState.CREATED,
  })
  state: TransferJobState;

  @Column({ type: 'varchar', nullable: true })
  jobId: string;

  @Column({ type: 'int', nullable: true })
  bankAccessId: number;

  @Column({ type: 'int', nullable: true })
  providerId: number;

  @Column({ type: 'int', default: 0 })
  totalCompleted: number;

  @Column({ type: 'int', default: 0 })
  totalFailed: number;

  // Relationships
  @ManyToOne(() => BankAccessEntity, (bankAccess) => bankAccess.id)
  bankAccess: BankAccessEntity;

  @ManyToOne(() => ProviderEntity, (provider) => provider.id)
  provider: ProviderEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-job/transfer-job.service.ts
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';
import { DataService } from 'src/database/data.service';
import { FindOneOptions, In, Repository } from 'typeorm';
import { CreateTransferJobDto } from 'src/api/v2/transfer-job/dtos/create-transfer-job.dto';
import { UpdateTransferJobDto } from 'src/api/v2/transfer-job/dtos/update-transfer-job.dto';
import { TransferJobEntity } from './entities/transfer-job.entity';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';
import { Environment } from 'src/common/enums/environment.enum';

const JOB_NAME_PREFIX = 'transfers-job';
@Injectable()
export class TransferJobService extends DataService<TransferJobEntity>(
  TransferJobEntity,
) {
  @InjectRepository(TransferJobEntity)
  private transferJobRepository: Repository<TransferJobEntity>;
  @Inject(AwsBatchService)
  private batchService: AwsBatchService;

  public async findOneByConditions(
    options?: FindOneOptions<TransferJobEntity>,
  ): Promise<TransferJobEntity> {
    const transferJob = this.transferJobRepository.findOne(options);

    if (!transferJob) throw new NotFoundException('Transfer job not found');

    return transferJob;
  }

  public async findOneUnfinished(
    bankAccessId: number,
  ): Promise<TransferJobEntity> {
    return this.findOneByConditions({
      where: {
        bankAccessId,
        state: In([TransferJobState.CREATED, TransferJobState.STARTED]),
      },
    });
  }

  public async create(
    createTransferJobDto: CreateTransferJobDto,
  ): Promise<TransferJobEntity> {
    const transferJob = this.transferJobRepository.create(createTransferJobDto);

    return this.transferJobRepository.save(transferJob);
  }

  public async update(
    id: number,
    updateTransferJobDto: UpdateTransferJobDto,
  ): Promise<TransferJobEntity> {
    const updatedTransferJob = await this.transferJobRepository.preload({
      id,
      ...updateTransferJobDto,
    });

    if (!updateTransferJobDto)
      throw new NotFoundException('Transfer job not found');

    return this.transferJobRepository.save(updatedTransferJob);
  }

  public generateJobName(args: {
    bankCode: string;
    bankAccountId: number;
    bankAccessId: number;
    env: Environment;
  }) {
    const { bankCode, bankAccessId, bankAccountId, env } = args;
    const formattedBankCode = bankCode.replace(/_/g, '-');
    const jobName = `${JOB_NAME_PREFIX}-${formattedBankCode}-${bankAccessId}-${bankAccountId}-${env}`;
    return jobName;
  }

  public async validateAnyRunningJob(
    jobName: string,
    bankAccessId: number,
  ): Promise<boolean> {
    const unfinishedJob = await this.findOneUnfinished(bankAccessId);
    const existingJobExecution =
      await this.batchService.findUnfinishedJobByName(
        jobName,
        AwsBatchJob.transfers,
      );

    if (unfinishedJob || existingJobExecution) {
      console.info('Found existing transfer job');
      return true;
    }
    return false;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-job/transfer-job.module.ts
import { Module } from '@nestjs/common';
import { TransferJobService } from './transfer-job.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TransferJobEntity } from './entities/transfer-job.entity';
import { AwsModule } from 'src/services/aws/aws.module';

@Module({
  providers: [TransferJobService],
  imports: [AwsModule, TypeOrmModule.forFeature([TransferJobEntity])],
  exports: [TransferJobService, TypeOrmModule],
})
export class TransferJobModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout-actions/payout-actions.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { PayoutActionEntity } from './entities/payout-action.entity';
import { PayoutActionsService } from './payout-actions.service';

describe('given a PayoutActionsService', () => {
  let service: PayoutActionsService;

  beforeEach(async () => {
    const mockPayoutActionEntity = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PayoutActionsService,
        {
          provide: getRepositoryToken(PayoutActionEntity),
          useValue: mockPayoutActionEntity,
        },
      ],
    }).compile();

    service = module.get<PayoutActionsService>(PayoutActionsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout-actions/payout-actions.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { PayoutActionEntity } from './entities/payout-action.entity';
import { DataService } from 'src/database/data.service';

@Injectable()
export class PayoutActionsService extends DataService<PayoutActionEntity>(
  PayoutActionEntity,
) {
  @InjectRepository(PayoutActionEntity)
  private payoutActionRepository: Repository<PayoutActionEntity>;

  public async getAutomatedPayoutAction(
    errorCode: TransferErrorCode,
  ): Promise<PayoutActionEntity> {
    return this.payoutActionRepository.findOne({
      where: { errorCode },
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout-actions/entities/payout-action.entity.ts
import { Column, Entity, Unique } from 'typeorm';
import { BaseEntity } from 'src/common/base.entity';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { IsEnum } from 'class-validator';
import { PayoutAction } from 'src/common/enums/payout-action.enum';
import { PayoutActionSuggestion } from 'src/common/enums/payout-action-suggestion.enum';

@Entity({ name: 'payout_action' })
export class PayoutActionEntity extends BaseEntity {
  @Unique(['errorCode'])
  @IsEnum(TransferErrorCode)
  @Column('enum', {
    enum: TransferErrorCode,
    default: null,
    nullable: false,
  })
  errorCode?: TransferErrorCode;

  @Column('enum', {
    enum: PayoutAction,
    default: null,
    nullable: true,
  })
  action?: PayoutAction;

  @Column('enum', {
    enum: PayoutActionSuggestion,
    default: null,
    nullable: true,
  })
  suggestion?: PayoutActionSuggestion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout-actions/payout-actions.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PayoutActionEntity } from './entities/payout-action.entity';
import { PayoutActionsService } from './payout-actions.service';

@Module({
  imports: [TypeOrmModule.forFeature([PayoutActionEntity])],
  providers: [PayoutActionsService],
  exports: [PayoutActionsService],
})
export class PayoutActionsModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank-access/entities/bank-access.entity.ts
import { IsEnum } from 'class-validator';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { EncryptTransformer } from 'src/common/transformers/encrypt.transformer';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import {
  Column,
  Entity,
  JoinColumn,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToMany,
} from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';
import { State } from 'src/common/enums/state.enum';
import { AccessType } from 'src/common/enums/access-type.enum';
import { ApiHideProperty } from '@nestjs/swagger';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { BankAccessCapability } from 'src/common/enums/bank-access-capability.enum';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';

@Entity({ name: 'bank_access' })
export class BankAccessEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 128 })
  name: string;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @IsEnum(AccessType)
  @Column('enum', {
    enum: AccessType,
    default: AccessType.BUSINESS,
    nullable: false,
  })
  accessType: AccessType;

  @ExcludeFromLogs()
  @Column({
    type: 'text',
    transformer: EncryptTransformer.default(),
    nullable: true,
  })
  credentials: any;

  @Column({ type: 'simple-array', nullable: true })
  capabilities: BankAccessCapability[];

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @Column({ type: 'varchar', length: 64, nullable: false })
  bankCode: string;

  @IsEnum(State)
  @Column('enum', {
    enum: ProviderType,
    default: ProviderType.ScraperCG,
    nullable: false,
  })
  providerType: ProviderType;

  // Relationships
  @ExcludeFromLogs()
  @ApiHideProperty()
  @OneToMany(
    () => TransferMethodEntity,
    (transferMethod) => transferMethod.bankAccess,
  )
  transferMethods: TransferMethodEntity[];

  @ManyToMany(
    () => BankAccountEntity,
    (bankAccount) => bankAccount.bankAccesses,
    { eager: true },
  )
  @JoinTable({ name: 'bank_access_accounts' })
  bankAccounts: BankAccountEntity[];

  @ApiHideProperty()
  @OneToMany(() => TransferEntity, (transfer) => transfer.originBankAccess)
  transfers: TransferEntity[];

  @ApiHideProperty()
  @ManyToOne(() => MerchantEntity, (merchant) => merchant.bankAccesses)
  merchant: MerchantEntity;

  @ApiHideProperty()
  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.bankAccesses, { eager: true })
  bank: BankEntity;

  @OneToMany(() => TransferJobEntity, (transferJob) => transferJob.bankAccess)
  transferJobs: TransferJobEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/provider/entities/provider.entity.ts
import { IsEnum } from 'class-validator';
import { Exclude } from 'class-transformer';
import {
  Column,
  DeleteDateColumn,
  Entity,
  ManyToOne,
  OneToMany,
} from 'typeorm';

import { State } from 'src/common/enums/state.enum';
import { BaseEntity } from 'src/common/base.entity';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';
import EncryptionTransformer from 'src/common/transformers/encryption.transformer';

import { AccountEntity } from 'src/models/account/entities/account.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import CredentialTransformer from 'src/common/transformers/credential.transformer';
import { Credential } from 'src/utils/encryption.util';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

@Entity({ name: 'provider' })
export class ProviderEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 128 })
  name: string;

  @IsEnum(ProviderType)
  @Column('enum', { enum: ProviderType, nullable: false })
  providerType: ProviderType;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.INACTIVE, nullable: false })
  state: State;

  @Exclude()
  @ExcludeFromLogs()
  @Column({
    type: 'text',
    transformer: EncryptionTransformer.default(),
    nullable: true,
  })
  credentials?: any;

  @Column({ type: 'json', nullable: true })
  rules?: RuleDefinition;

  @Column({ type: 'int', nullable: true })
  priority?: number;

  @Column({ type: 'int', nullable: false })
  accountId: number;

  @Column({
    type: 'simple-array',
    nullable: false,
  })
  capabilities: ProviderCapability[];

  @Exclude()
  @DeleteDateColumn()
  deletedAt?: Date;
  // Relationships
  @ManyToOne(() => AccountEntity, (account) => account.providers, {
    eager: true,
  })
  account: AccountEntity;

  @OneToMany(() => TransferEntity, (transfer) => transfer.provider)
  transfers?: TransferEntity[];

  // Properties

  // To access getters, the entity must be instantiated first (with repository.create)
  @Exclude()
  get decryptedCredentials(): Credential {
    return CredentialTransformer.decrypt(this.credentials);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/provider/provider.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ProviderService } from './provider.service';
import { ProviderEntity } from './entities/provider.entity';
import { ScraperCGProviderAdapter } from 'src/providers/scraperCG/scraperCG.provider';
import { ScraperPWProviderAdapter } from 'src/providers/scraperPW/scraperPW.provider';
import { MinkaProviderAdapter } from 'src/providers/minka/minka.provider';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';
import { ThomasProviderAdapter } from 'src/providers/thomas/thomas.provider';

describe('ProviderService', () => {
  let service: ProviderService;
  const fakeAccountRepository = {};

  const mockScraperCGProvider: Partial<ScraperCGProviderAdapter> = {};
  const mockScraperPWProvider: Partial<ScraperPWProviderAdapter> = {};
  const mockMinkaProvider: Partial<MinkaProviderAdapter> = {};
  const mockLiquidoProvider: Partial<LiquidoProviderAdapter> = {};
  const mockShinkansenProvider: Partial<ShinkansenProvider> = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProviderService,
        {
          provide: getRepositoryToken(ProviderEntity),
          useValue: fakeAccountRepository,
        },
        { provide: MinkaProviderAdapter, useValue: mockMinkaProvider },
        { provide: LiquidoProviderAdapter, useValue: mockLiquidoProvider },
        { provide: ScraperCGProviderAdapter, useValue: mockScraperCGProvider },
        { provide: ScraperPWProviderAdapter, useValue: mockScraperPWProvider },
        { provide: ShinkansenProvider, useValue: mockShinkansenProvider },
        { provide: ThomasProviderAdapter, useValue: {} },
      ],
    }).compile();

    service = module.get<ProviderService>(ProviderService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/provider/provider.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProviderService } from './provider.service';
import { ProviderEntity } from './entities/provider.entity';
import { ScraperCGProviderModule } from 'src/providers/scraperCG/scraperCG.provider.module';
import { ScraperPWProviderModule } from 'src/providers/scraperPW/scraperPW.provider.module';
import { MinkaProviderModule } from 'src/providers/minka/minka.provider.module';
import { LiquidoProviderModule } from 'src/providers/liquido/liquido.provider.module';
import { ShinkansenProviderModule } from 'src/providers/shinkansen/shinkansen.provider.module';
import { ThomasModule } from 'src/providers/thomas/thomas.module';

@Module({
  imports: [
    ScraperCGProviderModule,
    ScraperPWProviderModule,
    MinkaProviderModule,
    LiquidoProviderModule,
    ShinkansenProviderModule,
    ThomasModule,
    TypeOrmModule.forFeature([ProviderEntity]),
  ],
  providers: [ProviderService],
  exports: [ProviderService],
})
export class ProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/provider/provider.service.ts
import {
  Inject,
  Injectable,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import moment = require('moment');
import { CreateProviderDto } from 'src/api/v2/provider/dto/create-provider.dto';
import { UpdateProviderDto } from 'src/api/v2/provider/dto/update-provider.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import RulesEvaluator, { TotalTransferred } from 'src/common/rules/evaluator';
import { TimeWindow } from 'src/common/rules/rule-definitions/rule-definition-params';
import { DataService } from 'src/database/data.service';
import { Brackets, FindManyOptions, FindOneOptions, Repository } from 'typeorm';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { ProviderEntity } from './entities/provider.entity';
import { State } from 'src/common/enums/state.enum';
import CredentialTransformer from 'src/common/transformers/credential.transformer';
import { MinkaProviderAdapter } from 'src/providers/minka/minka.provider';
import { ScraperCGProviderAdapter } from 'src/providers/scraperCG/scraperCG.provider';
import { ScraperPWProviderAdapter } from 'src/providers/scraperPW/scraperPW.provider';
import { ShinkansenProvider } from 'src/providers/shinkansen/shinkansen.provider';
import { LiquidoProviderAdapter } from 'src/providers/liquido/liquido.provider';
import { ThomasProviderAdapter } from 'src/providers/thomas/thomas.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { BaseProviderAdapter } from 'src/providers/base.provider';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';

@Injectable()
export class ProviderService extends DataService<ProviderEntity>(
  ProviderEntity,
) {
  @InjectRepository(ProviderEntity)
  private providerRepository: Repository<ProviderEntity>;
  @Inject(MinkaProviderAdapter)
  private minkaProviderAdapter: MinkaProviderAdapter;
  @Inject(ScraperCGProviderAdapter)
  private scraperCGProviderAdapter: ScraperCGProviderAdapter;
  @Inject(ScraperPWProviderAdapter)
  private scraperPWProviderAdapter: ScraperPWProviderAdapter;
  @Inject(ShinkansenProvider)
  private shinkansenProviderAdapter: ShinkansenProvider;
  @Inject(LiquidoProviderAdapter)
  private liquidoProviderAdapter: LiquidoProviderAdapter;
  @Inject(ThomasProviderAdapter)
  private thomasProviderAdapter: ThomasProviderAdapter;

  getProviderAdapter(providerType: ProviderType): BaseProviderAdapter {
    if (providerType === ProviderType.Minka) return this.minkaProviderAdapter;
    if (providerType === ProviderType.ScraperCG)
      return this.scraperCGProviderAdapter;
    if (providerType === ProviderType.ScraperPW)
      return this.scraperPWProviderAdapter;
    if (providerType === ProviderType.Shinkansen)
      return this.shinkansenProviderAdapter;
    if (providerType === ProviderType.Liquido)
      return this.liquidoProviderAdapter;
    if (providerType === ProviderType.Thomas) return this.thomasProviderAdapter;

    throw new Error(`Provider type ${providerType} not supported`);
  }

  async findAll(
    options?: FindManyOptions<ProviderEntity>,
  ): Promise<ProviderEntity[]> {
    return this.providerRepository.find(options);
  }

  async findOne(id: number): Promise<ProviderEntity> {
    return this.providerRepository.findOne({ where: { id } });
  }

  async findOneByConditions(
    options?: FindOneOptions<ProviderEntity>,
  ): Promise<ProviderEntity> {
    return this.providerRepository.findOne(options);
  }

  async create(createProviderDto: CreateProviderDto): Promise<ProviderEntity> {
    const credentials = CredentialTransformer.encrypt(
      createProviderDto.credentials,
    );

    createProviderDto.credentials = credentials;

    if (!createProviderDto?.capabilities) {
      // Set default value at creation
      createProviderDto.capabilities = [ProviderCapability.CREATE_TRANSFER];
    }

    const provider = this.providerRepository.create(createProviderDto);

    return this.providerRepository.save(provider);
  }

  async update(
    id: number,
    updateProviderDto: UpdateProviderDto,
  ): Promise<ProviderEntity> {
    if (updateProviderDto?.state === State.DELETED) {
      throw new UnprocessableEntityException(
        "Can't update provider to 'deleted' state",
      );
    }
    const provider = await this.providerRepository.findOne({
      where: { id },
    });

    if (!provider) {
      throw new NotFoundException(`Provider ${id} not found`);
    }
    delete provider.credentials;
    if (updateProviderDto.credentials) {
      updateProviderDto.credentials = CredentialTransformer.encrypt(
        updateProviderDto.credentials,
      );
    } else {
      delete updateProviderDto.credentials;
    }
    const providerChanges = this.providerRepository.merge(
      provider,
      updateProviderDto,
    );
    const updatedProvider = await this.providerRepository.save(providerChanges);

    return updatedProvider;
  }

  async remove(id: number): Promise<void> {
    const provider = await this.providerRepository.findOne({ where: { id } });

    if (!provider) throw new NotFoundException('Provider not found');

    // TODO: Reminder of the need to refactor State enum
    // provider.state = State.DELETED;

    await this.providerRepository.softRemove(provider);
  }

  async getTotalTransferred(
    id: number,
    filters?: { window?: TimeWindow },
  ): Promise<TotalTransferred> {
    const { window } = filters ?? {};
    let limitDate: Date;

    if (window === 'daily') limitDate = moment().startOf('date').toDate();
    if (window === 'monthly') limitDate = moment().startOf('month').toDate();

    const queryResult = await this.providerRepository
      .createQueryBuilder('provider')
      .leftJoin('provider.transfers', 'transfer')
      .select('SUM(transfer.amount)', 'amount')
      .addSelect('COUNT(*)', 'count')
      .where('provider.id = :id', { id })
      .andWhere(
        new Brackets((qb) => {
          qb.where('transfer.state = :state', {
            state: TransferState.COMPLETED,
          });
          qb.andWhere('transfer.finishedAt >= :limitDate', { limitDate });
        }),
      )
      .orWhere(
        new Brackets((qb) => {
          qb.where('transfer.state IN (:...states)', {
            states: [TransferState.ASSIGNED, TransferState.PROCESSING],
          });
          qb.andWhere('transfer.createdAt >= :limitDate', { limitDate });
        }),
      )
      .getRawOne();

    // Ensure correct data type
    const result = {
      amount: parseFloat(queryResult.amount),
      count: parseInt(queryResult.count),
    };

    return result;
  }

  async buildEvaluatorContext(id: number, transfer: TransferEntity) {
    const totalDailyTransfered = await this.getTotalTransferred(id, {
      window: 'daily',
    });

    const context = {
      transfer,
      transferred: {
        all: {
          daily: totalDailyTransfered.amount,
        },
        count: {
          daily: totalDailyTransfered.count,
        },
      },
    };

    return context;
  }

  async evaluateRules(
    provider: ProviderEntity,
    transfer: TransferEntity,
  ): Promise<boolean> {
    const totalDailyTransfered = await this.getTotalTransferred(provider.id, {
      window: 'daily',
    });

    const context = {
      transfer,
      transferred: {
        all: {
          daily: totalDailyTransfered.amount,
        },
        count: {
          daily: totalDailyTransfered.count,
        },
      },
    };

    const processor = new RulesEvaluator(context);

    return processor.process(provider.rules);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/webhook-endpoint/webhook-endpoint.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { WebhookEndpointEntity } from './entities/webhook-endpoint.entity';
import { WebhookEndpointService } from './webhook-endpoint.service';

describe('given a WebhookEndpointService', () => {
  let service: WebhookEndpointService;

  beforeEach(async () => {
    const mockWebhookEndpointEntityRepo = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        WebhookEndpointService,
        {
          provide: getRepositoryToken(WebhookEndpointEntity),
          useValue: mockWebhookEndpointEntityRepo,
        },
      ],
    }).compile();

    service = module.get<WebhookEndpointService>(WebhookEndpointService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/webhook-endpoint/entities/webhook-endpoint.subscriber.ts
import {
  EntitySubscriberInterface,
  EventSubscriber,
  InsertEvent,
} from 'typeorm';
import { WebhookEndpointEntity } from './webhook-endpoint.entity';
import { generateSecret } from 'src/utils/secrets.util';

@EventSubscriber()
export class WebhookEndpointSubscriber
  implements EntitySubscriberInterface<WebhookEndpointEntity>
{
  listenTo() {
    return WebhookEndpointEntity;
  }

  beforeInsert(event: InsertEvent<WebhookEndpointEntity>) {
    event.entity.secret = generateSecret();
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/webhook-endpoint/entities/webhook-endpoint.entity.ts
import { IsEnum } from 'class-validator';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointState } from 'src/common/enums/webhook-endpoint-state.enum';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { Column, Entity, ManyToOne } from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';

@Entity({ name: 'webhook_endpoint' })
export class WebhookEndpointEntity extends BaseEntity {
  @Column({ type: 'text', nullable: false })
  url: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({ type: 'simple-array', nullable: false })
  enabledEvents: WebhookEvent[];

  @ExcludeFromLogs()
  @Column({ type: 'varchar', length: 128, nullable: false })
  secret: string;

  @IsEnum(WebhookEndpointState)
  @Column('enum', {
    enum: WebhookEndpointState,
    default: WebhookEndpointState.ENABLED,
    nullable: false,
  })
  state: WebhookEndpointState;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  // Relationships

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.webhookEndpoints, {
    eager: true,
  })
  merchant: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/webhook-endpoint/webhook-endpoint.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { WebhookEvent } from 'src/common/enums/webhook-endpoint-event.enum';
import { WebhookEndpointState } from 'src/common/enums/webhook-endpoint-state.enum';
import { FindManyOptions, FindOneOptions, Like, Repository } from 'typeorm';
import { CreateWebhookEndpointDto } from 'src/api/v2/webhook-endpoint/dto/create-webhook-endpoint.dto';
import { UpdateWebhookEndpointDto } from 'src/api/v2/webhook-endpoint/dto/update-webhook-endpoint.dto';
import { WebhookEndpointEntity } from './entities/webhook-endpoint.entity';

@Injectable()
export class WebhookEndpointService {
  constructor(
    @InjectRepository(WebhookEndpointEntity)
    private webhookEndpointRepository: Repository<WebhookEndpointEntity>,
  ) {}

  findAll(options: FindManyOptions = {}): Promise<WebhookEndpointEntity[]> {
    return this.webhookEndpointRepository.find(options);
  }

  async findByEventName(
    eventName: WebhookEvent,
    merchantId: number,
  ): Promise<WebhookEndpointEntity[]> {
    const eventNameMatch = `%${eventName}%` as unknown as WebhookEvent; // to avoid type error

    const options: FindManyOptions<WebhookEndpointEntity> = {
      where: {
        merchantId,
        state: WebhookEndpointState.ENABLED,
        enabledEvents: Like(eventNameMatch),
      },
    };

    const webhookEndpoints = await this.webhookEndpointRepository.find(options);
    return webhookEndpoints;
  }

  async findOne(id: number): Promise<WebhookEndpointEntity> {
    const webhookEndpoint = await this.webhookEndpointRepository.findOne({
      where: { id },
    });
    if (!webhookEndpoint) {
      throw new NotFoundException(`Webhook Endpoint ${id} not found`);
    }
    return webhookEndpoint;
  }

  async findOneByConditions(
    options?: FindOneOptions<WebhookEndpointEntity>,
  ): Promise<WebhookEndpointEntity> {
    const webhookEndpoint = await this.webhookEndpointRepository.findOne(
      options,
    );

    if (!webhookEndpoint) {
      throw new NotFoundException(`Webhook Endpoint not found`);
    }
    return webhookEndpoint;
  }

  create(
    createWebhookEndpointDto: CreateWebhookEndpointDto,
  ): Promise<WebhookEndpointEntity> {
    const webhookEndpoint = this.webhookEndpointRepository.create(
      createWebhookEndpointDto,
    );
    return this.webhookEndpointRepository.save(webhookEndpoint);
  }

  async update(
    id: number,
    updateWebhookEndpointDto: UpdateWebhookEndpointDto,
  ): Promise<WebhookEndpointEntity> {
    const webhookEndpoint = await this.webhookEndpointRepository.preload({
      id: Number(id),
      ...updateWebhookEndpointDto,
    });
    if (!webhookEndpoint) {
      throw new NotFoundException(`Webhook Endpoint ${id} not found`);
    }
    return this.webhookEndpointRepository.save(webhookEndpoint);
  }

  async remove(id: number): Promise<WebhookEndpointEntity> {
    const webhookEndpoint = await this.findOne(id);
    return this.webhookEndpointRepository.remove(webhookEndpoint);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/webhook-endpoint/webhook-endpoint.module.ts
import { Module } from '@nestjs/common';
import { WebhookEndpointService } from './webhook-endpoint.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { WebhookEndpointEntity } from './entities/webhook-endpoint.entity';

@Module({
  providers: [WebhookEndpointService],
  imports: [TypeOrmModule.forFeature([WebhookEndpointEntity])],
  exports: [TypeOrmModule, WebhookEndpointService],
})
export class WebhookEndpointModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/merchant.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { MerchantService } from './merchant.service';
import { MerchantEntity } from './entities/merchant.entity';

@Module({
  providers: [MerchantService],
  imports: [TypeOrmModule.forFeature([MerchantEntity])],
  exports: [TypeOrmModule, MerchantService],
})
export class MerchantModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/entities/merchant.entity.ts
import { ApiKeyEntity } from './../../apikey/entities/apikey.entity';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { MerchantLimitEntity } from 'src/models/merchant-limit/entities/merchant-limit.entity';
import { UserEntity } from 'src/models/user/entities/user.entity';
import { Column, Entity, OneToMany } from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';
import { DepositEntity } from 'src/models/deposit/entities/deposit.entity';
import { IsEnum } from 'class-validator';
import { State } from 'src/common/enums/state.enum';
import { WebhookEndpointEntity } from 'src/models/webhook-endpoint/entities/webhook-endpoint.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';

@Entity({ name: 'merchant' })
export class MerchantEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 128 })
  name: string;

  @Column({ type: 'varchar', length: 128, unique: true, nullable: false })
  identifier: string;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  // Relationships

  @OneToMany(() => UserEntity, (user) => user.merchant)
  users: UserEntity[];

  @OneToMany(() => ApiKeyEntity, (apiKey) => apiKey.merchant)
  apiKeys: ApiKeyEntity[];

  @OneToMany(() => BankAccessEntity, (bankAccess) => bankAccess.merchant)
  bankAccesses: BankAccessEntity[];

  @OneToMany(() => BankAccountEntity, (bankAccount) => bankAccount.merchant)
  bankAccounts: BankAccountEntity[];

  @OneToMany(() => PayoutEntity, (payout) => payout.merchant)
  payouts: PayoutEntity[];

  @OneToMany(() => TransferEntity, (transfer) => transfer.merchant)
  transfers: TransferEntity[];

  @OneToMany(() => DepositEntity, (deposit) => deposit.merchant)
  deposits: DepositEntity[];

  @OneToMany(() => AccountEntity, (account) => account.merchant)
  accounts: AccountEntity[];

  @OneToMany(
    () => MerchantLimitEntity,
    (merchantLimit) => merchantLimit.merchant,
  )
  merchantLimits?: MerchantLimitEntity[];

  @OneToMany(
    () => WebhookEndpointEntity,
    (webhookEndpoint) => webhookEndpoint.merchant,
  )
  webhookEndpoints: WebhookEndpointEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/merchant.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataService } from 'src/database/data.service';
import { Repository } from 'typeorm';
import { CreateMerchantDto } from 'src/models/merchant/dto/create-merchant.dto';
import { UpdateMerchantDto } from 'src/models/merchant/dto/update-merchant.dto';
import { MerchantEntity } from './entities/merchant.entity';

@Injectable()
export class MerchantService extends DataService<MerchantEntity>(
  MerchantEntity,
) {
  @InjectRepository(MerchantEntity)
  private merchantRepository: Repository<MerchantEntity>;

  findAll(): Promise<MerchantEntity[]> {
    return this.merchantRepository.find();
  }

  async findOne(id: number): Promise<MerchantEntity> {
    const merchant = await this.merchantRepository.findOne({ where: { id } });
    if (!merchant) throw new NotFoundException(`Merchant ${id} not found`);
    return merchant;
  }

  create(createMerchantDto: CreateMerchantDto): Promise<MerchantEntity> {
    const merchant = this.merchantRepository.create(createMerchantDto);
    return this.merchantRepository.save(merchant);
  }

  async update(
    id: number,
    updateMerchantDto: UpdateMerchantDto,
  ): Promise<MerchantEntity> {
    const merchant = await this.merchantRepository.preload({
      id: Number(id),
      ...updateMerchantDto,
    });
    if (!merchant) {
      throw new NotFoundException(`Merchant ${id} not found`);
    }
    return this.merchantRepository.save(merchant);
  }

  async remove(id: number): Promise<MerchantEntity> {
    const merchant = await this.findOne(id);
    return this.merchantRepository.remove(merchant);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/merchant.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { MerchantEntity } from './entities/merchant.entity';
import { MerchantService } from './merchant.service';

describe('given a MerchantService', () => {
  let service: MerchantService;

  beforeEach(async () => {
    const mockMerchantRepo = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MerchantService,
        {
          provide: getRepositoryToken(MerchantEntity),
          useValue: mockMerchantRepo,
        },
      ],
    }).compile();

    service = module.get<MerchantService>(MerchantService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/dto/update-merchant.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateMerchantDto } from './create-merchant.dto';

export class UpdateMerchantDto extends PartialType(CreateMerchantDto) {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/dto/create-merchant.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateMerchantDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  identifier: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant/dto/get-merchants-query.dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetMerchantsQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-method/entities/transfer-method.entity.ts
import { Column, Entity, Index, ManyToOne, OneToMany } from 'typeorm';
import { IsEnum } from 'class-validator';
import { BaseEntity } from 'src/common/base.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { EncryptTransformer } from 'src/common/transformers/encrypt.transformer';
import { State } from 'src/common/enums/state.enum';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { Exclude } from 'class-transformer';
import { AuthorizationCodeEntity } from 'src/models/authorization-code/entities/authorization-code.entity';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';

@Entity({ name: 'transfer_method' })
@Index(['identifier', 'methodType'], { unique: true })
export class TransferMethodEntity extends BaseEntity {
  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @ExcludeFromLogs()
  @Exclude()
  @Column({
    type: 'text',
    transformer: EncryptTransformer.default(),
    nullable: true,
  })
  signingKeys: any;

  @Column({ type: 'varchar', length: 128, nullable: false })
  identifier: string;

  @IsEnum(TransferMethodType)
  @Column('enum', {
    enum: TransferMethodType,
    nullable: false,
  })
  methodType: TransferMethodType;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @Column({ type: 'int', nullable: false })
  bankAccessId: number;

  // Relationships

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.bankAccounts)
  merchant: MerchantEntity;

  @ManyToOne(() => BankAccessEntity, (bankAccess) => bankAccess.transferMethods)
  bankAccess: BankAccessEntity;

  @OneToMany(
    () => AuthorizationCodeEntity,
    (authorizationCode) => authorizationCode.transferMethod,
  )
  authorizationCodes: AuthorizationCodeEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-method/transfer-method.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { TransferMethodType } from 'src/common/enums/transfer-method-type.enum';
import { DataService } from 'src/database/data.service';
import { FindManyOptions, FindOneOptions, Repository } from 'typeorm';
import { CreateTransferMethodDto } from 'src/api/v2/transfer-method/dto/create-transfer-method.dto';
import { UpdateTransferMethodDto } from 'src/api/v2/transfer-method/dto/update-transfer-method.dto';
import { TransferMethodEntity } from './entities/transfer-method.entity';

@Injectable()
export class TransferMethodService extends DataService<TransferMethodEntity>(
  TransferMethodEntity,
) {
  @InjectRepository(TransferMethodEntity)
  private transferMethodRepository: Repository<TransferMethodEntity>;

  findAll(options: FindManyOptions = {}): Promise<TransferMethodEntity[]> {
    return this.transferMethodRepository.find(options);
  }

  findByMerchantId(merchantId: number): Promise<TransferMethodEntity[]> {
    return this.transferMethodRepository.find({ where: { merchantId } });
  }

  async findOne(id: number): Promise<TransferMethodEntity> {
    const bankAccount = await this.transferMethodRepository.findOne({
      where: { id },
    });
    if (!bankAccount) {
      throw new NotFoundException(`Transfer Method ${id} not found`);
    }
    return bankAccount;
  }

  async findOneByConditions(
    options: FindOneOptions<TransferMethodEntity>,
  ): Promise<TransferMethodEntity> {
    const bankAccount = await this.transferMethodRepository.findOne(options);
    if (!bankAccount) throw new NotFoundException(`Transfer Method not found`);
    return bankAccount;
  }

  create(
    createTransferMethodDto: CreateTransferMethodDto,
  ): Promise<TransferMethodEntity> {
    const transferMethod = this.transferMethodRepository.create(
      createTransferMethodDto,
    );
    return this.transferMethodRepository.save(transferMethod);
  }

  async update(
    id: number,
    updateTransferMethodDto: UpdateTransferMethodDto,
  ): Promise<TransferMethodEntity> {
    const transferMethod = await this.transferMethodRepository.preload({
      id: Number(id),
      ...updateTransferMethodDto,
    });
    if (!transferMethod) {
      throw new NotFoundException(`TransferMethod ${id} not found`);
    }
    return this.transferMethodRepository.save(transferMethod);
  }

  async remove(id: number): Promise<TransferMethodEntity> {
    const transferMethod = await this.findOne(id);
    return this.transferMethodRepository.remove(transferMethod);
  }

  async findByPhoneNumber(phoneNumber: string): Promise<TransferMethodEntity> {
    const transferMethod = await this.transferMethodRepository.findOne({
      where: { identifier: phoneNumber, methodType: TransferMethodType.SMS },
    });
    return transferMethod;
  }

  async findByDigipassIdentifier(
    identifier: string,
  ): Promise<TransferMethodEntity> {
    const transferMethod = await this.transferMethodRepository.findOne({
      where: {
        identifier: identifier,
        methodType: TransferMethodType.DIGIPASS,
      },
    });
    return transferMethod;
  }

  async findByMobileIdentifier(
    identifier: string,
  ): Promise<TransferMethodEntity> {
    const transferMethod = await this.transferMethodRepository.findOne({
      where: {
        identifier: identifier,
        methodType: TransferMethodType.MOBILE,
      },
    });
    return transferMethod;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-method/transfer-method.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TransferMethodEntity } from './entities/transfer-method.entity';
import { TransferMethodService } from './transfer-method.service';

describe('given a TransferMethodService', () => {
  let service: TransferMethodService;

  beforeEach(async () => {
    const mockTransferMethodRepo = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferMethodService,
        {
          provide: getRepositoryToken(TransferMethodEntity),
          useValue: mockTransferMethodRepo,
        },
      ],
    }).compile();

    service = module.get<TransferMethodService>(TransferMethodService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-method/transfer-method.module.ts
import { Module } from '@nestjs/common';
import { TransferMethodService } from './transfer-method.service';
import { TransferMethodEntity } from './entities/transfer-method.entity';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  providers: [TransferMethodService],
  imports: [TypeOrmModule.forFeature([TransferMethodEntity])],
  exports: [TypeOrmModule, TransferMethodService],
})
export class TransferMethodModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/authorization-code.service.ts
import {
  ForbiddenException,
  Inject,
  Injectable,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';
import moment = require('moment');
import { DataService } from 'src/database/data.service';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { LessThan, MoreThanOrEqual, Not, Repository } from 'typeorm';
import { TransferMethodEntity } from '../transfer-method/entities/transfer-method.entity';
import { TransferMethodService } from '../transfer-method/transfer-method.service';
import { DeviceCodeMessageDto } from 'src/models/authorization-code/dto/device-code-message.dto';
import { AuthorizationCodeEntity } from './entities/authorization-code.entity';
import { TwilioMessageDto } from 'src/services/twilio/dto/twilio-message.dto';
import { CreateAuthorizationCodeDto } from './dto/create-authorization-code.dto';

const CODE_REGEX = new RegExp(/([0-9]{4,12})/, 'i');
const INVALID_CHARACTERS_REGEX = new RegExp(/[^0-9a-z]/, 'gi');

@Injectable()
export class AuthorizationCodeService extends DataService<AuthorizationCodeEntity>(
  AuthorizationCodeEntity,
) {
  @InjectRepository(AuthorizationCodeEntity)
  private authorizationCodeRepository: Repository<AuthorizationCodeEntity>;
  @Inject(TransferMethodService)
  private transferMethodService: TransferMethodService;

  async create(
    createAuthorizationCodeDto: CreateAuthorizationCodeDto,
  ): Promise<AuthorizationCodeEntity> {
    try {
      const authorizationCode = this.authorizationCodeRepository.create(
        createAuthorizationCodeDto,
      );

      const savedAuthCode = await this.authorizationCodeRepository.save(
        authorizationCode,
      );

      const { transferMethodId } = createAuthorizationCodeDto;

      // Expire all transfer method codes (except the new one)
      await this.repository.update(
        {
          id: Not(savedAuthCode.id),
          state: Not(AuthorizationCodeState.EXPIRED),
          transferMethodId: transferMethodId,
        },
        { state: AuthorizationCodeState.EXPIRED },
      );

      return savedAuthCode;
    } catch (error) {
      throw new UnprocessableEntityException(
        `Can't save an authorization code entity, error: ${error.message}`,
      );
    }
  }

  findAll(): Promise<AuthorizationCodeEntity[]> {
    return this.authorizationCodeRepository.find();
  }

  async findPendingForTransferMethod(
    transferMethod: TransferMethodEntity,
  ): Promise<AuthorizationCodeEntity> {
    const authorizationCode = await this.authorizationCodeRepository.findOne({
      where: {
        transferMethodId: transferMethod.id,
        state: AuthorizationCodeState.PENDING,
      },
      order: { createdAt: DESCENDING_ORDER },
    });
    return authorizationCode;
  }

  async findActiveForTransferMethod(
    transferMethod: TransferMethodEntity,
  ): Promise<AuthorizationCodeEntity> {
    const maxExpiration = moment().add(5, 'seconds').toDate();
    const authorizationCode = await this.authorizationCodeRepository.findOne({
      where: {
        transferMethodId: transferMethod.id,
        state: AuthorizationCodeState.ACTIVE,
        expiresAt: MoreThanOrEqual(maxExpiration),
      },
      order: { expiresAt: DESCENDING_ORDER },
    });
    return authorizationCode;
  }

  async findOneAndClaim(id: number): Promise<AuthorizationCodeEntity> {
    const authorizationCode = await this.authorizationCodeRepository.findOne({
      where: { id },
    });
    if (!authorizationCode)
      throw new NotFoundException(`AuthorizationCode ${id} not found`);

    if (authorizationCode.state !== AuthorizationCodeState.ACTIVE)
      throw new ForbiddenException(
        `Invalid state '${authorizationCode.state}', AuthorizationCode ${id} can't be claimed`,
      );

    authorizationCode.state = AuthorizationCodeState.CLAIMED;

    this.repository.save(authorizationCode);

    return authorizationCode;
  }

  async saveTwilioMessage(
    twilioMessageDto: TwilioMessageDto,
  ): Promise<AuthorizationCodeEntity> {
    const code = this.extractCode(twilioMessageDto.Body);
    const expiresAt = moment().add(60, 'seconds').toDate();

    const transferMethod = await this.transferMethodService.findByPhoneNumber(
      twilioMessageDto.To,
    );

    if (!transferMethod) return null;

    const authorizationCode = await this.create({
      code,
      expiresAt,
      transferMethodId: transferMethod.id,
      state: AuthorizationCodeState.ACTIVE,
    });

    return authorizationCode;
  }

  async saveDigipassMessage(
    deviceCodeMessageDto: DeviceCodeMessageDto,
  ): Promise<AuthorizationCodeEntity> {
    const { code, expiration, identifier } = deviceCodeMessageDto;
    const expiresAt = moment.unix(expiration).toDate();

    const transferMethod =
      await this.transferMethodService.findByDigipassIdentifier(identifier);

    if (!transferMethod) return null;

    const pendingAuthorizationCode = await this.findPendingForTransferMethod(
      transferMethod,
    );

    if (!pendingAuthorizationCode) {
      throw new UnprocessableEntityException(
        "Can't save Digipass code. No Authorization Codes in pending state",
      );
    }

    const authorizationCode = await this.repository.preload({
      id: pendingAuthorizationCode.id,
      code,
      expiresAt,
      state: AuthorizationCodeState.ACTIVE,
    });
    const updatedAuthorizationCode = await this.repository.save(
      authorizationCode,
    );

    return updatedAuthorizationCode;
  }

  async saveMobileMessage(
    deviceCodeMessageDto: DeviceCodeMessageDto,
  ): Promise<AuthorizationCodeEntity> {
    const { code, expiration, identifier } = deviceCodeMessageDto;
    const expiresAt = moment.unix(expiration).toDate();

    const transferMethod =
      await this.transferMethodService.findByMobileIdentifier(identifier);

    if (!transferMethod) return null;

    const pendingAuthorizationCode = await this.findPendingForTransferMethod(
      transferMethod,
    );

    if (!pendingAuthorizationCode) {
      throw new UnprocessableEntityException(
        "Can't save Mobile App code. No Authorization Codes in pending state",
      );
    }

    const authorizationCode = await this.repository.preload({
      id: pendingAuthorizationCode.id,
      code,
      expiresAt,
      state: AuthorizationCodeState.ACTIVE,
    });
    const updatedAuthorizationCode = await this.repository.save(
      authorizationCode,
    );

    return updatedAuthorizationCode;
  }

  extractCode(message: string): string {
    const cleanMessage = message.replace(INVALID_CHARACTERS_REGEX, '');
    const matches = CODE_REGEX.exec(cleanMessage);
    if (matches.length < 2) return null;

    const code = matches[1];
    return code;
  }

  public async updateExpiredCodes() {
    const currentDate = new Date();

    await this.repository.update(
      { expiresAt: LessThan(currentDate) },
      { state: AuthorizationCodeState.EXPIRED },
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/entities/authorization-code.entity.ts
import { Column, Entity, ManyToOne } from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';
import { EncryptTransformer } from 'src/common/transformers/encrypt.transformer';
import { TransferMethodEntity } from 'src/models/transfer-method/entities/transfer-method.entity';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';
import { IsEnum } from 'class-validator';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';

@Entity({ name: 'authorization_code' })
export class AuthorizationCodeEntity extends BaseEntity {
  @ExcludeFromLogs()
  @Column({
    type: 'text',
    transformer: EncryptTransformer.default(),
    nullable: true,
  })
  code: any;

  @Column({
    type: 'datetime',
    precision: 6,
    nullable: true,
  })
  expiresAt: Date;

  @Column({ type: 'int', nullable: false })
  transferMethodId: number;

  @IsEnum(AuthorizationCodeState)
  @Column('enum', {
    enum: AuthorizationCodeState,
    default: AuthorizationCodeState.ACTIVE,
  })
  state: AuthorizationCodeState;

  @ManyToOne(
    () => TransferMethodEntity,
    (transferMethod) => transferMethod.authorizationCodes,
  )
  transferMethod: TransferMethodEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/authorization-code.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TransferMethodService } from '../transfer-method/transfer-method.service';
import { AuthorizationCodeService } from './authorization-code.service';
import { AuthorizationCodeEntity } from './entities/authorization-code.entity';

describe('given a AuthorizationCodeService', () => {
  let service: AuthorizationCodeService;

  beforeEach(async () => {
    const mockAuthorizationCodeEntityRepo = {};
    const mockTransferMethodService = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthorizationCodeService,
        {
          provide: getRepositoryToken(AuthorizationCodeEntity),
          useValue: mockAuthorizationCodeEntityRepo,
        },
        {
          provide: TransferMethodService,
          useValue: mockTransferMethodService,
        },
      ],
    }).compile();

    service = module.get<AuthorizationCodeService>(AuthorizationCodeService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/dto/device-code-message.dto.ts
import { IsNotEmpty, IsNumber, IsString } from 'class-validator';

export class DeviceCodeMessageDto {
  @IsString()
  @IsNotEmpty()
  code: string;

  @IsNumber()
  @IsNotEmpty()
  expiration: number;

  @IsString()
  @IsNotEmpty()
  identifier: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/dto/create-authorization-code.dto.ts
import {
  IsDate,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { AuthorizationCodeState } from 'src/common/enums/authorization-code.state.enum';

export class CreateAuthorizationCodeDto {
  @IsNumber()
  transferMethodId: number;

  @IsString()
  @IsOptional()
  code?: string;

  @IsDate()
  @IsOptional()
  expiresAt?: Date;

  @IsEnum(AuthorizationCodeState)
  @IsOptional()
  state?: AuthorizationCodeState;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/authorization-code/authorization-code.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuthorizationCodeService } from './authorization-code.service';
import { AuthorizationCodeEntity } from './entities/authorization-code.entity';
import { TransferMethodModule } from '../transfer-method/transfer-method.module';
import { ConfigModule } from '@nestjs/config';
import twilioConfig from 'src/config/twilio.config';
import deviceConfig from 'src/config/device.config';

@Module({
  imports: [
    TypeOrmModule.forFeature([AuthorizationCodeEntity]),
    ConfigModule.forFeature(twilioConfig),
    ConfigModule.forFeature(deviceConfig),
    TransferMethodModule,
  ],
  providers: [AuthorizationCodeService],
  exports: [TypeOrmModule, AuthorizationCodeService],
})
export class AuthorizationCodeModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement/entities/account-statement.entity.ts
import { IsEnum } from 'class-validator';
import { Column, Entity, Index, ManyToOne } from 'typeorm';
import { BaseEntity } from 'src/common/base.entity';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementMetadata } from 'src/api/v2/account-statement/types';

@Index(['transactionCode', 'originBankAccountIdentifier', 'originBankCode'], {
  unique: true,
})
@Entity({ name: 'account_statement' })
export class AccountStatementEntity extends BaseEntity {
  @Column({ type: 'datetime', precision: 6, nullable: true })
  date: Date;

  @Column({ type: 'varchar', length: 64, nullable: true })
  originBankCode: string;

  @Column({ type: 'varchar', length: 64, nullable: true })
  originBankAccountIdentifier: string;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @Column({ type: 'text', nullable: true })
  concept: string;

  @IsEnum(CountryCode)
  @Column('enum', {
    enum: CountryCode,
    default: CountryCode.CHILE,
    nullable: false,
  })
  countryCode: CountryCode;

  @Column({
    type: 'decimal',
    precision: 18,
    scale: 2,
    nullable: false,
    default: 0,
  })
  amount: number;

  @IsEnum(TransferState)
  @Column('enum', {
    enum: TransferState,
    nullable: true,
  })
  state: TransferState;

  @Column({ type: 'varchar', length: 128, nullable: false })
  transactionCode: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  destinationHolderId: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationName: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationAccount: string;

  @Column({ type: 'varchar', nullable: true })
  destinationEmail: string;

  @Column({ type: 'varchar', length: 64, nullable: true })
  destinationBankCode: string;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  retrievedAt: Date;

  @Column({ type: 'json', nullable: true })
  metadata: AccountStatementMetadata;

  @Column({ type: 'int', nullable: false })
  accountStatementJobId: number;

  // Relationships
  @ManyToOne(
    () => AccountStatementJobEntity,
    (accountStatementJob) => accountStatementJob.accountStatements,
    {
      nullable: false,
    },
  )
  accountStatementJob: AccountStatementJobEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement/account-statement.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AwsModule } from 'src/services/aws/aws.module';
import { AccountStatementJobEntity } from '../account-statement-job/entities/account-statement-job.entity';
import { AccountStatementService } from './account-statement.service';
import { AccountStatementEntity } from './entities/account-statement.entity';

@Module({
  providers: [AccountStatementService],
  imports: [
    AwsModule,
    TypeOrmModule.forFeature([
      AccountStatementEntity,
      AccountStatementJobEntity,
    ]),
  ],
  exports: [TypeOrmModule, AccountStatementService],
})
export class AccountStatementModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement/account-statement.service.ts
import { Injectable, Logger } from '@nestjs/common';

import { CreateAccountStatementDto } from 'src/api/v2/account-statement/dto/create-account-statement.dto';
import { AccountStatementEntity } from './entities/account-statement.entity';
import { DataService } from 'src/database/data.service';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';

@Injectable()
export class AccountStatementService extends DataService<AccountStatementEntity>(
  AccountStatementEntity,
) {
  private readonly logger = new Logger('AccountStatementService');

  @InjectRepository(AccountStatementEntity)
  private accountStatementRepository: Repository<AccountStatementEntity>;

  private async findExistingStatement(
    dto: CreateAccountStatementDto,
  ): Promise<AccountStatementEntity> {
    return this.repository.findOne({
      where: {
        transactionCode: dto.transactionCode,
        originBankAccountIdentifier: dto.originBankAccountIdentifier,
        originBankCode: dto.originBankCode,
      },
    });
  }

  private async createOrUpdateStatement(
    dto: CreateAccountStatementDto,
  ): Promise<AccountStatementEntity> {
    const existingStatement = await this.findExistingStatement(dto);

    if (existingStatement) {
      existingStatement.accountStatementJobId = dto.accountStatementJobId;
      return this.accountStatementRepository.save(existingStatement);
    }

    const accountStatement = this.accountStatementRepository.create(dto);
    return this.accountStatementRepository.save(accountStatement);
  }

  async createMany(
    createAccountStatementDto: CreateAccountStatementDto[],
  ): Promise<AccountStatementEntity[]> {
    const result: AccountStatementEntity[] = [];

    for (const dto of createAccountStatementDto) {
      result.push(await this.createOrUpdateStatement(dto));
    }

    return result;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement/account-statement.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AccountStatementService } from './account-statement.service';
import { Repository } from 'typeorm';
import { AccountStatementEntity } from './entities/account-statement.entity';
import { getRepositoryToken } from '@nestjs/typeorm';

describe('given a AccountStatementService', () => {
  let service: AccountStatementService;

  beforeEach(async () => {
    const mockAccountStatementRepository: Partial<
      Repository<AccountStatementEntity>
    > = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AccountStatementService,
        {
          provide: getRepositoryToken(AccountStatementEntity),
          useValue: mockAccountStatementRepository,
        },
      ],
    }).compile();

    service = module.get<AccountStatementService>(AccountStatementService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/master-account/entities/master-account.entity.ts
import { Column, Entity, JoinColumn, OneToOne } from 'typeorm';
import { IsEnum } from 'class-validator';
import { BaseEntity } from 'src/common/base.entity';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { State } from 'src/common/enums/state.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';

@Entity({ name: 'master_account' })
export class MasterAccountEntity extends BaseEntity {
  @IsEnum(State)
  @Column('enum', { enum: State, default: State.INACTIVE, nullable: false })
  state: State;

  @Column({ type: 'int', nullable: false, default: 1 })
  priority: number;

  @Column({ type: 'json', nullable: true })
  transferRules: RuleDefinition;

  @Column({ type: 'int', nullable: false })
  bankAccountId: number;

  @JoinColumn()
  @OneToOne(() => BankAccountEntity, (bankAccount) => bankAccount.masterAccount)
  bankAccount: BankAccountEntity;

  public get name(): string {
    return this.bankAccount.name;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant-limit/merchant-limit.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { MerchantLimitEntity } from './entities/merchant-limit.entity';
import { MerchantModule } from '../merchant/merchant.module';
import { MerchantLimitService } from './merchant-limit.service';

@Module({
  providers: [MerchantLimitService],
  imports: [TypeOrmModule.forFeature([MerchantLimitEntity]), MerchantModule],
  exports: [MerchantLimitService],
})
export class MerchantLimitModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant-limit/entities/merchant-limit.entity.ts
import { IsEnum } from 'class-validator';
import { Exclude } from 'class-transformer';
import { Column, DeleteDateColumn, Entity, ManyToOne } from 'typeorm';

import { BaseEntity } from 'src/common/base.entity';
import { MerchantLimitType } from 'src/common/enums/merchant-limit-type.enum';
import { LimitAggregation } from 'src/common/enums/limit-aggregation.enum';
import { LimitCriteria } from 'src/common/enums/limit-criteria.enum';
import { LimitScope } from 'src/common/enums/limit-scope.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';

export interface MerchantLimitDefinition {
  value: number;
  criteria: LimitCriteria;
  scope: LimitScope;
  aggregation: LimitAggregation;
  currency?: Currency;
}

@Entity({ name: 'merchant_limit' })
export class MerchantLimitEntity extends BaseEntity {
  @IsEnum(MerchantLimitType)
  @Column('enum', {
    enum: MerchantLimitType,
    default: MerchantLimitType.RATE,
  })
  limitType: MerchantLimitType;

  @Column({ type: 'json' })
  limitDefinition: MerchantLimitDefinition;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.INACTIVE })
  state: State;

  @Column({ type: 'int' })
  merchantId: number;

  @Exclude()
  @DeleteDateColumn()
  deletedAt?: Date;

  // Relationships
  @Exclude()
  @ManyToOne(() => MerchantEntity, (merchant) => merchant.merchantLimits)
  merchant: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant-limit/merchant-limit.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { MerchantLimitService } from './merchant-limit.service';
import { MerchantService } from '../merchant/merchant.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { MerchantLimitEntity } from './entities/merchant-limit.entity';

describe('given a MerchantLimitService', () => {
  let service: MerchantLimitService;
  const mockMerchantLimitEntity = {};

  beforeEach(async () => {
    const mockMerchantService = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        MerchantLimitService,
        {
          provide: getRepositoryToken(MerchantLimitEntity),
          useValue: mockMerchantLimitEntity,
        },
        {
          provide: MerchantService,
          useValue: mockMerchantService,
        },
      ],
    }).compile();

    service = module.get<MerchantLimitService>(MerchantLimitService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/merchant-limit/merchant-limit.service.ts
import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { FindManyOptions, Repository } from 'typeorm';
import { DataService } from 'src/database/data.service';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { MerchantLimitEntity } from './entities/merchant-limit.entity';
import { MerchantService } from '../merchant/merchant.service';
import { CreateMerchantLimitDto } from 'src/api/v2/merchant-limit/dto/create-limit.dto';
import { GetMerchantLimitsQueryDto } from 'src/api/v2/merchant-limit/dto/get-merchant-limits-query.dto';
import { PatchMerchantLimitDto } from 'src/api/v2/merchant-limit/dto/patch-merchant-limit.dto';

@Injectable()
export class MerchantLimitService extends DataService<MerchantLimitEntity>(
  MerchantLimitEntity,
) {
  @InjectRepository(MerchantLimitEntity)
  private merchantLimitRepository: Repository<MerchantLimitEntity>;
  @Inject(MerchantService)
  private merchantService: MerchantService;

  async findAll(options?: FindManyOptions): Promise<MerchantLimitEntity[]> {
    const merchantLimits = await this.merchantLimitRepository.find(options);
    return merchantLimits;
  }

  async create(
    merchantId: number,
    createLimitDto: CreateMerchantLimitDto,
  ): Promise<MerchantLimitEntity> {
    const merchant = await this.merchantService.findOne(merchantId);
    const merchantLimit = this.merchantLimitRepository.create({
      ...createLimitDto,
      merchantId: merchant.id,
    });
    const createdLimit = await this.merchantLimitRepository.save(merchantLimit);
    return createdLimit;
  }

  async findAllForMerchant(
    merchantId: number,
    query: GetMerchantLimitsQueryDto,
  ) {
    const merchant = await this.merchantService.findOne(merchantId);

    const options: FindManyOptions<MerchantLimitEntity> = {
      where: {
        merchantId: merchant.id,
      },
      order: { createdAt: DESCENDING_ORDER },
    };
    return this.findAllPaginated({ ...query, options });
  }

  async update(
    id: number,
    merchantId: number,
    patchMerchantLimitDto: PatchMerchantLimitDto,
  ): Promise<MerchantLimitEntity> {
    const merchant = await this.merchantService.findOne(merchantId);
    const merchantLimit = await this.merchantLimitRepository.findOneBy({
      id,
      merchantId: merchant.id,
    });
    if (!merchantLimit) {
      throw new NotFoundException(`Merchant limit ${id} not found`);
    }

    if (patchMerchantLimitDto.limitDefinition) {
      const { value } = patchMerchantLimitDto.limitDefinition;
      merchantLimit.limitDefinition.value = value;
      delete patchMerchantLimitDto.limitDefinition;
    }
    const merchantLimitEntity = await this.merchantLimitRepository.preload({
      id: Number(id),
      ...merchantLimit,
      ...patchMerchantLimitDto,
    });

    return this.merchantLimitRepository.save(merchantLimitEntity);
  }

  async remove(id: number, merchantId: number): Promise<MerchantLimitEntity> {
    const merchant = await this.merchantService.findOne(merchantId);
    const merchantLimit = await this.merchantLimitRepository.findOneBy({
      id,
      merchantId: merchant.id,
    });
    if (!merchantLimit) {
      throw new NotFoundException(`Merchant limit ${id} not found`);
    }

    return this.merchantLimitRepository.softRemove(merchantLimit);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank-account/entities/bank-account.entity.ts
import {
  Column,
  Entity,
  JoinColumn,
  ManyToMany,
  ManyToOne,
  OneToMany,
  OneToOne,
} from 'typeorm';
import { IsEnum } from 'class-validator';
import { BaseEntity } from 'src/common/base.entity';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { MasterAccountEntity } from 'src/models/master-account/entities/master-account.entity';
import { State } from 'src/common/enums/state.enum';
import { Currency } from 'src/common/enums/currency.enum';
import { AccountType } from 'src/common/enums/account-type.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';

@Entity({ name: 'bank_account' })
export class BankAccountEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 128 })
  name: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  identifier: string;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @IsEnum(AccountType)
  @Column('enum', {
    enum: AccountType,
    default: AccountType.CURRENT,
    nullable: false,
  })
  accountType: AccountType;

  @Column({ type: 'varchar', length: 64, nullable: false })
  holderId: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  bankCode: string;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  // Relationships

  @OneToOne(
    () => MasterAccountEntity,
    (masterAccount) => masterAccount.bankAccount,
  )
  masterAccount: MasterAccountEntity;

  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.bankAccounts)
  bank: BankEntity;

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.bankAccounts)
  merchant: MerchantEntity;

  @ManyToMany(() => BankAccessEntity, (bankAccess) => bankAccess.bankAccounts)
  bankAccesses: BankAccessEntity[];

  @OneToMany(() => TransferEntity, (transfer) => transfer.originBankAccount)
  transfers: TransferEntity[];

  @OneToMany(
    () => AccountStatementJobEntity,
    (accountStatementJob) => accountStatementJob.bankAccount,
  )
  accountStatementJobs: AccountStatementJobEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account/account.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AccountService } from './account.service';
import { AccountEntity } from './entities/account.entity';

@Module({
  imports: [TypeOrmModule.forFeature([AccountEntity])],
  providers: [AccountService],
  exports: [AccountService],
})
export class AccountModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account/entities/account.entity.ts
import { Exclude } from 'class-transformer';
import { IsEnum } from 'class-validator';
import { BaseEntity } from 'src/common/base.entity';
import { Currency } from 'src/common/enums/currency.enum';
import { State } from 'src/common/enums/state.enum';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { Column, Entity, JoinColumn, ManyToOne, OneToMany } from 'typeorm';
import { CountryCode } from '../../../common/enums/country-code.enum';
import { RuleDefinition } from 'src/common/rules/rule-definitions/rule-definition';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';

@Entity({ name: 'account' })
export class AccountEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 64, nullable: false })
  bankCode: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  identifier: string;

  @Column({ type: 'varchar', length: 64, nullable: true })
  holderId?: string;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.INACTIVE, nullable: false })
  state: State;

  @Column({ type: 'varchar', length: 128, nullable: false })
  name: string;

  @Column({ type: 'json', nullable: true })
  rules?: RuleDefinition;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @IsEnum(CountryCode)
  @Column('enum', {
    enum: CountryCode,
    default: CountryCode.CHILE,
    nullable: false,
  })
  countryCode: CountryCode;

  // Relationships
  @OneToMany(() => ProviderEntity, (provider) => provider.account)
  providers?: ProviderEntity[];

  @Exclude()
  @OneToMany(
    () => AccountStatementJobEntity,
    (accountStatementJob) => accountStatementJob.bankAccount,
  )
  accountStatementJobs?: AccountStatementJobEntity[];

  @Exclude()
  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.accounts)
  bank?: BankEntity;

  @Exclude()
  @ManyToOne(() => MerchantEntity, (merchant) => merchant.accounts)
  merchant?: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account/account.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { AccountService } from './account.service';
import { AccountEntity } from './entities/account.entity';

describe('AccountService', () => {
  let service: AccountService;
  const fakeAccountRepository = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AccountService,
        {
          provide: getRepositoryToken(AccountEntity),
          useValue: fakeAccountRepository,
        },
      ],
    }).compile();

    service = module.get<AccountService>(AccountService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account/account.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import * as moment from 'moment';
import { CreateAccountDto } from 'src/api/v2/account/dto/create-account.dto';
import { UpdateAccountDto } from 'src/api/v2/account/dto/update-account.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import RulesEvaluator, { TotalTransferred } from 'src/common/rules/evaluator';
import { TimeWindow } from 'src/common/rules/rule-definitions/rule-definition-params';
import { DataService } from 'src/database/data.service';
import { Brackets, FindManyOptions, FindOneOptions, Repository } from 'typeorm';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { AccountEntity } from './entities/account.entity';

@Injectable()
export class AccountService extends DataService<AccountEntity>(AccountEntity) {
  @InjectRepository(AccountEntity)
  private accountRepository: Repository<AccountEntity>;

  async findAll(
    options?: FindManyOptions<AccountEntity>,
  ): Promise<AccountEntity[]> {
    return this.accountRepository.find(options);
  }

  async findOne(id: number): Promise<AccountEntity> {
    const account = await this.accountRepository.findOne({ where: { id } });

    return account;
  }

  async findOneByConditions(
    options: FindOneOptions<AccountEntity>,
  ): Promise<AccountEntity> {
    const account = await this.accountRepository.findOne(options);

    return account;
  }

  async create(createAccountDto: CreateAccountDto): Promise<AccountEntity> {
    const account = this.accountRepository.create(createAccountDto);

    return this.accountRepository.save(account);
  }

  async update(
    id: number,
    updateAccountDto: UpdateAccountDto,
  ): Promise<AccountEntity> {
    const account = await this.accountRepository.preload({
      id,
      ...updateAccountDto,
    });

    if (!account) return;

    return this.accountRepository.save(account);
  }

  async remove(id: number): Promise<AccountEntity> {
    const account = await this.accountRepository.findOne({ where: { id } });

    if (!account) return;

    return this.accountRepository.remove(account);
  }

  async getTotalTransferred(
    id: number,
    filters?: { window?: TimeWindow; from?: Date },
  ): Promise<TotalTransferred> {
    const { window, from } = filters ?? {};
    let limitDate: Date;
    // TODO: Add test case
    if (from) {
      limitDate = from;
    } else {
      if (window === 'daily') limitDate = moment().startOf('date').toDate();
      if (window === 'monthly') limitDate = moment().startOf('month').toDate();
    }

    const queryResult = await this.accountRepository
      .createQueryBuilder('account')
      .leftJoin('account.providers', 'provider')
      .leftJoin('provider.transfers', 'transfer')
      .select('SUM(transfer.amount)', 'amount')
      .addSelect('COUNT(*)', 'count')
      .where('account.id = :id', { id })
      .andWhere(
        new Brackets((qb) => {
          qb.where('transfer.state = :state', {
            state: TransferState.COMPLETED,
          });
          qb.andWhere('transfer.finishedAt >= :limitDate', { limitDate });
        }),
      )
      .orWhere(
        new Brackets((qb) => {
          qb.where('transfer.state IN (:...states)', {
            states: [TransferState.ASSIGNED, TransferState.PROCESSING],
          });
          qb.andWhere('transfer.createdAt >= :limitDate', { limitDate });
        }),
      )
      .getRawOne();
    // Ensure correct data type
    const result = {
      amount: parseFloat(queryResult.amount ?? 0),
      count: parseInt(queryResult.count),
    };

    return result;
  }

  async evaluateRules(
    account: AccountEntity,
    transfer: TransferEntity,
  ): Promise<boolean> {
    const totalDailyTransfered = await this.getTotalTransferred(account.id, {
      window: 'daily',
    });

    const context = {
      transfer,
      transferred: {
        all: {
          daily: totalDailyTransfered.amount,
        },
        count: {
          daily: totalDailyTransfered.count,
        },
      },
    };

    const processor = new RulesEvaluator(context);

    return processor.process(account.rules);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.service.ts
import { Repository } from 'typeorm';
import {
  Injectable,
  ConflictException,
  UnprocessableEntityException,
  Inject,
  Logger,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { plainToClass } from 'class-transformer';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { DataService } from 'src/database/data.service';
import { MYSQL_UNIQUE_CONSTRAINT_VIOLATION } from 'src/database/errors/database.errors';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { PayoutEntity } from './entities/payout.entity';
import PayoutStateMachine from './payout.statemachine';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { CreatePayoutDto } from './dto/create-payout.dto';
import { PayoutTransferDto } from './dto/create-transfer.dto';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

/**
 * @deprecated will be deprecated when EPIC PYT-797 is ready, use new payout service
 */
@Injectable()
export class PayoutService extends DataService<PayoutEntity>(PayoutEntity) {
  private stateMachine: PayoutStateMachine = new PayoutStateMachine();
  private readonly logger = new Logger('PayoutService');

  @InjectRepository(PayoutEntity)
  private payoutRepository: Repository<PayoutEntity>;
  @InjectRepository(TransferEntity)
  private transferRepository: Repository<TransferEntity>;
  @Inject(EventEmitter2)
  private eventEmitter: EventEmitter2;
  @Inject(FeatureFlagService)
  private featureFlagService: FeatureFlagService;

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  async create(createPayoutDto: CreatePayoutDto): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation) return;

    try {
      this.logger.debug('Creating payout from legacy service');
      const payoutEntity = this.payoutRepository.create(createPayoutDto);
      const payout = await this.payoutRepository.save(payoutEntity);

      this.eventEmitter.emit(PayoutEvent.CREATED, payout);

      return payoutEntity;
    } catch (err) {
      if (err?.code === MYSQL_UNIQUE_CONSTRAINT_VIOLATION) {
        throw new ConflictException('Payout tracking code must be unique');
      } else {
        throw err;
      }
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready, use findLastTransfer from payout new service
   */
  async findLastTransfer(payoutId: number): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne({
      where: { payoutId },
      order: { createdAt: DESCENDING_ORDER },
      relations: ['provider'],
    });
    return transfer;
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  @OnEvent(PayoutEvent.CREATED)
  async createTransfer(
    payoutEntity: PayoutEntity,
    providerId?: number,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (canUseNewPayoutCreation) return;
    const createTransferDto = plainToClass(PayoutTransferDto, payoutEntity, {
      excludeExtraneousValues: true,
    });

    const baseTransfer = this.transferRepository.create(createTransferDto);
    const transferEntity = this.transferRepository.merge(baseTransfer, {
      payoutId: payoutEntity.id,
      version: payoutEntity.version,
    });

    const transfer = await this.transferRepository.save(transferEntity);
    this.eventEmitter.emit(TransferEvent.CREATED, transfer, providerId);

    return transfer;
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  transitToState(payout: PayoutEntity, state: PayoutState) {
    try {
      const updatedPayout = this.stateMachine.transitTo(payout, state);
      return updatedPayout;
    } catch (error) {
      throw new UnprocessableEntityException(error.message);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready
   */
  async updateState(
    payoutId: number,
    state: PayoutState,
    metadata?: Record<string, string>,
  ): Promise<PayoutEntity> {
    const payout = await this.payoutRepository.findOne({
      where: { id: payoutId },
    });

    if (!state) {
      throw new UnprocessableEntityException('Payout State must be provided');
    }

    this.transitToState(payout, state);

    const lastTransfer = await this.findLastTransfer(payoutId);

    const changes: Partial<PayoutEntity> = {
      state,
      ...(lastTransfer?.errorCode && { errorCode: lastTransfer.errorCode }),
      ...(lastTransfer?.message && { message: lastTransfer.message }),
      metadata: { ...payout.metadata, ...metadata },
    };

    const mergedPayout = this.payoutRepository.merge(payout, changes);
    const updatedPayout = await this.payoutRepository.save(mergedPayout);

    if (state === PayoutState.PROCESSING) {
      this.eventEmitter.emit(PayoutEvent.PROCESSING, updatedPayout);
    }

    if (state === PayoutState.COMPLETED) {
      this.eventEmitter.emit(PayoutEvent.COMPLETED, updatedPayout);
    }

    if (state === PayoutState.CANCELED) {
      this.eventEmitter.emit(PayoutEvent.CANCELED, updatedPayout);
    }

    return updatedPayout;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.new.service.spec.ts
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';

import { PayoutEntity } from './entities/payout.entity';
import { PayoutNewService } from './payout.new.service';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { TransferService } from '../transfer/transfer.service';
import { TransferAssignmentNewService } from 'src/services/transfer-assignment/transfer-assignment.new.service';
import { MerchantLimitEvaluatorService } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';
import { ProviderService } from '../provider/provider.service';
import { AlertsService } from 'src/services/alerts/alerts.service';
import { DataSource } from 'typeorm';

describe('given a PayoutService', () => {
  let service: PayoutNewService;

  beforeEach(async () => {
    const mockEventEmitter = {};
    const mockFeatureFlagService = {};
    const mockMerchantLimitEvaluatorService = {};
    const mockPayoutRepository = {};
    const mockTransferAssignmentNewService = {};
    const mockTransferProviderService = {};
    const mockTransferRepository = {};
    const mockTransferService = {};
    const mockProviderService = {};
    const mockAlertService = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PayoutNewService,
        {
          provide: getRepositoryToken(PayoutEntity),
          useValue: mockPayoutRepository,
        },
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferRepository,
        },
        { provide: EventEmitter2, useValue: mockEventEmitter },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
        {
          provide: MerchantLimitEvaluatorService,
          useValue: mockMerchantLimitEvaluatorService,
        },
        {
          provide: ProviderService,
          useValue: mockProviderService,
        },
        {
          provide: AlertsService,
          useValue: mockAlertService,
        },
        {
          provide: TransferAssignmentNewService,
          useValue: mockTransferAssignmentNewService,
        },
        {
          provide: TransferProviderService,
          useValue: mockTransferProviderService,
        },
        {
          provide: TransferService,
          useValue: mockTransferService,
        },
        {
          provide: DataSource,
          useValue: 'mockDataSource',
        },
      ],
    }).compile();

    service = module.get<PayoutNewService>(PayoutNewService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.new.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { PayoutNewService } from './payout.new.service';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { TransferModule } from '../transfer/transfer.module';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { FeatureFlagModule } from 'src/services/feature-flag/feature-flag.module';
import { MerchantLimitEvaluatorModule } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.module';
import { TransferAssignmentNewModule } from 'src/services/transfer-assignment/transfer-assignment.new.module';
import { AlertsModule } from 'src/services/alerts/alerts.module';
import { ProviderModule } from '../provider/provider.module';
import { TransferErrorModule } from '../transfer-error/transfer-error.module';

@Module({
  providers: [PayoutNewService],
  imports: [
    FeatureFlagModule,
    MerchantLimitEvaluatorModule,
    TransferAssignmentNewModule,
    TransferModule,
    ProviderModule,
    AlertsModule,
    TransferErrorModule,
    TypeOrmModule.forFeature([PayoutEntity, TransferEntity]),
  ],
  exports: [PayoutNewService, TypeOrmModule],
})
export class PayoutNewModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/entities/payout.entity.ts
import { Exclude } from 'class-transformer';
import { IsEnum } from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { nullIfEmpty } from 'src/utils/string-methods.util';
import {
  BeforeInsert,
  Column,
  Entity,
  Index,
  JoinColumn,
  ManyToOne,
  OneToMany,
  Unique,
} from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';
@Entity({ name: 'payout' })
@Unique(['merchantId', 'trackingCode'])
export class PayoutEntity extends BaseEntity {
  @IsEnum(PayoutState)
  @Column('enum', {
    enum: PayoutState,
    default: PayoutState.PENDING,
    nullable: false,
  })
  state: PayoutState;

  @Column({
    type: 'decimal',
    precision: 18,
    scale: 2,
    nullable: false,
    default: 0,
  })
  amount: number;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @Column({ type: 'text' })
  concept: string;

  @Column({ type: 'varchar', length: 128 })
  trackingCode: string;

  @Column({ type: 'simple-json', nullable: true })
  metadata: any;

  @Index({ fulltext: true })
  @Column({ type: 'varchar', nullable: true })
  destinationEmail: string;

  @Index({ fulltext: true })
  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationName: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  destinationHolderId: string;

  @Index({ fulltext: true })
  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationAccount: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  destinationBankCode: string;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @Column({ type: 'text', nullable: true })
  destinationPhone: string;

  @Column({
    type: 'enum',
    enum: EntityVersion,
    nullable: false,
    default: EntityVersion.v2,
  })
  version: EntityVersion;

  @Column('varchar', {
    nullable: true,
  })
  errorCode: string;

  @Column({ type: 'text', nullable: true })
  message: string;

  // Relationships

  @Exclude()
  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.payouts)
  destinationBank: BankEntity;

  @Exclude()
  @ManyToOne(() => MerchantEntity, (merchant) => merchant.payouts)
  merchant: MerchantEntity;

  @OneToMany(() => TransferEntity, (transfer) => transfer.payout, {
    cascade: true,
    eager: true,
  })
  transfers: TransferEntity[];

  // Subscribers
  @BeforeInsert()
  sanitizeDestinationEmail() {
    this.destinationEmail = nullIfEmpty(this.destinationEmail);
  }

  // Methods
  public get finished(): boolean {
    const states = [
      PayoutState.COMPLETED,
      PayoutState.CANCELED,
      PayoutState.FAILED,
    ];
    return states.includes(this.state);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.service.spec.ts
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { PayoutEntity } from './entities/payout.entity';
import { PayoutService } from './payout.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';

describe('given a PayoutService', () => {
  let service: PayoutService;

  beforeEach(async () => {
    const mockEventEmitter = {};
    const mockFeatureFlagService = {};
    const mockTransferRepo = {};
    const mockPayoutRepo = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PayoutService,
        {
          provide: getRepositoryToken(PayoutEntity),
          useValue: mockPayoutRepo,
        },
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferRepo,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
        { provide: EventEmitter2, useValue: mockEventEmitter },
      ],
    }).compile();

    service = module.get<PayoutService>(PayoutService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.statemachine.ts
import { PayoutState } from 'src/common/enums/payout-state.enum';
import BaseStateMachine from 'src/common/state-machine/base-state-machine';
import { PayoutEntity } from './entities/payout.entity';
import PayoutTransitions from './payout.transitions';

export default class PayoutStateMachine extends BaseStateMachine<
  PayoutEntity,
  PayoutState
> {
  constructor() {
    super(PayoutTransitions);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.transitions.ts
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { Transition } from 'src/common/state-machine/state-machine.interfaces';

export enum PayoutTransition {
  PROCESS = 'process',
  COMPLETE = 'complete',
  CANCEL = 'cancel',
  FAIL = 'fail',
}

const PayoutTransitions: Transition<PayoutState>[] = [
  {
    name: PayoutTransition.PROCESS,
    from: [PayoutState.PENDING],
    to: PayoutState.PROCESSING,
  },
  {
    name: PayoutTransition.COMPLETE,
    from: [PayoutState.PROCESSING],
    to: PayoutState.COMPLETED,
  },
  {
    name: PayoutTransition.CANCEL,
    from: [PayoutState.PENDING, PayoutState.PROCESSING, PayoutState.FAILED],
    to: PayoutState.CANCELED,
  },
  {
    name: PayoutTransition.FAIL,
    from: [PayoutState.PENDING, PayoutState.PROCESSING],
    to: PayoutState.FAILED,
  },
];

export default PayoutTransitions;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { PayoutService } from './payout.service';
import { PayoutEntity } from './entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { FeatureFlagModule } from 'src/services/feature-flag/feature-flag.module';

@Module({
  providers: [PayoutService],
  imports: [
    TypeOrmModule.forFeature([PayoutEntity, TransferEntity]),
    FeatureFlagModule,
  ],
  exports: [TypeOrmModule, PayoutService],
})
export class PayoutModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/payout.new.service.ts
import {
  DataSource,
  FindOneOptions,
  In,
  Not,
  Repository,
  EntityManager,
} from 'typeorm';
import {
  ConflictException,
  Inject,
  Injectable,
  Logger,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';

import { CreatePayoutDto } from './dto/create-payout.dto';
import { CancelPayoutDto } from './dto/cancel-payout.dto';
import { CompletePayoutDto } from './dto/complete-payout.dto';
import { UpdatePayoutMetadataDto } from './dto/update-payout-metadata.dto';
import { PayoutEntity } from './entities/payout.entity';
import PayoutStateMachine from './payout.statemachine';
import { PayoutTransition } from './payout.transitions';
import { ProviderEntity } from '../provider/entities/provider.entity';
import { ProviderService } from '../provider/provider.service';
import { TransferEntity } from '../transfer/entities/transfer.entity';
import { TransferService } from '../transfer/transfer.service';
import TransferStateMachine from '../transfer/transfer.statemachine';
import { TransferTransition } from '../transfer/transfer.transitions';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { PayoutEvent } from 'src/common/enums/payout-event.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { MYSQL_UNIQUE_CONSTRAINT_VIOLATION } from 'src/database/errors/database.errors';
import { DataService } from 'src/database/data.service';
import { EntitiesValidationService } from 'src/services/entities-validation/entities-validation.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { MerchantLimitEvaluatorService } from 'src/services/merchant-limit-evaluator/merchant-limit-evaluator.service';
import { TransferAssignmentNewService } from 'src/services/transfer-assignment/transfer-assignment.new.service';
import { AlertsService } from 'src/services/alerts/alerts.service';
import { DESCENDING_ORDER } from 'src/database/query.constants';
import { QueryPayoutDto } from './dto/query-payout.dto';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import {
  filterPayoutByCurrency,
  filterPayoutByDestinationBank,
  filterPayoutByOriginBankCode,
  filterPayoutByRangeDate,
  filterPayoutByState,
} from 'src/common/queries/payout.query';
import { UpdateTransferMetadataDto } from './dto/update-transfer-metadata.dto';
import { LockMode } from 'src/common/enums/locks-mode.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { TransferErrorService } from '../transfer-error/transfer-error.service';
import { TransferErrorCode } from '../transfer-error/error.definition.type';
import { ProcessTransferDto } from '../transfer/dto/process-transfer.dto';

interface AssignationResult {
  result: boolean;
  detail?: {
    message?: string;
    state?: TransferState;
    provider?: ProviderEntity;
  };
}

@Injectable()
export class PayoutNewService extends DataService<PayoutEntity>(PayoutEntity) {
  private readonly logger = new Logger('PayoutNewService');
  private payoutStateMachine: PayoutStateMachine = new PayoutStateMachine();
  private transferStateMachine: TransferStateMachine =
    new TransferStateMachine();

  @InjectRepository(PayoutEntity)
  private payoutRepository: Repository<PayoutEntity>;
  @InjectRepository(TransferEntity)
  private transferRepository: Repository<TransferEntity>;
  @Inject(EventEmitter2)
  private eventEmitter: EventEmitter2;
  @Inject(FeatureFlagService)
  private featureFlagService: FeatureFlagService;
  @Inject(MerchantLimitEvaluatorService)
  private merchantLimitEvaluatorService: MerchantLimitEvaluatorService;
  @Inject(TransferAssignmentNewService)
  private transferAssignmentNewService: TransferAssignmentNewService;
  @Inject(TransferService)
  private transferService: TransferService;
  @Inject(TransferErrorService)
  private transferErrorService: TransferErrorService;
  @Inject(ProviderService)
  private providerService: ProviderService;
  @Inject(AlertsService)
  private alertsService: AlertsService;
  @Inject(DataSource)
  private dataSource: DataSource;

  // HELPERS
  async findOneOrFail(id: number): Promise<PayoutEntity> {
    const payout = await this.payoutRepository.findOne({ where: { id } });
    if (!payout) throw new NotFoundException(`Payout ${id} not found`);
    return payout;
  }
  async findOneByConditions(
    options?: FindOneOptions<PayoutEntity>,
  ): Promise<PayoutEntity> {
    const payout = await this.payoutRepository.findOne(options);
    if (!payout) throw new NotFoundException('Payout not found');
    return payout;
  }
  /**
   * Find last transfer from a payout base on created at property
   * @param payoutId
   * @returns A transfer with provider relation
   */
  async findLastTransfer(payoutId: number): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne({
      where: { payoutId },
      order: { createdAt: DESCENDING_ORDER },
      relations: ['provider'],
    });
    return transfer;
  }

  async updateTransferMetadata(
    transferId: TransferEntity['id'],
    metadata: UpdateTransferMetadataDto,
  ): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne({
      where: { id: transferId },
    });
    transfer.metadata = { ...transfer.metadata, ...metadata };
    await this.transferRepository.save(transfer);
    const updatedTransfer = await this.transferRepository.findOne({
      where: { id: transferId },
    });
    return updatedTransfer;
  }

  async updatePayoutMetadata(
    payoutId: number,
    metadata: UpdatePayoutMetadataDto,
  ): Promise<PayoutEntity> {
    const payout = await this.payoutRepository.findOne({
      where: { id: payoutId },
    });
    payout.metadata = { ...payout.metadata, ...metadata };
    await this.payoutRepository.save(payout);
    const updatedPayout = await this.payoutRepository.findOne({
      where: { id: payoutId },
    });
    return updatedPayout;
  }

  async cancelAllTransfers(
    payout: PayoutEntity, // quizás debiese recibir las transfers con lock ya?
    manager: EntityManager,
  ): Promise<void> {
    const transfers = await manager.find(TransferEntity, {
      where: {
        payoutId: payout.id,
        state: Not(In([TransferState.CANCELED])), // completed, failed, processing, assigned, pending
      },
      lock: { mode: LockMode.PESSIMISTIC_READ }, // borrar?
    });

    for (const transfer of transfers) {
      await this.cancelTransfer(transfer, payout, manager, {
        metadata: {
          message: 'Transfer canceled',
        },
      });
    }
  }

  async getExportableTransfers(
    query: QueryPayoutDto,
  ): Promise<TransferEntity[]> {
    const payoutsQuery = this.payoutRepository
      .createQueryBuilder('payout')
      .leftJoinAndSelect('payout.transfers', 'transfer')
      .leftJoinAndSelect('transfer.originBankAccess', 'bankAccess')
      .leftJoinAndSelect('transfer.originBankAccount', 'bankAccount')
      .leftJoinAndSelect('transfer.originBank', 'originBank')
      .where('payout.version IN(:version)', {
        version: [EntityVersion.v1, EntityVersion.v2],
      });

    filterPayoutByState(query?.states, payoutsQuery);
    filterPayoutByCurrency(query?.currency, payoutsQuery);
    filterPayoutByRangeDate({ from: query?.from, to: query?.to }, payoutsQuery);
    filterPayoutByDestinationBank(query?.destinationBankCode, payoutsQuery);
    filterPayoutByOriginBankCode(query?.transfer?.originBankCode, payoutsQuery);

    const payouts = await payoutsQuery.getMany();

    const transfers = payouts
      .flatMap((payout) => payout.transfers)
      .filter((transfer) => {
        if (query?.states) {
          const transferState = transfer.state as string;
          return query?.states.includes(transferState as PayoutState);
        }

        return transfer;
      });

    return transfers;
  }
  /**
   * Updates the autoRetried flag in the TransferEntity.
   * This flag indicates if a transfer was created due to an automated retry.
   *
   * @param {number} id - The ID of the transfer to update.
   * @param {boolean} autoRetried - The new value for the autoRetried flag.
   * @returns {Promise<TransferEntity>} The updated TransferEntity.
   */
  async updateAutoRetried(
    id: number,
    autoRetried: boolean,
  ): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne({ where: { id } });
    return this.transferRepository.save({ ...transfer, autoRetried });
  }

  /**
  private async secureUpdatePayoutState(
    id: number,
    updatedFields: Partial<PayoutEntity>,
    fromStates: PayoutState[],
    callBackValidation?: (
      payout: PayoutEntity,
      alertsService: AlertsService,
    ) => Promise<void>,
  ): Promise<PayoutEntity> {
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      const manager = queryRunner.manager;
      this.logger.log(`Starting transaction for payout ${id}`);
      await queryRunner.startTransaction();
      // cancelar transfers
      //
      if (process.env.NODE_ENV !== 'test') {
        // TODO: Remove this line
        await waitFor(10000);
      }
      const payout = await manager.findOne(PayoutEntity, {
        where: { id: id, state: In(fromStates) },
        relations: ['transfers'],
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      const mergeMetadata = {
        ...payout.metadata,
        ...updatedFields.metadata,
      };

      updatedFields = {
        ...updatedFields,
        metadata: mergeMetadata,
      };
      await callBackValidation(payout, this.alertsService);
      this.logger.log(`Operation executed for payout ${id}`);
      const merged = { ...payout, ...updatedFields };
      const payoutToSave = plainToInstance(PayoutEntity, merged);

      await manager.save(PayoutEntity, payoutToSave);
      await queryRunner.commitTransaction();
      this.logger.log(`Transaction committed for payout ${id}`);
    } catch (error) {
      this.logger.error(error.message);
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      throw error;
    } finally {
      await queryRunner.release();
      //await destroyConnection();
    }

    const updatedPayout = await this.payoutRepository.findOne({
      where: { id },
    });

    return updatedPayout;
  }
  */

  async validationPipeCancelable(
    payout: PayoutEntity,
    transfers: TransferEntity[],
  ): Promise<void> {
    const entitiesValidations = new EntitiesValidationService();

    const payoutCancelable = entitiesValidations
      .setPayout(payout)
      .payoutIsCancelable(transfers);

    if (!payoutCancelable.result) {
      const { message } = payoutCancelable.detail;
      throw new UnprocessableEntityException(message);
    }
  }

  async validationPipeCompletable(
    payout: PayoutEntity,
    transfers: TransferEntity[],
  ): Promise<void> {
    const entitiesValidations = new EntitiesValidationService();
    entitiesValidations.setPayout(payout);

    const uniqueTransferCompleted =
      entitiesValidations.payoutUniqueTransferCompleted(transfers);

    if (!uniqueTransferCompleted.result) {
      const { message: serviceError } = uniqueTransferCompleted.detail;
      await this.alertsService.notifyPayoutInconsistent(payout, serviceError);
    }

    const payoutCompletable = entitiesValidations.payoutIsCompletable();

    if (!payoutCompletable.result) {
      const { message } = payoutCompletable.detail;
      throw new UnprocessableEntityException(message);
    }
  }

  async validationPipeProcessable(
    payout: PayoutEntity,
    transfers: TransferEntity[],
  ): Promise<void> {
    const entitiesValidations = new EntitiesValidationService();
    entitiesValidations.setPayout(payout);

    const uniqueTransferProcessing =
      entitiesValidations.payoutUniqueTransferProcessing(transfers);

    if (!uniqueTransferProcessing.result) {
      const { message: serviceError } = uniqueTransferProcessing.detail;
      await this.alertsService.notifyPayoutInconsistent(payout, serviceError);
    }

    const payoutProcessable = entitiesValidations.payoutIsProcessable();

    if (!payoutProcessable.result) {
      const { message } = payoutProcessable.detail;
      throw new UnprocessableEntityException(message);
    }
  }

  // END HELPERS

  async createPayoutAndTransfer(
    createPayoutDto: CreatePayoutDto,
  ): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    this.logger.debug('Creating payout from new service');

    try {
      const queryRunner = this.dataSource.createQueryRunner();
      const manager = queryRunner.manager;
      await queryRunner.startTransaction();

      const payoutEntity = manager.create(PayoutEntity, createPayoutDto);
      await manager.save(payoutEntity);
      // TODO: recover event when feature flag CAN_USE_NEW_PAYOUT_CREATION is enabled
      // this.eventEmitter.emit(PayoutEvent.CREATED, payout);

      const payout = await manager.findOne(PayoutEntity, {
        where: { trackingCode: createPayoutDto.trackingCode },
      });

      await this.createTransferAndAssign(payout, manager);
      await queryRunner.commitTransaction();
      return payout;
    } catch (err) {
      if (err?.code === MYSQL_UNIQUE_CONSTRAINT_VIOLATION) {
        throw new ConflictException('Payout tracking code must be unique');
      } else {
        throw err;
      }
    }
  }

  async cancelPayoutAndTransfer(
    payoutId: PayoutEntity['id'],
    transferId: TransferEntity['id'],
    cancelPayoutDto?: CancelPayoutDto,
  ): Promise<PayoutEntity> {
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      const manager = queryRunner.manager;
      if (queryRunner.isTransactionActive) {
        throw new ConflictException('Transaction already active');
      }
      this.logger.log(
        `Starting transaction for payout ${payoutId} in order to cancel payout and transfer`,
      );
      this.logger.log(`Starting transaction for payout`);
      await queryRunner.startTransaction('READ COMMITTED');

      const { from } = this.payoutStateMachine.findTransitionByName(
        PayoutTransition.CANCEL,
      );
      const payout = await manager.findOne(PayoutEntity, {
        where: { id: payoutId, state: In(from) },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });

      const transfers = await manager.find(TransferEntity, {
        where: { payoutId },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      const transfer = transfers.find((transfer) => transfer.id === transferId);

      if (transfer.state !== TransferState.CANCELED) {
        await this.cancelTransfer(transfer, payout, manager, cancelPayoutDto);
      }

      await this.validationPipeCancelable(payout, transfers);
      const { message, metadata } = cancelPayoutDto ?? {};

      const mergeMetadata = {
        ...payout.metadata,
        ...metadata,
      };
      await manager.save(PayoutEntity, {
        ...payout,
        state: PayoutState.CANCELED,
        ...(message && { message }),
        ...(Object.keys(mergeMetadata).length > 0 && {
          metadata: mergeMetadata,
        }),
      });

      const updatedPayout = await manager.findOneBy(PayoutEntity, {
        id: payoutId,
      });
      await queryRunner.commitTransaction();

      this.logger.log('Emit PayoutEvent.CANCELED');
      this.eventEmitter.emit(PayoutEvent.CANCELED, updatedPayout);

      return updatedPayout;
    } catch (error) {
      this.logger.error(error.message);
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /*
  async cancelPayout(
    payoutId: number,
    manager: EntityManager,
    cancelPayoutDto?: CancelPayoutDto,
  ): Promise<PayoutEntity> {
  const canUseNewPayoutCreation =
    await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
    );
  if (!canUseNewPayoutCreation) return;
  const { from } = this.payoutStateMachine.findTransitionByName(
    PayoutTransition.CANCEL,
  );
  const payout = await manager.findOne(PayoutEntity, {
    where: { id: payoutId, state: In(from) },
  });
  const transfers = await manager.find(TransferEntity, {
    where: { payoutId },
    lock: { mode: LockMode.PESSIMISTIC_READ },
  });
  // debe recibir las transfer por separado
  await this.validationPipeCancelable(payout, transfers);
  const { message, metadata } = cancelPayoutDto ?? {};
  const mergeMetadata = {
    ...payout.metadata,
    ...metadata,
  };
  // matar secure update, usar manager
  // const updatedPayout = await this.secureUpdatePayoutState(
  //   payout.id,
  //   updateFields,
  //   from,
  //   this.validationPipeCancelable,
  // );
  await manager.save(PayoutEntity, {
    ...payout,
    state: PayoutState.CANCELED,
    ...(message && { message }),
    ...(Object.keys(mergeMetadata).length > 0 && {
      metadata: mergeMetadata,
    }),
  });
  const updatedPayout = await manager.findOneBy(PayoutEntity, {
    id: payoutId,
  });
  this.logger.log('Emit PayoutEvent.CANCELED');
  this.eventEmitter.emit(PayoutEvent.CANCELED, updatedPayout);
  }
  */

  async completePayoutAndTransfer(
    payoutId: PayoutEntity['id'],
    transferId: TransferEntity['id'],
    completePayoutDto?: CompletePayoutDto,
  ): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    const { message, metadata } = completePayoutDto ?? {};

    const queryRunner = this.dataSource.createQueryRunner();
    try {
      const manager = queryRunner.manager;
      if (queryRunner.isTransactionActive) {
        throw new ConflictException('Transaction already active');
      }

      this.logger.log(
        `Starting transaction for payout ${payoutId} in order to complete payout and transfer`,
      );
      await queryRunner.startTransaction('READ COMMITTED');

      const transfer = await manager.findOne(TransferEntity, {
        where: { id: transferId, payoutId },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      await this.completeTransfer(transfer, manager, completePayoutDto);

      const { from } = this.payoutStateMachine.findTransitionByName(
        PayoutTransition.COMPLETE,
      );

      const payout = await manager.findOne(PayoutEntity, {
        where: { id: payoutId, state: In(from) },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      const transfers = await manager.find(TransferEntity, {
        where: { payoutId },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });

      await this.validationPipeCompletable(payout, transfers);

      const mergeMetadata = {
        ...payout.metadata,
        ...metadata,
      };

      await manager.save(PayoutEntity, {
        ...payout,
        state: PayoutState.COMPLETED,
        ...(message && { message }), // podríamos guardarle el mensaje de la last transfer si no viene nada?
        ...(Object.keys(mergeMetadata).length > 0 && {
          metadata: mergeMetadata,
        }),
      });
      this.logger.log(`Complete operation executed for payout ${payoutId}`);
      await queryRunner.commitTransaction();
      this.logger.log(`Complete transaction committed for payout ${payoutId}`);
    } catch (error) {
      this.logger.error(error.message);
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      throw error;
    } finally {
      this.logger.log(`Endend transaction for payout`);
      await queryRunner.release(); // faltaba su await
    }

    const updatedPayout = await this.payoutRepository.findOneBy({
      id: payoutId,
    });

    this.logger.log('Emit PayoutEvent.COMPLETED');
    this.eventEmitter.emit(PayoutEvent.COMPLETED, updatedPayout);

    return updatedPayout;
  }

  /**
   * Processes a payout identified by the provided payout ID.
   *
   * This method fetches a payout by its ID, validates if the payout is processable,
   * and then processes the payout if it is valid. It also checks for multiple transfers
   * in processing state and if found, it **notifies** about the inconsistency 🚨🔍.
   *
   * @param payoutId - The ID of the payout to be processed.
   * @throws {UnprocessableEntityException} - Throws an exception if the payout is not processable.
   * @returns {Promise<PayoutEntity>} - Returns a promise that resolves to the processed payout entity.
   */
  private async processPayout(
    payout: PayoutEntity,
    manager: EntityManager,
  ): Promise<PayoutEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    const transfers = await manager.find(TransferEntity, {
      where: { payoutId: payout.id },
    });
    await this.validationPipeProcessable(payout, transfers);

    if (payout.state === PayoutState.PROCESSING) {
      this.logger.warn(
        `Payout ${payout.id} is already in state ${PayoutState.PROCESSING}. Found ${payout.transfers.length} transfers.`,
      );
      return payout;
    }
    const { from } = this.payoutStateMachine.findTransitionByName(
      PayoutTransition.PROCESS,
    );

    if (!from.includes(payout.state)) {
      throw new Error(
        `Invalid transition from ${payout.state} to ${PayoutState.PROCESSING}`,
      );
    }

    await manager.save(PayoutEntity, {
      ...payout,
      state: PayoutState.PROCESSING,
    });
    const updatedPayout = await manager.findOne(PayoutEntity, {
      where: {
        id: payout.id,
      },
    });
    this.logger.log('Emit PayoutEvent.PROCESSING');
    this.eventEmitter.emit(PayoutEvent.PROCESSING, updatedPayout);

    return updatedPayout;
  }

  async createTransferAndAssign(
    payoutEntity: PayoutEntity,
    manager: EntityManager,
    providerId?: number,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    try {
      const createdTransfer = await this.transferService.createTransfer(
        payoutEntity,
        manager,
      );

      const { result, detail } = await this.evaluateTransferAssignation(
        createdTransfer,
        manager,
        providerId,
      );

      if (result) {
        const { provider } = detail;
        this.logger.debug(
          `Assigning transfer ${createdTransfer.id} to ${provider.id}`,
        );
        return this.transferService.assignTransfer(
          createdTransfer,
          provider.id,
          manager,
        );
      }
      const { message, state } = detail;
      this.logger.debug(
        `Evaluate transfer assignation failed with message ${message}`,
      );

      if (state === TransferState.CANCELED) {
        return this.cancelTransfer(createdTransfer, payoutEntity, manager, {
          message,
        });
      }
      if (state === TransferState.FAILED) {
        return this.failTransferInTransaction(createdTransfer, manager, {
          message,
        });
      }
      this.logger.error('Transfer creationAndAssignation failed');
    } catch (error) {
      this.logger.error(error.message);
      this.alertsService.notifyPayoutInconsistent(payoutEntity, error.message);
      throw error;
    }
  }

  /**
   * Processes a transfer associated with a payout.
   *
   * This method fetches a transfer by its [transferId](vsls:/src/services/entities-validation/entities-validation.service.ts#190%2C13-190%2C13) and [payoutId](vsls:/src/models/payout/payout.new.service.ts#76%2C26-76%2C26), validates if the transfer is processable,
   * and then processes the transfer if it is valid.
   *
   * @param transferId - The id of the transfer to be processed.
   * @param processTransferDto - An optional object containing metadata and a message.
   * @param options.metadata - Optional metadata for the payout.
   * @param options.message - Optional message for the payout.
   *
   * @throws {UnprocessableEntityException} - Throws an exception if the transfer is not processable.
   *
   * @returns {Promise<TransferEntity>} - Returns a promise that resolves to the processed transfer entity. The TransferEntity includes the Payout object with its provider as a property.
   */
  private async processTransfer(
    transfer: TransferEntity,
    manager: EntityManager,
    processTransferDto?: ProcessTransferDto,
  ): Promise<TransferEntity> {
    const entitiesValidations = new EntitiesValidationService();

    const isProcessable = entitiesValidations
      .setTransfer(transfer)
      .transferIsValid();

    if (!isProcessable.result) {
      const { message } = isProcessable.detail;
      throw new UnprocessableEntityException(message);
    }

    const { from } = this.transferStateMachine.findTransitionByName(
      TransferTransition.PROCESS,
    );

    if (!from.includes(transfer.state)) {
      throw new Error(
        `Invalid transition from ${transfer.state} to ${TransferState.PROCESSING}`,
      );
    }
    const { metadata, message, externalId } = processTransferDto ?? {};
    const mergeMetadata = {
      ...transfer?.metadata,
      ...metadata,
    };
    await manager.save(TransferEntity, {
      ...transfer,
      metadata: mergeMetadata,
      message,
      externalId,
      state: TransferState.PROCESSING,
    });

    const updatedTransfer = await manager.findOne(TransferEntity, {
      where: {
        id: transfer.id,
      },
    });
    this.logger.log('Emit TransferEvent.PROCESSING');
    this.eventEmitter.emit(TransferEvent.PROCESSING, updatedTransfer);
    return updatedTransfer;
  }

  /**
   * Processes a transfer and its associated payout if applicable.
   *
   * This method fetches a transfer by its [transferId](vsls:/src/services/entities-validation/entities-validation.service.ts#190%2C13-190%2C13) and [payoutId](vsls:/src/models/payout/payout.new.service.ts#76%2C26-76%2C26), validates if the transfer is processable,
   * and then processes the transfer if it is valid. If the payout is also processable, it will be processed as well.
   *
   * @param transferId - The id of the transfer to be processed.
   * @param payoutId - The id of the payout associated with the transfer.
   * @param processTransferDto - An optional object containing metadata and a message.
   * @param options.metadata - Optional metadata for the payout.
   * @param options.message - Optional message for the payout.
   *
   * @throws {UnprocessableEntityException} - Throws an exception if the transfer is not processable.
   *
   * @returns {Promise<TransferEntity>} - Returns a promise that resolves to the processed transfer entity.
   *
   * @example
   * ```typescript
   * const processedTransfer = await payoutService.processTransferAndPayout(transferId, payoutId, {
   *   metadata: { key: 'value' },
   *   message: 'Processing transfer',
   * });
   * ```
   */
  public async processPayoutAndTransfer(
    payoutId: PayoutEntity['id'],
    transferId: TransferEntity['id'],
    processTransferDto?: ProcessTransferDto,
  ): Promise<TransferEntity> {
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      const manager = queryRunner.manager;
      if (queryRunner.isTransactionActive) {
        throw new ConflictException('Transaction already active');
      }
      this.logger.log(
        `Starting transaction for payout ${payoutId} in order to process payout and transfer`,
      );
      await queryRunner.startTransaction('READ COMMITTED');

      const transfer = await manager.findOne(TransferEntity, {
        where: { id: transferId, payoutId },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });
      await this.processTransfer(transfer, manager, processTransferDto);

      const payout = await manager.findOne(PayoutEntity, {
        where: { id: payoutId },
      });
      await this.processPayout(payout, manager);
      this.logger.log(`Process operation executed for payout ${payoutId}`);

      await queryRunner.commitTransaction();
      this.logger.log(`Process transaction committed for payout ${payoutId}`);

      return await manager.findOne(TransferEntity, {
        where: { id: transferId },
      });
    } catch (error) {
      this.logger.error(error.message);
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      // throw new UnprocessableEntityException(
      //   'Process payout failed due process transfer failure',
      // );
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  async cancelTransfer(
    transfer: TransferEntity,
    payout: PayoutEntity,
    manager: EntityManager,
    options?: {
      metadata?: PayoutEntity['metadata'];
      message?: string;
    },
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    const entitiesValidations = new EntitiesValidationService();

    const payoutIsValid = entitiesValidations.setPayout(payout).payoutIsValid();

    if (!payoutIsValid.result) {
      const { message } = payoutIsValid.detail;
      throw new UnprocessableEntityException(message);
    }

    const transferIsValid = entitiesValidations
      .setTransfer(transfer)
      .transferIsValid();

    if (!transferIsValid.result) {
      const { message } = transferIsValid.detail;
      throw new UnprocessableEntityException(message);
    }

    const { from } = this.transferStateMachine.findTransitionByName(
      TransferTransition.CANCEL,
    );
    const { metadata, message } = options ?? {};

    const mergeMetadata = {
      ...transfer?.metadata,
      ...metadata,
    };
    let fromStates = from;

    if (transfer.providerId) {
      const provider = await manager.findOneBy(ProviderEntity, {
        id: transfer.providerId,
      });
      const providerAdapter = this.providerService.getProviderAdapter(
        provider.providerType,
      );

      const providerFromStates = providerAdapter.cancelableStates;
      const isSubset = fromStates.every((state) => fromStates.includes(state));
      if (!isSubset) {
        throw new UnprocessableEntityException(
          'Provider cancelable states are not a subset of the state machine',
        );
      }
      fromStates = providerFromStates;
    }

    if (!fromStates.includes(transfer.state)) {
      throw new Error(
        `Invalid transition from ${transfer.state} to transit to ${TransferState.CANCELED}`,
      );
    }

    await manager.save(TransferEntity, {
      ...transfer,
      ...(Object.keys(mergeMetadata).length > 0 && {
        metadata: mergeMetadata,
      }),
      message,
      state: TransferState.CANCELED,
    });

    const updatedTransfer = await manager.findOneBy(TransferEntity, {
      id: transfer.id,
    });

    this.logger.log('Emit TransferEvent.CANCELED');
    this.eventEmitter.emit(TransferEvent.CANCELED, updatedTransfer);

    return updatedTransfer;
  }

  /**
   * Completes the transfer identified by the provided transfer ID.
   * @param transferId - ID of the transfer to be completed.
   * @param options - Additional options for the complete transfer operation.
   * @param options.metadata - Optional metadata for the transfer.
   * @param options.message - Optional message associated with the transfer.
   * @returns A promise that resolves with the updated transfer.
   * @throws {UnprocessableEntityException} If the transfer cannot be completed due to minimum validations.
   * @throws {UnprocessableEntityException} If completion states are inconsistent between the provider and state machine.
   * @remarks This function utilizes the feature flag `CAN_USE_NEW_PAYOUT_CREATION`. Should be removed
   */
  private async completeTransfer(
    transfer: TransferEntity,
    manager: EntityManager,
    options?: {
      metadata?: PayoutEntity['metadata'];
      message?: string;
    },
  ) {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    try {
      // const transfer = await manager.findOne(TransferEntity, {
      //   where: { id: transferId, payoutId },
      //   lock: { mode: LockMode.PESSIMISTIC_READ },
      //   relations: ['provider'],
      // });
      const provider = await manager.findOne(ProviderEntity, {
        where: { id: transfer.providerId },
      });
      const { metadata, message } = options ?? {};
      const entitiesValidations = new EntitiesValidationService();

      const isCompletable = entitiesValidations
        .setTransfer(transfer)
        .transferIsValid();

      if (!isCompletable.result) {
        const { message } = isCompletable.detail;
        throw new UnprocessableEntityException(message);
      }
      const { from } = this.transferStateMachine.findTransitionByName(
        TransferTransition.COMPLETE,
      );

      const providerAdapter = this.providerService.getProviderAdapter(
        provider?.providerType,
      );
      const fromStates = providerAdapter.completableStates;

      const isSubset = fromStates.every((state) => from.includes(state));

      if (!isSubset) {
        throw new UnprocessableEntityException(
          'Provider completable states are not a subset of the state machine',
        );
      }
      // EDITADO SOBRIA POR NATALIA EL LUNES --<--<@
      if (!fromStates.includes(transfer.state)) {
        throw new Error(
          `Invalid transition from ${transfer.state} to ${TransferState.COMPLETED}`,
        );
      }
      const mergeMetadata = {
        ...transfer.metadata,
        ...metadata,
      };

      await manager.save(TransferEntity, {
        ...transfer,
        state: TransferState.COMPLETED,
        ...(Object.keys(mergeMetadata).length > 0 && {
          metadata: mergeMetadata,
        }),
        message: message ?? 'Transferencia completada exitosamente',
      });

      const updatedTransfer = await manager.findOne(TransferEntity, {
        where: { id: transfer.id },
      });

      this.logger.log('Emit TransferEvent.COMPLETED');
      this.eventEmitter.emit(TransferEvent.COMPLETED, updatedTransfer);

      return updatedTransfer;
    } catch (error) {
      this.logger.error(error.message);
      throw new Error(error.message);
    }
  }

  async failTransferInTransaction(
    transfer: TransferEntity,
    manager: EntityManager,
    options?: {
      metadata?: PayoutEntity['metadata'];
      message?: string;
    },
  ): Promise<TransferEntity> {
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    const { metadata: transferMetadata } = transfer;
    const { metadata, message } = options;
    const entitiesValidations = new EntitiesValidationService();

    const isFailable = entitiesValidations
      .setTransfer(transfer)
      .transferIsValid();

    if (!isFailable.result) {
      const { message: failableMessage } = isFailable.detail;
      throw new UnprocessableEntityException(failableMessage);
    }

    const { from } = this.transferStateMachine.findTransitionByName(
      TransferTransition.FAIL,
    );

    let fromStates = from;
    let errorCode: TransferErrorCode;
    if (transfer.providerId) {
      const provider = await manager.findOne(ProviderEntity, {
        where: { id: transfer.providerId },
      }); // puede no existir
      const providerAdapter = this.providerService.getProviderAdapter(
        provider.providerType,
      );

      const providerFromStates = providerAdapter.failableStates;

      const isSubset = providerFromStates.every((state) =>
        from.includes(state),
      );

      if (!isSubset) {
        throw new UnprocessableEntityException(
          'Provider failable states are not a subset of the state machine',
        );
      }
      fromStates = providerFromStates;
      const providerErrorCode = transferMetadata?.providerErrorCode;
      const transferError = await this.transferErrorService.findOrCreateError(
        message,
        provider?.providerType,
        providerErrorCode,
      );
      errorCode = transferError?.errorCode;
    }

    if (!fromStates.includes(transfer.state)) {
      throw new Error(
        `Invalid transition from ${transfer.state} to ${TransferState.FAILED}`,
      );
    }

    const mergeMetadata = {
      ...transferMetadata,
      ...metadata,
    };

    await manager.save(TransferEntity, {
      ...transfer,
      state: TransferState.FAILED,
      message: message ?? 'Transferencia fallida',
      metadata: mergeMetadata,
      errorCode: errorCode,
    });

    const updatedTransfer = await manager.findOne(TransferEntity, {
      where: {
        id: transfer.id,
      },
    });
    this.logger.log('Emit TransferEvent.FAILED');
    this.eventEmitter.emit(TransferEvent.FAILED, updatedTransfer);

    return updatedTransfer;
  }

  async failTransfer(
    transferId: TransferEntity['id'],
    options?: {
      metadata?: PayoutEntity['metadata'];
      message?: string;
    },
  ): Promise<TransferEntity> {
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    const queryRunner = this.dataSource.createQueryRunner();
    const manager = queryRunner.manager;
    try {
      await queryRunner.startTransaction();
      const transfer = await manager.findOneBy(TransferEntity, {
        id: transferId,
      });
      const { metadata: transferMetadata } = transfer;
      const { metadata, message } = options;

      const provider = await manager.findOne(ProviderEntity, {
        where: { id: transfer.providerId },
      }); // puede no existir

      const entitiesValidations = new EntitiesValidationService();

      const isFailable = entitiesValidations
        .setTransfer(transfer)
        .transferIsValid();

      if (!isFailable.result) {
        const { message } = isFailable.detail;
        throw new UnprocessableEntityException(message);
      }

      const { from } = this.transferStateMachine.findTransitionByName(
        TransferTransition.FAIL,
      );

      let fromStates = from;
      if (provider) {
        const providerAdapter = this.providerService.getProviderAdapter(
          provider.providerType,
        );

        const providerFromStates = providerAdapter.failableStates;

        const isSubset = providerFromStates.every((state) =>
          from.includes(state),
        );

        if (!isSubset) {
          throw new UnprocessableEntityException(
            'Provider failable states are not a subset of the state machine',
          );
        }
        fromStates = providerFromStates;
      }

      if (!fromStates.includes(transfer.state)) {
        throw new Error(
          `Invalid transition from ${transfer.state} to ${TransferState.FAILED}`,
        );
      }

      const mergeMetadata = {
        ...transferMetadata,
        ...metadata,
      };

      const providerErrorCode = transferMetadata?.providerErrorCode;

      const transferError = await this.transferErrorService.findOrCreateError(
        message,
        provider?.providerType,
        providerErrorCode,
      );

      await manager.save(TransferEntity, {
        ...transfer,
        state: TransferState.FAILED,
        message: message ?? 'Transferencia fallida',
        metadata: mergeMetadata,
        errorCode: transferError?.errorCode,
      });

      const updatedTransfer = await manager.findOne(TransferEntity, {
        where: {
          id: transfer.id,
        },
      });

      this.logger.log('Emit TransferEvent.FAILED');
      this.eventEmitter.emit(TransferEvent.FAILED, updatedTransfer);
      await queryRunner.commitTransaction();

      return updatedTransfer;
    } catch (error) {
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  async reassignPayout(
    payoutId: number,
    providerId?: number,
  ): Promise<[PayoutEntity, TransferEntity]> {
    const queryRunner = this.dataSource.createQueryRunner();
    const manager = queryRunner.manager;

    try {
      const payout = await manager.findOne(PayoutEntity, {
        where: {
          id: payoutId,
        },
        lock: { mode: LockMode.PESSIMISTIC_READ },
      });

      const entitiesValidations = new EntitiesValidationService();

      const payoutIsUnfinished = entitiesValidations
        .setPayout(payout)
        .payoutIsUnfinished();

      if (!payoutIsUnfinished.result) {
        const { message } = payoutIsUnfinished.detail;
        throw new UnprocessableEntityException(message);
      }

      // TODO: This validation will not longer be in the payout metadata
      if (
        payout.metadata?.message === 'Account Funding Payout' ||
        payout.concept.startsWith('Payout Funding')
      ) {
        throw new UnprocessableEntityException(
          `Cannot reassign a account funding payout`,
        );
      }

      await this.cancelAllTransfers(payout, manager);
      const newTransfer = await this.createTransferAndAssign(
        payout,
        manager,
        providerId,
      );
      const updatedPayout = await manager.findOne(PayoutEntity, {
        where: { id: payoutId },
      });

      return [updatedPayout, newTransfer];
    } catch (error) {
      this.logger.error(error.message);
      if (queryRunner.isTransactionActive) {
        await queryRunner.rollbackTransaction();
      }
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  async evaluateTransferAssignation(
    transfer: TransferEntity,
    manager: EntityManager,
    providerId?: number,
  ): Promise<AssignationResult> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    const entitiesValidations = new EntitiesValidationService();

    // TODO: Payout and transfers should be send by params and evalaute if transfers are needed to evaluate assignation
    const payout = await manager.findOne(PayoutEntity, {
      where: { id: transfer.payoutId },
      relations: ['transfers'],
    });

    const evaluateResult = await this.merchantLimitEvaluatorService.evaluate(
      payout,
    );

    if (evaluateResult.exceeds) {
      this.logger.error(`Payout with id ${payout.id} exceeds merchant limit`);
      return {
        result: false,
        detail: {
          message: evaluateResult.errorMessage,
          state: TransferState.FAILED, // trigger auto_cancel payout
        },
      };
    }

    // TODO: missing state machine
    const transferIsAssignable = entitiesValidations
      .setTransfer(transfer)
      .setPayout(payout)
      .transferIsAssignable(transfer.id);

    if (!transferIsAssignable.result) {
      const { result, detail } = transferIsAssignable;
      return {
        result,
        detail: {
          message: detail.message,
          state: detail.state,
        },
      };
    }

    const payoutIsUnfinished = entitiesValidations.payoutIsUnfinished();

    if (!payoutIsUnfinished.result) {
      return payoutIsUnfinished;
    }

    const provider =
      await this.transferAssignmentNewService.findCapableProvider(
        transfer,
        providerId,
      );

    entitiesValidations.setProvider(provider);
    const providerIsValid = entitiesValidations.providerIsValid();

    if (!providerIsValid.result) {
      return providerIsValid;
    }

    return {
      result: true,
      detail: {
        provider,
      },
    };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/cancel-payout.dto.ts
import { Type } from 'class-transformer';
import { IsEnum, IsObject, IsOptional, IsString } from 'class-validator';
import { PayoutAction } from 'src/common/enums/payout-action.enum';

class PayoutMetadata {
  @IsString()
  @IsOptional()
  message?: string;

  @IsEnum(PayoutAction)
  @IsOptional()
  action?: PayoutAction;
}

export class CancelPayoutDto {
  @IsString()
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => PayoutMetadata)
  metadata?: PayoutMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/create-transfer.dto.ts
import { Expose } from 'class-transformer';
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';

export class PayoutTransferDto {
  @Expose()
  @IsNumber()
  @IsPositive()
  amount: number;

  @Expose()
  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @Expose()
  @IsString()
  concept: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  trackingCode: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationEmail?: string;

  @Expose()
  @IsString()
  destinationHolderId: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @Expose()
  @IsString()
  @IsNotEmpty()
  destinationBankCode: string;

  @Expose()
  @IsString()
  destinationPhone: string;

  @Expose()
  @IsNumber()
  @IsOptional()
  merchantId: number;

  @Expose()
  @IsEnum(EntityVersion)
  @IsOptional()
  version?: EntityVersion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/update-transfer-metadata.dto.ts
import { IsOptional, IsString } from 'class-validator';

export class UpdateTransferMetadataDto {
  @IsString()
  @IsOptional()
  message?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/complete-payout.dto copy.ts
import { Type } from 'class-transformer';
import { IsObject, IsOptional, IsString } from 'class-validator';

class PayoutMetadata {
  @IsString()
  @IsOptional()
  message?: string;
}

export class CompletePayoutDto {
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => PayoutMetadata)
  metadata?: PayoutMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/update-payout-metadata.dto.ts
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PayoutActionSuggestion } from 'src/common/enums/payout-action-suggestion.enum';

export class UpdatePayoutMetadataDto {
  @IsString()
  @IsOptional()
  message?: string;

  @IsEnum(PayoutActionSuggestion)
  @IsOptional()
  action?: PayoutActionSuggestion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/query-payout.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import {
  IsArray,
  IsDateString,
  IsEnum,
  IsIn,
  IsNumberString,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { PayoutState } from 'src/common/enums/payout-state.enum';
import { SortOrder } from 'src/utils/array-methods.util';

class PayoutMetadataDto {
  @IsNumberString()
  @IsOptional()
  paymentId?: number;
}

class PayoutTransferDto {
  @IsString()
  @IsOptional()
  public originBankCode?: string;

  @IsNumberString()
  @IsOptional()
  public providerId?: number;
}

export class QueryPayoutDto extends QueryPaginatedDto {
  @IsEnum(PayoutState)
  @IsOptional()
  public state?: PayoutState;

  @IsOptional()
  @IsArray()
  @IsEnum(PayoutState, { each: true })
  public states?: PayoutState[];

  @IsOptional()
  @IsString()
  public search?: string;

  @IsString()
  @IsOptional()
  public destinationBankCode?: string;

  @ValidateNested()
  @IsOptional()
  @ApiProperty({ type: () => PayoutTransferDto })
  @Type(() => PayoutTransferDto)
  public transfer?: PayoutTransferDto;

  @ValidateNested()
  @IsOptional()
  @ApiProperty({ type: () => PayoutMetadataDto })
  @Type(() => PayoutMetadataDto)
  public metadata?: PayoutMetadataDto;

  @IsString()
  @IsOptional()
  public trackingCode?: string;

  @IsDateString()
  @IsOptional()
  public from?: string;

  @IsDateString()
  @IsOptional()
  public to?: string;

  @IsEnum(SortOrder)
  @IsOptional()
  public sort? = SortOrder.ASCENDING;

  @IsEnum(Currency)
  @IsOptional()
  currency?: Currency;

  @IsOptional()
  @IsArray()
  @IsIn([EntityVersion.v1, EntityVersion.v2], { each: true })
  version?: EntityVersion[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/update-payout.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsObject,
  IsOptional,
  IsString,
} from 'class-validator';

import { PayoutState } from 'src/common/enums/payout-state.enum';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';

export class UpdatePayoutDto {
  @IsEnum(PayoutState)
  @IsOptional()
  state?: PayoutState;

  @IsObject()
  @IsOptional()
  metadata?: any;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  message?: string;

  @IsEnum(TransferErrorCode)
  @IsOptional()
  errorCode?: TransferErrorCode;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/process-payout.dto.ts
import { Type } from 'class-transformer';
import { IsObject, IsOptional, IsString } from 'class-validator';

class PayoutMetadata {
  @IsString()
  @IsOptional()
  message?: string;
}

export class ProcessPayoutDto {
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => PayoutMetadata)
  metadata?: PayoutMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/complete-payout.dto.ts
import { Type } from 'class-transformer';
import { IsObject, IsOptional, IsString } from 'class-validator';

class PayoutMetadata {
  @IsString()
  @IsOptional()
  message?: string;
}

export class CompletePayoutDto {
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => PayoutMetadata)
  metadata?: PayoutMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/payout/dto/create-payout.dto.ts
import {
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { EntityVersion } from 'src/common/enums/entity-version.enum';

export class CreatePayoutDto {
  @IsNumber()
  @IsPositive()
  amount: number;

  @IsEnum(Currency)
  @IsNotEmpty()
  currency: Currency;

  @IsString()
  concept: string;

  @IsString()
  @IsNotEmpty()
  trackingCode: string;

  @IsObject()
  @IsOptional()
  metadata?: any;

  @IsString()
  @IsNotEmpty()
  destinationEmail: string;

  @IsString()
  @IsNotEmpty()
  destinationName: string;

  @IsString()
  @IsNotEmpty()
  destinationHolderId: string;

  @IsString()
  @IsNotEmpty()
  destinationAccount: string;

  @IsString()
  @IsNotEmpty()
  destinationBankCode: string;

  @IsNumber()
  @IsOptional()
  merchantId: number;

  @IsString()
  @IsOptional()
  destinationPhone: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  providerId?: number;

  // TODO: Should only allow to set this to v2
  @IsEnum(EntityVersion)
  @IsOptional()
  version?: EntityVersion;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/transfer-error.module.ts
import { Module } from '@nestjs/common';
import { TransferErrorEntity } from './entities/transfer-error.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TransferErrorService } from './transfer-error.service';

@Module({
  providers: [TransferErrorService],
  imports: [TypeOrmModule.forFeature([TransferErrorEntity])],
  exports: [TypeOrmModule, TransferErrorService],
})
export class TransferErrorModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/entities/transfer-error.entity.ts
import { Column, Entity, Index } from 'typeorm';
import { BaseEntity } from 'src/common/base.entity';
import { TransferErrorCode } from '../error.definition.type';
import { IsEnum } from 'class-validator';
import { ProviderType } from 'src/common/enums/provider-type.enum';
@Entity({ name: 'transfer_error' })
@Index('IDX_ERROR_RAW', ['errorRaw'], { fulltext: true })
export class TransferErrorEntity extends BaseEntity {
  @Column({ type: 'text', nullable: false })
  errorRaw: string;

  @Column({ type: 'text', nullable: true })
  pattern: string;

  @IsEnum(TransferErrorCode)
  @Column('enum', {
    enum: TransferErrorCode,
    default: null,
    nullable: true,
  })
  errorCode?: TransferErrorCode;

  @Column({ type: 'varchar', length: 128, nullable: true })
  externalErrorCode?: string;

  @Column('enum', {
    enum: ProviderType,
    default: null,
    nullable: true,
  })
  providerType?: ProviderType;

  @IsEnum(Object.keys(TransferErrorCode))
  @Column('enum', {
    enum: Object.keys(TransferErrorCode),
    default: null,
    nullable: true,
  })
  errorType?: string;

  @Column({ type: 'varchar', length: 128, nullable: true })
  description?: string;

  @Column({ type: 'varchar', length: 128, nullable: true })
  issuer?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/transfer-error.service.ts
import { InjectRepository } from '@nestjs/typeorm';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { DataService } from 'src/database/data.service';
import { Repository } from 'typeorm';
import { CreateTransferErrorDto } from './dto/create-transfer-error.dto';
import { TransferErrorEntity } from './entities/transfer-error.entity';
import { MAPPED_ERROR_TYPE, TransferErrorCode } from './error.definition.type';

export class TransferErrorService extends DataService<TransferErrorEntity>(
  TransferErrorEntity,
) {
  @InjectRepository(TransferErrorEntity)
  private transferErrorRepository: Repository<TransferErrorEntity>;

  private async findAll(): Promise<TransferErrorEntity[]> {
    return this.transferErrorRepository.find();
  }

  private async findByProviderType(providerType: ProviderType) {
    return this.transferErrorRepository.find({
      where: { providerType },
    });
  }

  private async create(
    createTransferErrorDto: CreateTransferErrorDto,
  ): Promise<TransferErrorEntity> {
    const newTransferEntity = this.transferErrorRepository.create(
      createTransferErrorDto,
    );

    const transferError = await this.transferErrorRepository.save(
      newTransferEntity,
    );

    return transferError;
  }

  /**
   * Normalizes a string for comparison purposes.
   *
   * This function performs the following operations:
   *
   * 1. Removes diacritics using `normalize('NFD')`.
   * 2. Replaces newline characters with spaces.
   * 3. Collapses multiple spaces into a single space.
   * 4. Converts the string to lowercase.
   * 5. Trims leading and trailing whitespace.
   *
   * Optionally, you can specify `type="regexp"` to escape any remaining dots in the string, making it safer for use in regular expressions. Escaped dots will not be treated as special characters.
   *
   * The escaping only applies to dots not already preceded or followed by backslashes, and avoids escaping dots within literal character classes.
   *
   * @param value The string to normalize.
   * @param type (optional) Sets the normalization mode. Defaults to the basic text normalization without escaping dots.
   * @returns The normalized string.
   */
  private normalizeString(value: string, type?: 'regexp'): string {
    if (!value) return '';

    let normalizedString = value
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/\r?\n|\r/g, ' ')
      .replace(/\s+/g, ' ')
      .toLocaleLowerCase()
      .trim();

    if (type === 'regexp') {
      normalizedString = normalizedString.replace(/(?<!\\)\.(?!\*)/g, '\\.');
    }

    return normalizedString;
  }

  async findOrCreateError(
    message: string,
    providerType?: ProviderType,
    externalErrorCode?: string,
  ): Promise<TransferErrorEntity> {
    if (!message) return null;

    let errors: TransferErrorEntity[] = [];

    if (providerType) {
      errors = await this.findByProviderType(providerType);
    } else errors = await this.findAll();

    const normalizedMessage = this.normalizeString(message);

    for (const error of errors) {
      if (externalErrorCode && externalErrorCode === error.externalErrorCode) {
        return error;
      }

      const regex = error?.pattern
        ? new RegExp(this.normalizeString(error.pattern, 'regexp'))
        : null;

      if (regex?.test(normalizedMessage)) return error;

      const normalizedError = this.normalizeString(error.errorRaw);

      if (normalizedMessage === normalizedError) return error;
    }

    const createTransferErrorDto: CreateTransferErrorDto = {
      providerType,
      externalErrorCode,
      errorRaw: message,
      errorCode: TransferErrorCode.UNKNOWN_ERROR,
      errorType: MAPPED_ERROR_TYPE[TransferErrorCode.UNKNOWN_ERROR],
    };

    return this.create(createTransferErrorDto);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/dto/create-transfer-error.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferErrorCode } from '../error.definition.type';

export class CreateTransferErrorDto {
  @IsString()
  @IsNotEmpty()
  errorRaw: string;

  @IsEnum(TransferErrorCode)
  errorCode: TransferErrorCode;

  @IsString()
  @IsNotEmpty()
  errorType: string;

  @IsEnum(ProviderType)
  @IsOptional()
  providerType?: ProviderType;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  externalErrorCode?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/error.definition.type.ts
import { BankCode } from 'src/common/rules/rule-definitions/rule-definition-params';

export type TransferError = {
  code: TransferErrorCode;
  error: string;
  description: string;
  issuer?: BankCode;
};
export enum TransferErrorCode {
  UNKNOWN_ERROR = 'ERROR_0000',
  PROVIDER_INTERNAL_FAILURE = 'ERROR_0001',
  PROVIDER_INSUFFICIENT_FUNDS = 'ERROR_0002',
  RECIPIENT_FIRST_TRANSFER = 'ERROR_0003',
  RECIPIENT_INVALID_ACCOUNT = 'ERROR_0004',
  RECIPIENT_DISABLED_ACCOUNT = 'ERROR_0005',
  DESTINATION_BANK_IN_MAINTENANCE = 'ERROR_0006',
  DESTINATION_BANK_NOT_AVAILABLE = 'ERROR_0007',
  DESTINATION_BANK_TIMEOUT = 'ERROR_0008',
  RECIPIENT_ACCOUNT_OVER_LIMIT = 'ERROR_0009',
  MERCHANT_LIMIT_EXCEED = 'ERROR_0010',
}

export const actionablePayoutErrorCode = [
  TransferErrorCode.RECIPIENT_INVALID_ACCOUNT,
  TransferErrorCode.RECIPIENT_DISABLED_ACCOUNT,
  TransferErrorCode.DESTINATION_BANK_IN_MAINTENANCE,
  TransferErrorCode.DESTINATION_BANK_NOT_AVAILABLE,
  TransferErrorCode.RECIPIENT_ACCOUNT_OVER_LIMIT,
  TransferErrorCode.MERCHANT_LIMIT_EXCEED,
];

export const suggestedPayoutErrorCode = [
  TransferErrorCode.DESTINATION_BANK_TIMEOUT,
  TransferErrorCode.PROVIDER_INTERNAL_FAILURE,
];

export const MAPPED_ERROR_TYPE = Object.fromEntries(
  Object.entries(TransferErrorCode).map(([key, value]) => [value, key]),
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer-error/transfer-error.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { randUuid } from '@ngneat/falso';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { TransferErrorEntity } from './entities/transfer-error.entity';
import { TransferErrorService } from './transfer-error.service';

describe('given a TransferErrorService', () => {
  let service: TransferErrorService;
  let mockRepository: {
    find: jest.Mock<any, any>;
    create: jest.Mock<any, any>;
    save: jest.Mock<any, any>;
  };

  beforeEach(async () => {
    mockRepository = {
      find: jest.fn(),
      create: jest.fn(),
      save: jest
        .fn()
        .mockResolvedValue({ errorCode: TransferErrorCode.UNKNOWN_ERROR }),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferErrorService,
        {
          provide: getRepositoryToken(TransferErrorEntity),
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get(TransferErrorService);
  });

  describe('findOrCreateError', () => {
    const errorWithExternalError = {
      errorCode: 'ERROR_0012',
      errorRaw: 'Error, cannot process transaction',
      externalErrorCode: 'SHK_0001',
    };

    const errors = [
      {
        errorCode: 'ERROR_0008',
        errorRaw: 'Error al procesar la transferencia',
      },
      {
        errorCode: 'ERROR_0001',
        errorRaw: `Transaction NOT executed, verified by the bank support team. Bank report: 
        -------- Detalle ------.
       Cliente: BUK Pagos SpA.
       SHK ID: 05fda726-5027-4503-873c-81acfafd30eb.
       Estado: Rejected.
       Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
       .
       Mueve Dinero:No.
       Cliente puede reintentar: Si.
       Requiere Callback Manual: Si.
       Cliente recibirá Cargo Manual: No.
       `,
        pattern: `Transaction NOT executed, verified by the bank support team. Bank report: 
       -------- Detalle ------.
      Cliente: BUK Pagos SpA.
      SHK ID: (\\w+-+){4}\\w+.
      Estado: Rejected.
      Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
      .
      Mueve Dinero:No.
      Cliente puede reintentar: Si.
      Requiere Callback Manual: Si.
      Cliente recibirá Cargo Manual: No.
      `,
      },
      {
        errorCode: 'ERROR_00010',
        errorRaw:
          'Error: Shinkansen transaction 0c1deb94-36ab-4d3d-8950-12562399d1e3 failed after 4 attempts',
        pattern: `Error: Shinkansen transaction .* failed after 4 attempts`,
      },
      {
        errorCode: 'ERROR_00011',
        errorRaw: `<html>
        <head><title>400 No required SSL certificate was sent</title></head>
        <body>
        <center><h1>400 Bad Request</h1></center>
        <center>No required SSL certificate was sent</center>
        <hr><center>server</center>
        </body>
        </html>
        `,
      },
      {
        errorCode: 'ERROR_0002',
        errorRaw:
          'Ha ocurrido un error interno en BICE. An internal error has occurred, please try again later.. Por favor envíe una nueva transacción',
      },
      {
        errorCode: 'ERROR_0004',
        errorRaw: 'Error CCA 41. Cuenta destino incorrecta',
      },
      {
        errorCode: 'ERROR_0001',
        errorRaw:
          'Estimado cliente, hemos tenido un inconveniente al procesar la transacción (Cód. SKT0804).',
      },
      {
        errorCode: 'ERROR_0002',
        errorRaw:
          'Error al esperar resultado de la transferencia. 2023-01-08 00:16:38.520',
        pattern:
          'Error al esperar resultado de la transferencia. \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}',
      },
      errorWithExternalError,
    ];

    beforeEach(() => {
      mockRepository.find.mockResolvedValue(errors);
    });

    it.each([
      {
        message:
          'Estimado cliente, hemos tenido un inconveniente al procesar la transacción (Cód. SKT0804).',
        expected: 'ERROR_0001',
      },
      {
        message:
          'Ha ocurrido un error interno en BICE. An internal error has occurred, please try again later.. Por favor envíe una nueva transacción',
        expected: 'ERROR_0002',
      },
      {
        message: 'Error CCA 41. Cuenta destino incorrecta',
        expected: 'ERROR_0004',
      },
      {
        message: `<html>
        <head><title>400 No required SSL certificate was sent</title></head>
        <body>
        <center><h1>400 Bad Request</h1></center>
        <center>No required SSL certificate was sent</center>
        <hr><center>server</center>
        </body>
        </html>
        `,
        expected: 'ERROR_00011',
      },
    ])(
      'then should match errors without regex $expected',
      async ({ message, expected }) => {
        const result = await service.findOrCreateError(message);

        expect(result.errorCode).toEqual(expected);
      },
    );

    it.each([
      {
        message:
          'Error al esperar resultado de la transferencia. 2025-01-08 00:16:38.520',
        expected: 'ERROR_0002',
      },
      {
        message: `Transaction NOT executed, verified by the bank support team. Bank report:
        -------- Detalle ------.
       Cliente: BUK Pagos SpA.
       SHK ID: 05fda726-5027-4503-873a-81acfafd30eb.
       Estado: Rejected.
       Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
       .
       Mueve Dinero:No.
       Cliente puede reintentar: Si.
       Requiere Callback Manual: Si.
       Cliente recibirá Cargo Manual: No.`,
        expected: 'ERROR_0001',
      },
      {
        message: `Transaction NOT executed, verified by the bank support team. Bank report:
        -------- Detalle ------.
       Cliente: BUK Pagos SpA.
       SHK ID: 05fda726-5027-4503-873b-81acfafd30eb.
       Estado: Rejected.
       Detalle: Transacción no completada por intermitencia temporal. Se puede reintentar con seguridad.
       .
       Mueve Dinero:No.
       Cliente puede reintentar: Si.
       Requiere Callback Manual: Si.
       Cliente recibirá Cargo Manual: No.
       `,
        expected: 'ERROR_0001',
      },
      {
        message:
          'Error: Shinkansen transaction 056f8ada-acba-45dc-8084-68468acba284 failed after 4 attempts',
        expected: 'ERROR_00010',
      },
      {
        message:
          'Error: Shinkansen transaction 196b5579-53ee-4eb4-a44e-601a91bef614 failed after 4 attempts',
        expected: 'ERROR_00010',
      },
      {
        message: `<html>
        <head><title>400 No required SSL certificate was sent</title></head>
        <body>
        <center><h1>400 Bad Request</h1></center>
        <center>No required SSL certificate was sent</center>
        <hr><center>server</center>
        </body>
        </html>
        `,
        expected: 'ERROR_00011',
      },
    ])(
      'then should match errors with regex patterns $expected',
      async ({ message, expected }) => {
        const result = await service.findOrCreateError(message);

        expect(result.errorCode).toEqual(expected);
      },
    );

    it.each([
      {
        message: 'ERROR AL PROCESAR LA TRANSFERENCIA',
        expected: 'ERROR_0008',
      },
      {
        message: 'ERror Al pROCesAR La TransFERENcia',
        expected: 'ERROR_0008',
      },
    ])(
      'then should match errors case insensitive',
      async ({ message, expected }) => {
        const result = await service.findOrCreateError(message);

        expect(result.errorCode).toEqual(expected);
      },
    );

    it.each([
      {
        message: 'Error         al procesar                 la transferencia',
        expected: 'ERROR_0008',
      },
      {
        message: `Error al procesar 
        la transferencia`,
        expected: 'ERROR_0008',
      },
    ])(
      'then should match errors that have difference on the spacing',
      async ({ message, expected }) => {
        const result = await service.findOrCreateError(message);

        expect(result.errorCode).toEqual(expected);
      },
    );

    it('then it should match errors with and without accent marks', async () => {
      const result = await service.findOrCreateError(
        'Estimado cliente, hemos tenido un inconveniente al procesar la transaccion (Cód. SKT0804).',
      );

      expect(result.errorCode).toEqual('ERROR_0001');
    });

    it('then should return the default error code if there is no match', async () => {
      const result = await service.findOrCreateError(randUuid());

      expect(result.errorCode).toEqual(TransferErrorCode.UNKNOWN_ERROR);
    });

    it('then should allow to search by the externalErrorCode when provided', async () => {
      const result = await service.findOrCreateError(
        'Rand error',
        null,
        'SHK_0001',
      );

      expect(result.errorCode).toEqual(errorWithExternalError.errorCode);
      expect(result.externalErrorCode).toEqual(
        errorWithExternalError.externalErrorCode,
      );
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/user/entities/user.entity.ts
import { Exclude } from 'class-transformer';
import { IsEmail, IsEnum } from 'class-validator';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';
import { MFAState } from 'src/common/enums/mfa-state.enum';
import { State } from 'src/common/enums/state.enum';
import { UserRole } from 'src/common/enums/user-role.enum';
import { SecretTransformer } from 'src/common/transformers/secret.transformer';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { Column, DeleteDateColumn, Entity, ManyToOne, Unique } from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';

@Entity({ name: 'user' })
@Unique(['merchantId', 'email', 'deletedAt'])
export class UserEntity extends BaseEntity {
  @IsEmail()
  @Column({ type: 'varchar', length: 128, nullable: false })
  email: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  name: string;

  @Exclude()
  @ExcludeFromLogs()
  @Column({ type: 'varchar', length: 256, nullable: false })
  password: string;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  passwordUpdatedAt: Date;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @IsEnum(UserRole)
  @Column('enum', { enum: UserRole, default: UserRole.USER, nullable: false })
  role: UserRole;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @ExcludeFromLogs()
  @Column({
    type: 'text',
    transformer: SecretTransformer.default(),
    nullable: true,
  })
  seed: string;

  @IsEnum(MFAState)
  @Column('enum', {
    enum: MFAState,
    default: MFAState.DISABLED,
    nullable: false,
  })
  mfaState: string;

  @Column({
    type: 'boolean',
    default: false,
    nullable: false,
  })
  mfa: boolean;

  @Exclude()
  @DeleteDateColumn()
  deletedAt?: Date;

  // Relationships

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.users, {
    eager: true,
    nullable: false,
  })
  merchant: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/user/user.service.ts
import {
  ConflictException,
  Injectable,
  Logger,
  NotFoundException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataService } from 'src/database/data.service';
import { Repository } from 'typeorm';
import { CreateUserDto } from 'src/api/v2/user/dto/create-user.dto';
import { UserEntity } from './entities/user.entity';
import { State } from 'src/common/enums/state.enum';
import { UpdateUserEntityDto } from './dto/update-user-entity.dto';

@Injectable()
export class UserService extends DataService<UserEntity>(UserEntity) {
  private readonly logger = new Logger(UserService.name);

  @InjectRepository(UserEntity) private userRepository: Repository<UserEntity>;

  async findAll(): Promise<UserEntity[]> {
    return await this.userRepository.find();
  }

  async isEmailInUse(email: string): Promise<boolean> {
    const user = await this.userRepository.findOne({ where: { email } });
    return !!user;
  }

  /**
   * @param {number} id
   * @param {State} [state]
   * @returns {Promise<UserEntity>} The user entity if found.
   * @throws {NotFoundException} Throws an exception if no user is found.
   */
  async findOne(
    id: number,
    state?: State,
    lastPasswordUpdate?: Date,
  ): Promise<UserEntity> {
    const user = await this.userRepository.findOne({
      where: {
        id,
        ...(state && { state }),
        ...(lastPasswordUpdate && { passwordUpdatedAt: lastPasswordUpdate }),
      },
    });
    if (!user) throw new NotFoundException(`User with id ${id} not found`);
    return user;
  }

  /**
   * @param {string} email
   * @returns {Promise<UserEntity>} The user entity if found.
   * @throws {NotFoundException} Throws an exception if no user is found.
   */
  async findOneByEmail(email: string): Promise<UserEntity> {
    const user = await this.userRepository.findOne({ where: { email } });
    if (user) return user;

    throw new NotFoundException(`User with email ${email} not found`);
  }

  public async create(createUserDto: CreateUserDto): Promise<UserEntity> {
    const existingUser = await this.userRepository.findOne({
      where: { email: createUserDto.email },
    });
    if (existingUser) {
      throw new ConflictException(
        `User with email ${createUserDto.email} already exists`,
      );
    }

    const userEntity = this.userRepository.create(createUserDto);
    return await this.userRepository.save(userEntity);
  }

  async update(
    id: number,
    updateUserDto: UpdateUserEntityDto,
  ): Promise<UserEntity> {
    const userEntity = await this.userRepository.preload({
      id: Number(id),
      ...updateUserDto,
    });
    if (!userEntity) {
      throw new NotFoundException(`User ${id} not found`);
    }
    return await this.userRepository.save(userEntity);
  }

  async remove(id: number): Promise<void> {
    const user = await this.findOne(id);
    if (!user) throw new NotFoundException('User not found');
    // TODO: Reminder of the need to refactor State enum
    // user.state = State.DELETED;
    await this.repository.softRemove(user);
  }

  async setPassword(userId: number, newHashedPassword: string): Promise<void> {
    await this.update(userId, {
      password: newHashedPassword,
      passwordUpdatedAt: new Date(),
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/user/user.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UserService } from './user.service';
import { UserEntity } from './entities/user.entity';

@Module({
  providers: [UserService],
  imports: [TypeOrmModule.forFeature([UserEntity])],
  exports: [TypeOrmModule, UserService],
})
export class UserModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/user/dto/update-user-entity.dto.ts
/**
 * This UpdateUserDto is specifically for the UserService's update method.
 */
import {
  IsEmail,
  IsString,
  IsOptional,
  IsEnum,
  IsBoolean,
} from 'class-validator';
import { MFAState } from 'src/common/enums/mfa-state.enum';

export class UpdateUserEntityDto {
  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  password?: string;

  @IsString()
  @IsOptional()
  seed?: string;

  @IsOptional()
  @IsEnum(MFAState)
  mfaState?: string;

  @IsOptional()
  @IsBoolean()
  mfa?: boolean;

  passwordUpdatedAt?: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/user/user.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { UserEntity } from './entities/user.entity';
import { UserService } from './user.service';

describe('given a UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const mockUserEntityRepo = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UserService,
        {
          provide: getRepositoryToken(UserEntity),
          useValue: mockUserEntityRepo,
        },
      ],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/apikey.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ApiKeyService } from './apikey.service';
import { ApiKeyEntity } from './entities/apikey.entity';

describe('given a ApiKeyService', () => {
  let service: ApiKeyService;

  beforeEach(async () => {
    const mockApiKeyEntity = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ApiKeyService,
        {
          provide: getRepositoryToken(ApiKeyEntity),
          useValue: mockApiKeyEntity,
        },
      ],
    }).compile();

    service = module.get<ApiKeyService>(ApiKeyService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/entities/apikey.entity.ts
import { State } from 'src/common/enums/state.enum';
import { IsEnum } from 'class-validator';
import { Column, Entity, ManyToOne } from 'typeorm';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { BaseEntity } from 'src/common/base.entity';
import { Exclude } from 'class-transformer';
import { UserRole } from 'src/common/enums/user-role.enum';
import { ExcludeFromLogs } from 'src/common/decorators/exclude-from-logs.decorator';

@Entity({ name: 'apikey' })
export class ApiKeyEntity extends BaseEntity {
  @Column({ type: 'varchar', length: 128, nullable: false })
  name: string;

  @Exclude()
  @ExcludeFromLogs()
  @Column({
    type: 'varchar',
    length: 64,
    nullable: false,
  })
  key: string;

  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @Column({ type: 'int', nullable: true })
  merchantId: number;

  @IsEnum(UserRole)
  @Column('enum', { enum: UserRole, default: UserRole.SUPER, nullable: false })
  role: UserRole;

  // Relationships

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.apiKeys, {
    nullable: true,
  })
  merchant: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/apikey.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { State } from 'src/common/enums/state.enum';
import { Repository } from 'typeorm';
import { CreateApiKeyDto } from 'src/models/apikey/dto/create-apikey.dto';
import { UpdateApiKeyDto } from 'src/models/apikey/dto/update-apikey.dto';
import { ApiKeyEntity } from './entities/apikey.entity';
import { DataService } from 'src/database/data.service';
import { nanoid } from 'nanoid';
import { CreatedApiKeyDto } from 'src/models/apikey/dto/created-apikey.dto';
import { plainToClass } from 'class-transformer';
import { hashApiKey } from 'src/utils/hash-apiKey.util';

@Injectable()
export class ApiKeyService extends DataService<ApiKeyEntity>(ApiKeyEntity) {
  @InjectRepository(ApiKeyEntity)
  private apiKeyRepository: Repository<ApiKeyEntity>;

  async findAll(): Promise<ApiKeyEntity[]> {
    return await this.apiKeyRepository.find();
  }

  async findOne(id: number): Promise<ApiKeyEntity> {
    const apiKey = await this.apiKeyRepository.findOne({ where: { id } });
    if (!apiKey) throw new NotFoundException(`ApiKey with id ${id} not found`);
    return apiKey;
  }

  async findOneByKey(key: string): Promise<ApiKeyEntity> {
    const hashedKey = hashApiKey(key);
    const apiKey = await this.apiKeyRepository.findOne({
      where: { state: State.ACTIVE, key: hashedKey },
      relations: ['merchant'],
    });

    if (!apiKey)
      throw new NotFoundException(`ApiKey with key ${key} not found`);

    return apiKey;
  }

  async create(createApiKeyDto: CreateApiKeyDto): Promise<CreatedApiKeyDto> {
    const nanoKey = nanoid();
    const hashedKey = hashApiKey(nanoKey);

    const apiKeyEntity = this.apiKeyRepository.create({
      ...createApiKeyDto,
      key: hashedKey,
    });

    const { id: savedApiKeyId } = await this.apiKeyRepository.save(
      apiKeyEntity,
    );
    const savedApiKey = await this.findOne(savedApiKeyId);
    const createdApiKeyDto = plainToClass(CreatedApiKeyDto, savedApiKey, {
      excludeExtraneousValues: true,
    });
    createdApiKeyDto.key = nanoKey;
    return createdApiKeyDto;
  }

  async update(
    id: number,
    updateApiKeyDto: UpdateApiKeyDto,
  ): Promise<ApiKeyEntity> {
    const apiKeyEntity = await this.apiKeyRepository.preload({
      id: Number(id),
      ...updateApiKeyDto,
    });
    if (!apiKeyEntity) {
      throw new NotFoundException(`ApiKey ${id} not found`);
    }

    return await this.apiKeyRepository.save(apiKeyEntity);
  }

  async remove(id: number): Promise<ApiKeyEntity> {
    const apiKey = await this.findOne(id);
    return this.apiKeyRepository.remove(apiKey);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/apikey.module.ts
import { ApiKeyService } from './apikey.service';
import { ApiKeyEntity } from './entities/apikey.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Module } from '@nestjs/common';

@Module({
  providers: [ApiKeyService],
  imports: [TypeOrmModule.forFeature([ApiKeyEntity])],
  exports: [TypeOrmModule, ApiKeyService],
})
export class ApiKeyModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/dto/update-apikey.dto.ts
import { State } from 'src/common/enums/state.enum';
import { IsEnum, IsOptional, IsString } from 'class-validator';

export class UpdateApiKeyDto {
  @IsString()
  @IsOptional()
  name: string;

  @IsEnum(State)
  @IsOptional()
  state?: State;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/dto/created-apikey.dto.ts
import { Expose } from 'class-transformer';

/** DTO for created ApiKey
 * Used to send back the created ApiKey. This is the only time the key is sent back to the client.
 */
export class CreatedApiKeyDto {
  @Expose()
  id: number;

  @Expose()
  name: string;

  @Expose()
  key: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/dto/get-apikey-dto.ts
import { QueryPaginatedDto } from 'src/common/dto/query-paginated.dto';

export class GetApiKeysQueryDto extends QueryPaginatedDto {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/apikey/dto/create-apikey.dto.ts
import { IsString, IsNotEmpty, IsNumber, IsOptional } from 'class-validator';

/** Create ApiKey DTO
 * Used to create a new ApiKey
 */
export class CreateApiKeyDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsOptional()
  @IsNumber()
  merchantId: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement-job/account-statement-job.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AwsModule } from 'src/services/aws/aws.module';
import { AccountModule } from '../account/account.module';
import { AccountStatementJobService } from './account-statement-job.service';
import { AccountStatementJobEntity } from './entities/account-statement-job.entity';

@Module({
  imports: [
    AwsModule,
    AccountModule,
    TypeOrmModule.forFeature([AccountStatementJobEntity]),
  ],
  providers: [AccountStatementJobService],
  exports: [AccountStatementJobService, TypeOrmModule],
})
export class AccountStatementJobModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement-job/entities/account-statement-job.entity.ts
import { IsEnum } from 'class-validator';
import { Column, Entity, ManyToOne, OneToMany } from 'typeorm';
import { BaseEntity } from 'src/common/base.entity';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { AccountStatementEntity } from 'src/models/account-statement/entities/account-statement.entity';
import { AccountEntity } from 'src/models/account/entities/account.entity';

@Entity({ name: 'account_statement_job' })
export class AccountStatementJobEntity extends BaseEntity {
  @Column({ type: 'datetime', precision: 6, nullable: true })
  endDate: Date;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  startDate: Date;

  @IsEnum(AccountStatementJobState)
  @Column('enum', {
    enum: AccountStatementJobState,
    nullable: false,
  })
  state: AccountStatementJobState;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  endedAt: Date;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  startedAt: Date;

  @Column({
    type: 'decimal',
    precision: 18,
    scale: 2,
    nullable: true,
  })
  balance: number;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  retrievedAt: Date;

  @Column({ type: 'int', nullable: true })
  totalRetrieved: number;

  @Column({ type: 'text', nullable: true })
  jobId: string;

  @Column({ type: 'int', nullable: true })
  bankAccountId: number;

  @Column({ type: 'int', nullable: true })
  accountId: number;

  // Relationships
  @ManyToOne(() => BankAccountEntity, (bankAccount) => bankAccount.id)
  bankAccount: BankAccountEntity;

  @ManyToOne(() => AccountEntity, (account) => account.id)
  account: AccountEntity;

  @OneToMany(
    () => AccountStatementEntity,
    (accountStatement) => accountStatement.accountStatementJob,
  )
  accountStatements: AccountStatementEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement-job/account-statement-job.service.ts
import {
  Inject,
  Injectable,
  Logger,
  ServiceUnavailableException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { FindOneOptions, In, Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import * as moment from 'moment-timezone';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { DataService } from 'src/database/data.service';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { DownloadAccountStatementDto } from 'src/api/v2/account/dto/download-account-statement.dto';
import { CreateAccountStatementJobDto } from 'src/api/v2/account-statement-job/dto/create-account-statement-job.dto';
import { PatchAccountStatementJobDto } from 'src/api/v2/account-statement-job/dto/patch-account-statement-job.dto';
import { AccountStatementJobEntity } from './entities/account-statement-job.entity';
import { AccountStatementScraperBanks } from 'src/common/enums/scraper-banks.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { AccountService } from '../account/account.service';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { endOfDateISOString, startOfDateISOString } from 'src/utils/date-util';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';

const JOB_NAME_PREFIX = 'bank-account-statements-job';
interface JobEnvironmentVariable {
  name: string;
  value: string;
}

@Injectable()
export class AccountStatementJobService extends DataService<AccountStatementJobEntity>(
  AccountStatementJobEntity,
) {
  @InjectRepository(AccountStatementJobEntity)
  private accountStatementJobRepository: Repository<AccountStatementJobEntity>;
  @Inject(AwsBatchService)
  private batchService: AwsBatchService;
  @Inject(AccountService)
  private accountService: AccountService;
  create(
    createAccountStatementJobDto: Partial<CreateAccountStatementJobDto>,
  ): Promise<AccountStatementJobEntity> {
    const accountStatementJob = this.accountStatementJobRepository.create(
      createAccountStatementJobDto,
    );
    return this.accountStatementJobRepository.save(accountStatementJob);
  }

  async update(
    id: number,
    patchAccountStatementJobDto: PatchAccountStatementJobDto,
  ): Promise<AccountStatementJobEntity> {
    const accountStatementJob =
      await this.accountStatementJobRepository.preload({
        id: Number(id),
        ...patchAccountStatementJobDto,
      });

    return this.accountStatementJobRepository.save(accountStatementJob);
  }

  async findOneByConditions(
    options: FindOneOptions<AccountStatementJobEntity>,
  ): Promise<AccountStatementJobEntity> {
    return this.repository.findOne(options);
  }

  async startScraper(accountId: number, params: DownloadAccountStatementDto) {
    const account = await this.accountService.findOneByConditions({
      where: { id: accountId },
      relations: ['providers'],
    });

    const provider = account?.providers.find((provider) =>
      provider.capabilities.includes(ProviderCapability.READ_TRANSFER),
    );

    if (!provider) {
      throw new UnprocessableEntityException(
        `Can't enqueue job, the account doesn't have any provider with the ${ProviderCapability.READ_TRANSFER} capability`,
      );
    }

    const { bankCode, countryCode } = provider.account;

    this.validTransferBankCode(bankCode);

    const { id: providerId } = provider;

    const env = process.env.NODE_ENV as Environment;

    const jobName = this.generateJobName({
      bankCode,
      accountId,
      providerId,
      env,
      startDate: params.startDate,
      endDate: params.endDate,
    });

    await this.validateAnyRunningJob(jobName, accountId, bankCode);

    // Convert to the account country timezone
    const newParams = { ...params };
    newParams.startDate = startOfDateISOString(params.startDate, countryCode);
    newParams.endDate = endOfDateISOString(params.endDate, countryCode);

    const accountStatementJob = await this.generateCreatedJobRecord(
      accountId,
      newParams,
    );

    const data = this.buildJobData({
      bankCode,
      startDate: accountStatementJob.startDate.toISOString(),
      endDate: accountStatementJob.endDate.toISOString(),
      accountStatementJobId: accountStatementJob.id,
      accountId,
      providerId,
      env,
    });

    return await this.enqueueJob(jobName, accountStatementJob.id, data);
  }

  async getExecutionFromAccount(
    accountId: number,
  ): Promise<AccountStatementJobEntity> {
    const executingStates = [
      AccountStatementJobState.CREATED,
      AccountStatementJobState.STARTED,
    ];
    const accountStatementJob =
      await this.accountStatementJobRepository.findOne({
        where: {
          accountId,
          state: In(executingStates),
        },
      });

    return accountStatementJob;
  }

  async enqueueJob(
    jobName: string,
    accountStatementJobId: number,
    environmentVariables: JobEnvironmentVariable[],
  ) {
    try {
      const result = await this.batchService.submitBatchJob({
        job: AwsBatchJob.accountStatements,
        jobName,
        environmentVariables,
      });

      return result;
    } catch (error) {
      await this.finishJobRecordAsError(accountStatementJobId);

      throw new ServiceUnavailableException('Error while submitting batch job');
    }
  }
  private removeDateRangeFromJobName(jobName: string): string {
    const dateBlockLength = 22; // -YYYY-MM-DD-YYYY-MM-DD: 22 characteres long
    const modifiedJobName = jobName.slice(0, -dateBlockLength);

    return modifiedJobName;
  }

  private cleanJobName(jobName: string): string {
    return this.removeDateRangeFromJobName(jobName);
  }
  private generateJobName(args: {
    bankCode: string;
    accountId: number;
    providerId: number;
    env: Environment;
    startDate: string;
    endDate: string;
  }) {
    const { bankCode, accountId, providerId, env, startDate, endDate } = args;
    const formattedBankCode = bankCode.replace(/_/g, '-');
    const jobName = `${JOB_NAME_PREFIX}-${formattedBankCode}-${providerId}-${accountId}-${env}-${startDate}-${endDate}`;
    return jobName;
  }

  private async validateAnyRunningJob(
    jobName: string,
    accountId: number,
    bankCode: string,
  ) {
    const executingJob = await this.getExecutionFromAccount(accountId);
    const existingJobExecution =
      await this.batchService.findUnfinishedJobByName(
        this.cleanJobName(jobName),
        AwsBatchJob.accountStatements,
      );
    if (existingJobExecution || executingJob) {
      Logger.debug(
        `There is an existing account statement job execution:
         ${
           !!executingJob &&
           `- Found unfinished database job with Id: ${executingJob.id}`
         }
         ${
           !!existingJobExecution &&
           `- Found unfinished AWS job with jobName ${existingJobExecution.jobName}`
         } `,
      );

      throw new UnprocessableEntityException(
        `There is an execution in process for the account ${accountId} - ${bankCode}.`,
      );
    }
  }

  private validTransferBankCode(bankCode: string) {
    if (!AccountStatementScraperBanks[bankCode]) {
      throw new UnprocessableEntityException(
        `Can't start account statement job, unsupported bankCode '${bankCode}'`,
      );
    }
  }

  private async generateCreatedJobRecord(
    accountId: number,
    params: DownloadAccountStatementDto,
  ) {
    const { startDate, endDate } = params;
    const createdAccountStatementJob = await this.create({
      endDate: endDate ? moment.utc(endDate).toDate() : null,
      startDate: startDate ? moment.utc(startDate).toDate() : null,
      accountId,
      state: AccountStatementJobState.CREATED,
    });
    return createdAccountStatementJob;
  }
  private async finishJobRecordAsError(id: number) {
    await this.update(id, {
      state: AccountStatementJobState.ERROR,
    });
  }

  private buildJobData(dataParams: {
    bankCode: string;
    startDate: string;
    endDate: string;
    accountStatementJobId: number;
    accountId: number;
    providerId: number;
    env: Environment;
  }) {
    const {
      bankCode,
      accountId,
      providerId,
      accountStatementJobId,
      startDate,
      endDate,
      env,
    } = dataParams;

    const environmentVariables: JobEnvironmentVariable[] = [
      { name: 'PARAMS_BANK_CODE', value: bankCode },
      { name: 'PARAMS_START_DATE', value: startDate ?? '' },
      { name: 'PARAMS_END_DATE', value: endDate ?? '' },
      {
        name: 'ACCOUNT_STATEMENT_JOB_ID',
        value: accountStatementJobId.toString(),
      },
      { name: 'BANK_CODE', value: bankCode },
      { name: 'ACCOUNT_ID', value: accountId.toString() },
      { name: 'PROVIDER_ID', value: providerId.toString() },
      { name: 'PAYOUTS_API_VERSION', value: 'v2' },
      { name: 'NODE_ENV', value: env },
    ];
    return environmentVariables;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/account-statement-job/account-statement-job.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { Repository } from 'typeorm';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { AccountStatementJobService } from './account-statement-job.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { AccountStatementJobEntity } from './entities/account-statement-job.entity';
import { AccountService } from '../account/account.service';
import { ProviderService } from '../provider/provider.service';

describe('given a AccountStatementJobService', () => {
  let service: AccountStatementJobService;

  beforeEach(async () => {
    const mockAccountStatementJobRepository: Partial<
      Repository<AccountStatementJobEntity>
    > = {};
    const mockBatchService = {};
    const mockAccountService = {};
    const mockProviderService = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AccountStatementJobService,
        {
          provide: getRepositoryToken(AccountStatementJobEntity),
          useValue: mockAccountStatementJobRepository,
        },
        {
          provide: AccountService,
          useValue: mockAccountService,
        },
        {
          provide: ProviderService,
          useValue: mockProviderService,
        },
        { provide: AwsBatchService, useValue: mockBatchService },
      ],
    }).compile();

    service = module.get<AccountStatementJobService>(
      AccountStatementJobService,
    );
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/audit-log/audit-log.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { AuditLogService } from './audit-log.service';
import { AuditLogEntity } from './entities/audit-log.entity';
import { Repository } from 'typeorm';
import { getRepositoryToken } from '@nestjs/typeorm';

describe('AuditLogService', () => {
  let service: AuditLogService;

  beforeEach(async () => {
    const mockAuditLogRepository: Partial<Repository<AuditLogEntity>> = {};
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuditLogService,
        {
          provide: getRepositoryToken(AuditLogEntity),
          useValue: mockAuditLogRepository,
        },
      ],
    }).compile();

    service = module.get<AuditLogService>(AuditLogService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/audit-log/audit-log.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { AuditLogEntity } from './entities/audit-log.entity';
import { Repository } from 'typeorm';
import { CreateAuditLogDto } from 'src/api/v2/audit-log/dto/create-audit-log.dto';
import { DataService } from 'src/database/data.service';
import { validate } from 'class-validator';

@Injectable()
export class AuditLogService extends DataService<AuditLogEntity>(
  AuditLogEntity,
) {
  @InjectRepository(AuditLogEntity)
  private auditLogRepository: Repository<AuditLogEntity>;

  async create(createAuditLogDto: CreateAuditLogDto): Promise<AuditLogEntity> {
    const errors = await validate(createAuditLogDto);

    if (errors.length > 0) throw errors;

    const auditLog = this.auditLogRepository.create(createAuditLogDto);

    return this.auditLogRepository.save(auditLog);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/audit-log/entities/audit-log.entity.ts
import { BaseEntity } from 'src/common/base.entity';
import { AuditLogEvent } from 'src/common/enums/audit-log-event.enum';
import { Column, Entity, Index } from 'typeorm';

@Entity('audit_log')
@Index(['authorId', 'authorType'])
@Index(['entityType', 'entityId'])
export class AuditLogEntity extends BaseEntity {
  @Column({ type: 'text', nullable: true })
  context?: string;

  @Column({ type: 'int', nullable: true })
  authorId?: number;

  @Column({ length: 64, nullable: true })
  authorType?: string;

  @Column({ type: 'enum', enum: AuditLogEvent })
  event: AuditLogEvent;

  @Column({ length: 64 })
  entityType: string;

  @Column({ length: 128 })
  entityId: string;

  @Column({ type: 'longtext', nullable: true })
  entityAfter: string;

  @Column({ type: 'longtext', nullable: true })
  entityBefore: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/audit-log/audit-log.module.ts
import { Module } from '@nestjs/common';
import { AuditLogService } from './audit-log.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuditLogEntity } from './entities/audit-log.entity';

@Module({
  providers: [AuditLogService],
  imports: [TypeOrmModule.forFeature([AuditLogEntity])],
  exports: [AuditLogService],
})
export class AuditLogModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank/entities/bank.entity.ts
import { IsEnum } from 'class-validator';
import { Column, Entity, OneToMany } from 'typeorm';

import { BaseEntity } from 'src/common/base.entity';
import { State } from 'src/common/enums/state.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';
import { ApiHideProperty } from '@nestjs/swagger';
import { AccountEntity } from 'src/models/account/entities/account.entity';

@Entity({ name: 'bank' })
export class BankEntity extends BaseEntity {
  @IsEnum(State)
  @Column('enum', { enum: State, default: State.ACTIVE, nullable: false })
  state: State;

  @Column({ type: 'varchar', length: 128, nullable: false })
  name: string;

  @Column({ type: 'varchar', length: 64, unique: true, nullable: false })
  code: string;

  // Relationships

  @ApiHideProperty()
  @OneToMany(() => PayoutEntity, (payout) => payout.destinationBank)
  payouts: PayoutEntity[];

  @ApiHideProperty()
  @OneToMany(() => TransferEntity, (transfer) => transfer.destinationBank)
  incomingTransfers: TransferEntity[];

  @ApiHideProperty()
  @OneToMany(() => TransferEntity, (transfer) => transfer.originBank)
  outgoingTransfers: TransferEntity[];

  @ApiHideProperty()
  @OneToMany(() => BankAccessEntity, (bankAccess) => bankAccess.bank)
  bankAccesses: BankAccessEntity[];

  @ApiHideProperty()
  @OneToMany(() => BankAccessEntity, (bankAccount) => bankAccount.bank)
  bankAccounts: BankAccountEntity[];

  @ApiHideProperty()
  @OneToMany(() => AccountEntity, (account) => account.bank)
  accounts: AccountEntity[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank/bank.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { BankService } from './bank.service';
import { BankEntity } from './entities/bank.entity';
describe.skip('given a BankService', () => {
  let service: BankService;

  beforeEach(async () => {
    const mockBankRepository: Partial<Repository<BankEntity>> = {
      findOne: async () => {
        return Promise.resolve({} as BankEntity);
      },
    };
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        BankService,
        {
          provide: getRepositoryToken(BankEntity),
          useValue: mockBankRepository,
        },
      ],
    }).compile();

    service = module.get<BankService>(BankService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank/bank.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { DataService } from 'src/database/data.service';
import { FindOneOptions, Repository } from 'typeorm';
import { CreateBankDto } from 'src/api/v2/bank/dto/create-bank.dto';
import { UpdateBankDto } from 'src/api/v2/bank/dto/update-bank.dto';
import { BankEntity } from './entities/bank.entity';
import { InjectRepository } from '@nestjs/typeorm';

@Injectable()
export class BankService extends DataService<BankEntity>(BankEntity) {
  @InjectRepository(BankEntity) private bankRepository: Repository<BankEntity>;

  findAll(): Promise<BankEntity[]> {
    return this.bankRepository.find();
  }

  async findOne(id: number): Promise<BankEntity> {
    //const option: FindOneOptions = { where: {id??id} };
    const bank = await this.bankRepository.findOne({ where: { id: id } });
    if (!bank) throw new NotFoundException(`Bank ${id} not found`);
    return bank;
  }

  async findOneByConditions(options: FindOneOptions): Promise<BankEntity> {
    const bank = await this.bankRepository.findOne(options);
    if (!bank) throw new NotFoundException(`Bank not found`);
    return bank;
  }

  create(createBankDto: CreateBankDto): Promise<BankEntity> {
    const bank = this.bankRepository.create(createBankDto);
    return this.bankRepository.save(bank);
  }

  async update(id: number, updateBankDto: UpdateBankDto): Promise<BankEntity> {
    const bank = await this.bankRepository.preload({
      id: Number(id),
      ...updateBankDto,
    });
    if (!bank) {
      throw new NotFoundException(`Bank ${id} not found`);
    }
    return this.bankRepository.save(bank);
  }

  async remove(id: number): Promise<BankEntity> {
    const bank = await this.findOne(id);
    return this.bankRepository.remove(bank);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/bank/bank.module.ts
import { Module } from '@nestjs/common';
import { BankService } from './bank.service';
import { TypeOrmModule } from '@nestjs/typeorm';
import { BankEntity } from './entities/bank.entity';

@Module({
  providers: [BankService],
  imports: [TypeOrmModule.forFeature([BankEntity])],
  exports: [TypeOrmModule, BankService],
})
export class BankModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/deposit/entities/deposit.entity.ts
import { IsEnum } from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { DepositState } from 'src/common/enums/deposit-state.enum';
import { ColumnNumericTransformer } from 'src/common/transformers/decimal.transformer';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { Column, Entity, ManyToOne, Unique } from 'typeorm';
import { BaseEntity } from '../../../common/base.entity';

@Entity({ name: 'deposit' })
@Unique(['merchantId', 'trackingCode'])
export class DepositEntity extends BaseEntity {
  @IsEnum(DepositState)
  @Column('enum', {
    enum: DepositState,
    default: DepositState.CREATED,
    nullable: false,
  })
  state: DepositState;

  @Column({
    type: 'decimal',
    precision: 18,
    scale: 2,
    nullable: false,
    default: 0,
    transformer: new ColumnNumericTransformer(),
  })
  amount: number;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @Column({ type: 'text' })
  concept: string;

  @Column({ type: 'varchar', length: 128 })
  trackingCode: string;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  // Relationships

  @ManyToOne(() => MerchantEntity, (merchant) => merchant.deposits)
  merchant: MerchantEntity;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/transfer.statemachine.ts
import { TransferState } from 'src/common/enums/transfer-state.enum';
import BaseStateMachine from 'src/common/state-machine/base-state-machine';
import { TransferEntity } from './entities/transfer.entity';
import TransferTransitions from './transfer.transitions';

export default class TransferStateMachine extends BaseStateMachine<
  TransferEntity,
  TransferState
> {
  constructor() {
    super(TransferTransitions);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/transfer.module.ts
import { Module } from '@nestjs/common';
import { TransferService } from './transfer.service';
import { TransferEntity } from './entities/transfer.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TransferAuthModule } from 'src/services/transfer-auth/transfer-auth.module';
import { TransferErrorModule } from '../transfer-error/transfer-error.module';
import { FeatureFlagModule } from 'src/services/feature-flag/feature-flag.module';
import { ProviderEntity } from '../provider/entities/provider.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([TransferEntity, ProviderEntity]),
    TransferAuthModule,
    TransferErrorModule,
    FeatureFlagModule,
  ],
  providers: [TransferService],
  exports: [TypeOrmModule, TransferService],
})
export class TransferModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/entities/transfer.subscriber.ts
import { ConflictException } from '@nestjs/common';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { Transition } from 'src/common/state-machine/state-machine.interfaces';

import {
  EntitySubscriberInterface,
  EventSubscriber,
  UpdateEvent,
} from 'typeorm';
import TransferStateMachine from '../transfer.statemachine';
import { TransferTransition } from '../transfer.transitions';
import { TransferEntity } from './transfer.entity';

@EventSubscriber()
export class TransferSubscriber
  implements EntitySubscriberInterface<TransferEntity>
{
  listenTo() {
    return TransferEntity;
  }

  beforeUpdate(event: UpdateEvent<TransferEntity>) {
    const transition = checkTransition(event);
    setDates(transition, event);

    return Promise.resolve(event);
  }
}
function checkTransition(event: UpdateEvent<TransferEntity>) {
  const stateMachine = new TransferStateMachine();
  const stateGotUpdated = event.updatedColumns.find(
    (column) => column.propertyName,
    TransferEntity.prototype.state,
  );
  if (!stateGotUpdated) return;

  const oldEntity = event?.databaseEntity;
  const newEntity = event?.entity;
  const transition: Transition<TransferState> =
    stateMachine.findTransitionForEntity(oldEntity, newEntity.state);

  if (!transition && oldEntity.state !== newEntity.state) {
    throw new ConflictException(
      `Can't transition from ${oldEntity.state} to ${newEntity.state}`,
    );
  }
  return transition;
}

function setDates(
  transition: Transition<TransferState>,
  event: UpdateEvent<TransferEntity>,
) {
  if (transition)
    if (transition.name === TransferTransition.PROCESS) {
      event.entity.startedAt = new Date();
    } else if (transition.name === TransferTransition.COMPLETE) {
      event.entity.finishedAt = new Date();
    } else if (transition.name === TransferTransition.FAIL) {
      event.entity.finishedAt = new Date();
    } else if (transition.name === TransferTransition.CANCEL) {
      event.entity.finishedAt = new Date();
    }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/entities/transfer.subscriber.spec.ts
import { BankCode } from 'src/common/enums/bank-code.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { UpdateEvent } from 'typeorm';
import { ColumnMetadata } from 'typeorm/metadata/ColumnMetadata';
import { TransferEntity } from './transfer.entity';
import { TransferSubscriber } from './transfer.subscriber';

describe('given a TransferSubscriber', () => {
  let subscriber: TransferSubscriber;
  beforeAll(() => {
    subscriber = new TransferSubscriber();
  });
  describe('when beforeUpdate is called', () => {
    it('then return a object with a entity Key with not undefinied properties, TransferState.FAILED transition', async () => {
      const olderTransfer = new TransferEntity();
      olderTransfer.state = TransferState.PROCESSING;
      const transfer = new TransferEntity();
      transfer.message =
        'Estimado cliente, la cuenta del destinatario ingresada es inválida.';
      transfer.state = TransferState.FAILED;
      transfer.destinationBankCode = BankCode.BANCO_CONSORCIO;
      const columnMetadata: Partial<ColumnMetadata> = {
        propertyName: 'state',
      };
      const event: Partial<UpdateEvent<TransferEntity>> = {
        updatedColumns: [columnMetadata as ColumnMetadata],
        entity: transfer,
        databaseEntity: olderTransfer,
      };
      const result = await subscriber.beforeUpdate(
        event as UpdateEvent<TransferEntity>,
      );
      expect(result).toStrictEqual(expect.any(Object));
      expect(result.entity.finishedAt).not.toBe(undefined);
    });
    it('then return a object with a entity Key with not undefinied properties, TransferState.CANCELED transition', async () => {
      const olderTransfer = new TransferEntity();
      olderTransfer.state = TransferState.PROCESSING;
      const transfer = new TransferEntity();
      transfer.message =
        'Estimado cliente, la cuenta del destinatario ingresada es inválida.';
      transfer.state = TransferState.CANCELED;
      const columnMetadata: Partial<ColumnMetadata> = {
        propertyName: 'state',
      };
      const event: Partial<UpdateEvent<TransferEntity>> = {
        updatedColumns: [columnMetadata as ColumnMetadata],
        entity: transfer,
        databaseEntity: olderTransfer,
      };
      const result = await subscriber.beforeUpdate(
        event as UpdateEvent<TransferEntity>,
      );
      expect(result).toStrictEqual(expect.any(Object));
      expect(result.entity.finishedAt).not.toBe(undefined);
    });
    it('then return a object with a entity Key with undefinied properties, TransferState.FAILED transition', async () => {
      const olderTransfer = new TransferEntity();
      olderTransfer.state = TransferState.PROCESSING;
      const transfer = new TransferEntity();
      transfer.message =
        'Estimado cliente, su transferencia no se ha podido realizar debido a que el banco de destino nos informa que no estar disponible';
      //transfer.state = TransferState.FAILED;
      const columnMetadata: Partial<ColumnMetadata> = {
        //propertyName: 'state',
      };
      const event: Partial<UpdateEvent<TransferEntity>> = {
        updatedColumns: [columnMetadata as ColumnMetadata],
        entity: transfer,
        databaseEntity: olderTransfer,
      };
      const result = await subscriber.beforeUpdate(
        event as UpdateEvent<TransferEntity>,
      );
      expect(result).toStrictEqual(expect.any(Object));
      expect(result.entity.finishedAt).toBe(undefined);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/entities/transfer.entity.ts
import { BeforeInsert, Column, Entity, JoinColumn, ManyToOne } from 'typeorm';
import { Exclude } from 'class-transformer';
import { IsEnum } from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferMode } from 'src/common/enums/transfer-mode.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { BankAccessEntity } from 'src/models/bank-access/entities/bank-access.entity';
import { BankAccountEntity } from 'src/models/bank-account/entities/bank-account.entity';
import { BankEntity } from 'src/models/bank/entities/bank.entity';
import { MerchantEntity } from 'src/models/merchant/entities/merchant.entity';
import { PayoutEntity } from 'src/models/payout/entities/payout.entity';
import { TransferErrorCode } from 'src/models/transfer-error/error.definition.type';
import { nullIfEmpty } from 'src/utils/string-methods.util';
import { BaseEntity } from '../../../common/base.entity';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { EntityVersion } from 'src/common/enums/entity-version.enum';

interface TransferMetadata extends Record<string, string> {
  providerErrorCode?: string;
}

@Entity({ name: 'transfer' })
export class TransferEntity extends BaseEntity {
  @IsEnum(TransferState)
  @Column('enum', {
    enum: TransferState,
    default: TransferState.PENDING,
    nullable: false,
  })
  state: TransferState;

  @Column({
    type: 'decimal',
    precision: 18,
    scale: 2,
    nullable: false,
    default: 0,
  })
  amount: number;

  @IsEnum(Currency)
  @Column('enum', { enum: Currency, default: Currency.CHILE, nullable: false })
  currency: Currency;

  @IsEnum(TransferMode)
  @Column('enum', {
    enum: TransferMode,
    default: TransferMode.SINGLE,
    nullable: false,
  })
  mode: TransferMode;

  @Column({ type: 'text' })
  concept: string;

  @Column({ type: 'varchar', length: 128 })
  trackingCode: string;

  @Column({ type: 'varchar', nullable: true })
  destinationEmail: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationName: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  destinationHolderId: string;

  @Column({ type: 'varchar', length: 128, nullable: false })
  destinationAccount: string;

  @Column({ type: 'varchar', length: 64, nullable: false })
  destinationBankCode: string;

  @Column({ type: 'int', nullable: false })
  merchantId: number;

  @Column({ type: 'int', nullable: true })
  payoutId: number;

  @Column({ type: 'varchar', length: 64, nullable: true })
  originBankCode: string;

  @Column({ type: 'int', nullable: true })
  originBankAccessId: number;

  @Column({ type: 'int', nullable: true })
  originBankAccountId: number;

  @Column({ type: 'text', nullable: true })
  message: string;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  startedAt: Date;

  @Column({ type: 'datetime', precision: 6, nullable: true })
  finishedAt: Date;

  @Column({ type: 'simple-json', nullable: true })
  metadata?: TransferMetadata;

  @Column({ type: 'boolean', default: false })
  autoRetried: boolean;

  @Column({ type: 'varchar', length: 128, nullable: true })
  externalId?: string;

  @Column({ type: 'text', nullable: true })
  destinationPhone: string;

  @IsEnum(TransferErrorCode)
  @Column('enum', {
    enum: TransferErrorCode,
    default: null,
    nullable: true,
  })
  errorCode: TransferErrorCode;

  @Column({ type: 'int', nullable: true })
  providerId?: number;

  @Column({
    type: 'enum',
    enum: EntityVersion,
    nullable: false,
    default: EntityVersion.v2,
  })
  version: EntityVersion;

  // Relationships

  @Exclude()
  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.incomingTransfers)
  destinationBank: BankEntity;

  @ManyToOne(() => ProviderEntity, (provider) => provider.transfers)
  provider: ProviderEntity;

  @Exclude()
  @JoinColumn({ referencedColumnName: 'code' })
  @ManyToOne(() => BankEntity, (bank) => bank.outgoingTransfers, {
    nullable: true,
  })
  originBank: BankEntity;

  @Exclude()
  @ManyToOne(() => MerchantEntity, (merchant) => merchant.transfers)
  merchant: MerchantEntity;

  @Exclude()
  @ManyToOne(() => PayoutEntity, (payout) => payout.transfers, {
    nullable: true,
  })
  payout: PayoutEntity;

  @ManyToOne(() => BankAccessEntity, (bankAccess) => bankAccess.transfers, {
    nullable: true,
  })
  originBankAccess: BankAccessEntity;

  @Exclude()
  @ManyToOne(() => BankAccountEntity, (bankAccount) => bankAccount.transfers, {
    nullable: true,
  })
  originBankAccount: BankAccountEntity;

  // Methods

  public get assigned(): boolean {
    return !this.assignable;
  }

  public get assignable(): boolean {
    const isPending = this.state === TransferState.PENDING;
    const withoutProvider = this.providerId == null;
    return isPending && withoutProvider;
  }

  // TODO: This "cancelable" should be unified in a unique validate transfer transition
  public get cancelable(): boolean {
    const states = [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
    ];
    return states.includes(this.state);
  }

  public get canceledOrFailed(): boolean {
    const states = [TransferState.CANCELED, TransferState.FAILED];

    return states.includes(this.state);
  }

  public get completed(): boolean {
    return this.state === TransferState.COMPLETED;
  }

  // TODO: This "completable" should be unified in a unique validate transfer transition
  public get completable(): boolean {
    const completableStates = [
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
    ];
    return completableStates.includes(this.state);
  }

  // Subscribers
  // Subscribers
  @BeforeInsert()
  sanitizeDestinationEmail() {
    this.destinationEmail = nullIfEmpty(this.destinationEmail);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/transfer.transitions.ts
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { Transition } from 'src/common/state-machine/state-machine.interfaces';

export enum TransferTransition {
  ASSIGN = 'assign',
  PROCESS = 'process',
  COMPLETE = 'complete',
  FAIL = 'fail',
  CANCEL = 'cancel',
}

const TransferTransitions: Transition<TransferState>[] = [
  {
    name: TransferTransition.ASSIGN,
    from: [TransferState.PENDING],
    to: TransferState.ASSIGNED,
  },
  {
    name: TransferTransition.PROCESS,
    from: [TransferState.ASSIGNED],
    to: TransferState.PROCESSING,
  },
  {
    name: TransferTransition.COMPLETE,
    from: [TransferState.PROCESSING, TransferState.FAILED],
    to: TransferState.COMPLETED,
  },
  {
    name: TransferTransition.FAIL,
    from: [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
    ],
    to: TransferState.FAILED,
  },
  {
    name: TransferTransition.CANCEL,
    from: [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
    ],
    to: TransferState.CANCELED,
  },
];

export default TransferTransitions;


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/transfer.service.ts
import { plainToInstance, plainToClass } from 'class-transformer';
import { merge } from 'lodash';
import {
  EntityManager,
  FindManyOptions,
  FindOneOptions,
  In,
  Repository,
} from 'typeorm';
import {
  Inject,
  Injectable,
  Logger,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';

import { UpdateTransferDto } from './dto/update-transfer.dto';
import { TransferEntity } from './entities/transfer.entity';
import TransferStateMachine from './transfer.statemachine';
import { TransferErrorService } from '../transfer-error/transfer-error.service';
import { PayoutTransferDto } from '../payout/dto/create-transfer.dto';
import { PayoutEntity } from '../payout/entities/payout.entity';
import { ProviderEntity } from '../provider/entities/provider.entity';
import { DataService } from 'src/database/data.service';
import { EntityVersion } from 'src/common/enums/entity-version.enum';
import { State } from 'src/common/enums/state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferEvent } from 'src/common/enums/transfer-event.enum';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { FEATURE_FLAG } from 'src/common/enums/feature-flag.enum';
import { LockMode } from 'src/common/enums/locks-mode.enum';
import { waitFor } from 'src/utils/request.util';

@Injectable()
export class TransferService extends DataService<TransferEntity>(
  TransferEntity,
) {
  private stateMachine: TransferStateMachine = new TransferStateMachine();
  private readonly logger = new Logger('TransferService');

  @InjectRepository(TransferEntity)
  private transferRepository: Repository<TransferEntity>;
  @InjectRepository(ProviderEntity)
  private providerRepository: Repository<ProviderEntity>;
  @Inject(EventEmitter2)
  private eventEmitter: EventEmitter2;
  @Inject(FeatureFlagService)
  private featureFlagService: FeatureFlagService;
  @Inject(TransferErrorService)
  private transferErrorService: TransferErrorService;

  findAll(
    options: FindManyOptions<TransferEntity> = {},
    mergeOptions = true,
  ): Promise<TransferEntity[]> {
    const defaultOptions: FindManyOptions<TransferEntity> = {
      where: {
        merchant: { state: State.ACTIVE },
        originBankAccess: { state: State.ACTIVE },
        originBankAccount: { state: State.ACTIVE },
        originBank: { state: State.ACTIVE },
        destinationBank: { state: State.ACTIVE },
      },
      relations: [
        'merchant',
        'originBankAccess',
        'originBankAccount',
        'originBank',
        'destinationBank',
      ],
    };

    if (mergeOptions) {
      const filters = merge({}, options, defaultOptions);
      return this.transferRepository.find(filters);
    }

    return this.transferRepository.find(options);
  }

  async findOneOrFail(id: number): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne({ where: { id } });
    if (!transfer) throw new NotFoundException(`Transfer ${id} not found`);
    return transfer;
  }

  async findOneByConditions(
    options: FindOneOptions<TransferEntity>,
  ): Promise<TransferEntity> {
    const transfer = await this.transferRepository.findOne(options);
    if (!transfer)
      throw new NotFoundException(
        'Transfer not found for the provided conditions',
      );
    return transfer;
  }

  async findManyByConditions(
    options: FindManyOptions<TransferEntity>,
  ): Promise<TransferEntity[]> {
    const transfers = await this.transferRepository.find(options);
    return transfers;
  }

  private async findOneWithLock(
    id: number,
    manager: EntityManager,
    states: TransferState[] = [],
  ): Promise<TransferEntity> {
    const transfer = await manager.findOne(TransferEntity, {
      where: { id, state: In(states) },
      lock: { mode: LockMode.PESSIMISTIC_WRITE },
    });
    if (!transfer) throw new NotFoundException(`Transfer ${id} not found`);
    return transfer;
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready. If you want to reflect a state change, please use the respective payout new service methods.
   */
  transitToState(transfer: TransferEntity, state: TransferState) {
    try {
      const updatedTransfer = this.stateMachine.transitTo(transfer, state);
      return updatedTransfer;
    } catch (error) {
      throw new UnprocessableEntityException(error.message);
    }
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready. If you want to reflect a state change, please use the respective payout new service methods.
   */
  async updateState(id: number, state: TransferState) {
    const transfer = await this.transferRepository.findOne({ where: { id } });

    this.transitToState(transfer, state);

    return this.transferRepository.save(transfer);
  }

  /**
   * @deprecated will be deprecated when EPIC PYT-797 is ready. If you want to update a specific attribute change, please use the respective payout new service methods.
   */
  async update(
    id: number,
    updateTransferDto: UpdateTransferDto,
  ): Promise<TransferEntity> {
    const { state, message, metadata, externalId, providerId } =
      updateTransferDto;

    const transfer = await this.transferRepository.findOne({
      where: { id },
    });

    if (!transfer) {
      throw new NotFoundException(`Transfer ${id} not found`);
    }

    const olderState = transfer.state;

    if (transfer.version !== EntityVersion.v2) {
      throw new UnprocessableEntityException('Transfer version must be v2');
    }

    const stateChanged = state !== olderState;

    if (stateChanged) this.transitToState(transfer as TransferEntity, state);

    if (message) transfer.message = message;

    if (metadata) {
      transfer.metadata = {
        ...transfer.metadata,
        ...metadata,
      };
    }

    if (providerId && !transfer.providerId) {
      transfer.providerId = providerId;
    }

    if (externalId && !transfer.externalId) {
      transfer.externalId = externalId;
    }

    this.logger.debug(`Transfer current message: '${transfer.message}'`);
    this.logger.debug(`Transfer current state: '${transfer.state}'`);

    if (transfer.state === TransferState.FAILED) {
      // TODO: remove debug logs
      this.logger.debug(
        `Transfer failed. Getting Transfer Error for message '${message}'`,
      );

      const providerErrorCode = transfer.metadata?.providerErrorCode;

      const provider = await this.providerRepository.findOne({
        where: { id: transfer.providerId },
      });

      const transferError = await this.transferErrorService.findOrCreateError(
        transfer.message,
        provider?.providerType,
        providerErrorCode,
      );

      transfer.errorCode = transferError?.errorCode;
    }

    // Remove provider object to avoid wrong update
    const updatedTransfer = await this.transferRepository.save(transfer);

    if (stateChanged) {
      this.eventEmitter.emit(TransferEvent.UPDATED_STATE, updatedTransfer);
    }

    this.eventEmitter.emit(TransferEvent.UPDATED, updatedTransfer);
    return updatedTransfer;
  }

  // NEW METHODS
  private async secureUpdateTransferState(
    id: number,
    updatedFields: Partial<TransferEntity>,
    fromStates: TransferState[],
    operation: string,
    manager: EntityManager,
  ): Promise<TransferEntity> {
    if (process.env.NODE_ENV !== 'test') {
      // TODO: Remove this line
      await waitFor(5000);
    }

    const transfer = await this.findOneWithLock(id, manager, fromStates);

    const mergeMetadata = {
      ...transfer.metadata,
      ...updatedFields.metadata,
    };

    updatedFields = {
      ...updatedFields,
      id: transfer.id,
      metadata: mergeMetadata,
    };

    if (!fromStates.includes(transfer.state)) {
      throw new Error(`Transfer ${operation} failed`);
    }
    const merged = { ...transfer, ...updatedFields };
    const transferFromDto = plainToInstance(TransferEntity, merged);
    console.log('transferFromDto', transferFromDto);
    await manager.save(TransferEntity, transferFromDto);
    // await this.dataSource.transaction('SERIALIZABLE', async (manager) => {
    // });
    // const queryRunner = this.dataSource.createQueryRunner();
    // await queryRunner.startTransaction();
    // const manager = queryRunner.manager;
    // try {
    //   await queryRunner.commitTransaction();
    // } catch (error) {
    //   if (queryRunner.isTransactionActive) {
    //     await queryRunner.rollbackTransaction();
    //   }

    //   throw error;
    // } finally {
    //   await queryRunner.release();
    //   //await destroyConnection();
    // }

    const updatedTransfer = await this.transferRepository.findOne({
      where: { id },
    });
    console.log('updatedTransfer', updatedTransfer);
    return updatedTransfer;
  }

  async assignTransfer(
    transfer: TransferEntity,
    providerId: ProviderEntity['id'],
    manager: EntityManager,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    const updatedFields: Partial<TransferEntity> = {
      providerId,
      state: TransferState.ASSIGNED,
      message: 'Transferencia correctamente asignada',
    };

    const mergeMetadata = {
      ...transfer.metadata,
      ...updatedFields.metadata,
    };
    // ACÁ VALDIAR QUE EL ESTADO ES TRANSITABLE
    if (transfer.state !== TransferState.PENDING) {
      throw new Error(
        `Invalid transition from ${transfer.state} to ${TransferState.PENDING}`,
      );
    }
    try {
      await manager.save(TransferEntity, {
        ...transfer,
        mergeMetadata,
        ...updatedFields,
      });
    } catch (error) {
      console.log('error', error);
    }
    const assignedTransfer = await manager.findOne(TransferEntity, {
      where: {
        id: transfer.id,
      },
    });
    this.eventEmitter.emit(TransferEvent.ASSIGNED, assignedTransfer);
    return assignedTransfer;
  }

  async createTransfer(
    payoutEntity: PayoutEntity,
    manager: EntityManager,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;
    const createTransferDto = plainToClass(PayoutTransferDto, payoutEntity, {
      excludeExtraneousValues: true,
    });

    const baseTransfer = manager.create(TransferEntity, createTransferDto);
    const transferEntity = manager.merge(TransferEntity, baseTransfer, {
      payoutId: payoutEntity.id,
      version: payoutEntity.version,
    });
    console.log('manager', manager);
    this.logger.log(`Creating transfer for payout ${payoutEntity.id}`);
    const transfer = await manager.find(TransferEntity, {
      where: { payoutId: payoutEntity.id },
      lock: { mode: LockMode.PESSIMISTIC_READ },
    });
    // const payoutTransfers = await manager
    //   .createQueryBuilder(TransferEntity, 'transfer')
    //   .where('transfer.payoutId = :id', { id: payoutEntity.id })
    //   .setLock(LockMode.PESSIMISTIC_READ)
    //   .getMany();

    const allCanceled = transfer.every(
      (transfer) => transfer.state === TransferState.CANCELED,
    );

    if (!allCanceled) {
      throw new Error('Payout has active transfers');
    }

    const savedTransfer = await manager.save(transferEntity);

    const createdTransfer = await manager.findOneBy(TransferEntity, {
      id: savedTransfer.id,
    });

    if (createdTransfer) {
      this.logger.log('Emit TransferEvent.CREATED');
      this.eventEmitter.emit(TransferEvent.CREATED, createdTransfer);
    }
    return createdTransfer;
  }

  // /**
  //  * Processes a transfer. The TransferEntity includes the Payout object with its provider as a property.
  //  *
  //  * @param id - The ID of the transfer to process.
  //  * @param processTransferDto - The data transfer object containing the details for processing the transfer.
  //  * @returns A promise that resolves to the processed TransferEntity.
  //  */
  /**
  async processTransfer(
    id: TransferEntity['id'],
    manager: EntityManager,
    processTransferDto?: ProcessTransferDto,
  ): Promise<TransferEntity> {

  const { message, metadata, fromStates, externalId } = processTransferDto ?? {};

  const mergeMetadata = {
    ...transfer.metadata,
    ...metadata,
  };

  const updatedFields: Partial<TransferEntity> = {
    state: TransferState.PROCESSING,
    ...(message && { message }),
    metadata: mergeMetadata,
  };
  const operation = 'process';
  const updatedTransfer = await this.secureUpdateTransferState(
    id,
    updatedFields,
    fromStates,
    operation,
  );

  this.logger.log('Emit TransferEvent.PROCESSING');
  this.eventEmitter.emit(TransferEvent.PROCESSING, updatedTransfer);
  return updatedTransfer;
  }
 */
  // /**
  //  * Cancels a transfer given its ID and update details provided through a DTO. This method updates
  //  * the transfer's state to `CANCELED`, along with any message and metadata provided. It ensures the
  //  * operation is performed within a transactional scope to maintain data integrity. The transfer's
  //  * state is only updated if it is currently in one of the specified `fromStates` to prevent
  //  * unintended state changes.
  //  *
  //  * @param {TransferEntity['id']} id - The unique identifier of the transfer to be canceled.
  //  * @param {CancelTransferDto} cancelTransferDto - Data transfer object containing details for the
  //  * cancellation, such as a message, metadata, and the states from which the transfer can be
  //  * canceled.
  //  * @returns {Promise<TransferEntity>} - The updated transfer entity after cancellation.
  //  * @throws {EntityNotFoundException} If the transfer with the given ID does not exist.
  //  * @throws {UnprocessableEntityException} If the transfer is not in an expected state from which it
  //  * can be canceled.
  //  */
  /**
  async cancelTransfer(
    id: TransferEntity['id'],
    cancelTransferDto: CancelTransferDto,
  ): Promise<TransferEntity> {
  const canUseNewPayoutCreation =
    await this.featureFlagService.getFeatureStatus(
      FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
    );
  if (!canUseNewPayoutCreation) return;

  const { message, metadata, fromStates } = cancelTransferDto;
  const transfer = await this.transferRepository.findOne({
    where: { id },
  });

  const mergeMetadata = {
    ...transfer.metadata,
    ...metadata,
  };

  const updatedFields: Partial<TransferEntity> = {
    state: TransferState.CANCELED,
    ...(message && { message }),
    metadata: mergeMetadata,
  };
  const updatedTransfer = await this.withTransaction(async (manager) => {
    const transfer = await this.transferRepository.findOne({
      where: { id, state: In(fromStates) },
    });
    if (!transfer) {
      throw new Error('Transfer cancellation failed');
    }
    await manager.save(TransferEntity, {
      id: transfer.id,
      ...updatedFields,
    });
    return manager.findOne(TransferEntity, { where: { id } });
  });

  this.logger.log('Emit TransferEvent.CANCELED');
  this.eventEmitter.emit(TransferEvent.CANCELED, updatedTransfer);

  return updatedTransfer;
  }
 */
  /**
  async completeTransfer(
    id: TransferEntity['id'],
    completeTransferDto: CompleteTransferDto,
    manager,
  ) {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    // const { message, metadata, fromStates } = completeTransferDto;

    const transfer = await this.transferRepository.findOneOrFail({
      where: { id },
    });
    console.log('transfer', transfer);
    const mergeMetadata = {
      ...(transfer.metadata || {}),
      ...metadata,
    };

    const updatedFields: Partial<TransferEntity> = {
      state: TransferState.COMPLETED,
      message: message ?? 'Transferencia completada exitosamente',
      metadata: mergeMetadata,
    };
    const operation = 'completeness';
    const updatedTransfer = await this.secureUpdateTransferState(
      id,
      updatedFields,
      fromStates,
      operation,
      manager,
    );

    this.logger.log('Emit TransferEvent.COMPLETED');
    this.eventEmitter.emit(TransferEvent.COMPLETED, updatedTransfer);

    return updatedTransfer;
  }
  */
  /*
  async failTransfer(
    id: TransferEntity['id'],
    manager: EntityManager,
    failTransferDto: FailTransferDto,
  ): Promise<TransferEntity> {
    // TODO: Remove feature flag CAN_USE_NEW_PAYOUT_CREATION
    const canUseNewPayoutCreation =
      await this.featureFlagService.getFeatureStatus(
        FEATURE_FLAG.CAN_USE_NEW_PAYOUT_FLOW,
      );
    if (!canUseNewPayoutCreation) return;

    const { message, metadata, fromStates } = failTransferDto;

    const transfer = await this.transferRepository.findOne({
      where: { id },
    });

    const mergeMetadata = {
      ...transfer.metadata,
      ...metadata,
    };

    const providerErrorCode = transfer.metadata?.providerErrorCode;

    const provider = await this.providerRepository.findOne({
      where: { id: transfer.providerId },
    });

    const transferError = await this.transferErrorService.findOrCreateError(
      message,
      provider?.providerType,
      providerErrorCode,
    );

    const updatedFields: Partial<TransferEntity> = {
      state: TransferState.FAILED,
      message: message ?? 'Transferencia fallida',
      metadata: mergeMetadata,
      errorCode: transferError?.errorCode,
    };
    const operation = 'failure';
    const updatedTransfer = await this.secureUpdateTransferState(
      id,
      updatedFields,
      fromStates,
      operation,
      manager,
    );

    this.logger.log('Emit TransferEvent.FAILED');
    this.eventEmitter.emit(TransferEvent.FAILED, updatedTransfer);

    return updatedTransfer;
  }
  */
  // END NEW METHODS
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/dto/complete-transfer.dto.ts
// import { Type } from 'class-transformer';
// import { IsObject, IsOptional, IsString } from 'class-validator';

// class TransferMetadata {
//   @IsString()
//   @IsOptional()
//   message?: string;
// }

// // DIES, ERA USADO PARA EL TRANSFER SERVICE Y YA NO SE NECESITA
// export class CompleteTransferDto {
//   @IsString()
//   @IsOptional()
//   message?: string;

//   @IsObject()
//   @IsOptional()
//   @Type(() => TransferMetadata)
//   metadata?: TransferMetadata;
// }


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/dto/cancel-transfer.dto.ts
import { Type } from 'class-transformer';
import {
  IsArray,
  IsEnum,
  IsObject,
  IsOptional,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';

class TransferMetadata {
  @IsString()
  @IsOptional()
  message?: string;
}

export class CancelTransferDto {
  @IsString()
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => TransferMetadata)
  metadata?: TransferMetadata;

  @IsArray()
  @IsEnum(TransferState, { each: true })
  fromStates: TransferState[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/dto/process-transfer.dto.ts
import { Type } from 'class-transformer';
import { IsObject, IsOptional, IsString } from 'class-validator';

class TransferMetadata {
  @IsString()
  @IsOptional()
  message?: string;
}

export class ProcessTransferDto {
  @IsString()
  @IsOptional()
  message?: string;

  @IsString()
  @IsOptional()
  externalId?: string;

  @IsObject()
  @IsOptional()
  @Type(() => TransferMetadata)
  metadata?: TransferMetadata;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/dto/update-transfer.dto.ts
import {
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class UpdateTransferDto {
  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @IsString()
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  metadata?: object;

  @IsString()
  @IsOptional()
  externalId?: string;

  @IsNumber()
  @IsPositive()
  @IsOptional()
  providerId?: number;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/models/transfer/transfer.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { PayoutService } from '../payout/payout.service';
import { TransferEntity } from './entities/transfer.entity';
import { TransferService } from './transfer.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { TransferErrorService } from '../transfer-error/transfer-error.service';
import { FeatureFlagService } from 'src/services/feature-flag/feature-flag.service';
import { ProviderEntity } from '../provider/entities/provider.entity';
import { DataSource } from 'typeorm';

describe('given a TransferService', () => {
  let service: TransferService;

  beforeEach(async () => {
    const mockPayoutService = {};
    const mockTransferEntity = {};
    const mockEventEmitter = {};
    const mockFeatureFlagService = {};
    const mockTransferErrorService = {};

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransferService,
        {
          provide: getRepositoryToken(TransferEntity),
          useValue: mockTransferEntity,
        },
        {
          provide: getRepositoryToken(ProviderEntity),
          useValue: {},
        },
        {
          provide: PayoutService,
          useValue: mockPayoutService,
        },
        {
          provide: EventEmitter2,
          useValue: mockEventEmitter,
        },
        {
          provide: TransferErrorService,
          useValue: mockTransferErrorService,
        },
        { provide: FeatureFlagService, useValue: mockFeatureFlagService },
        {
          provide: DataSource,
          useValue: 'mockDataSource',
        },
      ],
    }).compile();

    service = module.get<TransferService>(TransferService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/app.module.ts
import {
  ClassSerializerInterceptor,
  MiddlewareConsumer,
  Module,
  NestModule,
  RequestMethod,
} from '@nestjs/common';
import * as noir from 'pino-noir';
import { ClsModule } from 'nestjs-cls';
import { HttpModule } from '@nestjs/axios';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ScheduleModule } from '@nestjs/schedule';
import { TerminusModule } from '@nestjs/terminus';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { LoggerModule, Params } from 'nestjs-pino';

import { AppController } from './app.controller';
import { QueueModule } from './jobs/queue.module';
import { RolesGuard } from './common/guards/roles.guard';
import { OBFUSCATE_VALUE } from './common/decorators/exclude-from-logs.decorator';
import { HealthController } from './health/health.controller';

// API
import { ApiV2Module } from './api/v2/api.module';
import { ApiInternalModule } from './api/internal/api.module';

// Models
import { AuditLogModule } from './models/audit-log/audit-log.module';
import { BankModule } from './models/bank/bank.module';
import { TransferErrorModule } from './models/transfer-error/transfer-error.module';
import { UserModule } from './models/user/user.module';
import { ApiKeyModule } from './models/apikey/apikey.module';
import { MerchantLimitModule } from './models/merchant-limit/merchant-limit.module';
import { PayoutModule } from './models/payout/payout.module';
import { AccountModule } from './models/account/account.module';
import { ProviderModule } from './models/provider/provider.module';
import { MerchantModule } from './models/merchant/merchant.module';
import { TransferModule } from './models/transfer/transfer.module';
import { TransferJobModule } from './models/transfer-job/transfer-job.module';
import { TransferMethodModule } from './models/transfer-method/transfer-method.module';
import { WebhookEndpointModule } from './models/webhook-endpoint/webhook-endpoint.module';
import { AccountStatementModule } from './models/account-statement/account-statement.module';
import { AuthorizationCodeModule } from './models/authorization-code/authorization-code.module';
import { AccountStatementJobModule } from './models/account-statement-job/account-statement-job.module';
import { PayoutActionsModule } from './models/payout-actions/payout-actions.module';

// Moddlewares
import { ApiVersionMiddleware } from './common/middlewares/api-version.middleware';
import { AuthorizationCodeMiddleware } from './common/middlewares/authorization-code.middleware';

// Providers
import { LiquidoProviderModule } from './providers/liquido/liquido.provider.module';
import { MinkaProviderModule } from './providers/minka/minka.provider.module';
import { ScraperCGProviderModule } from './providers/scraperCG/scraperCG.provider.module';
import { ScraperPWProviderModule } from './providers/scraperPW/scraperPW.provider.module';
import { ShinkansenProviderModule } from './providers/shinkansen/shinkansen.provider.module';
import { ProviderJobModule } from './providers/jobs/provider-job.module';

// Services
import { AuthModule } from './services/auth/auth.module';
import { SlackModule } from './services/slack/slack.module';
import { AuthGuard } from './services/auth/auth.guard';
import { AwsModule } from './services/aws/aws.module';
import { AlertsModule } from './services/alerts/alerts.module';
import { SentryModule } from './services/sentry/sentry.module';
import { PayoutManagementModule } from './services/payout-management/payout-management.module';
import { TransferProviderModule } from './services/transfer-provider/transfer-provider.module';
import { TransferFirebreakModule } from './services/transfer-firebreak/transfer-firebreak.module';
import { TransferAssignmentModule } from './services/transfer-assignment/transfer-assignment.module';
import { TransferReconciliationModule } from './services/transfer-reconciliation/transfer-reconciliation.module';
import { AutomatedPayoutActionModule } from './services/automated-payout-action/automated-payout-action.module';
import { MerchantLimitEvaluatorModule } from './services/merchant-limit-evaluator/merchant-limit-evaluator.module';
import { MailModule } from './services/mail/mail.module';
import { ExcelModule } from './services/excel/excel.module';
import { WebhookModule } from './services/webhook/webhook.module';
import { ChangeAuditSubscriber } from './database/subscribers/change-audit.subscriber';

// Configs
import awsConfig from './config/aws.config';
import databaseConfig from './config/database.config';
import deviceConfig from './config/device.config';
import generalConfig from './config/general.config';
import redisConfig from './config/redis.config';
import twilioConfig from './config/twilio.config';
import scraperConfig from './config/scraper.config';
import sentryConfig from './config/sentry.config';
import shinkansenConfig from './config/shinkansen.config';
import { MetricsModule } from './services/metrics/metrics.module';
import { AuthorizationCodeController } from './api/v2/authorization-code/authorization-code.controller';
import { PayoutNewModule } from './models/payout/payout.new.module';
import { ThomasModule } from './providers/thomas/thomas.module';
import thomasConfig from './config/thomas.config';
import { Environment } from 'src/common/enums/environment.enum';
import { dataSourceOptions } from './database/dataSource';

const isTesting = process.env.NODE_ENV === Environment.TEST;

const redaction = noir(
  [
    'req.headers.x-api-key',
    'req.headers.authorization',
    'req.headers.shinkansen-jws-signature',
    'req.headers.x-twilio-signature',
  ],
  OBFUSCATE_VALUE,
);

const loggerconfig: Params = {
  pinoHttp: {
    name: 'Payments Engine',
    autoLogging: true,
    level: 'trace',
    serializers: redaction,
  },
};

@Module({
  imports: [
    MailModule,
    ConfigModule.forRoot({
      load: [
        awsConfig,
        databaseConfig,
        deviceConfig,
        generalConfig,
        redisConfig,
        twilioConfig,
        scraperConfig,
        sentryConfig,
        shinkansenConfig,
        thomasConfig,
      ],
      isGlobal: true,
    }),
    TypeOrmModule.forRoot(dataSourceOptions),
    ClsModule.forRoot({
      global: true,
      middleware: {
        mount: true,
      },
    }),
    ...(!isTesting ? [LoggerModule.forRoot(loggerconfig)] : []),
    ScheduleModule.forRoot(),
    EventEmitterModule.forRoot(),
    ApiV2Module,
    QueueModule,
    HttpModule,
    TerminusModule,
    BankModule,
    MerchantModule,
    UserModule,
    AccountStatementModule,
    AccountStatementJobModule,
    ApiKeyModule,
    AuthModule,
    TransferMethodModule,
    PayoutModule,
    PayoutNewModule,
    MerchantLimitModule,
    MerchantLimitEvaluatorModule,
    AuthorizationCodeModule,
    TransferModule,
    WebhookEndpointModule,
    SlackModule,
    AwsModule,
    AccountStatementModule,
    TransferJobModule,
    AccountModule,
    ProviderModule,
    TransferAssignmentModule,
    TransferProviderModule,
    MinkaProviderModule,
    PayoutManagementModule,
    ScraperPWProviderModule,
    ApiInternalModule,
    TransferFirebreakModule,
    ShinkansenProviderModule,
    ScraperCGProviderModule,
    AlertsModule,
    SentryModule,
    ExcelModule,
    LiquidoProviderModule,
    TransferErrorModule,
    AuditLogModule,
    PayoutActionsModule,
    AutomatedPayoutActionModule,
    TransferReconciliationModule,
    ProviderJobModule,
    MetricsModule,
    WebhookModule,
    ThomasModule,
  ],
  controllers: [AppController, HealthController],
  providers: [
    {
      provide: APP_INTERCEPTOR,
      useClass: ClassSerializerInterceptor,
    },
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
    ChangeAuditSubscriber,
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(AuthorizationCodeMiddleware)
      .forRoutes(AuthorizationCodeController);
    consumer
      .apply(ApiVersionMiddleware)
      .forRoutes({ path: '*', method: RequestMethod.ALL });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/jobs/provider-job.module.ts
import { Module } from '@nestjs/common';
import { TransferProviderModule } from 'src/services/transfer-provider/transfer-provider.module';
import { MinkaProviderJob } from './minka.provider.job';

@Module({
  imports: [TransferProviderModule],
  providers: [MinkaProviderJob],
  exports: [MinkaProviderJob],
})
export class ProviderJobModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/jobs/minka.provider.job.ts
import moment = require('moment');

import { Inject, Injectable, Logger } from '@nestjs/common';
import { LessThan, MoreThanOrEqual } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferProviderService } from 'src/services/transfer-provider/transfer-provider.service';

@Injectable()
export class MinkaProviderJob {
  @Inject()
  private transferProviderService: TransferProviderService;

  private readonly logger = new Logger('MinkaProviderJobs');
  private readonly providerType = ProviderType.Minka;

  @Cron(CronExpression.EVERY_HOUR)
  async longTermUpdateTransactions() {
    const oneHourAgo = moment().subtract(1, 'hour').toDate();
    this.logger.debug(
      `Updating ${
        this.providerType
      } processing transactions created before ${oneHourAgo.toISOString()}`,
    );
    await this.transferProviderService.getTransactionsUpdate({
      providerType: this.providerType,
      lookupTime: LessThan(oneHourAgo),
    });
  }

  @Cron(CronExpression.EVERY_MINUTE)
  async shortTermUpdateTransactions() {
    const oneHourAgo = moment().subtract(1, 'hour').toDate();
    this.logger.debug(
      `Updating ${
        this.providerType
      } processing transactions created after ${oneHourAgo.toISOString()}`,
    );
    await this.transferProviderService.getTransactionsUpdate({
      providerType: this.providerType,
      lookupTime: MoreThanOrEqual(oneHourAgo),
    });
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/liquido.banks.ids.contant.ts
export const LiquidoBanksIdsConstants = {
  mx_banco_banamex: '40002',
  mx_banco_bbva: '40012',
  mx_banco_santander: '40014',
  mx_banco_hsbc: '40021',
  mx_banco_bajio: '40030',
  mx_banco_inbursa: '40036',
  mx_banca_mifel: '40042',
  mx_banco_scotiabank: '40044',
  mx_banco_banregio: '40058',
  mx_banco_invex: '40059',
  mx_banco_bansi: '40060',
  mx_banco_afirme: '40062',
  mx_banco_banorte: '40072',
  mx_banco_monex: '40112',
  mx_banco_vepormas: '40113',
  mx_banco_credit_suisse: '40126',
  mx_banco_azteca: '40127',
  mx_banco_autofin: '40128',
  mx_banco_multiva: '40132',
  mx_banco_actinver: '40133',
  mx_banco_bancoppel: '40137',
  mx_banco_abc_capital: '40138',
  mx_banco_consubanco: '40140',
  mx_banco_cibanco: '40143',
  mx_banco_base: '40145',
  mx_banco_bankaool: '40147',
  mx_banco_pagatodo: '40148',
  mx_banco_bancrea: '40152',
  mx_banco_finterra: '40154',
  mx_banco_sabadell: '40156',
  mx_banco_intercam: '90630',
};
export const LIQUIDO_UNSUPORTED_BANKS_CODE = ['mx_banco_forjadores'];


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/liquido.provider.module.ts
import { Module } from '@nestjs/common';
import { HttpModule } from '@nestjs/axios';
import { LiquidoProviderAdapter } from './liquido.provider';
import { LiquidoProviderService } from './liquido.provider.service';
import { BankModule } from 'src/models/bank/bank.module';

@Module({
  imports: [HttpModule, BankModule],
  providers: [LiquidoProviderAdapter, LiquidoProviderService],
  exports: [LiquidoProviderAdapter],
})
export class LiquidoProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/liquido.banks.names.constant.ts
export const LiquidoBanksNamesConstants = {
  mx_banco_bbva: 'BBVA MEXICO',
  mx_banco_banorte: 'BANORTE',
  mx_banco_banamex: 'BANAMEX',
  mx_banco_santander: 'SANTANDER',
  mx_banco_scotiabank: 'SCOTIABANK',
  mx_banco_hsbc: 'HSBC',
  mx_banco_inbursa: 'INBURSA',
  mx_banco_bajio: 'BAJIO',
  mx_banco_afirme: 'AFIRME',
  mx_banco_azteca: 'AZTECA',
  mx_banco_abc_capital: 'ABC CAPITAL',
  mx_american_express_bank: '',
  mx_banco_mifel: 'MIFEL',
  mx_banco_actinver: 'ACTINVER',
  mx_banco_autofin: 'AUTOFIN',
  mx_banco_bancrea: 'BANCREA',
  mx_banco_base: 'BBASE',
  mx_banco_compartamos: 'COMPARTAMOS',
  mx_banco_credit_suisse: 'CREDIT SUISSE',
  mx_banco_finterra: 'BANCO FINTERRA',
  mx_banco_forjadores: '',
  mx_banco_invex: 'INVEX',
  mx_banco_monex: 'BMONEX',
  mx_banco_multiva: 'MULTIVA BANCO',
  mx_banco_pagatodo: 'PAGATODO',
  mx_banco_banregio: 'BANREGIO',
  mx_banco_sabadell: 'SABADELL',
  mx_banco_vepormas: 'VE POR MAS',
  mx_banco_bancoppel: 'BANCOPPEL',
  mx_banco_bankaool: 'BANKAOOL',
  mx_banco_bansi: 'BANSI',
  mx_banco_cibanco: 'CIBANCO',
  mx_banco_consubanco: 'CONSUBANCO',
  mx_banco_intercam: 'INTERCAM BANCO',
  mx_banco_stp: 'STP',
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/liquido.provider.service.ts
import * as moment from 'moment';
import * as crypto from 'crypto';
import { HttpStatus, Inject, Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { LiquidoTransactionDto } from './dto/liquido.transaction.dto';
import { v4 as uuid } from 'uuid';
import { LiquidoBanksIdsConstants } from './liquido.banks.ids.contant';
import { LiquidoTransactionStatusDto } from './dto/liquido.transaction.status.dto';
import { LiquidoResponseDto } from './dto/liquido.response.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { LiquidoBalanceDto } from './dto/liquido.balance.dto';
import { isTokenExpired } from 'src/utils/token-expiration-validator';
import { translateLiquidoStateToTransferState } from '../common/state-translators/liquido-state.translator';
import { LiquidoProviderCredentialsDto } from './dto/liquido.credentials.dto';

@Injectable()
export class LiquidoProviderService {
  public providerType: ProviderType;
  private credentials: LiquidoProviderCredentialsDto =
    new LiquidoProviderCredentialsDto();
  private readonly logger = new Logger('LiquidoProviderService');
  private token: string;
  private idempotencyKey: string;
  @Inject()
  private http: HttpService;

  private get config() {
    return {
      headers: {
        'x-api-key': this.credentials.apiKey,
        Authorization: 'Bearer ' + this.token,
        'Content-Type': 'application/json',
      },
    };
  }

  get validToken(): boolean {
    return this.token && !isTokenExpired(this.token);
  }

  async ensureToken() {
    if (this.validToken) return;
    await this.authenticate();
  }

  private async authenticate(): Promise<void> {
    const url = `${this.credentials.authUrl}`;

    const grantType = 'client_credentials';

    const params = new URLSearchParams({
      client_id: this.credentials.clientId,
      client_secret: this.credentials.clientSecret,
      grant_type: grantType,
    });

    try {
      const { data } = await this.http.axiosRef.post(url, params, {
        headers: {
          'content-type': 'application/x-www-form-urlencoded',
        },
      });
      const _token = data?.access_token;

      if (!_token) {
        throw new Error('Liquido login failed');
      }
      //save token
      this.token = _token;
    } catch (e) {
      this.logger.debug(`Could not retrieve token error: ${e.message}`);
      throw new Error('Liquido login failed');
    }
  }

  private providerConfiguration(
    credentials: LiquidoProviderCredentialsDto,
  ): void {
    const { apiKey, clientId, clientSecret, authUrl, baseUrl } = credentials;
    this.credentials.authUrl = authUrl;
    this.credentials.baseUrl = baseUrl;
    this.credentials.clientId = clientId;
    this.credentials.clientSecret = clientSecret;
    this.credentials.apiKey = apiKey;
  }

  private buildPayload(transactionDto: TransactionDto): LiquidoTransactionDto {
    this.idempotencyKey = uuid();

    const payload = {
      idempotencyKey: this.idempotencyKey,
      country: 'MX',
      targetName: transactionDto.destinationName,
      targetEmail: transactionDto.destinationEmail,
      targetDocument: transactionDto.destinationHolderId,
      // targetBankName:
      //   LiquidoBanksNamesConstants[transactionDto.destinationBankCode],
      targetBankAccountId: transactionDto.destinationAccount,
      targetBankId:
        LiquidoBanksIdsConstants[transactionDto.destinationBankCode],
      amountInCents: Number(transactionDto.amount * 100),
      currency: transactionDto.currency.toUpperCase(),
      comment: transactionDto.concept,
    };
    return payload;
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    this.providerConfiguration(provider.credentials);
    await this.ensureToken();
    // TODO: Must re // Mapear country del transfeview if the URL is the same allways
    const url = `${this.credentials.baseUrl}/v1/payments/payouts/spei`;

    const payload = this.buildPayload(transactionDto);
    const { data } = await this.http.axiosRef.post<LiquidoResponseDto>(
      url,
      payload,
      this.config,
    );

    if (data.statusCode !== HttpStatus.OK) {
      this.logger.debug('Transfer creation failed for transfer');
      throw new Error(data.errorMsg);
    }

    const updatedState = translateLiquidoStateToTransferState(
      data.transferStatus,
    );
    return {
      state: updatedState,
      externalId: payload.idempotencyKey,
    };
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    this.providerConfiguration(provider.credentials);
    await this.ensureToken();

    const url = `${this.credentials.baseUrl}/v1/payments/payouts/key/${transactionId}`;

    const { data } = await this.http.axiosRef.get<LiquidoTransactionStatusDto>(
      url,
    );

    if (data.statusCode !== HttpStatus.OK) {
      throw new Error(data.errorMsg);
    }

    const updatedState = translateLiquidoStateToTransferState(
      data.transferStatus,
    );

    if (!updatedState) {
      throw new Error("Can't translate transaction state");
    }

    return {
      state: updatedState,
      message: data?.transferErrorMsg,
    };
  }

  public async getBalance(
    provider: ProviderEntity,
  ): Promise<AccountBalanceDto> {
    this.providerConfiguration(provider.credentials);
    await this.ensureToken();

    const url = `${this.credentials.baseUrl}/open-api/account/balance?countryCode=MX&transactionTypeCode=PAY_OUT`;

    const { data } = await this.http.axiosRef.get<LiquidoBalanceDto>(url);

    if (data.code !== HttpStatus.OK) {
      throw new Error(data.msg);
    }

    const now = moment().toDate();
    const accountBalance = {
      balance: data.data.accountBalance,
      currency: data.data.currency as Currency,
      retrievedAt: now,
    };
    return accountBalance;
  }
  public verifySignature(
    message: string,
    signature: string,
    provider: ProviderEntity,
  ): boolean {
    return signature === this.calculateSignature(message, provider);
  }
  private calculateSignature(
    message: string,
    provider: ProviderEntity,
  ): string {
    this.providerConfiguration(provider.credentials);
    const hmac = crypto.createHmac('sha256', this.credentials.clientSecret);
    hmac.update(message);
    const signature = hmac.digest('hex');
    return signature;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/dto/liquido.transaction.status.dto.ts
import { LiquidoResponseDto } from './liquido.response.dto';

export class LiquidoTransactionStatusDto extends LiquidoResponseDto {
  idempotencyKey: string;
  targetName: string;
  targetDocument: string;
  targetPixKey: string;
  targetPixKeyType: string;
  targetBankCode: string;
  targetBankAgency: string;
  targetBankAccountId: string;
  amount: string;
  amountInCents: number;
  currency: string;
  createTime: string;
  finalStatusTime: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/dto/liquido.transaction.dto.ts
export class LiquidoTransactionDto {
  idempotencyKey: string;
  country: string;
  targetName?: string;
  targetLastName?: string;
  targetEmail?: string;
  targetDocument?: string;
  targetBankName?: string;
  targetBankCode?: string;
  targetBankBranchId?: string;
  targetBankAccountId: string;
  targetBankId?: string;
  amountInCents: number;
  currency: string;
  comment?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/dto/liquido.response.dto.ts
import { LiquidoTransactionState } from 'src/common/enums/liquido-transaction-state.enum';

export class LiquidoResponseDto {
  statusCode: number;
  errorMsg?: string;
  transactionId?: '';
  transferStatus?: LiquidoTransactionState;
  transferStatusCode?: number;
  transferErrorMsg?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/dto/liquido.balance.dto.ts
export class LiquidoBalanceDto {
  code: number;
  msg: string;
  data?: Balance;
}
class Balance {
  accountBalance: number;
  currency: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/dto/liquido.credentials.dto.ts
export class LiquidoProviderCredentialsDto {
  authUrl: string;
  baseUrl: string;
  clientId: string;
  clientSecret: string;
  apiKey: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/liquido/liquido.provider.ts
import { Inject, Injectable } from '@nestjs/common';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { LiquidoProviderService } from './liquido.provider.service';
import { TransferState } from 'src/common/enums/transfer-state.enum';

@Injectable()
export class LiquidoProviderAdapter extends BaseProviderAdapter {
  @Inject()
  private liquidoProviderService: LiquidoProviderService;

  public providerType: ProviderType = ProviderType.Liquido;

  public get cancelableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get completableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    const canCreateTransaction = this.canCreateTransaction(transactionDto);
    if (!canCreateTransaction.capable) {
      throw new Error(canCreateTransaction.error);
    }

    return this.liquidoProviderService.createTransaction(
      provider,
      transactionDto,
    );
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    const transactionState =
      await this.liquidoProviderService.getTransactionState(
        provider,
        transactionId,
      );

    return transactionState;
  }

  public async getBalance(
    provider: ProviderEntity,
  ): Promise<AccountBalanceDto> {
    const balance = await this.liquidoProviderService.getBalance(provider);
    return balance;
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    if (transactionDto.currency !== Currency.MEXICO) {
      return {
        capable: false,
        error: `Invalid currency provided. Only '${Currency.MEXICO}' is accepted`,
      };
    }

    return { capable: true };
  }

  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;

    const transactionFailed = this.cancelableStates.includes(state);
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Liquido provider cannot cancel unresolved transactions',
    };
  }

  public canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility {
    const { state } = transactionDto;

    const transactionFailed = this.completableStates.includes(state);
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Liquido provider cannot complete unresolved transactions',
    };
  }

  public canRetryTransaction(transactionDto: TransactionDto): ProviderAbility {
    const transactionFailed = transactionDto.state === TransferState.FAILED;
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Liquido provider can only reassign failed transactions',
    };
  }

  public async verifySignature(
    message: string,
    headerSignature: string,
    provider: ProviderEntity,
  ) {
    return this.liquidoProviderService.verifySignature(
      message,
      headerSignature,
      provider,
    );
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/minka.provider.module.ts
import { HttpModule } from '@nestjs/axios';
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { BankModule } from 'src/models/bank/bank.module';
import { MinkaProviderAdapter } from 'src/providers/minka/minka.provider';
import { MinkaProviderService } from './minka.provider.service';

@Module({
  imports: [
    HttpModule,
    BankModule,
    JwtModule.register({ secret: 'hard!to-guess_secret' }),
  ],
  providers: [MinkaProviderAdapter, MinkaProviderService],
  exports: [MinkaProviderAdapter],
})
export class MinkaProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/minka.provider.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { Currency } from 'src/common/enums/currency.enum';
import { MinkaProviderService } from './minka.provider.service';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';

@Injectable()
export class MinkaProviderAdapter extends BaseProviderAdapter {
  @Inject()
  private minkaProviderService: MinkaProviderService;

  private readonly logger = new Logger('MinkaProvider');
  public providerType: ProviderType = ProviderType.Minka;

  public get cancelableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get completableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    const { capable, error } = this.canCreateTransaction(transactionDto);

    if (!capable) {
      this.logger.debug(error);
      return {
        message: error,
        state: TransferState.FAILED,
      };
    }

    const transaction = await this.minkaProviderService.createTransaction(
      transactionDto,
      provider,
    );

    return transaction;
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    try {
      const transactionState =
        await this.minkaProviderService.getTransactionState(
          provider,
          transactionId,
        );
      return transactionState;
    } catch (e) {
      this.logger.debug('MinkaProvider getTransactionState error');
      this.logger.error(e);
      throw new Error('MinkaProvider getTransactionState error');
    }
  }

  public getBalance(): Promise<AccountBalanceDto> {
    throw new Error('Method not implemented for MinkaProvider.');
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    if (!transactionDto?.destinationPhone) {
      return {
        capable: false,
        error: 'The destinationPhone cannot be null or empty',
      };
    }

    if (transactionDto.currency !== Currency.COLOMBIA) {
      return {
        capable: false,
        error: `Invalid currency provided. Only '${Currency.COLOMBIA}' is accepted`,
      };
    }

    return { capable: true };
  }

  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;
    const transactionFailed = this.cancelableStates.includes(state);
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Minka provider cannot cancel unresolved transactions',
    };
  }

  public canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility {
    const { state } = transactionDto;

    const transactionFailed = this.completableStates.includes(state);
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Minka provider cannot complete unresolved transactions',
    };
  }

  public canRetryTransaction(transactionDto: TransactionDto): ProviderAbility {
    const transactionFailed = transactionDto.state === TransferState.FAILED;
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Minka provider can only reassign failed transactions',
    };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/utils/state.spec.ts
import { MinkaTransactionState } from 'src/common/enums/minka-transaction-state.enum';
import { translateMinkaState } from './state';
import { TransferState } from 'src/common/enums/transfer-state.enum';

describe('translateMinkaState', () => {
  it('should return null if no state is provided', () => {
    expect(translateMinkaState(null)).toBe(null);
  });

  it('should return null if the state is not mapped', () => {
    expect(translateMinkaState('not mapped' as MinkaTransactionState)).toBe(
      null,
    );
  });

  it('should return the mapped state', () => {
    expect(translateMinkaState('CREATED' as MinkaTransactionState)).toBe(
      TransferState.PROCESSING,
    );

    expect(translateMinkaState('INITIATED' as MinkaTransactionState)).toBe(
      TransferState.PROCESSING,
    );

    expect(translateMinkaState('PENDING' as MinkaTransactionState)).toBe(
      TransferState.PROCESSING,
    );

    expect(translateMinkaState('ACCEPTED' as MinkaTransactionState)).toBe(
      TransferState.PROCESSING,
    );

    expect(translateMinkaState('COMPLETED' as MinkaTransactionState)).toBe(
      TransferState.COMPLETED,
    );

    expect(translateMinkaState('REJECTED' as MinkaTransactionState)).toBe(
      TransferState.FAILED,
    );

    expect(translateMinkaState('ERROR' as MinkaTransactionState)).toBe(
      TransferState.FAILED,
    );
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/utils/state.ts
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { MinkaTransactionState } from 'src/common/enums/minka-transaction-state.enum';

const MinkaStateMap = {
  [MinkaTransactionState.CREATED]: TransferState.PROCESSING,
  [MinkaTransactionState.INITIATED]: TransferState.PROCESSING,
  [MinkaTransactionState.PENDING]: TransferState.PROCESSING,
  [MinkaTransactionState.ACCEPTED]: TransferState.PROCESSING,
  [MinkaTransactionState.COMPLETED]: TransferState.COMPLETED,
  [MinkaTransactionState.REJECTED]: TransferState.FAILED,
  [MinkaTransactionState.ERROR]: TransferState.FAILED,
};

export function translateMinkaState(
  state: MinkaTransactionState,
): TransferState {
  if (!state) return null;

  const transferState = MinkaStateMap[state];
  return transferState ?? null;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/minka.provider.service.ts
import moment = require('moment');
import { Inject, Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { MinkaTransferDto } from './dto/minka.transfer.dto';
import { JwtService } from '@nestjs/jwt';
import { MinkaTransfersResponseDto } from './dto/minka.transfers.response.dto';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { MinkaCredentialsDto } from './dto/minka.provider.credentials.dto';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { CreateResponseMinkaDto } from './dto/minka.create.response.dto';
import { translateMinkaState } from './utils/state';
import { plainToClass } from 'class-transformer';
import { validateSync } from 'class-validator';
import { Credential } from 'src/utils/encryption.util';

@Injectable()
export class MinkaProviderService {
  @Inject()
  private http: HttpService;
  @Inject()
  private jwtService: JwtService;

  private token: string;
  public providerType: ProviderType;

  private readonly logger = new Logger('MinkaProviderService');

  private validateCredentials(credentials: Credential): MinkaCredentialsDto {
    const credentialDto = plainToClass(MinkaCredentialsDto, credentials);
    const errors = validateSync(credentialDto);

    if (errors.length > 0) {
      const messages = errors.map((error) => {
        return Object.values(error.constraints).join(', ');
      });
      const message = messages.join(', ');
      throw new Error(message);
    }

    return credentialDto;
  }

  private buildCredentials(provider: ProviderEntity): MinkaCredentialsDto {
    const { decryptedCredentials } = provider;
    const credentialsDto = this.validateCredentials(decryptedCredentials);
    return credentialsDto;
  }

  private buildHeaders(credentials: MinkaCredentialsDto) {
    return {
      'x-api-key': credentials.apiKey,
      'Content-Type': 'application/json',
      Authorization: `Bearer ${this.token}`,
    };
  }

  get validToken() {
    if (!this.token) return false;

    const decodedJwtAccessToken = this.jwtService.decode(this.token);
    if (!decodedJwtAccessToken) return false;

    const exp = decodedJwtAccessToken['exp'];
    if (!exp) return false;

    const expiresAt = moment(exp * 1000);
    const now = moment().add(5, 'minutes');

    const isValid = expiresAt.isAfter(now);
    return isValid;
  }

  async ensureToken(credentials: MinkaCredentialsDto): Promise<void> {
    if (this.validToken) return;
    await this.authenticate(credentials);
  }

  async authenticate(credentials: MinkaCredentialsDto): Promise<void> {
    const url = `${credentials.apiUrl}/oauth/token`;
    const options = {
      client_id: credentials.clientId,
      client_secret: credentials.clientSecret,
      grant_type: 'client_credentials',
    };
    const { data } = await this.http.axiosRef.post(url, options);
    const _token = data?.access_token;
    if (!_token) {
      throw new Error('Access token not found in response');
    }
    this.token = _token;
  }

  public async createTransaction(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ): Promise<CreatedTransactionDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Minka credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Minka credentials.`,
      };
    }

    const credentials = this.buildCredentials(provider);

    try {
      await this.ensureToken(credentials);
    } catch (error) {
      return {
        state: TransferState.FAILED,
        message: `Minka provider authentication failed. ${error?.message}`,
      };
    }

    try {
      const url = `${credentials.apiUrl}/v2/transfers`;
      const payload = this.createMinkaPayload(transactionDto, credentials);
      const headers = this.buildHeaders(credentials);

      const { data } = await this.http.axiosRef.post<CreateResponseMinkaDto>(
        url,
        payload,
        { headers },
      );
      const { transferId, labels } = data ?? {};
      const minkaTransactionState = labels?.status;
      const transferState = translateMinkaState(minkaTransactionState);

      return {
        message: `Minka transaction created correctly.`,
        externalId: transferId,
        state: transferState,
      };
    } catch (error) {
      return {
        state: TransferState.FAILED,
        message: `Minka transaction creation failed. ${error?.message}`,
      };
    }
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Minka credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Minka credentials.`,
      };
    }

    const credentials = this.buildCredentials(provider);

    const minkaTransfer = await this.getMinkaTransferByMinkaTransferId(
      transactionId,
      credentials,
    );

    if (!minkaTransfer) {
      throw new Error('Transfer status not found');
    }

    const state = translateMinkaState(minkaTransfer?.status);
    const message = minkaTransfer?.error?.message;

    const transactionState: TransactionStateDto = {
      state,
      ...(message && { message }),
    };

    return transactionState;
  }

  public getBalance(): Promise<AccountBalanceDto> {
    throw new Error('Method not implemented for MinkaProider.');
  }

  phoneToTarget(destinationPhone: string): string {
    const FORBIDDEN_CHARACTERS = /[\s\-.+*#_]/g;

    const cleanPhone = destinationPhone.replace(FORBIDDEN_CHARACTERS, '');
    const target = `$${cleanPhone}`;
    return target;
  }

  createMinkaPayload(
    transactionDto: TransactionDto,
    credentials: MinkaCredentialsDto,
  ): MinkaTransferDto {
    const { destinationPhone, amount } = transactionDto;
    const { source } = credentials;

    const target = this.phoneToTarget(destinationPhone);
    const formattedAmount = amount.toString();

    const data: MinkaTransferDto = {
      source: source,
      target: target,
      amount: formattedAmount,
      symbol: '$tin',
      labels: {
        type: 'SEND',
        domain: 'tin',
        description: 'Buk Adelantos',
        sourceChannel: 'WEB',
        transactionPurpose: 'PAYMENT',
        numberOfTransactions: '1',
      },
    };
    return data;
  }

  async getMinkaTransferByMinkaTransferId(
    minkaTransferId: string,
    credentials: MinkaCredentialsDto,
  ): Promise<MinkaTransferDto> {
    const { apiUrl } = credentials;

    await this.ensureToken(credentials);

    const url = `${apiUrl}/v2/transfers/${minkaTransferId}`;
    const headers = this.buildHeaders(credentials);

    const response = await this.http.axiosRef.get(url, { headers });
    const { entities } = response.data as MinkaTransfersResponseDto;

    if (Array.isArray(entities) && entities.length > 0) {
      return entities[0];
    }

    throw new Error(`Transfer not found for minka id ${minkaTransferId}`);
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/minka.provider.spec.ts
import { MinkaProviderService } from './minka.provider.service';

describe('given a MinkaProviderService', () => {
  const minkaService: MinkaProviderService = new MinkaProviderService();

  describe('when a user use makeAndCleanPhone', () => {
    it('then return a Colombian phone number + `$`', () => {
      const minkaTarget = minkaService.phoneToTarget('+57 3134135681');
      expect(minkaTarget).toBe('$573134135681');
    });
    it('then return a Colombian phone number + `$`', () => {
      const minkaTarget = minkaService.phoneToTarget('+57 31341 35681');
      expect(minkaTarget).toBe('$573134135681');
    });
    it('then return a Colombian phone number + `$`', () => {
      const minkaTarget = minkaService.phoneToTarget('+573134135681');
      expect(minkaTarget).toBe('$573134135681');
    });
    it('then return a Colombian phone number + `$`', () => {
      const minkaTarget = minkaService.phoneToTarget('573134135681');
      expect(minkaTarget).toBe('$573134135681');
    });
    it('then return Error if not valid string', () => {
      const falsyArray = [null, undefined, '', '+56925705213'];
      for (const falsy of falsyArray) {
        try {
          minkaService.phoneToTarget(falsy);
        } catch (error) {
          expect(error).toBeInstanceOf(Error);
        }
      }
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.transfer.dto.ts
import { MinkaSignerDto } from 'src/providers/minka/dto/minka.signer.dto';
import {
  IsEnum,
  IsNumber,
  IsString,
  IsObject,
  IsOptional,
} from 'class-validator';
import { MinkaTransactionState } from 'src/common/enums/minka-transaction-state.enum';
import { MinkaWalletDto } from 'src/providers/minka/dto/minka.wallet.dto';

export class MinkaTransferDto {
  @IsString()
  amount?: string;

  @IsEnum(MinkaTransactionState)
  status?: MinkaTransactionState;

  @IsObject()
  labels?: MinkaTransferLabelsDto;

  @IsString()
  source?: string;

  @IsString()
  target?: string;

  @IsString()
  symbol?: string;

  @IsObject()
  snapshot?: MinkaSnapshotDto;

  @IsObject()
  error?: MinkaErrorDto;

  @IsString()
  transferId?: string;

  @IsString()
  txId?: string;

  @IsString()
  txRef?: string;

  @IsString()
  sourceWallet?: string;

  @IsString()
  sourceSigner?: string;

  @IsString()
  sourceSignerBalance?: unknown;

  @IsString()
  sourceBank?: string;

  @IsString()
  sourceBankBicfi?: string;

  @IsString()
  targetWallet?: string;

  @IsString()
  targetSigner?: string;

  @IsString()
  targetSignerBalance?: unknown;

  @IsString()
  targetBank?: string;

  @IsString()
  targetBankBicfi?: string;

  @IsString()
  type?: string;

  @IsString()
  description?: string;

  @IsString()
  created?: string;

  @IsString()
  updated?: string;

  @IsString()
  domain?: string;

  @IsString()
  owner?: unknown;
}

export class MinkaTransferLabelsDto {
  @IsString()
  tx_id?: string;

  @IsEnum(MinkaTransactionState)
  status?: MinkaTransactionState;

  @IsString()
  hash?: string;

  @IsString()
  tx_ref?: string;

  @IsString()
  created?: string;

  @IsString()
  updated?: string;

  @IsString()
  description?: string;

  @IsString()
  domain?: string;

  @IsString()
  type: string;

  @IsString()
  invoiceId?: string;

  @IsString()
  transactionPurpose?: string;

  @IsString()
  numberOfTransactions?: string;

  @IsString()
  sourceChannel?: string;

  @IsObject()
  @IsOptional()
  deviceFingerPrint?: MinkaDeviceFingerprintDto;
}

export class MinkaSnapshotDto {
  @IsObject()
  target?: MinkaSnapshotTargetDto;

  @IsObject()
  source?: MinkaSnapshotSourceDto;

  @IsObject()
  symbol?: MinkaSnapshotSymbolDto;
}

export class MinkaSnapshotSourceDto {
  @IsObject()
  wallet?: MinkaWalletDto;

  @IsObject()
  signer?: MinkaSignerDto;
}

export class MinkaSnapshotTargetDto {
  @IsObject()
  wallet?: MinkaWalletDto;

  @IsObject()
  signer?: MinkaSignerDto;
}

export class MinkaSnapshotSymbolDto {
  @IsObject()
  wallet?: MinkaWalletDto;

  @IsObject()
  signer?: MinkaSignerDto;
}

export class MinkaErrorDto {
  @IsNumber()
  code?: number;

  @IsString()
  message?: string;
}

export class MinkaDeviceFingerprintDto {
  @IsString()
  hash?: string;

  @IsString()
  ipAddress?: string;

  @IsString()
  country?: string;

  @IsString()
  city?: string;

  @IsString()
  mobileDevice?: string;

  @IsString()
  SIMCardId?: string;

  @IsString()
  model?: string;

  @IsString()
  operator?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.signer.dto.ts
import { IsString, IsNumber, IsObject } from 'class-validator';

export class MinkaSignerDto {
  @IsString()
  handle?: string;

  @IsObject()
  labels?: MinkaSignerLabelsDto;
}

export class MinkaSignerLabelsDto {
  @IsString()
  type?: string;

  @IsString()
  email?: string;

  @IsString()
  mobile?: string;

  @IsString()
  created?: string;

  @IsString()
  bankName?: string;

  @IsString()
  lastName?: string;

  @IsString()
  bankBicfi?: string;

  @IsString()
  createdBy?: string;

  @IsString()
  firstName?: string;

  @IsString()
  assignedTo?: string[];

  @IsString()
  description?: string;

  @IsString()
  proprietary?: string;

  @IsString()
  sourceChannel?: string;

  @IsString()
  identification?: string;

  @IsString()
  bankAccountType?: string;

  @IsString()
  routerReference?: string;

  @IsString()
  bankAccountNumber?: string;

  @IsString()
  countryOfResidence?: string;

  @IsNumber()
  maxAmountOfTransfer?: number;

  @IsNumber()
  dailyCountOfTransfersLimit?: number;

  @IsNumber()
  dailySumAmountOfTransfersLimit?: number;

  routerAuthMethod?: unknown;

  routerAuthParams?: unknown;

  routerDownload?: unknown;

  routerAction?: unknown;

  routerFormat?: unknown;

  routerStatus?: unknown;

  routerUpload?: unknown;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.create.response.dto.ts
import { MinkaTransactionState } from 'src/common/enums/minka-transaction-state.enum';

export class CreateResponseMinkaDto {
  transferId: string;
  source: string;
  target: string;
  symbol: string;
  amount: string;
  labels: Labels;
  snapshot: any;
  _auth: Auth;
  error: Error;
}

export class Labels {
  description: string;
  domain: string;
  type: string;
  tx_id: string;
  tx_ref: string;
  flowId: string;
  status: MinkaTransactionState;
  created: string;
  updated: string;
}

export class Auth {
  organization: string;
  domain: string;
  realm: string;
  owner: string;
}

export class Error {
  code: number;
  message: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.transfers.response.dto.ts
import { MinkaErrorDto, MinkaTransferDto } from './minka.transfer.dto';

export class MinkaTransfersPaginationDto {
  pageNum: string;
  pageSize: string;
  totalResults: string;
}

export class MinkaTransfersResponseDto {
  entities: MinkaTransferDto[];
  pagination: MinkaTransfersPaginationDto;
  error: MinkaErrorDto;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.provider.credentials.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';
import { Credential } from 'src/utils/encryption.util';

export class MinkaCredentialsDto {
  @IsString()
  @IsNotEmpty()
  clientId: string;

  @IsString()
  @IsNotEmpty()
  clientSecret: string;

  @IsString()
  @IsNotEmpty()
  apiKey: string;

  @IsString()
  @IsNotEmpty()
  apiUrl: string;

  @IsString()
  @IsNotEmpty()
  source: string;
}

export interface MinkaCredentials extends Credential {
  clientId: string;
  clientSecret: string;
  apiKey: string;
  apiUrl: string;
  source: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/minka.wallet.dto.ts
import { IsString, IsObject, IsArray } from 'class-validator';

export class MinkaWalletDto {
  @IsString()
  handle: string;

  @IsObject()
  labels: MinkaWalletLabelsDto;

  @IsArray()
  signer: Array<string>;

  @IsString()
  default?: string;
}

export class MinkaWalletLabelsDto {
  @IsString()
  type?: string;

  @IsString()
  created?: string;

  @IsString()
  updated?: string;

  @IsString()
  createdBy?: string;

  @IsString()
  channelSms?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/errors/minka.error.signer.dto.ts
export class MinkaErrorSigner extends Error {
  constructor(response) {
    const statusCode = response.statusCode;
    const message = `Signer not found, status code: ${statusCode}`;
    super(message);
    this.name = 'MinkaErrorSigner';
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/minka/dto/errors/minka.error.transfer.dto.ts


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperPW/scraperPW.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { CreateTransferJobDto } from 'src/api/v2/transfer-job/dtos/create-transfer-job.dto';
import { TransferJobState } from 'src/common/enums/transfer-job-state.enum';
import { Environment } from 'src/common/enums/environment.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferJobService } from 'src/models/transfer-job/transfer-job.service';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ScraperCredentialsDto } from './dto/scraperPW.provider.credentials.dto';
import { Credential } from 'src/utils/encryption.util';
import { plainToClass } from 'class-transformer';
import { validateSync } from 'class-validator';
import { TransferJobEntity } from 'src/models/transfer-job/entities/transfer-job.entity';
import { AccountService } from 'src/models/account/account.service';
import { AccountEntity } from 'src/models/account/entities/account.entity';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';

interface JobEnvironmentVariable {
  name: string;
  value: string;
}

@Injectable()
export class ScraperPWService {
  private readonly logger = new Logger('ScraperPWService');

  constructor(
    private accountService: AccountService,
    private transferJobService: TransferJobService,
    private batchService: AwsBatchService,
  ) {}

  private validateCredentials(credentials: Credential): ScraperCredentialsDto {
    const credentialDto = plainToClass(ScraperCredentialsDto, credentials);
    const errors = validateSync(credentialDto);

    if (errors.length > 0) {
      const messages = errors.map((error) => {
        return Object.values(error.constraints).join(', ');
      });
      const message = messages.join(', ');
      throw new Error(message);
    }

    return credentialDto;
  }

  private buildCredentials(provider: ProviderEntity): ScraperCredentialsDto {
    const { decryptedCredentials } = provider;
    const credentialsDto = this.validateCredentials(decryptedCredentials);
    return credentialsDto;
  }

  private buildJobName(provider: ProviderEntity): string {
    const env = process.env.NODE_ENV as Environment;
    const credentials = this.buildCredentials(provider);

    const { bankAccessId, bankAccountId, bankCode } = credentials;

    const jobName = this.transferJobService.generateJobName({
      bankCode,
      bankAccessId: parseInt(bankAccessId),
      bankAccountId: parseInt(bankAccountId),
      env,
    });

    return jobName;
  }

  private buildEnvironmentVariables(
    provider: ProviderEntity,
    account: AccountEntity,
    transferJob: TransferJobEntity,
  ): JobEnvironmentVariable[] {
    const environment = process.env.NODE_ENV as Environment;
    const credentials = this.buildCredentials(provider);

    const { bankAccessId, bankAccountId } = credentials;

    const environmentVariables = [
      { name: 'BANK_CODE', value: account.bankCode.toString() },
      { name: 'BANK_ACCESS_ID', value: bankAccessId.toString() },
      { name: 'BANK_ACCOUNT_ID', value: bankAccountId.toString() },
      { name: 'ACCOUNT_ID', value: account.id.toString() },
      { name: 'PROVIDER_ID', value: provider.id.toString() },
      { name: 'TRANSFER_JOB_ID', value: transferJob.id.toString() },
      { name: 'PAYOUTS_API_VERSION', value: 'v2' },
      { name: 'NODE_ENV', value: environment },
    ];
    return environmentVariables;
  }

  private async enqueueJob(
    jobName: string,
    environmentVariables: JobEnvironmentVariable[],
  ) {
    const result = await this.batchService.submitBatchJob({
      job: AwsBatchJob.transfers,
      jobName,
      environmentVariables,
    });
    return result;
  }

  private async createTransferJob(providerId: number) {
    const createTransferJobDto: CreateTransferJobDto = {
      providerId,
      startedAt: new Date().toISOString(),
      state: TransferJobState.CREATED,
    };

    const createdTransferJob = await this.transferJobService.create(
      createTransferJobDto,
    );

    return createdTransferJob;
  }

  private async setTransferJobToError(transferJobId: number) {
    const endedAt = new Date().toISOString();

    const updatedTransferJob = await this.transferJobService.update(
      transferJobId,
      { state: TransferJobState.ERROR, endedAt },
    );

    return updatedTransferJob;
  }

  public async startScraper(
    provider: ProviderEntity,
  ): Promise<CreatedTransactionDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Scraper credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Scraper credentials.`,
      };
    }

    const credentials = this.buildCredentials(provider);

    const jobName = this.buildJobName(provider);
    // TODO review use of credentials.bankAccessId when Api v1 are deprecated
    const bankAccessId = parseInt(credentials.bankAccessId);

    try {
      const runningJob = await this.transferJobService.validateAnyRunningJob(
        jobName,
        bankAccessId,
      );

      // Scraper already running. No transaction occurred.
      if (runningJob) {
        return {
          message: `Scraper job already running.`,
          state: TransferState.ASSIGNED,
        };
      }
    } catch (error) {
      return {
        message: `Scraper job could not be verified. ${error?.message}`,
        state: TransferState.FAILED,
      };
    }

    let transferJob;

    try {
      transferJob = await this.createTransferJob(provider.id);
    } catch (error) {
      return {
        message: `Scraper job could not be created. ${error?.message}`,
        state: TransferState.FAILED,
      };
    }

    const account = await this.accountService.findOne(provider.accountId);

    try {
      const environmentVariables = this.buildEnvironmentVariables(
        provider,
        account,
        transferJob,
      );

      const awsResult = await this.enqueueJob(jobName, environmentVariables);

      if (!awsResult?.jobId) {
        return {
          message: `Scraper job could not be started. `,
          state: TransferState.FAILED,
        };
      }

      await this.transferJobService.update(transferJob.id, {
        jobId: awsResult.jobId,
      });

      return {
        jobId: awsResult.jobId,
        message: `Scraper job started successfully.`,
        state: TransferState.ASSIGNED,
      };
    } catch (error) {
      await this.setTransferJobToError(transferJob.id);
      return {
        message: `Scraper job could not be started. ${error?.message}`,
        state: TransferState.FAILED,
      };
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperPW/scraperPW.provider.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { Currency } from 'src/common/enums/currency.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { AwsBatchService } from 'src/services/aws/batch.service';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { ScraperPWProviderAdapter } from './scraperPW.provider';
import { ScraperPWService } from './scraperPW.service';
import { v4 as uuid } from 'uuid';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';

describe('ScraperPWProvider', () => {
  let service: ScraperPWProviderAdapter;
  const mockScraperPWService = {};
  const mockBatchService = {};
  const mockAccountStatementJobService = {};

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ScraperPWProviderAdapter,
        { provide: ScraperPWService, useValue: mockScraperPWService },
        { provide: AwsBatchService, useValue: mockBatchService },
        {
          provide: AccountStatementJobService,
          useValue: mockAccountStatementJobService,
        },
      ],
    }).compile();

    service = module.get<ScraperPWProviderAdapter>(ScraperPWProviderAdapter);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('When some code execute canCancelTransaction', () => {
    it("then shouldn't be capable if the transfer state is not in ('assigned', 'processing', 'failed' )", () => {
      const uncancelable = new Set([
        TransferState.COMPLETED,
        TransferState.CANCELED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncancelable) {
        const canCancelTransaction = service.canCancelTransaction({
          ...transactionDto,
          state,
        });

        expect(canCancelTransaction.capable).toEqual(false);
      }
    });
    it('then should be capable for cancel the transaction', () => {
      const cancelable = new Set([
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
      ]);

      const transactionDto: TransactionDto = {
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
        uuid: uuid(),
      };

      for (const state of cancelable) {
        const canCancelTransaction = service.canCancelTransaction({
          ...transactionDto,
          state,
        });

        expect(canCancelTransaction.capable).toEqual(true);
      }
    });
  });

  describe('When some code execute canCompleteTransaction', () => {
    it("then shouldn't be capable if the transfer state is not 'processing' or 'failed'", () => {
      const uncompletable = new Set([
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.COMPLETED,
        TransferState.CANCELED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncompletable) {
        const canCompleteTransaction = service.canCompleteTransaction({
          ...transactionDto,
          state,
        });

        expect(canCompleteTransaction.capable).toEqual(false);
      }
    });

    it('then should be capable for complete the transaction', () => {
      const completable = new Set([
        TransferState.PROCESSING,
        TransferState.FAILED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of completable) {
        const canCompleteTransaction = service.canCompleteTransaction({
          ...transactionDto,
          state,
        });

        expect(canCompleteTransaction.capable).toEqual(true);
      }
    });
  });

  describe('When some code execute canRetryTransaction', () => {
    it("then shouldn't be capable if the transfer state is 'completed'", () => {
      const unretriable = new Set([TransferState.COMPLETED]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of unretriable) {
        const canRetryTransaction = service.canRetryTransaction({
          ...transactionDto,
          state,
        });

        expect(canRetryTransaction.capable).toEqual(false);
      }
    });

    it('then should be capable for reassign the transaction', () => {
      const retriable = new Set([
        TransferState.PENDING,
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
        TransferState.CANCELED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of retriable) {
        const canRetryTransaction = service.canRetryTransaction({
          ...transactionDto,
          state,
        });

        expect(canRetryTransaction.capable).toEqual(true);
      }
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperPW/scraperPW.provider.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { ScraperPWService } from './scraperPW.service';
import { AccountStatementJobService } from 'src/models/account-statement-job/account-statement-job.service';
import { FindOneOptions } from 'typeorm';
import { AccountStatementJobEntity } from 'src/models/account-statement-job/entities/account-statement-job.entity';
import { AccountStatementJobState } from 'src/common/enums/account-statement-job.enum';
import { SortOrder } from 'src/utils/array-methods.util';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { Errors } from 'src/common/enums/errors.enum';

@Injectable()
export class ScraperPWProviderAdapter extends BaseProviderAdapter {
  @Inject(ScraperPWService)
  private scraperPWService: ScraperPWService;
  @Inject(AccountStatementJobService)
  private accountStatementJobService: AccountStatementJobService;

  public providerType = ProviderType.ScraperPW;
  private readonly logger = new Logger('ScraperPWProvider');

  public get cancelableStates(): TransferState[] {
    return [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
    ];
  }

  public get completableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.FAILED];
  }

  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    const { capable, error } = this.canCreateTransaction(transactionDto);

    if (!capable) {
      this.logger.debug(error);
      return {
        message: error,
        state: TransferState.FAILED,
      };
    }

    const transaction = await this.scraperPWService.startScraper(provider);

    return transaction;
  }

  public getTransactionState(
    _provider: ProviderEntity,
    _transactionId: string,
  ): Promise<TransactionStateDto> {
    throw new Error('Method not implemented.');
  }

  public async getBalance(
    provider: ProviderEntity,
  ): Promise<AccountBalanceDto> {
    if (!provider.capabilities.includes(ProviderCapability.READ_TRANSFER)) {
      throw new Error(Errors.MISSING_READ_TRANSFER_CAPABILITY);
    }

    const options: FindOneOptions<AccountStatementJobEntity> = {
      where: {
        state: AccountStatementJobState.FINISHED,
        accountId: provider.account.id,
      },
      order: {
        endedAt: SortOrder.DESCENDING,
      },
    };

    const latestJob = await this.accountStatementJobService.findOneByConditions(
      options,
    );

    if (isNaN(latestJob?.balance)) {
      throw new Error("Can't get balance for the account.");
    }

    return {
      currency: provider.account.currency,
      balance: latestJob.balance,
      retrievedAt: latestJob.retrievedAt,
    };
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { destinationAccount, destinationName, destinationHolderId } =
      transactionDto;

    if (!destinationAccount || !destinationName || !destinationHolderId) {
      return { capable: false, error: 'Missing recipient information' };
    }

    return { capable: true };
  }

  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;
    const cancelableStates = this.cancelableStates;
    const cancelable = cancelableStates.includes(state);
    if (cancelable) return { capable: true };

    return {
      capable: false,
      error: `Scraper provider cannot cancel ${state} transactions`,
    };
  }

  public canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility {
    const { state } = transactionDto;

    const completableStates = this.completableStates;
    const completable = completableStates.includes(state);

    if (completable) return { capable: true };

    return {
      capable: false,
      error: `Scraper provider cannot complete ${state} transactions`,
    };
  }
  public canRetryTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;

    const retriableStates = [
      TransferState.PENDING,
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
      TransferState.CANCELED,
    ];

    const isRetriable = retriableStates.includes(state);

    if (isRetriable) return { capable: true };

    return {
      capable: false,
      error: `Scraper provider cannot retry ${state} transactions`,
    };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperPW/dto/scraperPW.provider.credentials.dto.ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Credential } from 'src/utils/encryption.util';

export interface ScraperCredentials extends Credential {
  username: string;
  password: string;
  documentNumber?: string;
  bankCode: string;
  bankAccountId: string;
  bankAccessId: string;
}

export class ScraperCredentialsDto {
  @IsString()
  @IsNotEmpty()
  username: string;

  @IsString()
  @IsNotEmpty()
  password: string;

  @IsString()
  @IsOptional()
  documentNumber: string;

  @IsString()
  @IsNotEmpty()
  bankCode: string;

  @IsString()
  @IsNotEmpty()
  bankAccountId: string;

  @IsString()
  @IsNotEmpty()
  bankAccessId: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperPW/scraperPW.provider.module.ts
import { Module } from '@nestjs/common';
import { TransferJobModule } from 'src/models/transfer-job/transfer-job.module';
import { AwsModule } from 'src/services/aws/aws.module';
import { ScraperPWProviderAdapter } from './scraperPW.provider';
import { ScraperPWService } from './scraperPW.service';
import { AccountModule } from 'src/models/account/account.module';
import { AccountStatementJobModule } from 'src/models/account-statement-job/account-statement-job.module';

@Module({
  imports: [
    AwsModule,
    TransferJobModule,
    AccountModule,
    AccountStatementJobModule,
  ],
  providers: [ScraperPWProviderAdapter, ScraperPWService],
  exports: [ScraperPWProviderAdapter],
})
export class ScraperPWProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperCG/scraperCG.provider.ts
import { Injectable } from '@nestjs/common';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';

@Injectable()
export class ScraperCGProviderAdapter extends BaseProviderAdapter {
  public providerType: ProviderType = ProviderType.ScraperCG;

  public get cancelableStates(): TransferState[] {
    return [
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
    ];
  }

  public get completableStates(): TransferState[] {
    return [TransferState.PROCESSING];
  }

  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  /**
   * Always return undefined
   * @param _provider
   * @param _transactionDto
   * @returns ```undefined```
   */
  public async createTransaction(
    _provider: ProviderEntity,
    _transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    return undefined;
  }

  public getTransactionState(
    _provider: ProviderEntity,
    _transactionId: string,
  ): Promise<TransactionStateDto> {
    throw new Error('Method not implemented.');
  }
  public getBalance(_provider: ProviderEntity): Promise<AccountBalanceDto> {
    throw new Error('Method not implemented.');
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { destinationAccount, destinationName, destinationHolderId } =
      transactionDto;

    if (!destinationAccount || !destinationName || !destinationHolderId) {
      return { capable: false, error: 'Recipient information is required' };
    }

    return { capable: true };
  }
  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;
    const cancelable = this.cancelableStates;

    if (!cancelable.includes(state)) {
      return {
        capable: false,
        error: `Can't cancel transaction with state ${state}`,
      };
    }

    return { capable: true };
  }
  public canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility {
    const { state } = transactionDto;

    const completable = this.completableStates;

    if (!completable.includes(state)) {
      return {
        capable: false,
        error:
          "Can't complete transaction, only transactions with 'processing' state could be completed",
      };
    }

    return { capable: true };
  }
  public canRetryTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;

    const reassignable = new Set([
      TransferState.ASSIGNED,
      TransferState.PROCESSING,
      TransferState.FAILED,
      TransferState.CANCELED,
    ]);

    if (!reassignable.has(state)) {
      return {
        capable: false,
        error: `Can't reassign transaction with state ${state}.`,
      };
    }

    return { capable: true };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperCG/scraperCG.provider.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { v4 as uuid } from 'uuid';

import { ScraperCGProviderAdapter } from './scraperCG.provider';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { Currency } from 'src/common/enums/currency.enum';

describe('ScraperCGProvider', () => {
  let service: ScraperCGProviderAdapter;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ScraperCGProviderAdapter],
    }).compile();

    service = module.get<ScraperCGProviderAdapter>(ScraperCGProviderAdapter);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('When some code execute canCancelTransaction', () => {
    it("then shouldn't be capable if the transfer state is not in ('assigned', 'processing', 'failed' )", () => {
      const uncancelable = new Set([
        TransferState.CANCELED,
        TransferState.COMPLETED,
        TransferState.PENDING,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncancelable) {
        const canCancelTransaction = service.canCancelTransaction({
          ...transactionDto,
          state,
        });

        expect(canCancelTransaction.capable).toEqual(false);
      }
    });
    it('then should be capable for cancel the transaction', () => {
      const uncancelable = new Set([
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncancelable) {
        const canCancelTransaction = service.canCancelTransaction({
          ...transactionDto,
          state,
        });

        expect(canCancelTransaction.capable).toEqual(true);
      }
    });
  });

  describe('When some code execute canCompleteTransaction', () => {
    it("then shouldn't be capable if the transfer state is not 'processing'", () => {
      const uncompletable = new Set([
        TransferState.ASSIGNED,
        TransferState.CANCELED,
        TransferState.PENDING,
        TransferState.COMPLETED,
        TransferState.FAILED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: null,
        providerId: 1,
      };

      for (const state of uncompletable) {
        const canCompleteTransaction = service.canCompleteTransaction({
          ...transactionDto,
          state,
        });

        expect(canCompleteTransaction.capable).toEqual(false);
      }
    });

    it('then should be capable for complete the transaction', () => {
      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.PROCESSING,
        providerId: 1,
      };

      const canCompleteTransaction =
        service.canCompleteTransaction(transactionDto);

      expect(canCompleteTransaction.capable).toEqual(true);
    });
  });

  describe('When some code execute canRetryTransaction', () => {
    it("then shouldn't be capable if the transfer state is not 'processing'", () => {
      const uncompletable = new Set([
        TransferState.COMPLETED,
        TransferState.PENDING,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncompletable) {
        const canRetryTransaction = service.canRetryTransaction({
          ...transactionDto,
          state,
        });

        expect(canRetryTransaction.capable).toEqual(false);
      }
    });

    it('then should be capable for reassign the transaction', () => {
      const uncompletable = new Set([
        TransferState.ASSIGNED,
        TransferState.PROCESSING,
        TransferState.FAILED,
        TransferState.CANCELED,
      ]);

      const transactionDto: TransactionDto = {
        uuid: uuid(),
        currency: Currency.CHILE,
        amount: 100,
        state: TransferState.ASSIGNED,
        providerId: 1,
      };

      for (const state of uncompletable) {
        const canRetryTransaction = service.canRetryTransaction({
          ...transactionDto,
          state,
        });

        expect(canRetryTransaction.capable).toEqual(true);
      }
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/scraperCG/scraperCG.provider.module.ts
import { Module } from '@nestjs/common';
import { ScraperCGProviderAdapter } from './scraperCG.provider';

@Module({
  providers: [ScraperCGProviderAdapter],
  exports: [ScraperCGProviderAdapter],
})
export class ScraperCGProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/mock/mock-provider.service.ts
import { Logger } from '@nestjs/common';
import { randWord } from '@ngneat/falso';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';

export class MockProviderService extends BaseProviderAdapter {
  private readonly logger = new Logger('MockProvider');
  public providerType: ProviderType = ProviderType.Minka;

  public get cancelableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get completableStates(): TransferState[] {
    return [];
  }
  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    let state: TransferState;
    let message: string;
    let externalId: string;

    this.logger.log('Creating mock transaction');

    const canCreateTransaction = this.canCreateTransaction(transactionDto);

    if (!canCreateTransaction) {
      this.logger.log("Can't create transaction");
      return;
    }

    if (transactionDto.amount < 0) {
      this.logger.log(
        `Processing mock transaction with invalid amount: ${transactionDto.amount}`,
      );
      state = TransferState.FAILED;
      message = 'El monto de la transferencia debe ser mayor que cero';
    } else {
      this.logger.log('Processing mock transaction');
      state = TransferState.PROCESSING;
      externalId = randWord();
    }

    return Promise.resolve({
      message,
      state,
      externalId,
    });
  }
  public getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    this.logger.log('Getting mock transaction state');

    const result: TransactionStateDto = { state: TransferState.COMPLETED };

    if (transactionId === 'failed') {
      result.state = TransferState.FAILED;
      result.message = 'Ocurrió un error al procesar la transacción';
    }

    return Promise.resolve(result);
  }
  public getBalance(): Promise<AccountBalanceDto> {
    throw new Error('Method not implemented.');
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    if (transactionDto.amount <= 0)
      return { capable: false, error: 'The amout must be grather than cero' };

    return { capable: true };
  }

  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;
    if (!this.cancelableStates.includes(state)) {
      return {
        capable: false,
        error: 'Cannot cancel a transaction with state different from failed',
      };
    }

    return { capable: true };
  }

  public canCompleteTransaction(
    _transactionDto: TransactionDto,
  ): ProviderAbility {
    return { capable: true };
  }

  public canRetryTransaction(_transactionDto: TransactionDto): ProviderAbility {
    return { capable: true };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/thomas/thomas.provider.ts
import { Inject, Injectable, Logger } from '@nestjs/common';
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { HttpService } from '@nestjs/axios';
import thomasConfig from 'src/config/thomas.config';
import { ConfigType } from '@nestjs/config';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { Environment } from 'src/common/enums/environment.enum';

@Injectable()
export class ThomasProviderAdapter extends BaseProviderAdapter {
  @Inject()
  private http: HttpService;
  @Inject(thomasConfig.KEY)
  private config: ConfigType<typeof thomasConfig>;

  public providerType: ProviderType = ProviderType.Thomas;

  public get cancelableStates(): TransferState[] {
    return [TransferState.FAILED];
  }

  public get completableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.FAILED];
  }

  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    _provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    try {
      if (process.env.NODE_ENV === Environment.PRODUCTION) {
        throw new Error('Production environment is not allowed');
      }

      const { id, concept, amount } = transactionDto;

      const payload = {
        transferId: id,
        message: concept,
        state: Number(amount) === 9999 ? TransferState.FAILED : undefined,
      };

      const response = await this.http.axiosRef.post(
        `${this.config.apiUrl}/transactions`,
        payload,
      );

      const { status } = response;

      if (status === 201) return { state: TransferState.PROCESSING };

      throw new Error(`Failed to create transaction. Status: ${status}`);
    } catch (error) {
      Logger.error(error.message);
      return {
        state: TransferState.FAILED,
        message: `Can't create transaction: ${error.message}`,
      };
    }
  }
  public getTransactionState(
    _provider: ProviderEntity,
    _transactionId: string,
  ): Promise<TransactionStateDto> {
    throw new Error('Method not implemented.');
  }
  public getBalance(_provider: ProviderEntity): Promise<AccountBalanceDto> {
    throw new Error('Method not implemented.');
  }
  public canCreateTransaction(
    _transactionDto: TransactionDto,
  ): ProviderAbility {
    return { capable: true };
  }
  public canCancelTransaction(
    _transactionDto: TransactionDto,
  ): ProviderAbility {
    return { capable: true };
  }
  public canCompleteTransaction(
    _transactionDto: TransactionDto,
  ): ProviderAbility {
    return { capable: true };
  }
  public canRetryTransaction(_transactionDto: TransactionDto): ProviderAbility {
    return { capable: true };
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/thomas/thomas.provider.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ThomasProviderAdapter } from './thomas.provider';
import { HttpService } from '@nestjs/axios';
import thomasConfig from 'src/config/thomas.config';
import { Environment } from 'src/common/enums/environment.enum';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { TransferState } from 'src/common/enums/transfer-state.enum';

describe('ThomasProvider', () => {
  let service: ThomasProviderAdapter;
  let mockHttpService: { axiosRef: { post: jest.Mock<any, any> } };

  beforeEach(async () => {
    mockHttpService = {
      axiosRef: {
        post: jest.fn().mockResolvedValue({ status: 201 }),
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ThomasProviderAdapter,
        { provide: HttpService, useValue: mockHttpService },
        { provide: thomasConfig.KEY, useValue: {} },
      ],
    }).compile();

    service = module.get<ThomasProviderAdapter>(ThomasProviderAdapter);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('When some code executes createTransaction', () => {
    const provider = { id: 1, name: 'provider' } as ProviderEntity;
    it('then should not create the transaction if the environment is production', async () => {
      process.env.NODE_ENV = Environment.PRODUCTION;

      const transaction = { id: 1, amount: 1000 } as TransactionDto;

      const response = await service.createTransaction(provider, transaction);

      expect(mockHttpService.axiosRef.post).not.toHaveBeenCalled();
      expect(response.state).toEqual(TransferState.FAILED);
      process.env.NODE_ENV = Environment.TEST;
    });

    it('should call the provider with correct payload including "state" as "failed" when transaction amount is 9999', async () => {
      const transaction = { id: 1, amount: 9999 } as TransactionDto;

      const response = await service.createTransaction(provider, transaction);

      expect(mockHttpService.axiosRef.post).toHaveBeenCalled();
      expect(response.state).toEqual(TransferState.PROCESSING);
      expect(mockHttpService.axiosRef.post).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          state: TransferState.FAILED,
        }),
      );
    });

    it('should call the provider with correct payload', async () => {
      const transaction = {
        id: 1,
        amount: 9999,
        concept: 'concept',
      } as TransactionDto;

      const response = await service.createTransaction(provider, transaction);

      expect(mockHttpService.axiosRef.post).toHaveBeenCalled();
      expect(response.state).toEqual(TransferState.PROCESSING);
      expect(mockHttpService.axiosRef.post).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          transferId: transaction.id,
          message: transaction.concept,
        }),
      );
    });

    it('then should return and object containing "state" as "failed" if the provider response is unsuccessful', async () => {
      const transaction = {
        id: 1,
        amount: 9999,
        concept: 'concept',
      } as TransactionDto;

      mockHttpService.axiosRef.post.mockRejectedValueOnce({ status: 400 });

      const response = await service.createTransaction(provider, transaction);

      expect(mockHttpService.axiosRef.post).toHaveBeenCalled();
      expect(response.state).toEqual(TransferState.FAILED);
    });
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/thomas/thomas.module.ts
import { Module } from '@nestjs/common';
import { ThomasProviderAdapter } from './thomas.provider';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule } from '@nestjs/config';
import thomasConfig from 'src/config/thomas.config';

@Module({
  imports: [HttpModule, ConfigModule.forFeature(thomasConfig)],
  providers: [ThomasProviderAdapter],
  exports: [ThomasProviderAdapter],
})
export class ThomasModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.enum.ts
export enum ShinkansenTransactionStatus {
  OK = 'ok',
  ERROR = 'error',
  PENDING = 'pending',
}

export enum ShinkansenBankSchema {
  SHINKANSEN = 'SHINKANSEN',
  CLCMF = 'CLCMF',
}

export enum HolderIdSchema {
  // Chile
  CLID = 'CLID',
  // Colombia
  COCC = 'COCC',
  COTI = 'COTI',
  CONUIP = 'CONUIP',
  COCE = 'COCE',
  PASS = 'PASS',
  CONIT = 'CONIT',
  // Mexico
  MXRFC = 'MXRFC',
  MXCURP = 'MXCURP',
  // Perú
  PEDNI = 'PEDNI',
  PERUC = 'PERUC',
}

export enum AccountType {
  CASH_ACCOUNT = 'cash_account', // CL
  CURRENT_ACCOUNT = 'current_account', // CL, CO, MX, PE
  SAVINGS_ACCOUNT = 'savings_account', // CL, CO, MX, PE
  ELECTRONIC_DEPOSIT = 'electronic_deposit', // CO
  CLABE = 'clabe', // MX
  DEBIT_CARD = 'debit_card', // MX
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/state.spec.ts
import { ShinkansenTransactionStatus } from '../shinkansen.provider.enum';
import { translateShinkansenStatus } from './state';
import { TransferState } from 'src/common/enums/transfer-state.enum';

describe('translateShinkansenStatus', () => {
  it('should return null if no state is provided', () => {
    expect(translateShinkansenStatus(null)).toBe(null);
  });

  it('should return null if the state is not mapped', () => {
    expect(
      translateShinkansenStatus('not mapped' as ShinkansenTransactionStatus),
    ).toBe(null);
  });

  it('should return the mapped state for the OK status', () => {
    expect(translateShinkansenStatus(ShinkansenTransactionStatus.OK)).toBe(
      TransferState.COMPLETED,
    );
  });

  it('should return the mapped state for the pending status', () => {
    expect(translateShinkansenStatus(ShinkansenTransactionStatus.PENDING)).toBe(
      TransferState.PROCESSING,
    );
  });

  it('should return the mapped state for the error status', () => {
    expect(translateShinkansenStatus(ShinkansenTransactionStatus.ERROR)).toBe(
      TransferState.FAILED,
    );
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/verifier.spec.ts
import { SignatureVerifier } from './verifier';
import * as forge from 'node-forge';
import { createCertificate, createDetachedJws } from './verifier-test-code';

describe('SignatureVerifier', () => {
  it('should throw an error if signature is not a detached jws', () => {
    const jws = 'fakejws';
    expect(() => new SignatureVerifier(jws)).toThrow(
      'Invalid detached signature',
    );
  });
  const keyPair = forge.pki.rsa.generateKeyPair({ bits: 2048, e: 0x10001 });
  const certificate = createCertificate(keyPair.publicKey, keyPair.privateKey);
  it('should return true if all goes ok', async () => {
    const payload = { hello: 'world' };

    const detachedSignature = await createDetachedJws(
      keyPair.privateKey,
      certificate,
      payload,
    );

    const verifier = new SignatureVerifier(detachedSignature);
    const verified = await verifier.verify(payload, certificate, 'PS256');
    expect(verified).toBe(true);
  });
  it('should return false if is using other private key', async () => {
    const keyPairSecond = forge.pki.rsa.generateKeyPair({
      bits: 2048,
      e: 0x10001,
    });
    const payload = { id: 2 };
    const otherCertificate = createCertificate(
      keyPair.publicKey,
      keyPairSecond.privateKey,
    );
    const detachedSignature = await createDetachedJws(
      keyPairSecond.privateKey,
      otherCertificate,
      payload,
    );

    const verifier = new SignatureVerifier(detachedSignature);
    const verified = await verifier.verify(payload, otherCertificate, 'PS256');
    expect(verified).toBe(false);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/verifier.ts
import { Logger } from '@nestjs/common';
import * as jose from 'jose';
import * as forge from 'node-forge';
import {
  CertificateType,
  formatPem,
  stripPemHeaders,
} from 'src/utils/certificates.util';

const logger = new Logger('ShinkansenSignatureVerifier');

/**
 * A class that represents a certificate
 */
export class Certificate {
  public pem: string;
  public _publicKey?: jose.KeyLike;

  /**
   * @param pem - The certificate in PEM format
   * @example
   * const certificate = new Certificate('-----BEGIN CERTIFICATE-----\nMIIB..');
   * @throws {Error} - If the certificate is invalid
   */
  constructor(pem: string) {
    this.pem = pem;
    if (!this.valid) {
      throw new Error('Invalid certificate');
    }
  }

  /**
   * @returns The certificate in PEM format (only base64 content, no headers)
   */
  public get base64(): string {
    return stripPemHeaders(this.pem);
  }

  /**
   * @returns The public key of the certificate in JWK format (jose.KeyLike)
   * @throws {Error} - If the certificate is not built
   */
  public get publicKey(): jose.KeyLike {
    if (!this._publicKey) {
      throw new Error('Certificate not built');
    }

    return this._publicKey;
  }

  /**
   * @returns Whether the certificate is valid
   * @example
   * const certificate = new Certificate('-----BEGIN CERTIFICATE-----\nMIIB..');
   * console.log(certificate.valid); // true
   * @example
   * const certificate = new Certificate('-----BEGIN PRIVATE KEY-----\nMIIB..');
   * console.log(certificate.valid); // false
   */
  private get valid(): boolean {
    try {
      forge.pki.certificateFromPem(this.pem);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Imports the certificate and builds the public key
   * @returns A promise that resolves when the public key is built
   */
  public async build(): Promise<jose.KeyLike> {
    this._publicKey = await jose.importX509(this.pem, 'ES256');
    return this._publicKey;
  }
}

/**
 * A class that represents a JWS signature
 */
export class JwsSignature {
  private detachedSignature: string;
  private protectedHeader: string;
  private signature: string;
  private payload?: Payload;

  /**
   * @param detachedSignature - The detached signature in the format 'header..signature'
   * @example
   * const signature = new JwsSignature('header..signature');
   * @throws {Error} - If the signature is invalid
   */
  constructor(detachedSignature: string) {
    this.detachedSignature = detachedSignature;
    if (!this.valid) {
      throw new Error('Invalid detached signature');
    }

    const { header, signature } = this.parse();
    this.protectedHeader = header;
    this.signature = signature;
  }

  /**
   * @returns The detached signature in the format 'header..signature'
   */
  public get detachedJws(): string {
    return `${this.protectedHeader}..${this.signature}`;
  }

  /**
   * @returns The compact JWS in the format 'header.payload.signature'
   * @throws {Error} - If the payload is not attached
   */
  public get compactJws(): string {
    if (!this.payload) {
      throw new Error('Payload not attached');
    }

    const payload = this.payload.encoded;
    const jws = `${this.protectedHeader}.${payload}.${this.signature}`;
    return jws;
  }

  /**
   * @returns The flattened JWS in the format { protected, payload, signature }
   * @throws {Error} - If the payload is not attached
   */
  public get flattenedJws(): jose.FlattenedJWSInput {
    if (!this.payload) {
      throw new Error('Payload not attached');
    }

    return {
      signature: this.signature,
      protected: this.protectedHeader,
      payload: this.payload.arrayBuffer,
    };
  }

  /**
   * @returns Whether the signature is valid (detached JWS) against a regex
   * @example
   * const signature = new JwsSignature('header..signature');
   * console.log(signature.valid); // true
   */
  private get valid(): boolean {
    const jwsRegex = /^[A-Za-z0-9_-]+\.{2}[A-Za-z0-9_-]+$/;

    if (typeof this.detachedSignature !== 'string') return false;
    if (!jwsRegex.test(this.detachedSignature)) return false;

    const { header, signature } = this.parse();

    const validHeader = this.validateHeader(header);
    const validSignature = jose.base64url.decode(signature) !== null;
    return validHeader && validSignature;
  }

  public get certificates(): Certificate[] {
    const header = this.parseHeader(this.protectedHeader);
    const base64Certificates = header['x5c'];
    // validate base64Certificates is an array of strings
    const certificates = base64Certificates.map((base64Certificate: string) => {
      const pemCertificate = formatPem(
        base64Certificate,
        CertificateType.CERTIFICATE,
      );
      return new Certificate(pemCertificate);
    });
    return certificates;
  }

  public parseHeader(protectedHeader: string): object {
    const headerArray = jose.base64url.decode(protectedHeader);
    const headerString = Buffer.from(headerArray).toString('utf-8');
    const header = JSON.parse(headerString);
    return header;
  }

  /**
   * @returns Whether the header is valid JSON
   * @param header - The header to validate
   */
  private validateHeader(protectedHeader: string): boolean {
    try {
      this.parseHeader(protectedHeader);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * @returns The header and signature of the detached signature
   */
  private parse(): { header: string; signature: string } {
    const [header, signature] = this.detachedSignature.split('..');
    return { header, signature };
  }

  /**
   * Attaches a payload to the signature (to complete the detached JWS)
   * @param payload - The payload to attach
   * @example
   * const signature = new JwsSignature('header..signature');
   * const payload = new Payload({ foo: 'bar' });
   * signature.attachPayload(payload);
   */
  public attachPayload(payload: Payload): void {
    this.payload = payload;
  }

  /**
   * Verifies if any of the trusted certificates match the signature's certificate (header x5c field)
   * @param whitelist - The trusted certificates
   * @returns Whether the certificate is whitelisted
   */
  public validateIdentity(whitelist: Certificate[]): boolean {
    // whitelist certificate against signature certificates
    const whitelistedCertificates = whitelist.map((cert) => cert.base64);
    const receivedCertificates = this.certificates.map((cert) => cert.base64);

    const whitelisted = receivedCertificates.some((receivedCertificate) => {
      return whitelistedCertificates.includes(receivedCertificate);
    });

    if (!whitelisted) {
      return false;
    }

    return true;
  }
}

/**
 * A class that represents a JWS payload (claims)
 */
export class Payload {
  private payload: object;

  /**
   * @param payload - The payload to attach
   * @example
   * const payload = new Payload({ foo: 'bar' });
   */
  constructor(payload: object) {
    this.payload = payload;
  }

  /**
   * @returns The payload in JSON format
   */
  public get json(): string {
    const data = JSON.stringify(this.payload);
    return data;
  }

  /**
   * @returns The payload in ArrayBuffer format
   */
  public get arrayBuffer(): Uint8Array {
    const buffer = Buffer.from(this.json, 'utf-8');
    const arrayBuffer = new Uint8Array(buffer);
    return arrayBuffer;
  }

  /**
   * @returns The payload in base64url format
   */
  public get encoded(): string {
    const base64 = jose.base64url.encode(this.arrayBuffer);
    return base64;
  }
}

/**
 * A class that allows detached JWS verification using a certificate and a payload
 */
export class SignatureVerifier {
  public signature: JwsSignature;

  /**
   * @param signature - The signature to verify (detached JWS)
   * @example
   * const verifier = new Verifier('eyJhbGci..ZmFrZSBzaW');
   */
  constructor(signature: string) {
    this.signature = new JwsSignature(signature);
  }

  /**
   * @param data - The data to verify
   * @param cert - The certificate to use for verification (PEM format)
   * @param algorithm - The algorithm to use for verification
   * @returns A promise that resolves to a boolean indicating whether the verification was successful
   * @example
   * const verifier = new Verifier('eyJhbGci..ZmFrZSBzaW');
   * const isVerified = await verifier.verify({ foo: 'bar' }, 'MIIF..ZmFrZSBzaW', 'ES256');
   *
   */
  public async verify(
    data: object,
    cert: string,
    algorithm = 'PS256',
  ): Promise<boolean> {
    const trustedCertificate = new Certificate(cert);
    const publicKey = await trustedCertificate.build();

    const whitelist = [trustedCertificate];
    const whitelisted = this.signature.validateIdentity(whitelist);

    if (!whitelisted) {
      logger.error(
        'Shinkansen signature verification failed: Certificate is not whitelisted',
      );
      return false;
    }

    const payload = new Payload(data);
    this.signature.attachPayload(payload);

    const flattenedJws = this.signature.flattenedJws;

    try {
      const result = await jose.flattenedVerify(flattenedJws, publicKey, {
        algorithms: [algorithm],
      });
      if (result) return true;

      throw new Error('Verification result is not present');
    } catch (error) {
      logger.debug(
        'Shinkansen signature verification failed: JWS validation failed',
      );
      logger.error(error);
      return false;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/verifier-test-code.ts
import * as jose from 'jose';
import * as forge from 'node-forge';
import {
  convertPKCS1toPKCS8,
  stripPemHeaders,
} from '../../../utils/certificates.util';

export function createCertificate(
  publicKey: forge.pki.rsa.PublicKey,
  privateKey: forge.pki.rsa.PrivateKey,
) {
  const cert = forge.pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = '01';
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);

  // use your own attributes here, or supply a csr (check the docs)
  const attrs = [
    {
      name: 'commonName',
      value: 'example.org',
    },
  ];

  // here we set subject and issuer as the same one
  cert.setSubject(attrs);
  cert.setIssuer(attrs);

  // the actual certificate signing
  cert.sign(privateKey);

  // now convert the Forge certificate to PEM format
  const pem = forge.pki.certificateToPem(cert);
  return pem;
}

export async function createDetachedJws(
  privateKey: forge.pki.rsa.PrivateKey,
  certificate: string,
  payload: object,
) {
  const base64cert = stripPemHeaders(certificate);

  const serializedPayload = new Uint8Array(
    Buffer.from(JSON.stringify(payload), 'utf-8'),
  );
  const jws = await new jose.FlattenedSign(serializedPayload);

  jws.setProtectedHeader({
    alg: 'PS256',
    b64: false,
    crit: ['b64'],
    x5c: [base64cert],
  });

  const privateKeyPem = forge.pki.privateKeyToPem(privateKey);
  const pkcs8 = convertPKCS1toPKCS8(privateKeyPem);
  const key = await jose.importPKCS8(pkcs8, 'PS256');

  const signature = await jws.sign(key);
  const detachedSignature = `${signature.protected}..${signature.signature}`;
  return detachedSignature;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/format.spec.ts
import { HolderIdSchema } from '../shinkansen.provider.enum';
import { formatHolderId, isBlank } from './format';

describe('formatHolderId', () => {
  it('should format holder id', () => {
    expect(formatHolderId('12345678', HolderIdSchema.CLID)).toBe('1234567-8');
  });

  it('should return the same holder id if the schema is not CLID', () => {
    expect(formatHolderId('12345678', 'CUIL' as HolderIdSchema)).toBe(
      '12345678',
    );
  });
});

describe('isBlank', () => {
  it('should return true if the value is null', () => {
    expect(isBlank(null)).toBe(true);
  });

  it('should return true if the value is undefined', () => {
    expect(isBlank(undefined)).toBe(true);
  });

  it('should return true if the value is an empty string', () => {
    expect(isBlank('')).toBe(true);
  });

  it('should return false if the value is made of only spaces', () => {
    expect(isBlank('   ')).toBe(true);
  });

  it('should return false if the value is not null, undefined or an empty string', () => {
    expect(isBlank('not blank')).toBe(false);
  });
});


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/state.ts
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ShinkansenPayoutStatus } from 'src/common/enums/shinkansen-payout-state.enum';
import { ShinkansenTransactionStatus } from '../shinkansen.provider.enum';

const ShinkansenStatusMap = {
  [ShinkansenPayoutStatus.OK]: TransferState.COMPLETED,
  [ShinkansenPayoutStatus.PENDING]: TransferState.PROCESSING,
  [ShinkansenPayoutStatus.ERROR]: TransferState.FAILED,
};

export function translateShinkansenStatus(
  status: ShinkansenTransactionStatus,
): TransferState {
  if (!status) return null;

  const transferState = ShinkansenStatusMap[status];
  return transferState ?? null;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/utils/format.ts
import { HolderIdSchema } from '../shinkansen.provider.enum';

export function formatHolderId(
  holderId: string,
  schema: HolderIdSchema,
): string {
  if (schema === HolderIdSchema.CLID) {
    const identifier = holderId.slice(0, -1);
    const verificationDigit = holderId.slice(-1);
    const formattedId = `${identifier}-${verificationDigit}`;
    return formattedId;
  }

  if (schema === HolderIdSchema.PERUC) {
    return holderId.replace(/\D/g, '');
  }

  return holderId;
}

export function isBlank(value: string): boolean {
  return !value || /^\s*$/.test(value);
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.ts
import { BaseProviderAdapter, ProviderAbility } from '../base.provider';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { AccountBalanceDto } from '../common/dtos/account-balance.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { ShinkansenProviderService } from './shinkansen.provider.service';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { Inject, Injectable, Logger } from '@nestjs/common';
import { Currency } from 'src/common/enums/currency.enum';
import { TransactionDto } from '../common/dtos/transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ShinkansenTransactionUpdateDto } from 'src/api/v2/provider/webhooks/dto/shinkansen-transaction-update.dto';
import { SortOrder, sortByField } from 'src/utils/array-methods.util';
import { ProviderCapability } from 'src/common/enums/provider-capability.enum';
import { Errors } from 'src/common/enums/errors.enum';

@Injectable()
export class ShinkansenProvider extends BaseProviderAdapter {
  public providerType: ProviderType = ProviderType.Shinkansen;
  private readonly logger = new Logger('ShinkansenProviderClientLogger');
  @Inject()
  private shinkansenService: ShinkansenProviderService;

  public get cancelableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get completableStates(): TransferState[] {
    return [TransferState.FAILED];
  }
  public get failableStates(): TransferState[] {
    return [TransferState.PROCESSING, TransferState.ASSIGNED];
  }

  public async createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto> {
    const { capable, error } = this.canCreateTransaction(transactionDto);

    if (!capable) {
      this.logger.debug(error);
      return {
        message: error,
        state: TransferState.FAILED,
      };
    }

    const transaction = await this.shinkansenService.createTransaction(
      transactionDto,
      provider,
    );

    return transaction;
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    try {
      const transactionState = await this.shinkansenService.getTransactionState(
        provider,
        transactionId,
      );
      return transactionState;
    } catch (e) {
      this.logger.debug('ShinkansenProvider getTransactionState error');
      this.logger.error(e);
      throw new Error('ShinkansenProvider getTransactionState error');
    }
  }

  public async getBalance(
    provider: ProviderEntity,
  ): Promise<AccountBalanceDto> {
    if (!provider.capabilities.includes(ProviderCapability.READ_TRANSFER)) {
      throw new Error(Errors.MISSING_READ_TRANSFER_CAPABILITY);
    }

    const shinkansenBalance = await this.shinkansenService.getBalance(provider);

    const latestBalance = sortByField(
      shinkansenBalance.balances,
      'timestamp',
      SortOrder.DESCENDING,
    ).at(0);

    return {
      balance: Number(latestBalance.available_balance),
      currency: provider.account.currency,
      retrievedAt: new Date(latestBalance.timestamp),
    };
  }

  public canCreateTransaction(transactionDto: TransactionDto): ProviderAbility {
    if (transactionDto.currency !== Currency.CHILE) {
      return {
        capable: false,
        error: 'The currency of the transaction must be CLP',
      };
    }

    return {
      capable: true,
    };
  }

  public canCancelTransaction(transactionDto: TransactionDto): ProviderAbility {
    const { state } = transactionDto;
    const cancelableStates = this.cancelableStates;

    if (cancelableStates.includes(state)) return { capable: true };

    return {
      capable: false,
      error: 'Shinkansen provider cannot cancel unresolved transactions',
    };
  }

  public canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility {
    const { state } = transactionDto;
    const completableStates = this.completableStates;

    if (completableStates.includes(state)) return { capable: true };

    return {
      capable: false,
      error: 'Shinkansen provider cannot complete unresolved transactions',
    };
  }

  public canRetryTransaction(transactionDto: TransactionDto): ProviderAbility {
    const transactionFailed = transactionDto.state === TransferState.FAILED;
    if (transactionFailed) return { capable: true };

    return {
      capable: false,
      error: 'Shinkansen provider can only reassign failed transactions',
    };
  }

  public async validateSignature(
    headerSignature: string,
    updateTransactionDto: ShinkansenTransactionUpdateDto,
  ) {
    try {
      const validSignature = await this.shinkansenService.verifySignature(
        headerSignature,
        updateTransactionDto,
      );
      return validSignature;
    } catch (e) {
      this.logger.debug('ShinkansenProvider validateSignature error');
      this.logger.error(e);
      return false;
    }
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.constants.ts
import { BankCode } from 'src/common/enums/bank-code.enum';
import { AccountType, HolderIdSchema } from './shinkansen.provider.enum';
import { Currency } from 'src/common/enums/currency.enum';

export const ShinkansenBank = {
  cl_banco_bice: 'BANCO_BICE_CL',
  cl_banco_de_chile: 'BANCO_DE_CHILE_CL',
  cl_banco_consorcio: 'BANCO_CONSORCIO_CL',
  cl_banco_bci: 'BCI_CL',
  cl_banco_estado: 'BANCO_ESTADO_CL',
  cl_banco_falabella: 'BANCO_FALABELLA_CL',
  cl_banco_internacional: 'BANCO_INTERNACIONAL_CL',
  cl_banco_itau_chile: 'BANCO_ITAU_CL',
  cl_banco_ripley: 'BANCO_RIPLEY_CL',
  cl_banco_security: 'BANCO_SECURITY_CL',
  cl_banco_coopeuch: 'COOPEUCH_CL',
  cl_banco_corpbanca: 'CORPBANCA_CL',
  cl_hsbc_bank_chile: 'HSBC_CL',
  cl_prepago_los_heroes: 'PREPAGO_LOS_HEROES_CL',
  cl_scotiabank_azul: 'SCOTIABANK_AZUL_CL',
  cl_scotiabank_sud_americano: 'SCOTIABANK_CL',
  cl_tenpo_prepago: 'TENPO_CL',
  cl_banco_santander: 'BANCO_SANTANDER_CL',
  cl_jp_morgan_chase_bank: 'JP_MORGAN_CL',
  cl_tapp_caja_los_andes: 'TAPP_CL',
  cl_mercado_pago: 'MERCADO_PAGO_CL',

  pe_banco_de_la_nacion: 'BANCO_DE_LA_NACION_PE',
  pe_banco_bcp: 'BANCO_DE_CREDITO_PE',
  pe_banco_interbank: 'INTERBANK_PE',
  pe_banco_citibank: 'CITIBANK_PE',
  pe_banco_scotiabank: 'SCOTIABANK_PE',
  pe_banco_bbva: 'BBVA_CONTINENTAL_PE',
  pe_banco_de_comercio: 'BANCO_DE_COMERCIO_PE',
  pe_banco_pichincha: 'BANCO_PICHINCHA_PE',
  pe_banco_banbif: 'BANCO_INTERAMERICANO_PE',
  pe_crediscotia: 'CREDISCOTIA_PE',
  pe_banco_gnb: 'BANCO_GNB_PE',
  pe_banco_santander: 'BANCO_SANTANDER_PE',
  pe_banco_icbc: 'ICBC_BANK_PE',
  pe_trujillo: 'CMAC_TRUJILLO_PE',
  pe_arequipa: 'CMAC_AREQUIPA_PE',
  pe_sullana: 'CMAC_SULLANA_PE',
  pe_caja_metropolitana: 'CAJA_METROPOLITANA_PE',
  pe_cusco: 'CMAC_CUSCO_PE',
  pe_huancayo: 'CMAC_HUANCAYO_PE',
  pe_tacna: 'CMAC_TACNA_PE',
  pe_banco_mibanco: 'MI_BANCO_PE',
  pe_banco_falabella: 'BANCO_FALABELLA_PE',
};

export const HolderIdSchemaMap: Record<Currency, HolderIdSchema> = {
  [Currency.CHILE]: HolderIdSchema.CLID,
  [Currency.COLOMBIA]: null,
  [Currency.MEXICO]: null,
  [Currency.PERU]: HolderIdSchema.PERUC,
  [Currency.ARGENTINA]: null,
  [Currency.BOLIVIA]: null,
  [Currency.BRAZIL]: null,
  [Currency.ECUADOR]: null,
  [Currency.URUGUAY]: null,
};

export const AccountTypeSchemaMap: Record<Currency, AccountType> = {
  [Currency.CHILE]: AccountType.CURRENT_ACCOUNT,
  [Currency.COLOMBIA]: null,
  [Currency.MEXICO]: null,
  [Currency.PERU]: AccountType.CURRENT_ACCOUNT,
  [Currency.ARGENTINA]: null,
  [Currency.BOLIVIA]: null,
  [Currency.BRAZIL]: null,
  [Currency.ECUADOR]: null,
  [Currency.URUGUAY]: null,
};

export const ShinkansenKnownStatusCodes = [200, 400, 401, 403, 409];

export const ShinkansenUnsupportedBanks: string[] = [
  BankCode.BANCO_ABN_AMRO,
  BankCode.BANCO_DEL_DESARROLLO,
  BankCode.BANCO_PARIS,
  BankCode.BANCO_RABOBANK,
];


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { HttpModule } from '@nestjs/axios';
import { ConfigModule } from '@nestjs/config';

import shinkansenConfig from 'src/config/shinkansen.config';
import { ShinkansenProvider } from './shinkansen.provider';
import { ShinkansenProviderService } from './shinkansen.provider.service';

@Module({
  imports: [
    HttpModule,
    JwtModule.register({ secret: 'hard!to-guess_secret' }),
    ConfigModule.forFeature(shinkansenConfig),
  ],
  providers: [ShinkansenProviderService, ShinkansenProvider],
  exports: [ShinkansenProvider],
})
export class ShinkansenProviderModule {}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.service.ts
import { HttpService } from '@nestjs/axios';
import { Inject, Injectable, Logger } from '@nestjs/common';

import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';

import { TransactionDto } from '../common/dtos/transaction.dto';
import { TransactionStateDto } from '../common/dtos/transaction-state.dto';
import { CreatedTransactionDto } from '../common/dtos/created-transaction.dto';
import { ShinkansenCredentialsDto } from './dto/shinkansen.provider.credentials.dto';

import { SignatureVerifier } from './utils/verifier';
import { translateShinkansenStatus } from './utils/state';
import {
  CertificateType,
  convertPKCS1toPKCS8,
  createJws,
  formatPem,
  signJws,
  validatePemCertificate,
  validatePemPrivateKey,
} from 'src/utils/certificates.util';
import { ShinkansenTransactionStatusDto } from './dto/shinkansen.transaction.status.dto';
import { ShinkansenTransactionResponseDto } from './dto/shinkansen.transaction.response.dto';
import { ShinkansenErrorDto } from './dto/shinkansen.create.error.dto';
import {
  ShinkansenCreateResponseDto,
  ShinkansenTransaction,
} from './dto/shinkansen.create.response.dto';
import {
  AccountTypeSchemaMap,
  HolderIdSchemaMap,
  ShinkansenBank,
  ShinkansenKnownStatusCodes,
  ShinkansenUnsupportedBanks,
} from './shinkansen.provider.constants';
import { isUUID, validateSync } from 'class-validator';
import {
  ShinkansenBalanceResult,
  ShinkansenCreditor,
  ShinkansenDebtor,
  ShinkansenResult,
} from './shinkansen.provider.interface';
import moment = require('moment');
import { formatHolderId, isBlank } from './utils/format';
import { ShinkansenBankSchema } from './shinkansen.provider.enum';
import { ShinkansenCreateTransactionDto } from './dto/shinkansen.create.dto';
import { AxiosResponse } from 'axios';
import { CreateTransactionOptions, waitFor } from 'src/utils/request.util';
import shinkansenConfig from 'src/config/shinkansen.config';
import { ConfigType } from '@nestjs/config';
import { plainToClass } from 'class-transformer';
import { Credential } from 'src/utils/encryption.util';

@Injectable()
export class ShinkansenProviderService {
  private readonly logger = new Logger('ShinkansenProviderService');

  @Inject()
  private http: HttpService;

  @Inject(shinkansenConfig.KEY)
  private config: ConfigType<typeof shinkansenConfig>;

  private validateCredentials(
    credentials: Credential,
  ): ShinkansenCredentialsDto {
    const credentialDto = plainToClass(ShinkansenCredentialsDto, credentials);
    const errors = validateSync(credentialDto);

    if (errors.length > 0) {
      const messages = errors.map((error) => {
        return Object.values(error.constraints).join(', ');
      });
      const message = messages.join(', ');
      throw new Error(message);
    }

    return credentialDto;
  }

  private buildCredentials(provider: ProviderEntity): ShinkansenCredentialsDto {
    const { decryptedCredentials } = provider;

    const credentialsDto = this.validateCredentials(decryptedCredentials);
    return credentialsDto;
  }

  private buildHeaders(
    apiKey: string,
    signature?: string,
  ): Record<string, string> {
    const headers = {
      accept: 'application/json',
      'Content-Type': 'application/json',
      'shinkansen-api-key': apiKey,
    };

    if (signature) {
      headers['shinkansen-jws-signature'] = signature;
    }

    return headers;
  }

  public async createTransaction(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ): Promise<CreatedTransactionDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Shinkansen credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Shinkansen credentials.`,
      };
    }

    try {
      const options = {
        attempt: 1,
        attempts: 3,
        delay: 1000,
      } as CreateTransactionOptions;
      const { shinkansenId } = await this.retryTransaction(
        transactionDto,
        provider,
        options,
      );
      return {
        externalId: shinkansenId,
        state: TransferState.PROCESSING,
      };
    } catch (err) {
      this.logger.error(err);
      return {
        message: err?.message,
        state: TransferState.FAILED,
      };
    }
  }

  public async retryTransaction(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
    options: CreateTransactionOptions,
  ): Promise<ShinkansenResult> {
    const { attempt, attempts, delay } = options;
    const { destinationBankCode, uuid } = transactionDto;

    if (attempt > attempts || attempt > 3) {
      const error = `Error: Shinkansen transaction could not be created, provider API is not responding`;
      throw new Error(error);
    }

    const unsupportedBank =
      ShinkansenUnsupportedBanks.includes(destinationBankCode);

    if (unsupportedBank) {
      const error = `Error: Unsupported destination bank ${destinationBankCode}`;
      throw new Error(error);
    }

    if (!isUUID(uuid)) {
      const error = `Error: Invalid idempotency ID ${uuid}`;
      throw new Error(error);
    }

    const credentials = this.buildCredentials(provider);

    const { coreApiKey, certificate, privateKey } = credentials;

    const endpoint = `${this.config.apiUrl}/messages/payouts`;

    let response: AxiosResponse;
    let headers: Record<string, string>;
    let payload: ShinkansenCreateTransactionDto;

    try {
      payload = this.buildPayload(transactionDto, provider);
      const signature = await this.signPayload(
        certificate,
        privateKey,
        payload,
      );
      headers = this.buildHeaders(coreApiKey, signature);
    } catch (err) {
      this.logger.error(err);
      const error = `Error: Shinkansen Signing process failed. Detail: ${err.message}`;
      throw new Error(error);
    }

    try {
      this.logger.debug(`Shinkansen request for transaction ${uuid}`);
      response = await this.http.axiosRef.post(endpoint, payload, {
        headers,
        validateStatus: (status) => ShinkansenKnownStatusCodes.includes(status),
      });
    } catch (err) {
      this.logger.error(err);

      const backoff = Math.pow(2, attempt - 1) * delay;
      await waitFor(backoff);

      const retryOptions = { attempt: attempt + 1, attempts, delay };

      return await this.retryTransaction(
        transactionDto,
        provider,
        retryOptions,
      );
    }

    const { status, statusText, data } = response;

    this.logger.debug(`Shinkansen request succeed: ${status} (${statusText})`);

    if (status === 200 || status === 409) {
      const { transactions } = data as ShinkansenCreateResponseDto;
      const results = this.buildResults(transactions);
      const result = results.find((result) => result.transactionId === uuid);
      return result;
    }

    if (status === 400) {
      const shinkansenError = data as ShinkansenErrorDto;
      const error = this.buildError(shinkansenError);
      throw new Error(error);
    }

    if (status === 401 || status === 403) {
      const error = `Error ${status}: ${statusText}`;
      throw new Error(error);
    }
  }

  public async getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    const transactionStatus = await this.getTransactionStatus(
      provider,
      transactionId,
    );

    // There is no need to check the transaction response if the transaction is still processing
    if (transactionStatus.state === TransferState.PROCESSING) {
      return transactionStatus;
    }

    const finalStates = [TransferState.FAILED, TransferState.COMPLETED];
    const invalidState = !finalStates.includes(transactionStatus.state);

    if (invalidState) {
      throw new Error(`GetTransactionState failed. ${transactionStatus.state}`);
    }

    const transactionResponse = await this.getTransactionResponse(
      provider,
      transactionId,
    );

    return transactionResponse;
  }

  public async getTransactionStatus(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Shinkansen credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Shinkansen credentials.`,
      };
    }

    const credentials = this.buildCredentials(provider);

    const { coreApiKey } = credentials;

    const headers = this.buildHeaders(coreApiKey);

    try {
      const endpoint = `${this.config.apiUrl}/transactions/${transactionId}/status`;
      const { data } = await this.http.axiosRef.get(endpoint, {
        headers,
        validateStatus: (status) => status === 200,
      });

      const transactionStatus = data as ShinkansenTransactionStatusDto;
      const transferState = translateShinkansenStatus(
        transactionStatus.shinkansen_transaction_status,
      );
      this.logger.debug(
        `Transaction update for ${transactionId}: ${transactionStatus} (${transferState}))`,
      );
      return { state: transferState };
    } catch (e) {
      this.logger.debug(`getTransactionStatus error: ${e?.response?.status}`);
      this.logger.error(e);
      throw new Error(`Shinkansen getTransactionStatus failed.`);
    }
  }

  public async getTransactionResponse(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto> {
    try {
      this.validateCredentials(provider.decryptedCredentials);
    } catch (error) {
      this.logger.debug(`Invalid Shinkansen credentials. ${error?.message}`);
      return {
        state: TransferState.FAILED,
        message: `Invalid Shinkansen credentials.`,
      };
    }

    const credentials = this.buildCredentials(provider);

    const { coreApiKey } = credentials;

    const headers = this.buildHeaders(coreApiKey);

    try {
      const endpoint = `${this.config.apiUrl}/transactions/${transactionId}/response`;
      const { data } = await this.http.axiosRef.get(endpoint, {
        headers,
        validateStatus: (status) => status === 200,
      });

      const transaction = data as ShinkansenTransactionResponseDto;

      const {
        shinkansen_transaction_status: status,
        response_message,
        response_status,
      } = transaction;

      // response_message is empty for successful transactions
      const message = response_message || response_status;
      const state = translateShinkansenStatus(status);

      return { message, state };
    } catch (e) {
      this.logger.debug(`getTransactionResponse error: ${e?.response?.status}`);
      this.logger.error(e);
      throw new Error(`Shinkansen getTransactionResponse failed.`);
    }
  }

  public async getBalance(
    provider: ProviderEntity,
  ): Promise<ShinkansenBalanceResult> {
    this.validateCredentials(provider.decryptedCredentials);

    const { treasuryApiKey } = this.buildCredentials(provider);

    const { identifier, bankCode } = provider.account;

    const endpoint = `${this.config.treasuryApiUrl}/accounts/${ShinkansenBank[bankCode]}/${identifier}/balances/latest`;

    const response = await this.http.axiosRef.get<ShinkansenBalanceResult>(
      endpoint,
      {
        headers: {
          'Shinkansen-Treasury-Api-Key': treasuryApiKey,
        },
        validateStatus: (status) => ShinkansenKnownStatusCodes.includes(status),
      },
    );

    return response.data;
  }

  private buildDebtor(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ): ShinkansenDebtor {
    const { currency } = transactionDto;

    const credentials = this.buildCredentials(provider);

    const { name, email, holderId, bankCode, account } = credentials;

    const debtorBankSchema = ShinkansenBankSchema.SHINKANSEN;
    const debtorBank = ShinkansenBank[bankCode];

    const debtorIdSchema = HolderIdSchemaMap[currency];
    const debtorId = formatHolderId(holderId, debtorIdSchema);

    const accountType = AccountTypeSchemaMap[currency];

    return {
      name: name,
      email: email,
      identification: {
        id_schema: debtorIdSchema,
        id: debtorId,
      },
      financial_institution: {
        fin_id_schema: debtorBankSchema,
        fin_id: debtorBank,
      },
      account_type: accountType,
      account: account,
    };
  }

  private buildCreditor(transactionDto: TransactionDto): ShinkansenCreditor {
    const {
      destinationName,
      destinationEmail,
      destinationAccount,
      destinationBankCode,
      destinationHolderId,
      currency,
    } = transactionDto;

    const creditorBankSchema = ShinkansenBankSchema.SHINKANSEN;
    const creditorBank = ShinkansenBank[destinationBankCode];

    const accountType = AccountTypeSchemaMap[currency];

    const creditorIdSchema = HolderIdSchemaMap[currency];
    const creditorId = formatHolderId(destinationHolderId, creditorIdSchema);

    return {
      name: destinationName,
      email: destinationEmail,
      identification: {
        id_schema: creditorIdSchema,
        id: creditorId,
      },
      financial_institution: {
        fin_id_schema: creditorBankSchema,
        fin_id: creditorBank,
      },
      account_type: accountType,
      account: destinationAccount,
    };
  }

  private buildDocumentHeader(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ) {
    const { destinationBankCode, uuid } = transactionDto;

    const credentials = this.buildCredentials(provider);

    const { senderId } = credentials;

    const receiverBankId = ShinkansenBank[destinationBankCode];
    const creationDate = moment().toISOString();

    return {
      message_id: uuid,
      creation_date: creationDate,
      sender: {
        fin_id_schema: ShinkansenBankSchema.SHINKANSEN,
        fin_id: senderId,
      },
      receiver: {
        fin_id_schema: ShinkansenBankSchema.SHINKANSEN,
        fin_id: receiverBankId,
      },
    };
  }

  private buildPayload(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ) {
    const { destinationBankCode } = transactionDto;

    if (ShinkansenUnsupportedBanks.includes(destinationBankCode)) {
      throw new Error('Shinkansen unsupported bank');
    }

    const header = this.buildDocumentHeader(transactionDto, provider);
    const transaction = this.buildTransaction(transactionDto, provider);
    const transactions = [transaction];

    const payload: ShinkansenCreateTransactionDto = {
      document: { header, transactions },
    };

    return payload;
  }

  private buildTransaction(
    transactionDto: TransactionDto,
    provider: ProviderEntity,
  ) {
    const { amount, uuid, currency } = transactionDto;

    const debtor = this.buildDebtor(transactionDto, provider);
    const creditor = this.buildCreditor(transactionDto);

    const executionDate = moment().toISOString();

    const description = 'Adelanto de sueldo';

    return {
      transaction_id: uuid,
      transaction_type: 'payout',
      description,
      debtor,
      creditor,
      amount: amount.toString(),
      currency: currency.toUpperCase(),
      execution_date: executionDate,
    };
  }

  private buildResults(
    transactions: ShinkansenTransaction[],
  ): ShinkansenResult[] {
    return transactions.map((transaction) => {
      return {
        shinkansenId: transaction.shinkansen_transaction_id,
        transactionId: transaction.transaction_id,
      };
    });
  }

  private buildError(shinkansenError: ShinkansenErrorDto): string {
    const errors = shinkansenError?.errors;
    const invalidError = !Array.isArray(errors) || errors.length === 0;

    if (invalidError) {
      return `Shinkansen status 400 error: ${JSON.stringify(shinkansenError)}`;
    }

    const errorSummary = errors
      .map((error) => `${error?.error_code} ${error?.error_message}`)
      .filter((error) => !isBlank(error))
      .join(', ');

    return `Shinkansen status 400 error: ${errorSummary}`;
  }

  public async signPayload(
    certificate: string,
    privateKey: string,
    payload?: unknown,
  ) {
    const certificatePem = formatPem(certificate, CertificateType.CERTIFICATE);

    const privateKeyPem = formatPem(
      privateKey,
      CertificateType.RSA_PRIVATE_KEY,
    );

    const validCertificate = validatePemCertificate(certificatePem);
    const validPrivateKey = validatePemPrivateKey(privateKeyPem);

    if (!validCertificate) throw new Error('Invalid Shinkansen certificate');
    if (!validPrivateKey) throw new Error('Invalid Shinkansen private key');

    const flatJws = createJws(certificatePem, payload);

    const pkcs8 = convertPKCS1toPKCS8(privateKeyPem);
    const jwsSignature = await signJws(flatJws, pkcs8);
    return jwsSignature;
  }

  public async verifySignature(
    signature: string,
    payload: object,
  ): Promise<boolean> {
    const shinkansenCertificate = this.config.certificate;

    if (!shinkansenCertificate) {
      this.logger.error('Missing Shinkansen certificate');
      throw new Error('Missing Shinkansen certificate');
    }

    const pemCertificate = formatPem(
      shinkansenCertificate,
      CertificateType.CERTIFICATE,
    );

    const verifier = new SignatureVerifier(signature);
    const verified = await verifier.verify(payload, pemCertificate);
    return verified;
  }
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/shinkansen.provider.interface.ts
import { ShinkansenErrorDto } from './dto/shinkansen.create.error.dto';
import { ShinkansenTransactionStatusDto } from './dto/shinkansen.transaction.status.dto';
import { ShinkansenCreateResponseDto } from './dto/shinkansen.create.response.dto';
import { ShinkansenTransactionResponseDto } from './dto/shinkansen.transaction.response.dto';

export interface RequestCreateState {
  success?: ShinkansenCreateResponseDto;
  error?: ShinkansenErrorDto;
}

export interface CreatePayoutResult {
  result?: ShinkansenResult;
  error?: string;
  retry?: boolean;
}

export interface ShinkansenPayoutStatusResponse {
  success?: ShinkansenTransactionStatusDto;
  error?: ShinkansenErrorDto;
}

export interface RequestNonPendingPayout {
  success?: ShinkansenTransactionResponseDto;
  error?: ShinkansenErrorDto;
}

export interface ShinkansenDebtor {
  name: string;
  email: string;
  identification: ShinkansenIdentification;
  financial_institution: ShinkansenFinancialInstitution;
  account_type: string;
  account: string;
}

export interface ShinkansenCreditor {
  name: string;
  email: string;
  identification: ShinkansenIdentification;
  financial_institution: ShinkansenFinancialInstitution;
  account_type: string;
  account: string;
}

export interface ShinkansenIdentification {
  id_schema: string;
  id: string;
}

export interface ShinkansenFinancialInstitution {
  fin_id_schema: string;
  fin_id: string;
}

export interface ShinkansenCredentials {
  debtor: ShinkansenDebtor;
}

export interface ShinkansenResult {
  shinkansenId: string;
  transactionId: string;
}

interface ShinkansenBalanceSource {
  source_type: string; // account_report | account_statement
  source_id: string;
}

interface ShinkansenBalance {
  balance_type: string; // snapshot | end_of_booking_day | end_of_statement
  book_balance: string;
  available_balance: string;
  timestamp: string;
  source: ShinkansenBalanceSource;
}

export interface ShinkansenBalanceResult {
  account: string;
  financial_institution: ShinkansenFinancialInstitution;
  currency: string;
  balances: ShinkansenBalance[];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.payout.status.dto.ts
import { ShinkansenPayoutStatus } from 'src/common/enums/shinkansen-payout-state.enum';

export class ShinkansenPayoutStatusDto {
  shinkansen_transaction_status: ShinkansenPayoutStatus;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.create.error.dto.ts
export class ShinkansenErrorDto {
  errors: ShinkansenError[];
}

export class ShinkansenError {
  error_code: string;
  error_message: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.create.response.dto.ts
export class ShinkansenCreateResponseDto {
  transactions: ShinkansenTransaction[];
}
export class ShinkansenTransaction {
  shinkansen_transaction_id: string;
  transaction_id: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.create.dto.ts
export class ShinkansenCreateTransactionDto {
  document: ShinkansenDocument;
}
class ShinkansenDocument {
  header: ShinkansenHeader;
  transactions: ShinkansenTransaction[];
}

class ShinkansenHeader {
  message_id: string;
  creation_date: string;
  sender: ShinkansenSender;
  receiver: ShinkansenReceiver;
}

class ShinkansenSender {
  fin_id_schema: string;
  fin_id: string;
}

class ShinkansenReceiver {
  fin_id_schema: string;
  fin_id: string;
}

class ShinkansenTransaction {
  transaction_type: string;
  transaction_id: string;
  currency: string;
  amount: string;
  execution_date: string;
  description: string;
  debtor: ShinkansenDebtor;
  creditor: ShinkansenCreditor;
}

class ShinkansenDebtor {
  name: string;
  email: string;
  identification: ShinkansenIdentification;
  financial_institution: ShinkansenFinancialInstitution;
  account_type: string;
  account: string;
}

class ShinkansenIdentification {
  id_schema: string;
  id: string;
}

class ShinkansenFinancialInstitution {
  fin_id_schema: string;
  fin_id: string;
}

class ShinkansenCreditor {
  name: string;
  email: string;
  identification: ShinkansenIdentification;
  financial_institution: ShinkansenCreditorFinancialInstitution;
  account_type: string;
  account: string;
}

class ShinkansenCreditorFinancialInstitution {
  fin_id_schema: string;
  fin_id: string;
}

export class ShincansenCreateDto {
  document: ShinkansenDocument;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.provider.credentials.dto.ts
import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { Credential } from 'src/utils/encryption.util';

export interface ShinkansenCredentials extends Credential {
  name: string;
  email: string;
  holderId: string;
  senderId: string;
  account: string;
  bankCode: string;
  apiKey: string;
  privateKey: string;
  certificate: string;
  webhookCertificate?: string;
}

export class ShinkansenCredentialsDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  email: string;

  @IsString()
  @IsNotEmpty()
  holderId: string;

  @IsString()
  @IsNotEmpty()
  senderId: string;

  @IsString()
  @IsNotEmpty()
  account: string;

  @IsString()
  @IsNotEmpty()
  bankCode: string;

  @IsString()
  @IsOptional()
  coreApiKey?: string;

  @IsOptional()
  @IsString()
  treasuryApiKey?: string;

  @IsString()
  @IsNotEmpty()
  privateKey: string;

  @IsString()
  @IsNotEmpty()
  certificate: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.transaction.status.dto.ts
import { ShinkansenTransactionStatus } from '../shinkansen.provider.enum';

export class ShinkansenTransactionStatusDto {
  shinkansen_transaction_status: ShinkansenTransactionStatus;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/shinkansen/dto/shinkansen.transaction.response.dto.ts
import { ShinkansenTransactionStatus } from '../shinkansen.provider.enum';

export class ShinkansenTransactionResponseDto {
  response_id: string;
  response_message: string;
  transaction_type: string;
  transaction_id: string;
  shinkansen_transaction_id: string;
  response_status: string;
  shinkansen_transaction_status: ShinkansenTransactionStatus;
  shinkansen_transaction_message: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/dtos/update-transaction.dto.ts
import { Type } from 'class-transformer';
import {
  IsEnum,
  IsNumber,
  IsObject,
  IsOptional,
  IsPositive,
  IsString,
} from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { TransferEntity } from 'src/models/transfer/entities/transfer.entity';

export class UpdateTransactionDto {
  @IsNumber()
  @IsPositive()
  @IsOptional()
  transferId?: number;

  @IsString()
  @IsOptional()
  externalId?: string;

  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @IsString()
  @IsOptional()
  message?: string;

  @IsObject()
  @IsOptional()
  @Type(() => TransferEntity['metadata'])
  metadata?: TransferEntity['metadata'];
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/dtos/transaction.dto.ts
import { Expose } from 'class-transformer';
import {
  IsEmail,
  IsEnum,
  IsNumber,
  IsNumberString,
  IsOptional,
  IsString,
} from 'class-validator';
import { Currency } from 'src/common/enums/currency.enum';
import { CountryCode } from 'src/common/enums/country-code.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class TransactionDto {
  @Expose()
  @IsNumber()
  @IsOptional()
  id?: number;

  @Expose()
  @IsString()
  @IsOptional()
  uuid?: string;

  // TODO: Change this. Must be a number but typescript parse it to string for decimal. 1 -> '1.00'
  // Breaking change for scrapers
  @Expose()
  @IsNumberString()
  amount: number;

  @Expose()
  @IsEnum(TransferState)
  state: TransferState;

  @Expose()
  @IsString()
  @IsOptional()
  destinationName?: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationBankCode?: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationAccount?: string;

  @Expose()
  @IsEmail()
  @IsOptional()
  destinationEmail?: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationPhone?: string;

  @Expose()
  @IsString()
  @IsOptional()
  destinationHolderId?: string;

  @Expose()
  @IsEnum(Currency)
  currency: Currency;

  @Expose()
  @IsString()
  @IsOptional()
  message?: string;

  @Expose()
  @IsEnum(CountryCode)
  @IsOptional()
  countryCode?: CountryCode;

  @Expose()
  @IsNumber()
  providerId: number;

  @Expose()
  @IsString()
  @IsOptional()
  concept?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/dtos/account-balance.dto.ts
import { Currency } from 'src/common/enums/currency.enum';

export class AccountBalanceDto {
  balance: number;
  currency: Currency;
  retrievedAt: Date;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/dtos/created-transaction.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class CreatedTransactionDto {
  @IsString()
  @IsNotEmpty()
  @IsOptional()
  externalId?: string;

  @IsEnum(TransferState)
  @IsOptional()
  state?: TransferState;

  @IsString()
  @IsNotEmpty()
  @IsOptional()
  message?: string;

  @IsString()
  @IsOptional()
  jobId?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/dtos/transaction-state.dto.ts
import { TransferState } from 'src/common/enums/transfer-state.enum';

export class TransactionStateDto {
  state: TransferState;
  message?: string;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/state-translators/shinkansen-state.translator.ts
import { ShinkansenPayoutStatus } from 'src/common/enums/shinkansen-payout-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';
import { ShinkansenPayoutStatusDto } from 'src/providers/shinkansen/dto/shinkansen.payout.status.dto';

export const translateShinkansenStateToTransferState = (
  shinkansenState: ShinkansenPayoutStatusDto,
): TransferState => {
  if (shinkansenState) {
    if (
      shinkansenState.shinkansen_transaction_status ===
      ShinkansenPayoutStatus.OK
    ) {
      return TransferState.COMPLETED;
    }
    if (
      shinkansenState.shinkansen_transaction_status ===
      ShinkansenPayoutStatus.PENDING
    ) {
      return TransferState.PROCESSING;
    }
    if (
      shinkansenState.shinkansen_transaction_status ===
      ShinkansenPayoutStatus.ERROR
    ) {
      return TransferState.FAILED;
    }
  }
  return undefined;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/common/state-translators/liquido-state.translator.ts
import { Logger } from '@nestjs/common';
import { LiquidoTransactionState } from 'src/common/enums/liquido-transaction-state.enum';
import { TransferState } from 'src/common/enums/transfer-state.enum';

const logger = new Logger('LiquidoTranslatorLogger');

export const translateLiquidoStateToTransferState = (
  liquidoState: LiquidoTransactionState,
): TransferState => {
  if (liquidoState) {
    if (liquidoState === LiquidoTransactionState.SETTLED) {
      return TransferState.COMPLETED;
    }
    if (liquidoState === LiquidoTransactionState.IN_PROGRESS) {
      return TransferState.PROCESSING;
    }
    if (liquidoState === LiquidoTransactionState.FAILED) {
      return TransferState.FAILED;
    }
    if (liquidoState === LiquidoTransactionState.REJECTED) {
      return TransferState.FAILED;
    }
  }
  logger.debug('Error liquido status Translate: ', liquidoState);
  return undefined;
};


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/providers/base.provider.ts
import { Injectable } from '@nestjs/common';
import { ProviderType } from 'src/common/enums/provider-type.enum';
import { ProviderEntity } from 'src/models/provider/entities/provider.entity';
import { AccountBalanceDto } from './common/dtos/account-balance.dto';
import { TransactionDto } from './common/dtos/transaction.dto';
import { TransactionStateDto } from './common/dtos/transaction-state.dto';
import { CreatedTransactionDto } from './common/dtos/created-transaction.dto';
import { TransferState } from 'src/common/enums/transfer-state.enum';

export interface ProviderAbility {
  capable: boolean;
  error?: string;
}
@Injectable()
export abstract class BaseProviderAdapter {
  public abstract providerType: ProviderType;

  public abstract get cancelableStates(): TransferState[];
  public abstract get completableStates(): TransferState[];
  public abstract get failableStates(): TransferState[];

  /**
   * Creates a new transaction on the given provider
   * @param provider The provider that contains the required credentials
   * @param transactionDto
   * @returns ```CreatedTransactionDto```
   */
  public abstract createTransaction(
    provider: ProviderEntity,
    transactionDto: TransactionDto,
  ): Promise<CreatedTransactionDto>;

  /**
   * Get the last transaction state and returns it translated to the transfer state. Also includes its message if it exists
   * @param provider The provider that contains the requred credentials
   * @param transactionId: The externalId stored in the transfer
   * @returns ```TransactionStateDto```
   */
  public abstract getTransactionState(
    provider: ProviderEntity,
    transactionId: string,
  ): Promise<TransactionStateDto>;

  /**
   * Gets the balance for the account associated to the provider. If this feature available
   * @param provider: The provider that have the needed credentials
   * @returns The account balance
   */
  public abstract getBalance(
    provider: ProviderEntity,
  ): Promise<AccountBalanceDto>;

  /**
   * Evaluate if the provider can process the specified transfer.
   * @param transactionDto The transaction object that will be evaluated
   * @returns `true | false`
   */
  public abstract canCreateTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility;

  /**
   * Evaluates if a given transaction can be canceled. If not, throws an error.
   * @param transactionDto The transfer data that must be evaluated for cancelation
   */
  public abstract canCancelTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility;

  /**
   * Evaluates if a given transaction can be completed. If not, throws an error.
   * @param transactionDto The transfer data that must be evaluated for completion
   */
  public abstract canCompleteTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility;

  /**
   * Evaluates if a given transaction can be retried. If not, throws an error.
   * @param transactionDto The transfer data that must be evaluated for reassign
   */
  public abstract canRetryTransaction(
    transactionDto: TransactionDto,
  ): ProviderAbility;
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/alerts.config.ts
import { registerAs } from '@nestjs/config';
import { parseBoolean } from 'src/utils/string-methods.util';

export default registerAs('alerts', () => ({
  alerts: {
    transfers: process.env.TRANSFER_ALERTS_THRESHOLDS ?? '',
    filters: process.env.TRANSFER_ALERTS_FILTER_STATE ?? '',
    cronExpression: process.env.TRANSFER_ALERTS_CRON ?? '',
    enabled: parseBoolean(process.env.TRANSFER_ALERTS_ENABLED),
  },
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/redis.config.ts
import { registerAs } from '@nestjs/config';
import { parseBoolean, parsePort } from 'src/utils/string-methods.util';

export default registerAs('redis', () => ({
  host: process.env.REDIS_HOST ?? 'localhost',
  port: parsePort(process.env.REDIS_PORT) ?? 6378,
  clusterMode: parseBoolean(process.env.REDIS_CLUSTER_MODE),
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/database.config.ts
import { registerAs } from '@nestjs/config';
import { parseBoolean, parsePort } from 'src/utils/string-methods.util';

export interface DatabaseConfig {
  host: string;
  port: number;
  username: string;
  password: string;
  database: string;
  logging: boolean;
}

export default registerAs('database', () => ({
  host: process.env.DATABASE_HOST ?? 'localhost',
  port: parsePort(process.env.DATABASE_PORT) ?? 3306,
  username: process.env.DATABASE_USERNAME ?? 'root',
  password: process.env.DATABASE_PASSWORD ?? 'root',
  database: process.env.DATABASE_NAME ?? 'payments_engine_dev',
  logging: parseBoolean(process.env.DATABASE_LOGS) ?? false,
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/sentry.config.ts
import { registerAs } from '@nestjs/config';

export interface SentryConfig {
  dsn: string;
  enabled: boolean;
}

export default registerAs('sentry', () => ({
  dsn: process.env.SENTRY_DNS ?? '',
  enabled: process.env.SENTRY_ENABLED === 'true',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/configcat.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('configcat', () => ({
  key: process.env.CONFIGCAT_KEY ?? 'CONFIGCAT_KEY',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/device.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('device', () => ({
  token: process.env.INTERNAL_DEVICE_TOKEN ?? 'development_device_token',
  queueUrl: process.env.INTERNAL_DEVICE_QUEUE_URL ?? '',
  topicArn: process.env.AWS_AUTHORIZATION_CODES_SNS_TOPIC_ARN ?? '',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/mail.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('mail', () => ({
  sendGridApiKey: process.env.SENDGRID_API_KEY ?? '',
  senderEmail: process.env.SENDER_EMAIL ?? '',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/general.config.ts
import { registerAs } from '@nestjs/config';
import { Environment } from 'src/common/enums/environment.enum';
import { enforceEnvValue } from 'src/utils/enviroment-setup.util';
import { parsePort, splitOrDefault } from 'src/utils/string-methods.util';

export const config = () => ({
  version: process.env.RELEASE_VERSION,
  api: {
    url: process.env.API_URL ?? 'http://localhost:5000/api/v2',
    env: (process.env.NODE_ENV as Environment) ?? Environment.DEVELOPMENT,
    port: parsePort(process.env.API_PORT) ?? '5000',
    version: splitOrDefault(process.env.API_VERSION, 'v2'),
  },
  security: {
    securityKey: enforceEnvValue(
      'SECURITY_KEY',
      '36d787deeaa212960d09ca77634407e2775dbf8530effb9e2416fe365dec267e',
    ),
    mfaName:
      process.env.PAYOUTS_ENGINE_MFA_NAME ?? 'payouts-engine-mfa-name-dev',
  },
  jwt: {
    secret: enforceEnvValue('JWT_SECRET', 'jwt_secret_dev'),
    expiration: process.env.JWT_EXPIRATION ?? '30m',
  },
  payouts: {
    autoRetryLimit: Number(process.env.PAYOUT_AUTO_RETRY_LIMIT ?? 0),
  },
});

export type GeneralConfig = ReturnType<typeof config>;

export default registerAs('general', config);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/shinkansen.config.ts
import { registerAs } from '@nestjs/config';

// Temporary config. This credentials should be securely passed to the provider via secrets
export default registerAs('shinkansen', () => ({
  apiUrl: process.env.SHINKANSEN_API_URL ?? 'https://api.shinkansen.finance/v1',
  treasuryApiUrl:
    process.env.SHINKANSEN_TREASURY_API_URL ??
    'https://api.treasury.shinkansen.finance/v1',
  certificate: process.env.SHINKANSEN_CERTIFICATE ?? '',
  bukApiKey: process.env.SHINKANSEN_BUK_API_KEY ?? '',
  bukPrivateKey: process.env.SHINKANSEN_BUK_PRIVATE_KEY ?? '',
  bukCertificate: process.env.SHINKANSEN_BUK_CERTIFICATE ?? '',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/slack.config.ts
import { registerAs } from '@nestjs/config';

export type SlackChannelName = 'alerts-payouts' | 'payouts';

type SlackChannelConfig = {
  name: string;
  webhookUrl: string;
};
export interface SlackConfig {
  token: string;
  channels: Record<SlackChannelName, SlackChannelConfig>;
}

export default registerAs<SlackConfig>('slack', () => ({
  token: process.env.SLACK_APP_TOKEN ?? '',
  channels: {
    'alerts-payouts': {
      name: 'alerts-payouts',
      webhookUrl: process.env.SLACK_ALERTS_WEBHOOK_URL ?? '',
    },
    payouts: {
      name: 'payouts',
      webhookUrl: process.env.SLACK_PAYOUTS_WEBHOOK_URL ?? '',
    },
  },
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/scraper.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('scraper', () => ({
  // TODO: Must rename it
  token: process.env.SCRAPERV2_HMAC_TOKEN ?? 'development_scraper_token',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/aws.config.ts
import { registerAs } from '@nestjs/config';
import { AwsBatchJob } from 'src/common/enums/aws-batch-jobs.enum';

type AwsBatchJobParams = {
  jobDefinition: string;
  jobQueue: string;
};

type AwsConfig = {
  region: string;
  accessKeyId: string;
  secretAccessKey: string;
  jobs: Record<AwsBatchJob, AwsBatchJobParams>;
};

export default registerAs(
  'aws',
  (): AwsConfig => ({
    region: process.env.AWS_REGION ?? 'us-west-1',
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    jobs: {
      [AwsBatchJob.accountStatements]: {
        jobDefinition: process.env.AWS_BANK_STATEMENTS_JOB_DEFINITION ?? '',
        jobQueue: process.env.AWS_BANK_STATEMENTS_JOB_QUEUE ?? '',
      },
      [AwsBatchJob.transfers]: {
        jobDefinition: process.env.AWS_TRANSFERS_JOB_DEFINITION ?? '',
        jobQueue: process.env.AWS_BANK_STATEMENTS_JOB_QUEUE ?? '',
      },
    },
  }),
);


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/twilio.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('twilio', () => ({
  token: process.env.TWILIO_TOKEN,
  url: process.env.TWILIO_WEBHOOK,
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/src/config/thomas.config.ts
import { registerAs } from '@nestjs/config';

// Temporary config. This credentials should be securely passed to the provider via secrets
export default registerAs('thomas', () => ({
  apiUrl: process.env.THOMAS_API_URL ?? 'http://localhost:9000',
  hmacKey: process.env.THOMAS_HMAC_KEY ?? 'hmac_key_development',
}));


/home/agustin/Documentos/Repos/Payouts/payouts-api/apps/api/nest-cli.workers.json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "entryFile": "workers/main"
}


/home/agustin/Documentos/Repos/Payouts/payouts-api/tsconfig.json
{
  "extends": "@repo/typescript-config/api.json",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "src/*": ["./apps/api/src/*", "./apps/dashboard/src/*"]
    }
  },
  "include": ["apps/*"],
  "exclude": ["dist"],
  "references": [{ "path": "./apps/api" }, { "path": "./apps/dashboard" }]
}


